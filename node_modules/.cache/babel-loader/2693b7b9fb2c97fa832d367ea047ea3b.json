{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { HostComponent, HostText, HostRoot, SuspenseComponent } from 'react-reconciler/src/ReactWorkTags';\nimport { getParentSuspenseInstance } from './ReactDOMHostConfig';\nimport { enableScopeAPI } from 'shared/ReactFeatureFlags';\nconst randomKey = Math.random().toString(36).slice(2);\nconst internalInstanceKey = '__reactFiber$' + randomKey;\nconst internalPropsKey = '__reactProps$' + randomKey;\nconst internalContainerInstanceKey = '__reactContainer$' + randomKey;\nconst internalEventHandlersKey = '__reactEvents$' + randomKey;\nconst internalEventHandlerListenersKey = '__reactListeners$' + randomKey;\nconst internalEventHandlesSetKey = '__reactHandles$' + randomKey;\nexport function detachDeletedInstance(node) {\n  // TODO: This function is only called on host components. I don't think all of\n  // these fields are relevant.\n  delete node[internalInstanceKey];\n  delete node[internalPropsKey];\n  delete node[internalEventHandlersKey];\n  delete node[internalEventHandlerListenersKey];\n  delete node[internalEventHandlesSetKey];\n}\nexport function precacheFiberNode(hostInst, node) {\n  node[internalInstanceKey] = hostInst;\n}\nexport function markContainerAsRoot(hostRoot, node) {\n  node[internalContainerInstanceKey] = hostRoot;\n}\nexport function unmarkContainerAsRoot(node) {\n  node[internalContainerInstanceKey] = null;\n}\nexport function isContainerMarkedAsRoot(node) {\n  return !!node[internalContainerInstanceKey];\n} // Given a DOM node, return the closest HostComponent or HostText fiber ancestor.\n// If the target node is part of a hydrated or not yet rendered subtree, then\n// this may also return a SuspenseComponent or HostRoot to indicate that.\n// Conceptually the HostRoot fiber is a child of the Container node. So if you\n// pass the Container node as the targetNode, you will not actually get the\n// HostRoot back. To get to the HostRoot, you need to pass a child of it.\n// The same thing applies to Suspense boundaries.\n\nexport function getClosestInstanceFromNode(targetNode) {\n  let targetInst = targetNode[internalInstanceKey];\n\n  if (targetInst) {\n    // Don't return HostRoot or SuspenseComponent here.\n    return targetInst;\n  } // If the direct event target isn't a React owned DOM node, we need to look\n  // to see if one of its parents is a React owned DOM node.\n\n\n  let parentNode = targetNode.parentNode;\n\n  while (parentNode) {\n    // We'll check if this is a container root that could include\n    // React nodes in the future. We need to check this first because\n    // if we're a child of a dehydrated container, we need to first\n    // find that inner container before moving on to finding the parent\n    // instance. Note that we don't check this field on  the targetNode\n    // itself because the fibers are conceptually between the container\n    // node and the first child. It isn't surrounding the container node.\n    // If it's not a container, we check if it's an instance.\n    targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey];\n\n    if (targetInst) {\n      // Since this wasn't the direct target of the event, we might have\n      // stepped past dehydrated DOM nodes to get here. However they could\n      // also have been non-React nodes. We need to answer which one.\n      // If we the instance doesn't have any children, then there can't be\n      // a nested suspense boundary within it. So we can use this as a fast\n      // bailout. Most of the time, when people add non-React children to\n      // the tree, it is using a ref to a child-less DOM node.\n      // Normally we'd only need to check one of the fibers because if it\n      // has ever gone from having children to deleting them or vice versa\n      // it would have deleted the dehydrated boundary nested inside already.\n      // However, since the HostRoot starts out with an alternate it might\n      // have one on the alternate so we need to check in case this was a\n      // root.\n      const alternate = targetInst.alternate;\n\n      if (targetInst.child !== null || alternate !== null && alternate.child !== null) {\n        // Next we need to figure out if the node that skipped past is\n        // nested within a dehydrated boundary and if so, which one.\n        let suspenseInstance = getParentSuspenseInstance(targetNode);\n\n        while (suspenseInstance !== null) {\n          // We found a suspense instance. That means that we haven't\n          // hydrated it yet. Even though we leave the comments in the\n          // DOM after hydrating, and there are boundaries in the DOM\n          // that could already be hydrated, we wouldn't have found them\n          // through this pass since if the target is hydrated it would\n          // have had an internalInstanceKey on it.\n          // Let's get the fiber associated with the SuspenseComponent\n          // as the deepest instance.\n          const targetSuspenseInst = suspenseInstance[internalInstanceKey];\n\n          if (targetSuspenseInst) {\n            return targetSuspenseInst;\n          } // If we don't find a Fiber on the comment, it might be because\n          // we haven't gotten to hydrate it yet. There might still be a\n          // parent boundary that hasn't above this one so we need to find\n          // the outer most that is known.\n\n\n          suspenseInstance = getParentSuspenseInstance(suspenseInstance); // If we don't find one, then that should mean that the parent\n          // host component also hasn't hydrated yet. We can return it\n          // below since it will bail out on the isMounted check later.\n        }\n      }\n\n      return targetInst;\n    }\n\n    targetNode = parentNode;\n    parentNode = targetNode.parentNode;\n  }\n\n  return null;\n}\n/**\n * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent\n * instance, or null if the node was not rendered by this React.\n */\n\nexport function getInstanceFromNode(node) {\n  const inst = node[internalInstanceKey] || node[internalContainerInstanceKey];\n\n  if (inst) {\n    if (inst.tag === HostComponent || inst.tag === HostText || inst.tag === SuspenseComponent || inst.tag === HostRoot) {\n      return inst;\n    } else {\n      return null;\n    }\n  }\n\n  return null;\n}\n/**\n * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding\n * DOM node.\n */\n\nexport function getNodeFromInstance(inst) {\n  if (inst.tag === HostComponent || inst.tag === HostText) {\n    // In Fiber this, is just the state node right now. We assume it will be\n    // a host component or host text.\n    return inst.stateNode;\n  } // Without this first invariant, passing a non-DOM-component triggers the next\n  // invariant for a missing parent, which is super confusing.\n\n\n  throw new Error('getNodeFromInstance: Invalid argument.');\n}\nexport function getFiberCurrentPropsFromNode(node) {\n  return node[internalPropsKey] || null;\n}\nexport function updateFiberProps(node, props) {\n  node[internalPropsKey] = props;\n}\nexport function getEventListenerSet(node) {\n  let elementListenerSet = node[internalEventHandlersKey];\n\n  if (elementListenerSet === undefined) {\n    elementListenerSet = node[internalEventHandlersKey] = new Set();\n  }\n\n  return elementListenerSet;\n}\nexport function getFiberFromScopeInstance(scope) {\n  if (enableScopeAPI) {\n    return scope[internalInstanceKey] || null;\n  }\n\n  return null;\n}\nexport function setEventHandlerListeners(scope, listeners) {\n  scope[internalEventHandlerListenersKey] = listeners;\n}\nexport function getEventHandlerListeners(scope) {\n  return scope[internalEventHandlerListenersKey] || null;\n}\nexport function addEventHandleToTarget(target, eventHandle) {\n  let eventHandles = target[internalEventHandlesSetKey];\n\n  if (eventHandles === undefined) {\n    eventHandles = target[internalEventHandlesSetKey] = new Set();\n  }\n\n  eventHandles.add(eventHandle);\n}\nexport function doesTargetHaveEventHandle(target, eventHandle) {\n  const eventHandles = target[internalEventHandlesSetKey];\n\n  if (eventHandles === undefined) {\n    return false;\n  }\n\n  return eventHandles.has(eventHandle);\n}","map":{"version":3,"sources":["/Users/zhangshuo/git/my-app/src/react/packages/react-dom/src/client/ReactDOMComponentTree.js"],"names":["HostComponent","HostText","HostRoot","SuspenseComponent","getParentSuspenseInstance","enableScopeAPI","randomKey","Math","random","toString","slice","internalInstanceKey","internalPropsKey","internalContainerInstanceKey","internalEventHandlersKey","internalEventHandlerListenersKey","internalEventHandlesSetKey","detachDeletedInstance","node","precacheFiberNode","hostInst","markContainerAsRoot","hostRoot","unmarkContainerAsRoot","isContainerMarkedAsRoot","getClosestInstanceFromNode","targetNode","targetInst","parentNode","alternate","child","suspenseInstance","targetSuspenseInst","getInstanceFromNode","inst","tag","getNodeFromInstance","stateNode","Error","getFiberCurrentPropsFromNode","updateFiberProps","props","getEventListenerSet","elementListenerSet","undefined","Set","getFiberFromScopeInstance","scope","setEventHandlerListeners","listeners","getEventHandlerListeners","addEventHandleToTarget","target","eventHandle","eventHandles","add","doesTargetHaveEventHandle","has"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Fiber} from 'react-reconciler/src/ReactInternalTypes';\nimport type {ReactScopeInstance} from 'shared/ReactTypes';\nimport type {\n  ReactDOMEventHandle,\n  ReactDOMEventHandleListener,\n} from '../shared/ReactDOMTypes';\nimport type {\n  Container,\n  TextInstance,\n  Instance,\n  SuspenseInstance,\n  Props,\n} from './ReactDOMHostConfig';\n\nimport {\n  HostComponent,\n  HostText,\n  HostRoot,\n  SuspenseComponent,\n} from 'react-reconciler/src/ReactWorkTags';\n\nimport {getParentSuspenseInstance} from './ReactDOMHostConfig';\n\nimport {enableScopeAPI} from 'shared/ReactFeatureFlags';\n\nconst randomKey = Math.random()\n  .toString(36)\n  .slice(2);\nconst internalInstanceKey = '__reactFiber$' + randomKey;\nconst internalPropsKey = '__reactProps$' + randomKey;\nconst internalContainerInstanceKey = '__reactContainer$' + randomKey;\nconst internalEventHandlersKey = '__reactEvents$' + randomKey;\nconst internalEventHandlerListenersKey = '__reactListeners$' + randomKey;\nconst internalEventHandlesSetKey = '__reactHandles$' + randomKey;\n\nexport function detachDeletedInstance(node: Instance): void {\n  // TODO: This function is only called on host components. I don't think all of\n  // these fields are relevant.\n  delete (node: any)[internalInstanceKey];\n  delete (node: any)[internalPropsKey];\n  delete (node: any)[internalEventHandlersKey];\n  delete (node: any)[internalEventHandlerListenersKey];\n  delete (node: any)[internalEventHandlesSetKey];\n}\n\nexport function precacheFiberNode(\n  hostInst: Fiber,\n  node: Instance | TextInstance | SuspenseInstance | ReactScopeInstance,\n): void {\n  (node: any)[internalInstanceKey] = hostInst;\n}\n\nexport function markContainerAsRoot(hostRoot: Fiber, node: Container): void {\n  node[internalContainerInstanceKey] = hostRoot;\n}\n\nexport function unmarkContainerAsRoot(node: Container): void {\n  node[internalContainerInstanceKey] = null;\n}\n\nexport function isContainerMarkedAsRoot(node: Container): boolean {\n  return !!node[internalContainerInstanceKey];\n}\n\n// Given a DOM node, return the closest HostComponent or HostText fiber ancestor.\n// If the target node is part of a hydrated or not yet rendered subtree, then\n// this may also return a SuspenseComponent or HostRoot to indicate that.\n// Conceptually the HostRoot fiber is a child of the Container node. So if you\n// pass the Container node as the targetNode, you will not actually get the\n// HostRoot back. To get to the HostRoot, you need to pass a child of it.\n// The same thing applies to Suspense boundaries.\nexport function getClosestInstanceFromNode(targetNode: Node): null | Fiber {\n  let targetInst = (targetNode: any)[internalInstanceKey];\n  if (targetInst) {\n    // Don't return HostRoot or SuspenseComponent here.\n    return targetInst;\n  }\n  // If the direct event target isn't a React owned DOM node, we need to look\n  // to see if one of its parents is a React owned DOM node.\n  let parentNode = targetNode.parentNode;\n  while (parentNode) {\n    // We'll check if this is a container root that could include\n    // React nodes in the future. We need to check this first because\n    // if we're a child of a dehydrated container, we need to first\n    // find that inner container before moving on to finding the parent\n    // instance. Note that we don't check this field on  the targetNode\n    // itself because the fibers are conceptually between the container\n    // node and the first child. It isn't surrounding the container node.\n    // If it's not a container, we check if it's an instance.\n    targetInst =\n      (parentNode: any)[internalContainerInstanceKey] ||\n      (parentNode: any)[internalInstanceKey];\n    if (targetInst) {\n      // Since this wasn't the direct target of the event, we might have\n      // stepped past dehydrated DOM nodes to get here. However they could\n      // also have been non-React nodes. We need to answer which one.\n\n      // If we the instance doesn't have any children, then there can't be\n      // a nested suspense boundary within it. So we can use this as a fast\n      // bailout. Most of the time, when people add non-React children to\n      // the tree, it is using a ref to a child-less DOM node.\n      // Normally we'd only need to check one of the fibers because if it\n      // has ever gone from having children to deleting them or vice versa\n      // it would have deleted the dehydrated boundary nested inside already.\n      // However, since the HostRoot starts out with an alternate it might\n      // have one on the alternate so we need to check in case this was a\n      // root.\n      const alternate = targetInst.alternate;\n      if (\n        targetInst.child !== null ||\n        (alternate !== null && alternate.child !== null)\n      ) {\n        // Next we need to figure out if the node that skipped past is\n        // nested within a dehydrated boundary and if so, which one.\n        let suspenseInstance = getParentSuspenseInstance(targetNode);\n        while (suspenseInstance !== null) {\n          // We found a suspense instance. That means that we haven't\n          // hydrated it yet. Even though we leave the comments in the\n          // DOM after hydrating, and there are boundaries in the DOM\n          // that could already be hydrated, we wouldn't have found them\n          // through this pass since if the target is hydrated it would\n          // have had an internalInstanceKey on it.\n          // Let's get the fiber associated with the SuspenseComponent\n          // as the deepest instance.\n          const targetSuspenseInst = suspenseInstance[internalInstanceKey];\n          if (targetSuspenseInst) {\n            return targetSuspenseInst;\n          }\n          // If we don't find a Fiber on the comment, it might be because\n          // we haven't gotten to hydrate it yet. There might still be a\n          // parent boundary that hasn't above this one so we need to find\n          // the outer most that is known.\n          suspenseInstance = getParentSuspenseInstance(suspenseInstance);\n          // If we don't find one, then that should mean that the parent\n          // host component also hasn't hydrated yet. We can return it\n          // below since it will bail out on the isMounted check later.\n        }\n      }\n      return targetInst;\n    }\n    targetNode = parentNode;\n    parentNode = targetNode.parentNode;\n  }\n  return null;\n}\n\n/**\n * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent\n * instance, or null if the node was not rendered by this React.\n */\nexport function getInstanceFromNode(node: Node): Fiber | null {\n  const inst =\n    (node: any)[internalInstanceKey] ||\n    (node: any)[internalContainerInstanceKey];\n  if (inst) {\n    if (\n      inst.tag === HostComponent ||\n      inst.tag === HostText ||\n      inst.tag === SuspenseComponent ||\n      inst.tag === HostRoot\n    ) {\n      return inst;\n    } else {\n      return null;\n    }\n  }\n  return null;\n}\n\n/**\n * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding\n * DOM node.\n */\nexport function getNodeFromInstance(inst: Fiber): Instance | TextInstance {\n  if (inst.tag === HostComponent || inst.tag === HostText) {\n    // In Fiber this, is just the state node right now. We assume it will be\n    // a host component or host text.\n    return inst.stateNode;\n  }\n\n  // Without this first invariant, passing a non-DOM-component triggers the next\n  // invariant for a missing parent, which is super confusing.\n  throw new Error('getNodeFromInstance: Invalid argument.');\n}\n\nexport function getFiberCurrentPropsFromNode(\n  node: Instance | TextInstance | SuspenseInstance,\n): Props {\n  return (node: any)[internalPropsKey] || null;\n}\n\nexport function updateFiberProps(\n  node: Instance | TextInstance | SuspenseInstance,\n  props: Props,\n): void {\n  (node: any)[internalPropsKey] = props;\n}\n\nexport function getEventListenerSet(node: EventTarget): Set<string> {\n  let elementListenerSet = (node: any)[internalEventHandlersKey];\n  if (elementListenerSet === undefined) {\n    elementListenerSet = (node: any)[internalEventHandlersKey] = new Set();\n  }\n  return elementListenerSet;\n}\n\nexport function getFiberFromScopeInstance(\n  scope: ReactScopeInstance,\n): null | Fiber {\n  if (enableScopeAPI) {\n    return (scope: any)[internalInstanceKey] || null;\n  }\n  return null;\n}\n\nexport function setEventHandlerListeners(\n  scope: EventTarget | ReactScopeInstance,\n  listeners: Set<ReactDOMEventHandleListener>,\n): void {\n  (scope: any)[internalEventHandlerListenersKey] = listeners;\n}\n\nexport function getEventHandlerListeners(\n  scope: EventTarget | ReactScopeInstance,\n): null | Set<ReactDOMEventHandleListener> {\n  return (scope: any)[internalEventHandlerListenersKey] || null;\n}\n\nexport function addEventHandleToTarget(\n  target: EventTarget | ReactScopeInstance,\n  eventHandle: ReactDOMEventHandle,\n): void {\n  let eventHandles = (target: any)[internalEventHandlesSetKey];\n  if (eventHandles === undefined) {\n    eventHandles = (target: any)[internalEventHandlesSetKey] = new Set();\n  }\n  eventHandles.add(eventHandle);\n}\n\nexport function doesTargetHaveEventHandle(\n  target: EventTarget | ReactScopeInstance,\n  eventHandle: ReactDOMEventHandle,\n): boolean {\n  const eventHandles = (target: any)[internalEventHandlesSetKey];\n  if (eventHandles === undefined) {\n    return false;\n  }\n  return eventHandles.has(eventHandle);\n}\n"]},"metadata":{},"sourceType":"module"}