{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { resetWorkInProgressVersions as resetMutableSourceWorkInProgressVersions } from './ReactMutableSource.new';\nimport { ClassComponent, HostRoot, HostComponent, HostPortal, ContextProvider, SuspenseComponent, SuspenseListComponent, OffscreenComponent, LegacyHiddenComponent, CacheComponent } from './ReactWorkTags';\nimport { DidCapture, NoFlags, ShouldCapture } from './ReactFiberFlags';\nimport { NoMode, ProfileMode } from './ReactTypeOfMode';\nimport { enableSuspenseServerRenderer, enableProfilerTimer, enableCache } from 'shared/ReactFeatureFlags';\nimport { popHostContainer, popHostContext } from './ReactFiberHostContext.new';\nimport { popSuspenseContext } from './ReactFiberSuspenseContext.new';\nimport { resetHydrationState } from './ReactFiberHydrationContext.new';\nimport { isContextProvider as isLegacyContextProvider, popContext as popLegacyContext, popTopLevelContextObject as popTopLevelLegacyContextObject } from './ReactFiberContext.new';\nimport { popProvider } from './ReactFiberNewContext.new';\nimport { popRenderLanes } from './ReactFiberWorkLoop.new';\nimport { popCacheProvider, popRootCachePool, popCachePool } from './ReactFiberCacheComponent.new';\nimport { transferActualDuration } from './ReactProfilerTimer.new';\nimport { popTreeContext } from './ReactFiberTreeContext.new';\n\nfunction unwindWork(workInProgress, renderLanes) {\n  // Note: This intentionally doesn't check if we're hydrating because comparing\n  // to the current tree provider fiber is just as fast and less error-prone.\n  // Ideally we would have a special version of the work loop only\n  // for hydration.\n  popTreeContext(workInProgress);\n\n  switch (workInProgress.tag) {\n    case ClassComponent:\n      {\n        const Component = workInProgress.type;\n\n        if (isLegacyContextProvider(Component)) {\n          popLegacyContext(workInProgress);\n        }\n\n        const flags = workInProgress.flags;\n\n        if (flags & ShouldCapture) {\n          workInProgress.flags = flags & ~ShouldCapture | DidCapture;\n\n          if (enableProfilerTimer && (workInProgress.mode & ProfileMode) !== NoMode) {\n            transferActualDuration(workInProgress);\n          }\n\n          return workInProgress;\n        }\n\n        return null;\n      }\n\n    case HostRoot:\n      {\n        if (enableCache) {\n          const root = workInProgress.stateNode;\n          popRootCachePool(root, renderLanes);\n          const cache = workInProgress.memoizedState.cache;\n          popCacheProvider(workInProgress, cache);\n        }\n\n        popHostContainer(workInProgress);\n        popTopLevelLegacyContextObject(workInProgress);\n        resetMutableSourceWorkInProgressVersions();\n        const flags = workInProgress.flags;\n\n        if ((flags & DidCapture) !== NoFlags) {\n          throw new Error('The root failed to unmount after an error. This is likely a bug in ' + 'React. Please file an issue.');\n        }\n\n        workInProgress.flags = flags & ~ShouldCapture | DidCapture;\n        return workInProgress;\n      }\n\n    case HostComponent:\n      {\n        // TODO: popHydrationState\n        popHostContext(workInProgress);\n        return null;\n      }\n\n    case SuspenseComponent:\n      {\n        popSuspenseContext(workInProgress);\n\n        if (enableSuspenseServerRenderer) {\n          const suspenseState = workInProgress.memoizedState;\n\n          if (suspenseState !== null && suspenseState.dehydrated !== null) {\n            if (workInProgress.alternate === null) {\n              throw new Error('Threw in newly mounted dehydrated component. This is likely a bug in ' + 'React. Please file an issue.');\n            }\n\n            resetHydrationState();\n          }\n        }\n\n        const flags = workInProgress.flags;\n\n        if (flags & ShouldCapture) {\n          workInProgress.flags = flags & ~ShouldCapture | DidCapture; // Captured a suspense effect. Re-render the boundary.\n\n          if (enableProfilerTimer && (workInProgress.mode & ProfileMode) !== NoMode) {\n            transferActualDuration(workInProgress);\n          }\n\n          return workInProgress;\n        }\n\n        return null;\n      }\n\n    case SuspenseListComponent:\n      {\n        popSuspenseContext(workInProgress); // SuspenseList doesn't actually catch anything. It should've been\n        // caught by a nested boundary. If not, it should bubble through.\n\n        return null;\n      }\n\n    case HostPortal:\n      popHostContainer(workInProgress);\n      return null;\n\n    case ContextProvider:\n      const context = workInProgress.type._context;\n      popProvider(context, workInProgress);\n      return null;\n\n    case OffscreenComponent:\n    case LegacyHiddenComponent:\n      popRenderLanes(workInProgress);\n\n      if (enableCache) {\n        const spawnedCachePool = workInProgress.updateQueue;\n\n        if (spawnedCachePool !== null) {\n          popCachePool(workInProgress);\n        }\n      }\n\n      return null;\n\n    case CacheComponent:\n      if (enableCache) {\n        const cache = workInProgress.memoizedState.cache;\n        popCacheProvider(workInProgress, cache);\n      }\n\n      return null;\n\n    default:\n      return null;\n  }\n}\n\nfunction unwindInterruptedWork(interruptedWork, renderLanes) {\n  // Note: This intentionally doesn't check if we're hydrating because comparing\n  // to the current tree provider fiber is just as fast and less error-prone.\n  // Ideally we would have a special version of the work loop only\n  // for hydration.\n  popTreeContext(interruptedWork);\n\n  switch (interruptedWork.tag) {\n    case ClassComponent:\n      {\n        const childContextTypes = interruptedWork.type.childContextTypes;\n\n        if (childContextTypes !== null && childContextTypes !== undefined) {\n          popLegacyContext(interruptedWork);\n        }\n\n        break;\n      }\n\n    case HostRoot:\n      {\n        if (enableCache) {\n          const root = interruptedWork.stateNode;\n          popRootCachePool(root, renderLanes);\n          const cache = interruptedWork.memoizedState.cache;\n          popCacheProvider(interruptedWork, cache);\n        }\n\n        popHostContainer(interruptedWork);\n        popTopLevelLegacyContextObject(interruptedWork);\n        resetMutableSourceWorkInProgressVersions();\n        break;\n      }\n\n    case HostComponent:\n      {\n        popHostContext(interruptedWork);\n        break;\n      }\n\n    case HostPortal:\n      popHostContainer(interruptedWork);\n      break;\n\n    case SuspenseComponent:\n      popSuspenseContext(interruptedWork);\n      break;\n\n    case SuspenseListComponent:\n      popSuspenseContext(interruptedWork);\n      break;\n\n    case ContextProvider:\n      const context = interruptedWork.type._context;\n      popProvider(context, interruptedWork);\n      break;\n\n    case OffscreenComponent:\n    case LegacyHiddenComponent:\n      popRenderLanes(interruptedWork);\n\n      if (enableCache) {\n        const spawnedCachePool = interruptedWork.updateQueue;\n\n        if (spawnedCachePool !== null) {\n          popCachePool(interruptedWork);\n        }\n      }\n\n      break;\n\n    case CacheComponent:\n      if (enableCache) {\n        const cache = interruptedWork.memoizedState.cache;\n        popCacheProvider(interruptedWork, cache);\n      }\n\n      break;\n\n    default:\n      break;\n  }\n}\n\nexport { unwindWork, unwindInterruptedWork };","map":{"version":3,"sources":["/Users/zhangshuo/git/react-source-test/src/react/packages/react-reconciler/src/ReactFiberUnwindWork.new.js"],"names":["resetWorkInProgressVersions","resetMutableSourceWorkInProgressVersions","ClassComponent","HostRoot","HostComponent","HostPortal","ContextProvider","SuspenseComponent","SuspenseListComponent","OffscreenComponent","LegacyHiddenComponent","CacheComponent","DidCapture","NoFlags","ShouldCapture","NoMode","ProfileMode","enableSuspenseServerRenderer","enableProfilerTimer","enableCache","popHostContainer","popHostContext","popSuspenseContext","resetHydrationState","isContextProvider","isLegacyContextProvider","popContext","popLegacyContext","popTopLevelContextObject","popTopLevelLegacyContextObject","popProvider","popRenderLanes","popCacheProvider","popRootCachePool","popCachePool","transferActualDuration","popTreeContext","unwindWork","workInProgress","renderLanes","tag","Component","type","flags","mode","root","stateNode","cache","memoizedState","Error","suspenseState","dehydrated","alternate","context","_context","spawnedCachePool","updateQueue","unwindInterruptedWork","interruptedWork","childContextTypes","undefined"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {ReactContext} from 'shared/ReactTypes';\nimport type {Fiber, FiberRoot} from './ReactInternalTypes';\nimport type {Lanes} from './ReactFiberLane.new';\nimport type {SuspenseState} from './ReactFiberSuspenseComponent.new';\nimport type {Cache, SpawnedCachePool} from './ReactFiberCacheComponent.new';\n\nimport {resetWorkInProgressVersions as resetMutableSourceWorkInProgressVersions} from './ReactMutableSource.new';\nimport {\n  ClassComponent,\n  HostRoot,\n  HostComponent,\n  HostPortal,\n  ContextProvider,\n  SuspenseComponent,\n  SuspenseListComponent,\n  OffscreenComponent,\n  LegacyHiddenComponent,\n  CacheComponent,\n} from './ReactWorkTags';\nimport {DidCapture, NoFlags, ShouldCapture} from './ReactFiberFlags';\nimport {NoMode, ProfileMode} from './ReactTypeOfMode';\nimport {\n  enableSuspenseServerRenderer,\n  enableProfilerTimer,\n  enableCache,\n} from 'shared/ReactFeatureFlags';\n\nimport {popHostContainer, popHostContext} from './ReactFiberHostContext.new';\nimport {popSuspenseContext} from './ReactFiberSuspenseContext.new';\nimport {resetHydrationState} from './ReactFiberHydrationContext.new';\nimport {\n  isContextProvider as isLegacyContextProvider,\n  popContext as popLegacyContext,\n  popTopLevelContextObject as popTopLevelLegacyContextObject,\n} from './ReactFiberContext.new';\nimport {popProvider} from './ReactFiberNewContext.new';\nimport {popRenderLanes} from './ReactFiberWorkLoop.new';\nimport {\n  popCacheProvider,\n  popRootCachePool,\n  popCachePool,\n} from './ReactFiberCacheComponent.new';\nimport {transferActualDuration} from './ReactProfilerTimer.new';\nimport {popTreeContext} from './ReactFiberTreeContext.new';\n\nfunction unwindWork(workInProgress: Fiber, renderLanes: Lanes) {\n  // Note: This intentionally doesn't check if we're hydrating because comparing\n  // to the current tree provider fiber is just as fast and less error-prone.\n  // Ideally we would have a special version of the work loop only\n  // for hydration.\n  popTreeContext(workInProgress);\n  switch (workInProgress.tag) {\n    case ClassComponent: {\n      const Component = workInProgress.type;\n      if (isLegacyContextProvider(Component)) {\n        popLegacyContext(workInProgress);\n      }\n      const flags = workInProgress.flags;\n      if (flags & ShouldCapture) {\n        workInProgress.flags = (flags & ~ShouldCapture) | DidCapture;\n        if (\n          enableProfilerTimer &&\n          (workInProgress.mode & ProfileMode) !== NoMode\n        ) {\n          transferActualDuration(workInProgress);\n        }\n        return workInProgress;\n      }\n      return null;\n    }\n    case HostRoot: {\n      if (enableCache) {\n        const root: FiberRoot = workInProgress.stateNode;\n        popRootCachePool(root, renderLanes);\n\n        const cache: Cache = workInProgress.memoizedState.cache;\n        popCacheProvider(workInProgress, cache);\n      }\n      popHostContainer(workInProgress);\n      popTopLevelLegacyContextObject(workInProgress);\n      resetMutableSourceWorkInProgressVersions();\n      const flags = workInProgress.flags;\n\n      if ((flags & DidCapture) !== NoFlags) {\n        throw new Error(\n          'The root failed to unmount after an error. This is likely a bug in ' +\n            'React. Please file an issue.',\n        );\n      }\n\n      workInProgress.flags = (flags & ~ShouldCapture) | DidCapture;\n      return workInProgress;\n    }\n    case HostComponent: {\n      // TODO: popHydrationState\n      popHostContext(workInProgress);\n      return null;\n    }\n    case SuspenseComponent: {\n      popSuspenseContext(workInProgress);\n      if (enableSuspenseServerRenderer) {\n        const suspenseState: null | SuspenseState =\n          workInProgress.memoizedState;\n        if (suspenseState !== null && suspenseState.dehydrated !== null) {\n          if (workInProgress.alternate === null) {\n            throw new Error(\n              'Threw in newly mounted dehydrated component. This is likely a bug in ' +\n                'React. Please file an issue.',\n            );\n          }\n\n          resetHydrationState();\n        }\n      }\n      const flags = workInProgress.flags;\n      if (flags & ShouldCapture) {\n        workInProgress.flags = (flags & ~ShouldCapture) | DidCapture;\n        // Captured a suspense effect. Re-render the boundary.\n        if (\n          enableProfilerTimer &&\n          (workInProgress.mode & ProfileMode) !== NoMode\n        ) {\n          transferActualDuration(workInProgress);\n        }\n        return workInProgress;\n      }\n      return null;\n    }\n    case SuspenseListComponent: {\n      popSuspenseContext(workInProgress);\n      // SuspenseList doesn't actually catch anything. It should've been\n      // caught by a nested boundary. If not, it should bubble through.\n      return null;\n    }\n    case HostPortal:\n      popHostContainer(workInProgress);\n      return null;\n    case ContextProvider:\n      const context: ReactContext<any> = workInProgress.type._context;\n      popProvider(context, workInProgress);\n      return null;\n    case OffscreenComponent:\n    case LegacyHiddenComponent:\n      popRenderLanes(workInProgress);\n      if (enableCache) {\n        const spawnedCachePool: SpawnedCachePool | null = (workInProgress.updateQueue: any);\n        if (spawnedCachePool !== null) {\n          popCachePool(workInProgress);\n        }\n      }\n      return null;\n    case CacheComponent:\n      if (enableCache) {\n        const cache: Cache = workInProgress.memoizedState.cache;\n        popCacheProvider(workInProgress, cache);\n      }\n      return null;\n    default:\n      return null;\n  }\n}\n\nfunction unwindInterruptedWork(interruptedWork: Fiber, renderLanes: Lanes) {\n  // Note: This intentionally doesn't check if we're hydrating because comparing\n  // to the current tree provider fiber is just as fast and less error-prone.\n  // Ideally we would have a special version of the work loop only\n  // for hydration.\n  popTreeContext(interruptedWork);\n  switch (interruptedWork.tag) {\n    case ClassComponent: {\n      const childContextTypes = interruptedWork.type.childContextTypes;\n      if (childContextTypes !== null && childContextTypes !== undefined) {\n        popLegacyContext(interruptedWork);\n      }\n      break;\n    }\n    case HostRoot: {\n      if (enableCache) {\n        const root: FiberRoot = interruptedWork.stateNode;\n        popRootCachePool(root, renderLanes);\n\n        const cache: Cache = interruptedWork.memoizedState.cache;\n        popCacheProvider(interruptedWork, cache);\n      }\n      popHostContainer(interruptedWork);\n      popTopLevelLegacyContextObject(interruptedWork);\n      resetMutableSourceWorkInProgressVersions();\n      break;\n    }\n    case HostComponent: {\n      popHostContext(interruptedWork);\n      break;\n    }\n    case HostPortal:\n      popHostContainer(interruptedWork);\n      break;\n    case SuspenseComponent:\n      popSuspenseContext(interruptedWork);\n      break;\n    case SuspenseListComponent:\n      popSuspenseContext(interruptedWork);\n      break;\n    case ContextProvider:\n      const context: ReactContext<any> = interruptedWork.type._context;\n      popProvider(context, interruptedWork);\n      break;\n    case OffscreenComponent:\n    case LegacyHiddenComponent:\n      popRenderLanes(interruptedWork);\n      if (enableCache) {\n        const spawnedCachePool: SpawnedCachePool | null = (interruptedWork.updateQueue: any);\n        if (spawnedCachePool !== null) {\n          popCachePool(interruptedWork);\n        }\n      }\n\n      break;\n    case CacheComponent:\n      if (enableCache) {\n        const cache: Cache = interruptedWork.memoizedState.cache;\n        popCacheProvider(interruptedWork, cache);\n      }\n      break;\n    default:\n      break;\n  }\n}\n\nexport {unwindWork, unwindInterruptedWork};\n"]},"metadata":{},"sourceType":"module"}