{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { enableCache } from 'shared/ReactFeatureFlags';\nimport { REACT_CONTEXT_TYPE } from 'shared/ReactSymbols';\nimport { isPrimaryRenderer } from './ReactFiberHostConfig';\nimport { createCursor, push, pop } from './ReactFiberStack.old';\nimport { pushProvider, popProvider } from './ReactFiberNewContext.old';\nimport * as Scheduler from 'scheduler';\n// Intentionally not named imports because Rollup would\n// use dynamic dispatch for CommonJS interop named imports.\nconst {\n  unstable_scheduleCallback: scheduleCallback,\n  unstable_NormalPriority: NormalPriority\n} = Scheduler;\nexport const CacheContext = enableCache ? {\n  $$typeof: REACT_CONTEXT_TYPE,\n  // We don't use Consumer/Provider for Cache components. So we'll cheat.\n  Consumer: null,\n  Provider: null,\n  // We'll initialize these at the root.\n  _currentValue: null,\n  _currentValue2: null,\n  _threadCount: 0\n} : null;\n\nif (__DEV__ && enableCache) {\n  CacheContext._currentRenderer = null;\n  CacheContext._currentRenderer2 = null;\n} // The cache that newly mounted Cache boundaries should use. It's either\n// retrieved from the cache pool, or the result of a refresh.\n\n\nlet pooledCache = null; // When retrying a Suspense/Offscreen boundary, we override pooledCache with the\n// cache from the render that suspended.\n\nconst prevFreshCacheOnStack = createCursor(null); // Creates a new empty Cache instance with a ref-count of 0. The caller is responsible\n// for retaining the cache once it is in use (retainCache), and releasing the cache\n// once it is no longer needed (releaseCache).\n\nexport function createCache() {\n  if (!enableCache) {\n    return null;\n  }\n\n  const cache = {\n    controller: new AbortController(),\n    data: new Map(),\n    refCount: 0\n  };\n  return cache;\n}\nexport function retainCache(cache) {\n  if (!enableCache) {\n    return;\n  }\n\n  if (__DEV__) {\n    if (cache.controller.signal.aborted) {\n      console.warn('A cache instance was retained after it was already freed. ' + 'This likely indicates a bug in React.');\n    }\n  }\n\n  cache.refCount++;\n} // Cleanup a cache instance, potentially freeing it if there are no more references\n\nexport function releaseCache(cache) {\n  if (!enableCache) {\n    return;\n  }\n\n  cache.refCount--;\n\n  if (__DEV__) {\n    if (cache.refCount < 0) {\n      console.warn('A cache instance was released after it was already freed. ' + 'This likely indicates a bug in React.');\n    }\n  }\n\n  if (cache.refCount === 0) {\n    scheduleCallback(NormalPriority, () => {\n      cache.controller.abort();\n    });\n  }\n}\nexport function pushCacheProvider(workInProgress, cache) {\n  if (!enableCache) {\n    return;\n  }\n\n  pushProvider(workInProgress, CacheContext, cache);\n}\nexport function popCacheProvider(workInProgress, cache) {\n  if (!enableCache) {\n    return;\n  }\n\n  popProvider(CacheContext, workInProgress);\n}\nexport function requestCacheFromPool(renderLanes) {\n  if (!enableCache) {\n    return null;\n  }\n\n  if (pooledCache !== null) {\n    return pooledCache;\n  } // Create a fresh cache. The pooled cache must be owned - it is freed\n  // in releaseRootPooledCache() - but the cache instance handed out\n  // is retained/released in the commit phase of the component that\n  // references is (ie the host root, cache boundary, suspense component)\n  // Ie, pooledCache is conceptually an Option<Arc<Cache>> (owned),\n  // whereas the return value of this function is a &Arc<Cache> (borrowed).\n\n\n  pooledCache = createCache();\n  retainCache(pooledCache);\n  return pooledCache;\n}\nexport function pushRootCachePool(root) {\n  if (!enableCache) {\n    return;\n  } // When we start rendering a tree, read the pooled cache for this render\n  // from `root.pooledCache`. If it's currently `null`, we will lazily\n  // initialize it the first type it's requested. However, we only mutate\n  // the root itself during the complete/unwind phase of the HostRoot.\n\n\n  const rootCache = root.pooledCache;\n\n  if (rootCache != null) {\n    pooledCache = rootCache;\n    root.pooledCache = null;\n  } else {\n    pooledCache = null;\n  }\n}\nexport function popRootCachePool(root, renderLanes) {\n  if (!enableCache) {\n    return;\n  } // The `pooledCache` variable points to the cache that was used for new\n  // cache boundaries during this render, if any. Move ownership of the\n  // cache to the root so that parallel transitions may share the same\n  // cache. We will clear this field once all the transitions that depend\n  // on it (which we track with `pooledCacheLanes`) have committed.\n\n\n  root.pooledCache = pooledCache;\n\n  if (pooledCache !== null) {\n    root.pooledCacheLanes |= renderLanes;\n  } // set to null, conceptually we are moving ownership to the root\n\n\n  pooledCache = null;\n}\nexport function restoreSpawnedCachePool(offscreenWorkInProgress, prevCachePool) {\n  if (!enableCache) {\n    return null;\n  }\n\n  const nextParentCache = isPrimaryRenderer ? CacheContext._currentValue : CacheContext._currentValue2;\n\n  if (nextParentCache !== prevCachePool.parent) {\n    // There was a refresh. Don't bother restoring anything since the refresh\n    // will override it.\n    return null;\n  } else {\n    // No refresh. Resume with the previous cache. This will override the cache\n    // pool so that any new Cache boundaries in the subtree use this one instead\n    // of requesting a fresh one.\n    push(prevFreshCacheOnStack, pooledCache, offscreenWorkInProgress);\n    pooledCache = prevCachePool.pool; // Return the cache pool to signal that we did in fact push it. We will\n    // assign this to the field on the fiber so we know to pop the context.\n\n    return prevCachePool;\n  }\n} // Note: Ideally, `popCachePool` would return this value, and then we would pass\n// it to `getSuspendedCachePool`. But factoring reasons, those two functions are\n// in different phases/files. They are always called in sequence, though, so we\n// can stash the value here temporarily.\n\nlet _suspendedPooledCache = null;\nexport function popCachePool(workInProgress) {\n  if (!enableCache) {\n    return;\n  }\n\n  _suspendedPooledCache = pooledCache;\n  pooledCache = prevFreshCacheOnStack.current;\n  pop(prevFreshCacheOnStack, workInProgress);\n}\nexport function getSuspendedCachePool() {\n  if (!enableCache) {\n    return null;\n  } // We check the cache on the stack first, since that's the one any new Caches\n  // would have accessed.\n\n\n  let pool = pooledCache;\n\n  if (pool === null) {\n    // There's no pooled cache above us in the stack. However, a child in the\n    // suspended tree may have requested a fresh cache pool. If so, we would\n    // have unwound it with `popCachePool`.\n    if (_suspendedPooledCache !== null) {\n      pool = _suspendedPooledCache;\n      _suspendedPooledCache = null;\n    } else {\n      // There's no suspended cache pool.\n      return null;\n    }\n  }\n\n  return {\n    // We must also save the parent, so that when we resume we can detect\n    // a refresh.\n    parent: isPrimaryRenderer ? CacheContext._currentValue : CacheContext._currentValue2,\n    pool\n  };\n}\nexport function getOffscreenDeferredCachePool() {\n  if (!enableCache) {\n    return null;\n  }\n\n  if (pooledCache === null) {\n    // There's no deferred cache pool.\n    return null;\n  }\n\n  return {\n    // We must also store the parent, so that when we resume we can detect\n    // a refresh.\n    parent: isPrimaryRenderer ? CacheContext._currentValue : CacheContext._currentValue2,\n    pool: pooledCache\n  };\n}","map":{"version":3,"sources":["/Users/zhangshuo/git/react-source-test/src/react/packages/react-reconciler/src/ReactFiberCacheComponent.old.js"],"names":["enableCache","REACT_CONTEXT_TYPE","isPrimaryRenderer","createCursor","push","pop","pushProvider","popProvider","Scheduler","unstable_scheduleCallback","scheduleCallback","unstable_NormalPriority","NormalPriority","CacheContext","$$typeof","Consumer","Provider","_currentValue","_currentValue2","_threadCount","__DEV__","_currentRenderer","_currentRenderer2","pooledCache","prevFreshCacheOnStack","createCache","cache","controller","AbortController","data","Map","refCount","retainCache","signal","aborted","console","warn","releaseCache","abort","pushCacheProvider","workInProgress","popCacheProvider","requestCacheFromPool","renderLanes","pushRootCachePool","root","rootCache","popRootCachePool","pooledCacheLanes","restoreSpawnedCachePool","offscreenWorkInProgress","prevCachePool","nextParentCache","parent","pool","_suspendedPooledCache","popCachePool","current","getSuspendedCachePool","getOffscreenDeferredCachePool"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {ReactContext} from 'shared/ReactTypes';\nimport type {FiberRoot} from './ReactInternalTypes';\nimport type {Lanes} from './ReactFiberLane.old';\nimport type {StackCursor} from './ReactFiberStack.old';\n\nimport {enableCache} from 'shared/ReactFeatureFlags';\nimport {REACT_CONTEXT_TYPE} from 'shared/ReactSymbols';\n\nimport {isPrimaryRenderer} from './ReactFiberHostConfig';\nimport {createCursor, push, pop} from './ReactFiberStack.old';\nimport {pushProvider, popProvider} from './ReactFiberNewContext.old';\nimport * as Scheduler from 'scheduler';\n\nexport type Cache = {|\n  controller: AbortController,\n  data: Map<() => mixed, mixed>,\n  refCount: number,\n|};\n\nexport type CacheComponentState = {|\n  +parent: Cache,\n  +cache: Cache,\n|};\n\nexport type SpawnedCachePool = {|\n  +parent: Cache,\n  +pool: Cache,\n|};\n\n// Intentionally not named imports because Rollup would\n// use dynamic dispatch for CommonJS interop named imports.\nconst {\n  unstable_scheduleCallback: scheduleCallback,\n  unstable_NormalPriority: NormalPriority,\n} = Scheduler;\n\nexport const CacheContext: ReactContext<Cache> = enableCache\n  ? {\n      $$typeof: REACT_CONTEXT_TYPE,\n      // We don't use Consumer/Provider for Cache components. So we'll cheat.\n      Consumer: (null: any),\n      Provider: (null: any),\n      // We'll initialize these at the root.\n      _currentValue: (null: any),\n      _currentValue2: (null: any),\n      _threadCount: 0,\n    }\n  : (null: any);\n\nif (__DEV__ && enableCache) {\n  CacheContext._currentRenderer = null;\n  CacheContext._currentRenderer2 = null;\n}\n\n// The cache that newly mounted Cache boundaries should use. It's either\n// retrieved from the cache pool, or the result of a refresh.\nlet pooledCache: Cache | null = null;\n\n// When retrying a Suspense/Offscreen boundary, we override pooledCache with the\n// cache from the render that suspended.\nconst prevFreshCacheOnStack: StackCursor<Cache | null> = createCursor(null);\n\n// Creates a new empty Cache instance with a ref-count of 0. The caller is responsible\n// for retaining the cache once it is in use (retainCache), and releasing the cache\n// once it is no longer needed (releaseCache).\nexport function createCache(): Cache {\n  if (!enableCache) {\n    return (null: any);\n  }\n  const cache: Cache = {\n    controller: new AbortController(),\n    data: new Map(),\n    refCount: 0,\n  };\n\n  return cache;\n}\n\nexport function retainCache(cache: Cache) {\n  if (!enableCache) {\n    return;\n  }\n  if (__DEV__) {\n    if (cache.controller.signal.aborted) {\n      console.warn(\n        'A cache instance was retained after it was already freed. ' +\n          'This likely indicates a bug in React.',\n      );\n    }\n  }\n  cache.refCount++;\n}\n\n// Cleanup a cache instance, potentially freeing it if there are no more references\nexport function releaseCache(cache: Cache) {\n  if (!enableCache) {\n    return;\n  }\n  cache.refCount--;\n  if (__DEV__) {\n    if (cache.refCount < 0) {\n      console.warn(\n        'A cache instance was released after it was already freed. ' +\n          'This likely indicates a bug in React.',\n      );\n    }\n  }\n  if (cache.refCount === 0) {\n    scheduleCallback(NormalPriority, () => {\n      cache.controller.abort();\n    });\n  }\n}\n\nexport function pushCacheProvider(workInProgress: Fiber, cache: Cache) {\n  if (!enableCache) {\n    return;\n  }\n  pushProvider(workInProgress, CacheContext, cache);\n}\n\nexport function popCacheProvider(workInProgress: Fiber, cache: Cache) {\n  if (!enableCache) {\n    return;\n  }\n  popProvider(CacheContext, workInProgress);\n}\n\nexport function requestCacheFromPool(renderLanes: Lanes): Cache {\n  if (!enableCache) {\n    return (null: any);\n  }\n  if (pooledCache !== null) {\n    return pooledCache;\n  }\n  // Create a fresh cache. The pooled cache must be owned - it is freed\n  // in releaseRootPooledCache() - but the cache instance handed out\n  // is retained/released in the commit phase of the component that\n  // references is (ie the host root, cache boundary, suspense component)\n  // Ie, pooledCache is conceptually an Option<Arc<Cache>> (owned),\n  // whereas the return value of this function is a &Arc<Cache> (borrowed).\n  pooledCache = createCache();\n  retainCache(pooledCache);\n  return pooledCache;\n}\n\nexport function pushRootCachePool(root: FiberRoot) {\n  if (!enableCache) {\n    return;\n  }\n  // When we start rendering a tree, read the pooled cache for this render\n  // from `root.pooledCache`. If it's currently `null`, we will lazily\n  // initialize it the first type it's requested. However, we only mutate\n  // the root itself during the complete/unwind phase of the HostRoot.\n  const rootCache = root.pooledCache;\n  if (rootCache != null) {\n    pooledCache = rootCache;\n    root.pooledCache = null;\n  } else {\n    pooledCache = null;\n  }\n}\n\nexport function popRootCachePool(root: FiberRoot, renderLanes: Lanes) {\n  if (!enableCache) {\n    return;\n  }\n  // The `pooledCache` variable points to the cache that was used for new\n  // cache boundaries during this render, if any. Move ownership of the\n  // cache to the root so that parallel transitions may share the same\n  // cache. We will clear this field once all the transitions that depend\n  // on it (which we track with `pooledCacheLanes`) have committed.\n  root.pooledCache = pooledCache;\n  if (pooledCache !== null) {\n    root.pooledCacheLanes |= renderLanes;\n  }\n  // set to null, conceptually we are moving ownership to the root\n  pooledCache = null;\n}\n\nexport function restoreSpawnedCachePool(\n  offscreenWorkInProgress: Fiber,\n  prevCachePool: SpawnedCachePool,\n): SpawnedCachePool | null {\n  if (!enableCache) {\n    return (null: any);\n  }\n  const nextParentCache = isPrimaryRenderer\n    ? CacheContext._currentValue\n    : CacheContext._currentValue2;\n  if (nextParentCache !== prevCachePool.parent) {\n    // There was a refresh. Don't bother restoring anything since the refresh\n    // will override it.\n    return null;\n  } else {\n    // No refresh. Resume with the previous cache. This will override the cache\n    // pool so that any new Cache boundaries in the subtree use this one instead\n    // of requesting a fresh one.\n    push(prevFreshCacheOnStack, pooledCache, offscreenWorkInProgress);\n    pooledCache = prevCachePool.pool;\n\n    // Return the cache pool to signal that we did in fact push it. We will\n    // assign this to the field on the fiber so we know to pop the context.\n    return prevCachePool;\n  }\n}\n\n// Note: Ideally, `popCachePool` would return this value, and then we would pass\n// it to `getSuspendedCachePool`. But factoring reasons, those two functions are\n// in different phases/files. They are always called in sequence, though, so we\n// can stash the value here temporarily.\nlet _suspendedPooledCache: Cache | null = null;\n\nexport function popCachePool(workInProgress: Fiber) {\n  if (!enableCache) {\n    return;\n  }\n  _suspendedPooledCache = pooledCache;\n  pooledCache = prevFreshCacheOnStack.current;\n  pop(prevFreshCacheOnStack, workInProgress);\n}\n\nexport function getSuspendedCachePool(): SpawnedCachePool | null {\n  if (!enableCache) {\n    return null;\n  }\n  // We check the cache on the stack first, since that's the one any new Caches\n  // would have accessed.\n  let pool = pooledCache;\n  if (pool === null) {\n    // There's no pooled cache above us in the stack. However, a child in the\n    // suspended tree may have requested a fresh cache pool. If so, we would\n    // have unwound it with `popCachePool`.\n    if (_suspendedPooledCache !== null) {\n      pool = _suspendedPooledCache;\n      _suspendedPooledCache = null;\n    } else {\n      // There's no suspended cache pool.\n      return null;\n    }\n  }\n\n  return {\n    // We must also save the parent, so that when we resume we can detect\n    // a refresh.\n    parent: isPrimaryRenderer\n      ? CacheContext._currentValue\n      : CacheContext._currentValue2,\n    pool,\n  };\n}\n\nexport function getOffscreenDeferredCachePool(): SpawnedCachePool | null {\n  if (!enableCache) {\n    return null;\n  }\n\n  if (pooledCache === null) {\n    // There's no deferred cache pool.\n    return null;\n  }\n\n  return {\n    // We must also store the parent, so that when we resume we can detect\n    // a refresh.\n    parent: isPrimaryRenderer\n      ? CacheContext._currentValue\n      : CacheContext._currentValue2,\n    pool: pooledCache,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}