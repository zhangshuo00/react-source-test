{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { resetWorkInProgressVersions as resetMutableSourceWorkInProgressVersions } from './ReactMutableSource.new';\nimport { now } from './Scheduler';\nimport { IndeterminateComponent, FunctionComponent, ClassComponent, HostRoot, HostComponent, HostText, HostPortal, ContextProvider, ContextConsumer, ForwardRef, Fragment, Mode, Profiler, SuspenseComponent, SuspenseListComponent, MemoComponent, SimpleMemoComponent, LazyComponent, IncompleteClassComponent, ScopeComponent, OffscreenComponent, LegacyHiddenComponent, CacheComponent } from './ReactWorkTags';\nimport { NoMode, ConcurrentMode, ProfileMode } from './ReactTypeOfMode';\nimport { Ref, RefStatic, Placement, Update, Visibility, NoFlags, DidCapture, Snapshot, ChildDeletion, StaticMask, MutationMask, Passive } from './ReactFiberFlags';\nimport { createInstance, createTextInstance, appendInitialChild, finalizeInitialChildren, prepareUpdate, supportsMutation, supportsPersistence, cloneInstance, cloneHiddenInstance, cloneHiddenTextInstance, createContainerChildSet, appendChildToContainerChildSet, finalizeContainerChildren, preparePortalMount, prepareScopeUpdate } from './ReactFiberHostConfig';\nimport { getRootHostContainer, popHostContext, getHostContext, popHostContainer } from './ReactFiberHostContext.new';\nimport { suspenseStackCursor, InvisibleParentSuspenseContext, hasSuspenseContext, popSuspenseContext, pushSuspenseContext, setShallowSuspenseContext, ForceSuspenseFallback, setDefaultShallowSuspenseContext } from './ReactFiberSuspenseContext.new';\nimport { findFirstSuspended } from './ReactFiberSuspenseComponent.new';\nimport { isContextProvider as isLegacyContextProvider, popContext as popLegacyContext, popTopLevelContextObject as popTopLevelLegacyContextObject } from './ReactFiberContext.new';\nimport { popProvider } from './ReactFiberNewContext.new';\nimport { prepareToHydrateHostInstance, prepareToHydrateHostTextInstance, prepareToHydrateHostSuspenseInstance, popHydrationState, resetHydrationState, getIsHydrating } from './ReactFiberHydrationContext.new';\nimport { enableSuspenseCallback, enableSuspenseServerRenderer, enableScopeAPI, enableProfilerTimer, enableCache, enableSuspenseLayoutEffectSemantics, enablePersistentOffscreenHostContainer } from 'shared/ReactFeatureFlags';\nimport { renderDidSuspend, renderDidSuspendDelayIfPossible, renderHasNotSuspendedYet, popRenderLanes, getRenderTargetTime, subtreeRenderLanes } from './ReactFiberWorkLoop.new';\nimport { OffscreenLane, SomeRetryLane, NoLanes, includesSomeLane, mergeLanes } from './ReactFiberLane.new';\nimport { resetChildFibers } from './ReactChildFiber.new';\nimport { createScopeInstance } from './ReactFiberScope.new';\nimport { transferActualDuration } from './ReactProfilerTimer.new';\nimport { popCacheProvider, popRootCachePool, popCachePool } from './ReactFiberCacheComponent.new';\nimport { popTreeContext } from './ReactFiberTreeContext.new';\n\nfunction markUpdate(workInProgress) {\n  // Tag the fiber with an update effect. This turns a Placement into\n  // a PlacementAndUpdate.\n  workInProgress.flags |= Update;\n}\n\nfunction markRef(workInProgress) {\n  workInProgress.flags |= Ref;\n\n  if (enableSuspenseLayoutEffectSemantics) {\n    workInProgress.flags |= RefStatic;\n  }\n}\n\nfunction hadNoMutationsEffects(current, completedWork) {\n  const didBailout = current !== null && current.child === completedWork.child;\n\n  if (didBailout) {\n    return true;\n  }\n\n  if ((completedWork.flags & ChildDeletion) !== NoFlags) {\n    return false;\n  } // TODO: If we move the `hadNoMutationsEffects` call after `bubbleProperties`\n  // then we only have to check the `completedWork.subtreeFlags`.\n\n\n  let child = completedWork.child;\n\n  while (child !== null) {\n    if ((child.flags & MutationMask) !== NoFlags || (child.subtreeFlags & MutationMask) !== NoFlags) {\n      return false;\n    }\n\n    child = child.sibling;\n  }\n\n  return true;\n}\n\nlet appendAllChildren;\nlet updateHostContainer;\nlet updateHostComponent;\nlet updateHostText;\n\nif (supportsMutation) {\n  // Mutation mode\n  appendAllChildren = function (parent, workInProgress, needsVisibilityToggle, isHidden) {\n    // We only have the top Fiber that was created but we need recurse down its\n    // children to find all the terminal nodes.\n    let node = workInProgress.child;\n\n    while (node !== null) {\n      if (node.tag === HostComponent || node.tag === HostText) {\n        appendInitialChild(parent, node.stateNode);\n      } else if (node.tag === HostPortal) {// If we have a portal child, then we don't want to traverse\n        // down its children. Instead, we'll get insertions from each child in\n        // the portal directly.\n      } else if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n\n      if (node === workInProgress) {\n        return;\n      }\n\n      while (node.sibling === null) {\n        if (node.return === null || node.return === workInProgress) {\n          return;\n        }\n\n        node = node.return;\n      }\n\n      node.sibling.return = node.return;\n      node = node.sibling;\n    }\n  };\n\n  updateHostContainer = function (current, workInProgress) {// Noop\n  };\n\n  updateHostComponent = function (current, workInProgress, type, newProps, rootContainerInstance) {\n    // If we have an alternate, that means this is an update and we need to\n    // schedule a side-effect to do the updates.\n    const oldProps = current.memoizedProps;\n\n    if (oldProps === newProps) {\n      // In mutation mode, this is sufficient for a bailout because\n      // we won't touch this node even if children changed.\n      return;\n    } // If we get updated because one of our children updated, we don't\n    // have newProps so we'll have to reuse them.\n    // TODO: Split the update API as separate for the props vs. children.\n    // Even better would be if children weren't special cased at all tho.\n\n\n    const instance = workInProgress.stateNode;\n    const currentHostContext = getHostContext(); // TODO: Experiencing an error where oldProps is null. Suggests a host\n    // component is hitting the resume path. Figure out why. Possibly\n    // related to `hidden`.\n\n    const updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext); // TODO: Type this specific to this type of component.\n\n    workInProgress.updateQueue = updatePayload; // If the update payload indicates that there is a change or if there\n    // is a new ref we mark this as an update. All the work is done in commitWork.\n\n    if (updatePayload) {\n      markUpdate(workInProgress);\n    }\n  };\n\n  updateHostText = function (current, workInProgress, oldText, newText) {\n    // If the text differs, mark it as an update. All the work in done in commitWork.\n    if (oldText !== newText) {\n      markUpdate(workInProgress);\n    }\n  };\n} else if (supportsPersistence) {\n  // Persistent host tree mode\n  appendAllChildren = function (parent, workInProgress, needsVisibilityToggle, isHidden) {\n    // We only have the top Fiber that was created but we need recurse down its\n    // children to find all the terminal nodes.\n    let node = workInProgress.child;\n\n    while (node !== null) {\n      // eslint-disable-next-line no-labels\n      branches: if (node.tag === HostComponent) {\n        let instance = node.stateNode;\n\n        if (needsVisibilityToggle && isHidden) {\n          // This child is inside a timed out tree. Hide it.\n          const props = node.memoizedProps;\n          const type = node.type;\n          instance = cloneHiddenInstance(instance, type, props, node);\n        }\n\n        appendInitialChild(parent, instance);\n      } else if (node.tag === HostText) {\n        let instance = node.stateNode;\n\n        if (needsVisibilityToggle && isHidden) {\n          // This child is inside a timed out tree. Hide it.\n          const text = node.memoizedProps;\n          instance = cloneHiddenTextInstance(instance, text, node);\n        }\n\n        appendInitialChild(parent, instance);\n      } else if (node.tag === HostPortal) {// If we have a portal child, then we don't want to traverse\n        // down its children. Instead, we'll get insertions from each child in\n        // the portal directly.\n      } else if (node.tag === OffscreenComponent && node.memoizedState !== null) {\n        // The children in this boundary are hidden. Toggle their visibility\n        // before appending.\n        const child = node.child;\n\n        if (child !== null) {\n          child.return = node;\n        }\n\n        if (enablePersistentOffscreenHostContainer) {\n          appendAllChildren(parent, node, false, false);\n        } else {\n          appendAllChildren(parent, node, true, true);\n        }\n      } else if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      } // $FlowFixMe This is correct but Flow is confused by the labeled break.\n\n\n      node = node;\n\n      if (node === workInProgress) {\n        return;\n      }\n\n      while (node.sibling === null) {\n        if (node.return === null || node.return === workInProgress) {\n          return;\n        }\n\n        node = node.return;\n      }\n\n      node.sibling.return = node.return;\n      node = node.sibling;\n    }\n  }; // An unfortunate fork of appendAllChildren because we have two different parent types.\n\n\n  const appendAllChildrenToContainer = function (containerChildSet, workInProgress, needsVisibilityToggle, isHidden) {\n    // We only have the top Fiber that was created but we need recurse down its\n    // children to find all the terminal nodes.\n    let node = workInProgress.child;\n\n    while (node !== null) {\n      // eslint-disable-next-line no-labels\n      branches: if (node.tag === HostComponent) {\n        let instance = node.stateNode;\n\n        if (needsVisibilityToggle && isHidden) {\n          // This child is inside a timed out tree. Hide it.\n          const props = node.memoizedProps;\n          const type = node.type;\n          instance = cloneHiddenInstance(instance, type, props, node);\n        }\n\n        appendChildToContainerChildSet(containerChildSet, instance);\n      } else if (node.tag === HostText) {\n        let instance = node.stateNode;\n\n        if (needsVisibilityToggle && isHidden) {\n          // This child is inside a timed out tree. Hide it.\n          const text = node.memoizedProps;\n          instance = cloneHiddenTextInstance(instance, text, node);\n        }\n\n        appendChildToContainerChildSet(containerChildSet, instance);\n      } else if (node.tag === HostPortal) {// If we have a portal child, then we don't want to traverse\n        // down its children. Instead, we'll get insertions from each child in\n        // the portal directly.\n      } else if (node.tag === OffscreenComponent && node.memoizedState !== null) {\n        // The children in this boundary are hidden. Toggle their visibility\n        // before appending.\n        const child = node.child;\n\n        if (child !== null) {\n          child.return = node;\n        }\n\n        if (enablePersistentOffscreenHostContainer) {\n          appendAllChildrenToContainer(containerChildSet, node, false, false);\n        } else {\n          appendAllChildrenToContainer(containerChildSet, node, true, true);\n        }\n      } else if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      } // $FlowFixMe This is correct but Flow is confused by the labeled break.\n\n\n      node = node;\n\n      if (node === workInProgress) {\n        return;\n      }\n\n      while (node.sibling === null) {\n        if (node.return === null || node.return === workInProgress) {\n          return;\n        }\n\n        node = node.return;\n      }\n\n      node.sibling.return = node.return;\n      node = node.sibling;\n    }\n  };\n\n  updateHostContainer = function (current, workInProgress) {\n    const portalOrRoot = workInProgress.stateNode;\n    const childrenUnchanged = hadNoMutationsEffects(current, workInProgress);\n\n    if (childrenUnchanged) {// No changes, just reuse the existing instance.\n    } else {\n      const container = portalOrRoot.containerInfo;\n      const newChildSet = createContainerChildSet(container); // If children might have changed, we have to add them all to the set.\n\n      appendAllChildrenToContainer(newChildSet, workInProgress, false, false);\n      portalOrRoot.pendingChildren = newChildSet; // Schedule an update on the container to swap out the container.\n\n      markUpdate(workInProgress);\n      finalizeContainerChildren(container, newChildSet);\n    }\n  };\n\n  updateHostComponent = function (current, workInProgress, type, newProps, rootContainerInstance) {\n    const currentInstance = current.stateNode;\n    const oldProps = current.memoizedProps; // If there are no effects associated with this node, then none of our children had any updates.\n    // This guarantees that we can reuse all of them.\n\n    const childrenUnchanged = hadNoMutationsEffects(current, workInProgress);\n\n    if (childrenUnchanged && oldProps === newProps) {\n      // No changes, just reuse the existing instance.\n      // Note that this might release a previous clone.\n      workInProgress.stateNode = currentInstance;\n      return;\n    }\n\n    const recyclableInstance = workInProgress.stateNode;\n    const currentHostContext = getHostContext();\n    let updatePayload = null;\n\n    if (oldProps !== newProps) {\n      updatePayload = prepareUpdate(recyclableInstance, type, oldProps, newProps, rootContainerInstance, currentHostContext);\n    }\n\n    if (childrenUnchanged && updatePayload === null) {\n      // No changes, just reuse the existing instance.\n      // Note that this might release a previous clone.\n      workInProgress.stateNode = currentInstance;\n      return;\n    }\n\n    const newInstance = cloneInstance(currentInstance, updatePayload, type, oldProps, newProps, workInProgress, childrenUnchanged, recyclableInstance);\n\n    if (finalizeInitialChildren(newInstance, type, newProps, rootContainerInstance, currentHostContext)) {\n      markUpdate(workInProgress);\n    }\n\n    workInProgress.stateNode = newInstance;\n\n    if (childrenUnchanged) {\n      // If there are no other effects in this tree, we need to flag this node as having one.\n      // Even though we're not going to use it for anything.\n      // Otherwise parents won't know that there are new children to propagate upwards.\n      markUpdate(workInProgress);\n    } else {\n      // If children might have changed, we have to add them all to the set.\n      appendAllChildren(newInstance, workInProgress, false, false);\n    }\n  };\n\n  updateHostText = function (current, workInProgress, oldText, newText) {\n    if (oldText !== newText) {\n      // If the text content differs, we'll create a new text instance for it.\n      const rootContainerInstance = getRootHostContainer();\n      const currentHostContext = getHostContext();\n      workInProgress.stateNode = createTextInstance(newText, rootContainerInstance, currentHostContext, workInProgress); // We'll have to mark it as having an effect, even though we won't use the effect for anything.\n      // This lets the parents know that at least one of their children has changed.\n\n      markUpdate(workInProgress);\n    } else {\n      workInProgress.stateNode = current.stateNode;\n    }\n  };\n} else {\n  // No host operations\n  updateHostContainer = function (current, workInProgress) {// Noop\n  };\n\n  updateHostComponent = function (current, workInProgress, type, newProps, rootContainerInstance) {// Noop\n  };\n\n  updateHostText = function (current, workInProgress, oldText, newText) {// Noop\n  };\n}\n\nfunction cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {\n  if (getIsHydrating()) {\n    // If we're hydrating, we should consume as many items as we can\n    // so we don't leave any behind.\n    return;\n  }\n\n  switch (renderState.tailMode) {\n    case 'hidden':\n      {\n        // Any insertions at the end of the tail list after this point\n        // should be invisible. If there are already mounted boundaries\n        // anything before them are not considered for collapsing.\n        // Therefore we need to go through the whole tail to find if\n        // there are any.\n        let tailNode = renderState.tail;\n        let lastTailNode = null;\n\n        while (tailNode !== null) {\n          if (tailNode.alternate !== null) {\n            lastTailNode = tailNode;\n          }\n\n          tailNode = tailNode.sibling;\n        } // Next we're simply going to delete all insertions after the\n        // last rendered item.\n\n\n        if (lastTailNode === null) {\n          // All remaining items in the tail are insertions.\n          renderState.tail = null;\n        } else {\n          // Detach the insertion after the last node that was already\n          // inserted.\n          lastTailNode.sibling = null;\n        }\n\n        break;\n      }\n\n    case 'collapsed':\n      {\n        // Any insertions at the end of the tail list after this point\n        // should be invisible. If there are already mounted boundaries\n        // anything before them are not considered for collapsing.\n        // Therefore we need to go through the whole tail to find if\n        // there are any.\n        let tailNode = renderState.tail;\n        let lastTailNode = null;\n\n        while (tailNode !== null) {\n          if (tailNode.alternate !== null) {\n            lastTailNode = tailNode;\n          }\n\n          tailNode = tailNode.sibling;\n        } // Next we're simply going to delete all insertions after the\n        // last rendered item.\n\n\n        if (lastTailNode === null) {\n          // All remaining items in the tail are insertions.\n          if (!hasRenderedATailFallback && renderState.tail !== null) {\n            // We suspended during the head. We want to show at least one\n            // row at the tail. So we'll keep on and cut off the rest.\n            renderState.tail.sibling = null;\n          } else {\n            renderState.tail = null;\n          }\n        } else {\n          // Detach the insertion after the last node that was already\n          // inserted.\n          lastTailNode.sibling = null;\n        }\n\n        break;\n      }\n  }\n}\n\nfunction bubbleProperties(completedWork) {\n  const didBailout = completedWork.alternate !== null && completedWork.alternate.child === completedWork.child;\n  let newChildLanes = NoLanes;\n  let subtreeFlags = NoFlags;\n\n  if (!didBailout) {\n    // Bubble up the earliest expiration time.\n    if (enableProfilerTimer && (completedWork.mode & ProfileMode) !== NoMode) {\n      // In profiling mode, resetChildExpirationTime is also used to reset\n      // profiler durations.\n      let actualDuration = completedWork.actualDuration;\n      let treeBaseDuration = completedWork.selfBaseDuration;\n      let child = completedWork.child;\n\n      while (child !== null) {\n        newChildLanes = mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes));\n        subtreeFlags |= child.subtreeFlags;\n        subtreeFlags |= child.flags; // When a fiber is cloned, its actualDuration is reset to 0. This value will\n        // only be updated if work is done on the fiber (i.e. it doesn't bailout).\n        // When work is done, it should bubble to the parent's actualDuration. If\n        // the fiber has not been cloned though, (meaning no work was done), then\n        // this value will reflect the amount of time spent working on a previous\n        // render. In that case it should not bubble. We determine whether it was\n        // cloned by comparing the child pointer.\n\n        actualDuration += child.actualDuration;\n        treeBaseDuration += child.treeBaseDuration;\n        child = child.sibling;\n      }\n\n      completedWork.actualDuration = actualDuration;\n      completedWork.treeBaseDuration = treeBaseDuration;\n    } else {\n      let child = completedWork.child;\n\n      while (child !== null) {\n        newChildLanes = mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes));\n        subtreeFlags |= child.subtreeFlags;\n        subtreeFlags |= child.flags; // Update the return pointer so the tree is consistent. This is a code\n        // smell because it assumes the commit phase is never concurrent with\n        // the render phase. Will address during refactor to alternate model.\n\n        child.return = completedWork;\n        child = child.sibling;\n      }\n    }\n\n    completedWork.subtreeFlags |= subtreeFlags;\n  } else {\n    // Bubble up the earliest expiration time.\n    if (enableProfilerTimer && (completedWork.mode & ProfileMode) !== NoMode) {\n      // In profiling mode, resetChildExpirationTime is also used to reset\n      // profiler durations.\n      let treeBaseDuration = completedWork.selfBaseDuration;\n      let child = completedWork.child;\n\n      while (child !== null) {\n        newChildLanes = mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes)); // \"Static\" flags share the lifetime of the fiber/hook they belong to,\n        // so we should bubble those up even during a bailout. All the other\n        // flags have a lifetime only of a single render + commit, so we should\n        // ignore them.\n\n        subtreeFlags |= child.subtreeFlags & StaticMask;\n        subtreeFlags |= child.flags & StaticMask;\n        treeBaseDuration += child.treeBaseDuration;\n        child = child.sibling;\n      }\n\n      completedWork.treeBaseDuration = treeBaseDuration;\n    } else {\n      let child = completedWork.child;\n\n      while (child !== null) {\n        newChildLanes = mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes)); // \"Static\" flags share the lifetime of the fiber/hook they belong to,\n        // so we should bubble those up even during a bailout. All the other\n        // flags have a lifetime only of a single render + commit, so we should\n        // ignore them.\n\n        subtreeFlags |= child.subtreeFlags & StaticMask;\n        subtreeFlags |= child.flags & StaticMask; // Update the return pointer so the tree is consistent. This is a code\n        // smell because it assumes the commit phase is never concurrent with\n        // the render phase. Will address during refactor to alternate model.\n\n        child.return = completedWork;\n        child = child.sibling;\n      }\n    }\n\n    completedWork.subtreeFlags |= subtreeFlags;\n  }\n\n  completedWork.childLanes = newChildLanes;\n  return didBailout;\n}\n\nexport function completeSuspendedOffscreenHostContainer(current, workInProgress) {\n  // This is a fork of the complete phase for HostComponent. We use it when\n  // a suspense tree is in its fallback state, because in that case the primary\n  // tree that includes the offscreen boundary is skipped over without a\n  // regular complete phase.\n  //\n  // We can optimize this path further by inlining the update logic for\n  // offscreen instances specifically, i.e. skipping the `prepareUpdate` call.\n  const rootContainerInstance = getRootHostContainer();\n  const type = workInProgress.type;\n  const newProps = workInProgress.memoizedProps;\n\n  if (current !== null) {\n    updateHostComponent(current, workInProgress, type, newProps, rootContainerInstance);\n  } else {\n    const currentHostContext = getHostContext();\n    const instance = createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress);\n    appendAllChildren(instance, workInProgress, false, false);\n    workInProgress.stateNode = instance; // Certain renderers require commit-time effects for initial mount.\n    // (eg DOM renderer supports auto-focus for certain elements).\n    // Make sure such renderers get scheduled for later work.\n\n    if (finalizeInitialChildren(instance, type, newProps, rootContainerInstance, currentHostContext)) {\n      markUpdate(workInProgress);\n    }\n\n    if (workInProgress.ref !== null) {\n      // If there is a ref on a host node we need to schedule a callback\n      markRef(workInProgress);\n    }\n  }\n\n  bubbleProperties(workInProgress);\n}\n\nfunction completeWork(current, workInProgress, renderLanes) {\n  const newProps = workInProgress.pendingProps; // Note: This intentionally doesn't check if we're hydrating because comparing\n  // to the current tree provider fiber is just as fast and less error-prone.\n  // Ideally we would have a special version of the work loop only\n  // for hydration.\n\n  popTreeContext(workInProgress);\n\n  switch (workInProgress.tag) {\n    case IndeterminateComponent:\n    case LazyComponent:\n    case SimpleMemoComponent:\n    case FunctionComponent:\n    case ForwardRef:\n    case Fragment:\n    case Mode:\n    case Profiler:\n    case ContextConsumer:\n    case MemoComponent:\n      bubbleProperties(workInProgress);\n      return null;\n\n    case ClassComponent:\n      {\n        const Component = workInProgress.type;\n\n        if (isLegacyContextProvider(Component)) {\n          popLegacyContext(workInProgress);\n        }\n\n        bubbleProperties(workInProgress);\n        return null;\n      }\n\n    case HostRoot:\n      {\n        const fiberRoot = workInProgress.stateNode;\n\n        if (enableCache) {\n          popRootCachePool(fiberRoot, renderLanes);\n          let previousCache = null;\n\n          if (workInProgress.alternate !== null) {\n            previousCache = workInProgress.alternate.memoizedState.cache;\n          }\n\n          const cache = workInProgress.memoizedState.cache;\n\n          if (cache !== previousCache) {\n            // Run passive effects to retain/release the cache.\n            workInProgress.flags |= Passive;\n          }\n\n          popCacheProvider(workInProgress, cache);\n        }\n\n        popHostContainer(workInProgress);\n        popTopLevelLegacyContextObject(workInProgress);\n        resetMutableSourceWorkInProgressVersions();\n\n        if (fiberRoot.pendingContext) {\n          fiberRoot.context = fiberRoot.pendingContext;\n          fiberRoot.pendingContext = null;\n        }\n\n        if (current === null || current.child === null) {\n          // If we hydrated, pop so that we can delete any remaining children\n          // that weren't hydrated.\n          const wasHydrated = popHydrationState(workInProgress);\n\n          if (wasHydrated) {\n            // If we hydrated, then we'll need to schedule an update for\n            // the commit side-effects on the root.\n            markUpdate(workInProgress);\n          } else if (!fiberRoot.isDehydrated) {\n            // Schedule an effect to clear this container at the start of the next commit.\n            // This handles the case of React rendering into a container with previous children.\n            // It's also safe to do for updates too, because current.child would only be null\n            // if the previous render was null (so the container would already be empty).\n            workInProgress.flags |= Snapshot;\n          }\n        }\n\n        updateHostContainer(current, workInProgress);\n        bubbleProperties(workInProgress);\n        return null;\n      }\n\n    case HostComponent:\n      {\n        popHostContext(workInProgress);\n        const rootContainerInstance = getRootHostContainer();\n        const type = workInProgress.type;\n\n        if (current !== null && workInProgress.stateNode != null) {\n          updateHostComponent(current, workInProgress, type, newProps, rootContainerInstance);\n\n          if (current.ref !== workInProgress.ref) {\n            markRef(workInProgress);\n          }\n        } else {\n          if (!newProps) {\n            if (workInProgress.stateNode === null) {\n              throw new Error('We must have new props for new mounts. This error is likely ' + 'caused by a bug in React. Please file an issue.');\n            } // This can happen when we abort work.\n\n\n            bubbleProperties(workInProgress);\n            return null;\n          }\n\n          const currentHostContext = getHostContext(); // TODO: Move createInstance to beginWork and keep it on a context\n          // \"stack\" as the parent. Then append children as we go in beginWork\n          // or completeWork depending on whether we want to add them top->down or\n          // bottom->up. Top->down is faster in IE11.\n\n          const wasHydrated = popHydrationState(workInProgress);\n\n          if (wasHydrated) {\n            // TODO: Move this and createInstance step into the beginPhase\n            // to consolidate.\n            if (prepareToHydrateHostInstance(workInProgress, rootContainerInstance, currentHostContext)) {\n              // If changes to the hydrated node need to be applied at the\n              // commit-phase we mark this as such.\n              markUpdate(workInProgress);\n            }\n          } else {\n            const instance = createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress);\n            appendAllChildren(instance, workInProgress, false, false);\n            workInProgress.stateNode = instance; // Certain renderers require commit-time effects for initial mount.\n            // (eg DOM renderer supports auto-focus for certain elements).\n            // Make sure such renderers get scheduled for later work.\n\n            if (finalizeInitialChildren(instance, type, newProps, rootContainerInstance, currentHostContext)) {\n              markUpdate(workInProgress);\n            }\n          }\n\n          if (workInProgress.ref !== null) {\n            // If there is a ref on a host node we need to schedule a callback\n            markRef(workInProgress);\n          }\n        }\n\n        bubbleProperties(workInProgress);\n        return null;\n      }\n\n    case HostText:\n      {\n        const newText = newProps;\n\n        if (current && workInProgress.stateNode != null) {\n          const oldText = current.memoizedProps; // If we have an alternate, that means this is an update and we need\n          // to schedule a side-effect to do the updates.\n\n          updateHostText(current, workInProgress, oldText, newText);\n        } else {\n          if (typeof newText !== 'string') {\n            if (workInProgress.stateNode === null) {\n              throw new Error('We must have new props for new mounts. This error is likely ' + 'caused by a bug in React. Please file an issue.');\n            } // This can happen when we abort work.\n\n          }\n\n          const rootContainerInstance = getRootHostContainer();\n          const currentHostContext = getHostContext();\n          const wasHydrated = popHydrationState(workInProgress);\n\n          if (wasHydrated) {\n            if (prepareToHydrateHostTextInstance(workInProgress)) {\n              markUpdate(workInProgress);\n            }\n          } else {\n            workInProgress.stateNode = createTextInstance(newText, rootContainerInstance, currentHostContext, workInProgress);\n          }\n        }\n\n        bubbleProperties(workInProgress);\n        return null;\n      }\n\n    case SuspenseComponent:\n      {\n        popSuspenseContext(workInProgress);\n        const nextState = workInProgress.memoizedState;\n\n        if (enableSuspenseServerRenderer) {\n          if (nextState !== null && nextState.dehydrated !== null) {\n            // We might be inside a hydration state the first time we're picking up this\n            // Suspense boundary, and also after we've reentered it for further hydration.\n            const wasHydrated = popHydrationState(workInProgress);\n\n            if (current === null) {\n              if (!wasHydrated) {\n                throw new Error('A dehydrated suspense component was completed without a hydrated node. ' + 'This is probably a bug in React.');\n              }\n\n              prepareToHydrateHostSuspenseInstance(workInProgress);\n              bubbleProperties(workInProgress);\n\n              if (enableProfilerTimer) {\n                if ((workInProgress.mode & ProfileMode) !== NoMode) {\n                  const isTimedOutSuspense = nextState !== null;\n\n                  if (isTimedOutSuspense) {\n                    // Don't count time spent in a timed out Suspense subtree as part of the base duration.\n                    const primaryChildFragment = workInProgress.child;\n\n                    if (primaryChildFragment !== null) {\n                      // $FlowFixMe Flow doesn't support type casting in combination with the -= operator\n                      workInProgress.treeBaseDuration -= primaryChildFragment.treeBaseDuration;\n                    }\n                  }\n                }\n              }\n\n              return null;\n            } else {\n              // We might have reentered this boundary to hydrate it. If so, we need to reset the hydration\n              // state since we're now exiting out of it. popHydrationState doesn't do that for us.\n              resetHydrationState();\n\n              if ((workInProgress.flags & DidCapture) === NoFlags) {\n                // This boundary did not suspend so it's now hydrated and unsuspended.\n                workInProgress.memoizedState = null;\n              } // If nothing suspended, we need to schedule an effect to mark this boundary\n              // as having hydrated so events know that they're free to be invoked.\n              // It's also a signal to replay events and the suspense callback.\n              // If something suspended, schedule an effect to attach retry listeners.\n              // So we might as well always mark this.\n\n\n              workInProgress.flags |= Update;\n              bubbleProperties(workInProgress);\n\n              if (enableProfilerTimer) {\n                if ((workInProgress.mode & ProfileMode) !== NoMode) {\n                  const isTimedOutSuspense = nextState !== null;\n\n                  if (isTimedOutSuspense) {\n                    // Don't count time spent in a timed out Suspense subtree as part of the base duration.\n                    const primaryChildFragment = workInProgress.child;\n\n                    if (primaryChildFragment !== null) {\n                      // $FlowFixMe Flow doesn't support type casting in combination with the -= operator\n                      workInProgress.treeBaseDuration -= primaryChildFragment.treeBaseDuration;\n                    }\n                  }\n                }\n              }\n\n              return null;\n            }\n          }\n        }\n\n        if ((workInProgress.flags & DidCapture) !== NoFlags) {\n          // Something suspended. Re-render with the fallback children.\n          workInProgress.lanes = renderLanes; // Do not reset the effect list.\n\n          if (enableProfilerTimer && (workInProgress.mode & ProfileMode) !== NoMode) {\n            transferActualDuration(workInProgress);\n          } // Don't bubble properties in this case.\n\n\n          return workInProgress;\n        }\n\n        const nextDidTimeout = nextState !== null;\n        let prevDidTimeout = false;\n\n        if (current === null) {\n          popHydrationState(workInProgress);\n        } else {\n          const prevState = current.memoizedState;\n          prevDidTimeout = prevState !== null;\n        }\n\n        if (enableCache && nextDidTimeout) {\n          const offscreenFiber = workInProgress.child;\n          let previousCache = null;\n\n          if (offscreenFiber.alternate !== null && offscreenFiber.alternate.memoizedState !== null && offscreenFiber.alternate.memoizedState.cachePool !== null) {\n            previousCache = offscreenFiber.alternate.memoizedState.cachePool.pool;\n          }\n\n          let cache = null;\n\n          if (offscreenFiber.memoizedState !== null && offscreenFiber.memoizedState.cachePool !== null) {\n            cache = offscreenFiber.memoizedState.cachePool.pool;\n          }\n\n          if (cache !== previousCache) {\n            // Run passive effects to retain/release the cache.\n            offscreenFiber.flags |= Passive;\n          }\n        } // If the suspended state of the boundary changes, we need to schedule\n        // an effect to toggle the subtree's visibility. When we switch from\n        // fallback -> primary, the inner Offscreen fiber schedules this effect\n        // as part of its normal complete phase. But when we switch from\n        // primary -> fallback, the inner Offscreen fiber does not have a complete\n        // phase. So we need to schedule its effect here.\n        //\n        // We also use this flag to connect/disconnect the effects, but the same\n        // logic applies: when re-connecting, the Offscreen fiber's complete\n        // phase will handle scheduling the effect. It's only when the fallback\n        // is active that we have to do anything special.\n\n\n        if (nextDidTimeout && !prevDidTimeout) {\n          const offscreenFiber = workInProgress.child;\n          offscreenFiber.flags |= Visibility; // TODO: This will still suspend a synchronous tree if anything\n          // in the concurrent tree already suspended during this render.\n          // This is a known bug.\n\n          if ((workInProgress.mode & ConcurrentMode) !== NoMode) {\n            // TODO: Move this back to throwException because this is too late\n            // if this is a large tree which is common for initial loads. We\n            // don't know if we should restart a render or not until we get\n            // this marker, and this is too late.\n            // If this render already had a ping or lower pri updates,\n            // and this is the first time we know we're going to suspend we\n            // should be able to immediately restart from within throwException.\n            const hasInvisibleChildContext = current === null && workInProgress.memoizedProps.unstable_avoidThisFallback !== true;\n\n            if (hasInvisibleChildContext || hasSuspenseContext(suspenseStackCursor.current, InvisibleParentSuspenseContext)) {\n              // If this was in an invisible tree or a new render, then showing\n              // this boundary is ok.\n              renderDidSuspend();\n            } else {\n              // Otherwise, we're going to have to hide content so we should\n              // suspend for longer if possible.\n              renderDidSuspendDelayIfPossible();\n            }\n          }\n        }\n\n        const wakeables = workInProgress.updateQueue;\n\n        if (wakeables !== null) {\n          // Schedule an effect to attach a retry listener to the promise.\n          // TODO: Move to passive phase\n          workInProgress.flags |= Update;\n        }\n\n        if (enableSuspenseCallback && workInProgress.updateQueue !== null && workInProgress.memoizedProps.suspenseCallback != null) {\n          // Always notify the callback\n          // TODO: Move to passive phase\n          workInProgress.flags |= Update;\n        }\n\n        bubbleProperties(workInProgress);\n\n        if (enableProfilerTimer) {\n          if ((workInProgress.mode & ProfileMode) !== NoMode) {\n            if (nextDidTimeout) {\n              // Don't count time spent in a timed out Suspense subtree as part of the base duration.\n              const primaryChildFragment = workInProgress.child;\n\n              if (primaryChildFragment !== null) {\n                // $FlowFixMe Flow doesn't support type casting in combination with the -= operator\n                workInProgress.treeBaseDuration -= primaryChildFragment.treeBaseDuration;\n              }\n            }\n          }\n        }\n\n        return null;\n      }\n\n    case HostPortal:\n      popHostContainer(workInProgress);\n      updateHostContainer(current, workInProgress);\n\n      if (current === null) {\n        preparePortalMount(workInProgress.stateNode.containerInfo);\n      }\n\n      bubbleProperties(workInProgress);\n      return null;\n\n    case ContextProvider:\n      // Pop provider fiber\n      const context = workInProgress.type._context;\n      popProvider(context, workInProgress);\n      bubbleProperties(workInProgress);\n      return null;\n\n    case IncompleteClassComponent:\n      {\n        // Same as class component case. I put it down here so that the tags are\n        // sequential to ensure this switch is compiled to a jump table.\n        const Component = workInProgress.type;\n\n        if (isLegacyContextProvider(Component)) {\n          popLegacyContext(workInProgress);\n        }\n\n        bubbleProperties(workInProgress);\n        return null;\n      }\n\n    case SuspenseListComponent:\n      {\n        popSuspenseContext(workInProgress);\n        const renderState = workInProgress.memoizedState;\n\n        if (renderState === null) {\n          // We're running in the default, \"independent\" mode.\n          // We don't do anything in this mode.\n          bubbleProperties(workInProgress);\n          return null;\n        }\n\n        let didSuspendAlready = (workInProgress.flags & DidCapture) !== NoFlags;\n        const renderedTail = renderState.rendering;\n\n        if (renderedTail === null) {\n          // We just rendered the head.\n          if (!didSuspendAlready) {\n            // This is the first pass. We need to figure out if anything is still\n            // suspended in the rendered set.\n            // If new content unsuspended, but there's still some content that\n            // didn't. Then we need to do a second pass that forces everything\n            // to keep showing their fallbacks.\n            // We might be suspended if something in this render pass suspended, or\n            // something in the previous committed pass suspended. Otherwise,\n            // there's no chance so we can skip the expensive call to\n            // findFirstSuspended.\n            const cannotBeSuspended = renderHasNotSuspendedYet() && (current === null || (current.flags & DidCapture) === NoFlags);\n\n            if (!cannotBeSuspended) {\n              let row = workInProgress.child;\n\n              while (row !== null) {\n                const suspended = findFirstSuspended(row);\n\n                if (suspended !== null) {\n                  didSuspendAlready = true;\n                  workInProgress.flags |= DidCapture;\n                  cutOffTailIfNeeded(renderState, false); // If this is a newly suspended tree, it might not get committed as\n                  // part of the second pass. In that case nothing will subscribe to\n                  // its thenables. Instead, we'll transfer its thenables to the\n                  // SuspenseList so that it can retry if they resolve.\n                  // There might be multiple of these in the list but since we're\n                  // going to wait for all of them anyway, it doesn't really matter\n                  // which ones gets to ping. In theory we could get clever and keep\n                  // track of how many dependencies remain but it gets tricky because\n                  // in the meantime, we can add/remove/change items and dependencies.\n                  // We might bail out of the loop before finding any but that\n                  // doesn't matter since that means that the other boundaries that\n                  // we did find already has their listeners attached.\n\n                  const newThenables = suspended.updateQueue;\n\n                  if (newThenables !== null) {\n                    workInProgress.updateQueue = newThenables;\n                    workInProgress.flags |= Update;\n                  } // Rerender the whole list, but this time, we'll force fallbacks\n                  // to stay in place.\n                  // Reset the effect flags before doing the second pass since that's now invalid.\n                  // Reset the child fibers to their original state.\n\n\n                  workInProgress.subtreeFlags = NoFlags;\n                  resetChildFibers(workInProgress, renderLanes); // Set up the Suspense Context to force suspense and immediately\n                  // rerender the children.\n\n                  pushSuspenseContext(workInProgress, setShallowSuspenseContext(suspenseStackCursor.current, ForceSuspenseFallback)); // Don't bubble properties in this case.\n\n                  return workInProgress.child;\n                }\n\n                row = row.sibling;\n              }\n            }\n\n            if (renderState.tail !== null && now() > getRenderTargetTime()) {\n              // We have already passed our CPU deadline but we still have rows\n              // left in the tail. We'll just give up further attempts to render\n              // the main content and only render fallbacks.\n              workInProgress.flags |= DidCapture;\n              didSuspendAlready = true;\n              cutOffTailIfNeeded(renderState, false); // Since nothing actually suspended, there will nothing to ping this\n              // to get it started back up to attempt the next item. While in terms\n              // of priority this work has the same priority as this current render,\n              // it's not part of the same transition once the transition has\n              // committed. If it's sync, we still want to yield so that it can be\n              // painted. Conceptually, this is really the same as pinging.\n              // We can use any RetryLane even if it's the one currently rendering\n              // since we're leaving it behind on this node.\n\n              workInProgress.lanes = SomeRetryLane;\n            }\n          } else {\n            cutOffTailIfNeeded(renderState, false);\n          } // Next we're going to render the tail.\n\n        } else {\n          // Append the rendered row to the child list.\n          if (!didSuspendAlready) {\n            const suspended = findFirstSuspended(renderedTail);\n\n            if (suspended !== null) {\n              workInProgress.flags |= DidCapture;\n              didSuspendAlready = true; // Ensure we transfer the update queue to the parent so that it doesn't\n              // get lost if this row ends up dropped during a second pass.\n\n              const newThenables = suspended.updateQueue;\n\n              if (newThenables !== null) {\n                workInProgress.updateQueue = newThenables;\n                workInProgress.flags |= Update;\n              }\n\n              cutOffTailIfNeeded(renderState, true); // This might have been modified.\n\n              if (renderState.tail === null && renderState.tailMode === 'hidden' && !renderedTail.alternate && !getIsHydrating() // We don't cut it if we're hydrating.\n              ) {\n                  // We're done.\n                  bubbleProperties(workInProgress);\n                  return null;\n                }\n            } else if ( // The time it took to render last row is greater than the remaining\n            // time we have to render. So rendering one more row would likely\n            // exceed it.\n            now() * 2 - renderState.renderingStartTime > getRenderTargetTime() && renderLanes !== OffscreenLane) {\n              // We have now passed our CPU deadline and we'll just give up further\n              // attempts to render the main content and only render fallbacks.\n              // The assumption is that this is usually faster.\n              workInProgress.flags |= DidCapture;\n              didSuspendAlready = true;\n              cutOffTailIfNeeded(renderState, false); // Since nothing actually suspended, there will nothing to ping this\n              // to get it started back up to attempt the next item. While in terms\n              // of priority this work has the same priority as this current render,\n              // it's not part of the same transition once the transition has\n              // committed. If it's sync, we still want to yield so that it can be\n              // painted. Conceptually, this is really the same as pinging.\n              // We can use any RetryLane even if it's the one currently rendering\n              // since we're leaving it behind on this node.\n\n              workInProgress.lanes = SomeRetryLane;\n            }\n          }\n\n          if (renderState.isBackwards) {\n            // The effect list of the backwards tail will have been added\n            // to the end. This breaks the guarantee that life-cycles fire in\n            // sibling order but that isn't a strong guarantee promised by React.\n            // Especially since these might also just pop in during future commits.\n            // Append to the beginning of the list.\n            renderedTail.sibling = workInProgress.child;\n            workInProgress.child = renderedTail;\n          } else {\n            const previousSibling = renderState.last;\n\n            if (previousSibling !== null) {\n              previousSibling.sibling = renderedTail;\n            } else {\n              workInProgress.child = renderedTail;\n            }\n\n            renderState.last = renderedTail;\n          }\n        }\n\n        if (renderState.tail !== null) {\n          // We still have tail rows to render.\n          // Pop a row.\n          const next = renderState.tail;\n          renderState.rendering = next;\n          renderState.tail = next.sibling;\n          renderState.renderingStartTime = now();\n          next.sibling = null; // Restore the context.\n          // TODO: We can probably just avoid popping it instead and only\n          // setting it the first time we go from not suspended to suspended.\n\n          let suspenseContext = suspenseStackCursor.current;\n\n          if (didSuspendAlready) {\n            suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);\n          } else {\n            suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);\n          }\n\n          pushSuspenseContext(workInProgress, suspenseContext); // Do a pass over the next row.\n          // Don't bubble properties in this case.\n\n          return next;\n        }\n\n        bubbleProperties(workInProgress);\n        return null;\n      }\n\n    case ScopeComponent:\n      {\n        if (enableScopeAPI) {\n          if (current === null) {\n            const scopeInstance = createScopeInstance();\n            workInProgress.stateNode = scopeInstance;\n            prepareScopeUpdate(scopeInstance, workInProgress);\n\n            if (workInProgress.ref !== null) {\n              markRef(workInProgress);\n              markUpdate(workInProgress);\n            }\n          } else {\n            if (workInProgress.ref !== null) {\n              markUpdate(workInProgress);\n            }\n\n            if (current.ref !== workInProgress.ref) {\n              markRef(workInProgress);\n            }\n          }\n\n          bubbleProperties(workInProgress);\n          return null;\n        }\n\n        break;\n      }\n\n    case OffscreenComponent:\n    case LegacyHiddenComponent:\n      {\n        popRenderLanes(workInProgress);\n        const nextState = workInProgress.memoizedState;\n        const nextIsHidden = nextState !== null;\n\n        if (current !== null) {\n          const prevState = current.memoizedState;\n          const prevIsHidden = prevState !== null;\n\n          if (prevIsHidden !== nextIsHidden && newProps.mode !== 'unstable-defer-without-hiding' && // LegacyHidden doesn't do any hiding — it only pre-renders.\n          workInProgress.tag !== LegacyHiddenComponent) {\n            workInProgress.flags |= Visibility;\n          }\n        }\n\n        if (!nextIsHidden || (workInProgress.mode & ConcurrentMode) === NoMode) {\n          bubbleProperties(workInProgress);\n        } else {\n          // Don't bubble properties for hidden children unless we're rendering\n          // at offscreen priority.\n          if (includesSomeLane(subtreeRenderLanes, OffscreenLane)) {\n            bubbleProperties(workInProgress);\n\n            if (supportsMutation) {\n              // Check if there was an insertion or update in the hidden subtree.\n              // If so, we need to hide those nodes in the commit phase, so\n              // schedule a visibility effect.\n              if (workInProgress.tag !== LegacyHiddenComponent && workInProgress.subtreeFlags & (Placement | Update) && newProps.mode !== 'unstable-defer-without-hiding') {\n                workInProgress.flags |= Visibility;\n              }\n            }\n          }\n        }\n\n        if (enableCache) {\n          let previousCache = null;\n\n          if (workInProgress.alternate !== null && workInProgress.alternate.memoizedState !== null && workInProgress.alternate.memoizedState.cachePool !== null) {\n            previousCache = workInProgress.alternate.memoizedState.cachePool.pool;\n          }\n\n          let cache = null;\n\n          if (workInProgress.memoizedState !== null && workInProgress.memoizedState.cachePool !== null) {\n            cache = workInProgress.memoizedState.cachePool.pool;\n          }\n\n          if (cache !== previousCache) {\n            // Run passive effects to retain/release the cache.\n            workInProgress.flags |= Passive;\n          }\n\n          const spawnedCachePool = workInProgress.updateQueue;\n\n          if (spawnedCachePool !== null) {\n            popCachePool(workInProgress);\n          }\n        }\n\n        return null;\n      }\n\n    case CacheComponent:\n      {\n        if (enableCache) {\n          let previousCache = null;\n\n          if (workInProgress.alternate !== null) {\n            previousCache = workInProgress.alternate.memoizedState.cache;\n          }\n\n          const cache = workInProgress.memoizedState.cache;\n\n          if (cache !== previousCache) {\n            // Run passive effects to retain/release the cache.\n            workInProgress.flags |= Passive;\n          }\n\n          popCacheProvider(workInProgress, cache);\n          bubbleProperties(workInProgress);\n          return null;\n        }\n      }\n  }\n\n  throw new Error(`Unknown unit of work tag (${workInProgress.tag}). This error is likely caused by a bug in ` + 'React. Please file an issue.');\n}\n\nexport { completeWork };","map":{"version":3,"sources":["/Users/zhangshuo/git/react-source-test/src/react/packages/react-reconciler/src/ReactFiberCompleteWork.new.js"],"names":["resetWorkInProgressVersions","resetMutableSourceWorkInProgressVersions","now","IndeterminateComponent","FunctionComponent","ClassComponent","HostRoot","HostComponent","HostText","HostPortal","ContextProvider","ContextConsumer","ForwardRef","Fragment","Mode","Profiler","SuspenseComponent","SuspenseListComponent","MemoComponent","SimpleMemoComponent","LazyComponent","IncompleteClassComponent","ScopeComponent","OffscreenComponent","LegacyHiddenComponent","CacheComponent","NoMode","ConcurrentMode","ProfileMode","Ref","RefStatic","Placement","Update","Visibility","NoFlags","DidCapture","Snapshot","ChildDeletion","StaticMask","MutationMask","Passive","createInstance","createTextInstance","appendInitialChild","finalizeInitialChildren","prepareUpdate","supportsMutation","supportsPersistence","cloneInstance","cloneHiddenInstance","cloneHiddenTextInstance","createContainerChildSet","appendChildToContainerChildSet","finalizeContainerChildren","preparePortalMount","prepareScopeUpdate","getRootHostContainer","popHostContext","getHostContext","popHostContainer","suspenseStackCursor","InvisibleParentSuspenseContext","hasSuspenseContext","popSuspenseContext","pushSuspenseContext","setShallowSuspenseContext","ForceSuspenseFallback","setDefaultShallowSuspenseContext","findFirstSuspended","isContextProvider","isLegacyContextProvider","popContext","popLegacyContext","popTopLevelContextObject","popTopLevelLegacyContextObject","popProvider","prepareToHydrateHostInstance","prepareToHydrateHostTextInstance","prepareToHydrateHostSuspenseInstance","popHydrationState","resetHydrationState","getIsHydrating","enableSuspenseCallback","enableSuspenseServerRenderer","enableScopeAPI","enableProfilerTimer","enableCache","enableSuspenseLayoutEffectSemantics","enablePersistentOffscreenHostContainer","renderDidSuspend","renderDidSuspendDelayIfPossible","renderHasNotSuspendedYet","popRenderLanes","getRenderTargetTime","subtreeRenderLanes","OffscreenLane","SomeRetryLane","NoLanes","includesSomeLane","mergeLanes","resetChildFibers","createScopeInstance","transferActualDuration","popCacheProvider","popRootCachePool","popCachePool","popTreeContext","markUpdate","workInProgress","flags","markRef","hadNoMutationsEffects","current","completedWork","didBailout","child","subtreeFlags","sibling","appendAllChildren","updateHostContainer","updateHostComponent","updateHostText","parent","needsVisibilityToggle","isHidden","node","tag","stateNode","return","type","newProps","rootContainerInstance","oldProps","memoizedProps","instance","currentHostContext","updatePayload","updateQueue","oldText","newText","branches","props","text","memoizedState","appendAllChildrenToContainer","containerChildSet","portalOrRoot","childrenUnchanged","container","containerInfo","newChildSet","pendingChildren","currentInstance","recyclableInstance","newInstance","cutOffTailIfNeeded","renderState","hasRenderedATailFallback","tailMode","tailNode","tail","lastTailNode","alternate","bubbleProperties","newChildLanes","mode","actualDuration","treeBaseDuration","selfBaseDuration","lanes","childLanes","completeSuspendedOffscreenHostContainer","ref","completeWork","renderLanes","pendingProps","Component","fiberRoot","previousCache","cache","pendingContext","context","wasHydrated","isDehydrated","Error","nextState","dehydrated","isTimedOutSuspense","primaryChildFragment","nextDidTimeout","prevDidTimeout","prevState","offscreenFiber","cachePool","pool","hasInvisibleChildContext","unstable_avoidThisFallback","wakeables","suspenseCallback","_context","didSuspendAlready","renderedTail","rendering","cannotBeSuspended","row","suspended","newThenables","renderingStartTime","isBackwards","previousSibling","last","next","suspenseContext","scopeInstance","nextIsHidden","prevIsHidden","spawnedCachePool"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Fiber} from './ReactInternalTypes';\nimport type {Lanes, Lane} from './ReactFiberLane.new';\nimport type {\n  ReactScopeInstance,\n  ReactContext,\n  Wakeable,\n} from 'shared/ReactTypes';\nimport type {FiberRoot} from './ReactInternalTypes';\nimport type {\n  Instance,\n  Type,\n  Props,\n  Container,\n  ChildSet,\n} from './ReactFiberHostConfig';\nimport type {\n  SuspenseState,\n  SuspenseListRenderState,\n} from './ReactFiberSuspenseComponent.new';\nimport type {SuspenseContext} from './ReactFiberSuspenseContext.new';\nimport type {OffscreenState} from './ReactFiberOffscreenComponent';\nimport type {Cache, SpawnedCachePool} from './ReactFiberCacheComponent.new';\n\nimport {resetWorkInProgressVersions as resetMutableSourceWorkInProgressVersions} from './ReactMutableSource.new';\n\nimport {now} from './Scheduler';\n\nimport {\n  IndeterminateComponent,\n  FunctionComponent,\n  ClassComponent,\n  HostRoot,\n  HostComponent,\n  HostText,\n  HostPortal,\n  ContextProvider,\n  ContextConsumer,\n  ForwardRef,\n  Fragment,\n  Mode,\n  Profiler,\n  SuspenseComponent,\n  SuspenseListComponent,\n  MemoComponent,\n  SimpleMemoComponent,\n  LazyComponent,\n  IncompleteClassComponent,\n  ScopeComponent,\n  OffscreenComponent,\n  LegacyHiddenComponent,\n  CacheComponent,\n} from './ReactWorkTags';\nimport {NoMode, ConcurrentMode, ProfileMode} from './ReactTypeOfMode';\nimport {\n  Ref,\n  RefStatic,\n  Placement,\n  Update,\n  Visibility,\n  NoFlags,\n  DidCapture,\n  Snapshot,\n  ChildDeletion,\n  StaticMask,\n  MutationMask,\n  Passive,\n} from './ReactFiberFlags';\n\nimport {\n  createInstance,\n  createTextInstance,\n  appendInitialChild,\n  finalizeInitialChildren,\n  prepareUpdate,\n  supportsMutation,\n  supportsPersistence,\n  cloneInstance,\n  cloneHiddenInstance,\n  cloneHiddenTextInstance,\n  createContainerChildSet,\n  appendChildToContainerChildSet,\n  finalizeContainerChildren,\n  preparePortalMount,\n  prepareScopeUpdate,\n} from './ReactFiberHostConfig';\nimport {\n  getRootHostContainer,\n  popHostContext,\n  getHostContext,\n  popHostContainer,\n} from './ReactFiberHostContext.new';\nimport {\n  suspenseStackCursor,\n  InvisibleParentSuspenseContext,\n  hasSuspenseContext,\n  popSuspenseContext,\n  pushSuspenseContext,\n  setShallowSuspenseContext,\n  ForceSuspenseFallback,\n  setDefaultShallowSuspenseContext,\n} from './ReactFiberSuspenseContext.new';\nimport {findFirstSuspended} from './ReactFiberSuspenseComponent.new';\nimport {\n  isContextProvider as isLegacyContextProvider,\n  popContext as popLegacyContext,\n  popTopLevelContextObject as popTopLevelLegacyContextObject,\n} from './ReactFiberContext.new';\nimport {popProvider} from './ReactFiberNewContext.new';\nimport {\n  prepareToHydrateHostInstance,\n  prepareToHydrateHostTextInstance,\n  prepareToHydrateHostSuspenseInstance,\n  popHydrationState,\n  resetHydrationState,\n  getIsHydrating,\n} from './ReactFiberHydrationContext.new';\nimport {\n  enableSuspenseCallback,\n  enableSuspenseServerRenderer,\n  enableScopeAPI,\n  enableProfilerTimer,\n  enableCache,\n  enableSuspenseLayoutEffectSemantics,\n  enablePersistentOffscreenHostContainer,\n} from 'shared/ReactFeatureFlags';\nimport {\n  renderDidSuspend,\n  renderDidSuspendDelayIfPossible,\n  renderHasNotSuspendedYet,\n  popRenderLanes,\n  getRenderTargetTime,\n  subtreeRenderLanes,\n} from './ReactFiberWorkLoop.new';\nimport {\n  OffscreenLane,\n  SomeRetryLane,\n  NoLanes,\n  includesSomeLane,\n  mergeLanes,\n} from './ReactFiberLane.new';\nimport {resetChildFibers} from './ReactChildFiber.new';\nimport {createScopeInstance} from './ReactFiberScope.new';\nimport {transferActualDuration} from './ReactProfilerTimer.new';\nimport {\n  popCacheProvider,\n  popRootCachePool,\n  popCachePool,\n} from './ReactFiberCacheComponent.new';\nimport {popTreeContext} from './ReactFiberTreeContext.new';\n\nfunction markUpdate(workInProgress: Fiber) {\n  // Tag the fiber with an update effect. This turns a Placement into\n  // a PlacementAndUpdate.\n  workInProgress.flags |= Update;\n}\n\nfunction markRef(workInProgress: Fiber) {\n  workInProgress.flags |= Ref;\n  if (enableSuspenseLayoutEffectSemantics) {\n    workInProgress.flags |= RefStatic;\n  }\n}\n\nfunction hadNoMutationsEffects(current: null | Fiber, completedWork: Fiber) {\n  const didBailout = current !== null && current.child === completedWork.child;\n  if (didBailout) {\n    return true;\n  }\n\n  if ((completedWork.flags & ChildDeletion) !== NoFlags) {\n    return false;\n  }\n\n  // TODO: If we move the `hadNoMutationsEffects` call after `bubbleProperties`\n  // then we only have to check the `completedWork.subtreeFlags`.\n  let child = completedWork.child;\n  while (child !== null) {\n    if (\n      (child.flags & MutationMask) !== NoFlags ||\n      (child.subtreeFlags & MutationMask) !== NoFlags\n    ) {\n      return false;\n    }\n    child = child.sibling;\n  }\n  return true;\n}\n\nlet appendAllChildren;\nlet updateHostContainer;\nlet updateHostComponent;\nlet updateHostText;\nif (supportsMutation) {\n  // Mutation mode\n\n  appendAllChildren = function(\n    parent: Instance,\n    workInProgress: Fiber,\n    needsVisibilityToggle: boolean,\n    isHidden: boolean,\n  ) {\n    // We only have the top Fiber that was created but we need recurse down its\n    // children to find all the terminal nodes.\n    let node = workInProgress.child;\n    while (node !== null) {\n      if (node.tag === HostComponent || node.tag === HostText) {\n        appendInitialChild(parent, node.stateNode);\n      } else if (node.tag === HostPortal) {\n        // If we have a portal child, then we don't want to traverse\n        // down its children. Instead, we'll get insertions from each child in\n        // the portal directly.\n      } else if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n      if (node === workInProgress) {\n        return;\n      }\n      while (node.sibling === null) {\n        if (node.return === null || node.return === workInProgress) {\n          return;\n        }\n        node = node.return;\n      }\n      node.sibling.return = node.return;\n      node = node.sibling;\n    }\n  };\n\n  updateHostContainer = function(current: null | Fiber, workInProgress: Fiber) {\n    // Noop\n  };\n  updateHostComponent = function(\n    current: Fiber,\n    workInProgress: Fiber,\n    type: Type,\n    newProps: Props,\n    rootContainerInstance: Container,\n  ) {\n    // If we have an alternate, that means this is an update and we need to\n    // schedule a side-effect to do the updates.\n    const oldProps = current.memoizedProps;\n    if (oldProps === newProps) {\n      // In mutation mode, this is sufficient for a bailout because\n      // we won't touch this node even if children changed.\n      return;\n    }\n\n    // If we get updated because one of our children updated, we don't\n    // have newProps so we'll have to reuse them.\n    // TODO: Split the update API as separate for the props vs. children.\n    // Even better would be if children weren't special cased at all tho.\n    const instance: Instance = workInProgress.stateNode;\n    const currentHostContext = getHostContext();\n    // TODO: Experiencing an error where oldProps is null. Suggests a host\n    // component is hitting the resume path. Figure out why. Possibly\n    // related to `hidden`.\n    const updatePayload = prepareUpdate(\n      instance,\n      type,\n      oldProps,\n      newProps,\n      rootContainerInstance,\n      currentHostContext,\n    );\n    // TODO: Type this specific to this type of component.\n    workInProgress.updateQueue = (updatePayload: any);\n    // If the update payload indicates that there is a change or if there\n    // is a new ref we mark this as an update. All the work is done in commitWork.\n    if (updatePayload) {\n      markUpdate(workInProgress);\n    }\n  };\n  updateHostText = function(\n    current: Fiber,\n    workInProgress: Fiber,\n    oldText: string,\n    newText: string,\n  ) {\n    // If the text differs, mark it as an update. All the work in done in commitWork.\n    if (oldText !== newText) {\n      markUpdate(workInProgress);\n    }\n  };\n} else if (supportsPersistence) {\n  // Persistent host tree mode\n\n  appendAllChildren = function(\n    parent: Instance,\n    workInProgress: Fiber,\n    needsVisibilityToggle: boolean,\n    isHidden: boolean,\n  ) {\n    // We only have the top Fiber that was created but we need recurse down its\n    // children to find all the terminal nodes.\n    let node = workInProgress.child;\n    while (node !== null) {\n      // eslint-disable-next-line no-labels\n      branches: if (node.tag === HostComponent) {\n        let instance = node.stateNode;\n        if (needsVisibilityToggle && isHidden) {\n          // This child is inside a timed out tree. Hide it.\n          const props = node.memoizedProps;\n          const type = node.type;\n          instance = cloneHiddenInstance(instance, type, props, node);\n        }\n        appendInitialChild(parent, instance);\n      } else if (node.tag === HostText) {\n        let instance = node.stateNode;\n        if (needsVisibilityToggle && isHidden) {\n          // This child is inside a timed out tree. Hide it.\n          const text = node.memoizedProps;\n          instance = cloneHiddenTextInstance(instance, text, node);\n        }\n        appendInitialChild(parent, instance);\n      } else if (node.tag === HostPortal) {\n        // If we have a portal child, then we don't want to traverse\n        // down its children. Instead, we'll get insertions from each child in\n        // the portal directly.\n      } else if (\n        node.tag === OffscreenComponent &&\n        node.memoizedState !== null\n      ) {\n        // The children in this boundary are hidden. Toggle their visibility\n        // before appending.\n        const child = node.child;\n        if (child !== null) {\n          child.return = node;\n        }\n        if (enablePersistentOffscreenHostContainer) {\n          appendAllChildren(parent, node, false, false);\n        } else {\n          appendAllChildren(parent, node, true, true);\n        }\n      } else if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n      // $FlowFixMe This is correct but Flow is confused by the labeled break.\n      node = (node: Fiber);\n      if (node === workInProgress) {\n        return;\n      }\n      while (node.sibling === null) {\n        if (node.return === null || node.return === workInProgress) {\n          return;\n        }\n        node = node.return;\n      }\n      node.sibling.return = node.return;\n      node = node.sibling;\n    }\n  };\n\n  // An unfortunate fork of appendAllChildren because we have two different parent types.\n  const appendAllChildrenToContainer = function(\n    containerChildSet: ChildSet,\n    workInProgress: Fiber,\n    needsVisibilityToggle: boolean,\n    isHidden: boolean,\n  ) {\n    // We only have the top Fiber that was created but we need recurse down its\n    // children to find all the terminal nodes.\n    let node = workInProgress.child;\n    while (node !== null) {\n      // eslint-disable-next-line no-labels\n      branches: if (node.tag === HostComponent) {\n        let instance = node.stateNode;\n        if (needsVisibilityToggle && isHidden) {\n          // This child is inside a timed out tree. Hide it.\n          const props = node.memoizedProps;\n          const type = node.type;\n          instance = cloneHiddenInstance(instance, type, props, node);\n        }\n        appendChildToContainerChildSet(containerChildSet, instance);\n      } else if (node.tag === HostText) {\n        let instance = node.stateNode;\n        if (needsVisibilityToggle && isHidden) {\n          // This child is inside a timed out tree. Hide it.\n          const text = node.memoizedProps;\n          instance = cloneHiddenTextInstance(instance, text, node);\n        }\n        appendChildToContainerChildSet(containerChildSet, instance);\n      } else if (node.tag === HostPortal) {\n        // If we have a portal child, then we don't want to traverse\n        // down its children. Instead, we'll get insertions from each child in\n        // the portal directly.\n      } else if (\n        node.tag === OffscreenComponent &&\n        node.memoizedState !== null\n      ) {\n        // The children in this boundary are hidden. Toggle their visibility\n        // before appending.\n        const child = node.child;\n        if (child !== null) {\n          child.return = node;\n        }\n        if (enablePersistentOffscreenHostContainer) {\n          appendAllChildrenToContainer(containerChildSet, node, false, false);\n        } else {\n          appendAllChildrenToContainer(containerChildSet, node, true, true);\n        }\n      } else if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n      // $FlowFixMe This is correct but Flow is confused by the labeled break.\n      node = (node: Fiber);\n      if (node === workInProgress) {\n        return;\n      }\n      while (node.sibling === null) {\n        if (node.return === null || node.return === workInProgress) {\n          return;\n        }\n        node = node.return;\n      }\n      node.sibling.return = node.return;\n      node = node.sibling;\n    }\n  };\n  updateHostContainer = function(current: null | Fiber, workInProgress: Fiber) {\n    const portalOrRoot: {\n      containerInfo: Container,\n      pendingChildren: ChildSet,\n      ...\n    } = workInProgress.stateNode;\n    const childrenUnchanged = hadNoMutationsEffects(current, workInProgress);\n    if (childrenUnchanged) {\n      // No changes, just reuse the existing instance.\n    } else {\n      const container = portalOrRoot.containerInfo;\n      const newChildSet = createContainerChildSet(container);\n      // If children might have changed, we have to add them all to the set.\n      appendAllChildrenToContainer(newChildSet, workInProgress, false, false);\n      portalOrRoot.pendingChildren = newChildSet;\n      // Schedule an update on the container to swap out the container.\n      markUpdate(workInProgress);\n      finalizeContainerChildren(container, newChildSet);\n    }\n  };\n  updateHostComponent = function(\n    current: Fiber,\n    workInProgress: Fiber,\n    type: Type,\n    newProps: Props,\n    rootContainerInstance: Container,\n  ) {\n    const currentInstance = current.stateNode;\n    const oldProps = current.memoizedProps;\n    // If there are no effects associated with this node, then none of our children had any updates.\n    // This guarantees that we can reuse all of them.\n    const childrenUnchanged = hadNoMutationsEffects(current, workInProgress);\n    if (childrenUnchanged && oldProps === newProps) {\n      // No changes, just reuse the existing instance.\n      // Note that this might release a previous clone.\n      workInProgress.stateNode = currentInstance;\n      return;\n    }\n    const recyclableInstance: Instance = workInProgress.stateNode;\n    const currentHostContext = getHostContext();\n    let updatePayload = null;\n    if (oldProps !== newProps) {\n      updatePayload = prepareUpdate(\n        recyclableInstance,\n        type,\n        oldProps,\n        newProps,\n        rootContainerInstance,\n        currentHostContext,\n      );\n    }\n    if (childrenUnchanged && updatePayload === null) {\n      // No changes, just reuse the existing instance.\n      // Note that this might release a previous clone.\n      workInProgress.stateNode = currentInstance;\n      return;\n    }\n    const newInstance = cloneInstance(\n      currentInstance,\n      updatePayload,\n      type,\n      oldProps,\n      newProps,\n      workInProgress,\n      childrenUnchanged,\n      recyclableInstance,\n    );\n    if (\n      finalizeInitialChildren(\n        newInstance,\n        type,\n        newProps,\n        rootContainerInstance,\n        currentHostContext,\n      )\n    ) {\n      markUpdate(workInProgress);\n    }\n    workInProgress.stateNode = newInstance;\n    if (childrenUnchanged) {\n      // If there are no other effects in this tree, we need to flag this node as having one.\n      // Even though we're not going to use it for anything.\n      // Otherwise parents won't know that there are new children to propagate upwards.\n      markUpdate(workInProgress);\n    } else {\n      // If children might have changed, we have to add them all to the set.\n      appendAllChildren(newInstance, workInProgress, false, false);\n    }\n  };\n  updateHostText = function(\n    current: Fiber,\n    workInProgress: Fiber,\n    oldText: string,\n    newText: string,\n  ) {\n    if (oldText !== newText) {\n      // If the text content differs, we'll create a new text instance for it.\n      const rootContainerInstance = getRootHostContainer();\n      const currentHostContext = getHostContext();\n      workInProgress.stateNode = createTextInstance(\n        newText,\n        rootContainerInstance,\n        currentHostContext,\n        workInProgress,\n      );\n      // We'll have to mark it as having an effect, even though we won't use the effect for anything.\n      // This lets the parents know that at least one of their children has changed.\n      markUpdate(workInProgress);\n    } else {\n      workInProgress.stateNode = current.stateNode;\n    }\n  };\n} else {\n  // No host operations\n  updateHostContainer = function(current: null | Fiber, workInProgress: Fiber) {\n    // Noop\n  };\n  updateHostComponent = function(\n    current: Fiber,\n    workInProgress: Fiber,\n    type: Type,\n    newProps: Props,\n    rootContainerInstance: Container,\n  ) {\n    // Noop\n  };\n  updateHostText = function(\n    current: Fiber,\n    workInProgress: Fiber,\n    oldText: string,\n    newText: string,\n  ) {\n    // Noop\n  };\n}\n\nfunction cutOffTailIfNeeded(\n  renderState: SuspenseListRenderState,\n  hasRenderedATailFallback: boolean,\n) {\n  if (getIsHydrating()) {\n    // If we're hydrating, we should consume as many items as we can\n    // so we don't leave any behind.\n    return;\n  }\n  switch (renderState.tailMode) {\n    case 'hidden': {\n      // Any insertions at the end of the tail list after this point\n      // should be invisible. If there are already mounted boundaries\n      // anything before them are not considered for collapsing.\n      // Therefore we need to go through the whole tail to find if\n      // there are any.\n      let tailNode = renderState.tail;\n      let lastTailNode = null;\n      while (tailNode !== null) {\n        if (tailNode.alternate !== null) {\n          lastTailNode = tailNode;\n        }\n        tailNode = tailNode.sibling;\n      }\n      // Next we're simply going to delete all insertions after the\n      // last rendered item.\n      if (lastTailNode === null) {\n        // All remaining items in the tail are insertions.\n        renderState.tail = null;\n      } else {\n        // Detach the insertion after the last node that was already\n        // inserted.\n        lastTailNode.sibling = null;\n      }\n      break;\n    }\n    case 'collapsed': {\n      // Any insertions at the end of the tail list after this point\n      // should be invisible. If there are already mounted boundaries\n      // anything before them are not considered for collapsing.\n      // Therefore we need to go through the whole tail to find if\n      // there are any.\n      let tailNode = renderState.tail;\n      let lastTailNode = null;\n      while (tailNode !== null) {\n        if (tailNode.alternate !== null) {\n          lastTailNode = tailNode;\n        }\n        tailNode = tailNode.sibling;\n      }\n      // Next we're simply going to delete all insertions after the\n      // last rendered item.\n      if (lastTailNode === null) {\n        // All remaining items in the tail are insertions.\n        if (!hasRenderedATailFallback && renderState.tail !== null) {\n          // We suspended during the head. We want to show at least one\n          // row at the tail. So we'll keep on and cut off the rest.\n          renderState.tail.sibling = null;\n        } else {\n          renderState.tail = null;\n        }\n      } else {\n        // Detach the insertion after the last node that was already\n        // inserted.\n        lastTailNode.sibling = null;\n      }\n      break;\n    }\n  }\n}\n\nfunction bubbleProperties(completedWork: Fiber) {\n  const didBailout =\n    completedWork.alternate !== null &&\n    completedWork.alternate.child === completedWork.child;\n\n  let newChildLanes = NoLanes;\n  let subtreeFlags = NoFlags;\n\n  if (!didBailout) {\n    // Bubble up the earliest expiration time.\n    if (enableProfilerTimer && (completedWork.mode & ProfileMode) !== NoMode) {\n      // In profiling mode, resetChildExpirationTime is also used to reset\n      // profiler durations.\n      let actualDuration = completedWork.actualDuration;\n      let treeBaseDuration = ((completedWork.selfBaseDuration: any): number);\n\n      let child = completedWork.child;\n      while (child !== null) {\n        newChildLanes = mergeLanes(\n          newChildLanes,\n          mergeLanes(child.lanes, child.childLanes),\n        );\n\n        subtreeFlags |= child.subtreeFlags;\n        subtreeFlags |= child.flags;\n\n        // When a fiber is cloned, its actualDuration is reset to 0. This value will\n        // only be updated if work is done on the fiber (i.e. it doesn't bailout).\n        // When work is done, it should bubble to the parent's actualDuration. If\n        // the fiber has not been cloned though, (meaning no work was done), then\n        // this value will reflect the amount of time spent working on a previous\n        // render. In that case it should not bubble. We determine whether it was\n        // cloned by comparing the child pointer.\n        actualDuration += child.actualDuration;\n\n        treeBaseDuration += child.treeBaseDuration;\n        child = child.sibling;\n      }\n\n      completedWork.actualDuration = actualDuration;\n      completedWork.treeBaseDuration = treeBaseDuration;\n    } else {\n      let child = completedWork.child;\n      while (child !== null) {\n        newChildLanes = mergeLanes(\n          newChildLanes,\n          mergeLanes(child.lanes, child.childLanes),\n        );\n\n        subtreeFlags |= child.subtreeFlags;\n        subtreeFlags |= child.flags;\n\n        // Update the return pointer so the tree is consistent. This is a code\n        // smell because it assumes the commit phase is never concurrent with\n        // the render phase. Will address during refactor to alternate model.\n        child.return = completedWork;\n\n        child = child.sibling;\n      }\n    }\n\n    completedWork.subtreeFlags |= subtreeFlags;\n  } else {\n    // Bubble up the earliest expiration time.\n    if (enableProfilerTimer && (completedWork.mode & ProfileMode) !== NoMode) {\n      // In profiling mode, resetChildExpirationTime is also used to reset\n      // profiler durations.\n      let treeBaseDuration = ((completedWork.selfBaseDuration: any): number);\n\n      let child = completedWork.child;\n      while (child !== null) {\n        newChildLanes = mergeLanes(\n          newChildLanes,\n          mergeLanes(child.lanes, child.childLanes),\n        );\n\n        // \"Static\" flags share the lifetime of the fiber/hook they belong to,\n        // so we should bubble those up even during a bailout. All the other\n        // flags have a lifetime only of a single render + commit, so we should\n        // ignore them.\n        subtreeFlags |= child.subtreeFlags & StaticMask;\n        subtreeFlags |= child.flags & StaticMask;\n\n        treeBaseDuration += child.treeBaseDuration;\n        child = child.sibling;\n      }\n\n      completedWork.treeBaseDuration = treeBaseDuration;\n    } else {\n      let child = completedWork.child;\n      while (child !== null) {\n        newChildLanes = mergeLanes(\n          newChildLanes,\n          mergeLanes(child.lanes, child.childLanes),\n        );\n\n        // \"Static\" flags share the lifetime of the fiber/hook they belong to,\n        // so we should bubble those up even during a bailout. All the other\n        // flags have a lifetime only of a single render + commit, so we should\n        // ignore them.\n        subtreeFlags |= child.subtreeFlags & StaticMask;\n        subtreeFlags |= child.flags & StaticMask;\n\n        // Update the return pointer so the tree is consistent. This is a code\n        // smell because it assumes the commit phase is never concurrent with\n        // the render phase. Will address during refactor to alternate model.\n        child.return = completedWork;\n\n        child = child.sibling;\n      }\n    }\n\n    completedWork.subtreeFlags |= subtreeFlags;\n  }\n\n  completedWork.childLanes = newChildLanes;\n\n  return didBailout;\n}\n\nexport function completeSuspendedOffscreenHostContainer(\n  current: Fiber | null,\n  workInProgress: Fiber,\n) {\n  // This is a fork of the complete phase for HostComponent. We use it when\n  // a suspense tree is in its fallback state, because in that case the primary\n  // tree that includes the offscreen boundary is skipped over without a\n  // regular complete phase.\n  //\n  // We can optimize this path further by inlining the update logic for\n  // offscreen instances specifically, i.e. skipping the `prepareUpdate` call.\n  const rootContainerInstance = getRootHostContainer();\n  const type = workInProgress.type;\n  const newProps = workInProgress.memoizedProps;\n  if (current !== null) {\n    updateHostComponent(\n      current,\n      workInProgress,\n      type,\n      newProps,\n      rootContainerInstance,\n    );\n  } else {\n    const currentHostContext = getHostContext();\n    const instance = createInstance(\n      type,\n      newProps,\n      rootContainerInstance,\n      currentHostContext,\n      workInProgress,\n    );\n\n    appendAllChildren(instance, workInProgress, false, false);\n\n    workInProgress.stateNode = instance;\n\n    // Certain renderers require commit-time effects for initial mount.\n    // (eg DOM renderer supports auto-focus for certain elements).\n    // Make sure such renderers get scheduled for later work.\n    if (\n      finalizeInitialChildren(\n        instance,\n        type,\n        newProps,\n        rootContainerInstance,\n        currentHostContext,\n      )\n    ) {\n      markUpdate(workInProgress);\n    }\n\n    if (workInProgress.ref !== null) {\n      // If there is a ref on a host node we need to schedule a callback\n      markRef(workInProgress);\n    }\n  }\n  bubbleProperties(workInProgress);\n}\n\nfunction completeWork(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderLanes: Lanes,\n): Fiber | null {\n  const newProps = workInProgress.pendingProps;\n  // Note: This intentionally doesn't check if we're hydrating because comparing\n  // to the current tree provider fiber is just as fast and less error-prone.\n  // Ideally we would have a special version of the work loop only\n  // for hydration.\n  popTreeContext(workInProgress);\n  switch (workInProgress.tag) {\n    case IndeterminateComponent:\n    case LazyComponent:\n    case SimpleMemoComponent:\n    case FunctionComponent:\n    case ForwardRef:\n    case Fragment:\n    case Mode:\n    case Profiler:\n    case ContextConsumer:\n    case MemoComponent:\n      bubbleProperties(workInProgress);\n      return null;\n    case ClassComponent: {\n      const Component = workInProgress.type;\n      if (isLegacyContextProvider(Component)) {\n        popLegacyContext(workInProgress);\n      }\n      bubbleProperties(workInProgress);\n      return null;\n    }\n    case HostRoot: {\n      const fiberRoot = (workInProgress.stateNode: FiberRoot);\n      if (enableCache) {\n        popRootCachePool(fiberRoot, renderLanes);\n\n        let previousCache: Cache | null = null;\n        if (workInProgress.alternate !== null) {\n          previousCache = workInProgress.alternate.memoizedState.cache;\n        }\n        const cache: Cache = workInProgress.memoizedState.cache;\n        if (cache !== previousCache) {\n          // Run passive effects to retain/release the cache.\n          workInProgress.flags |= Passive;\n        }\n        popCacheProvider(workInProgress, cache);\n      }\n      popHostContainer(workInProgress);\n      popTopLevelLegacyContextObject(workInProgress);\n      resetMutableSourceWorkInProgressVersions();\n      if (fiberRoot.pendingContext) {\n        fiberRoot.context = fiberRoot.pendingContext;\n        fiberRoot.pendingContext = null;\n      }\n      if (current === null || current.child === null) {\n        // If we hydrated, pop so that we can delete any remaining children\n        // that weren't hydrated.\n        const wasHydrated = popHydrationState(workInProgress);\n        if (wasHydrated) {\n          // If we hydrated, then we'll need to schedule an update for\n          // the commit side-effects on the root.\n          markUpdate(workInProgress);\n        } else if (!fiberRoot.isDehydrated) {\n          // Schedule an effect to clear this container at the start of the next commit.\n          // This handles the case of React rendering into a container with previous children.\n          // It's also safe to do for updates too, because current.child would only be null\n          // if the previous render was null (so the container would already be empty).\n          workInProgress.flags |= Snapshot;\n        }\n      }\n      updateHostContainer(current, workInProgress);\n      bubbleProperties(workInProgress);\n      return null;\n    }\n    case HostComponent: {\n      popHostContext(workInProgress);\n      const rootContainerInstance = getRootHostContainer();\n      const type = workInProgress.type;\n      if (current !== null && workInProgress.stateNode != null) {\n        updateHostComponent(\n          current,\n          workInProgress,\n          type,\n          newProps,\n          rootContainerInstance,\n        );\n\n        if (current.ref !== workInProgress.ref) {\n          markRef(workInProgress);\n        }\n      } else {\n        if (!newProps) {\n          if (workInProgress.stateNode === null) {\n            throw new Error(\n              'We must have new props for new mounts. This error is likely ' +\n                'caused by a bug in React. Please file an issue.',\n            );\n          }\n\n          // This can happen when we abort work.\n          bubbleProperties(workInProgress);\n          return null;\n        }\n\n        const currentHostContext = getHostContext();\n        // TODO: Move createInstance to beginWork and keep it on a context\n        // \"stack\" as the parent. Then append children as we go in beginWork\n        // or completeWork depending on whether we want to add them top->down or\n        // bottom->up. Top->down is faster in IE11.\n        const wasHydrated = popHydrationState(workInProgress);\n        if (wasHydrated) {\n          // TODO: Move this and createInstance step into the beginPhase\n          // to consolidate.\n          if (\n            prepareToHydrateHostInstance(\n              workInProgress,\n              rootContainerInstance,\n              currentHostContext,\n            )\n          ) {\n            // If changes to the hydrated node need to be applied at the\n            // commit-phase we mark this as such.\n            markUpdate(workInProgress);\n          }\n        } else {\n          const instance = createInstance(\n            type,\n            newProps,\n            rootContainerInstance,\n            currentHostContext,\n            workInProgress,\n          );\n\n          appendAllChildren(instance, workInProgress, false, false);\n\n          workInProgress.stateNode = instance;\n\n          // Certain renderers require commit-time effects for initial mount.\n          // (eg DOM renderer supports auto-focus for certain elements).\n          // Make sure such renderers get scheduled for later work.\n          if (\n            finalizeInitialChildren(\n              instance,\n              type,\n              newProps,\n              rootContainerInstance,\n              currentHostContext,\n            )\n          ) {\n            markUpdate(workInProgress);\n          }\n        }\n\n        if (workInProgress.ref !== null) {\n          // If there is a ref on a host node we need to schedule a callback\n          markRef(workInProgress);\n        }\n      }\n      bubbleProperties(workInProgress);\n      return null;\n    }\n    case HostText: {\n      const newText = newProps;\n      if (current && workInProgress.stateNode != null) {\n        const oldText = current.memoizedProps;\n        // If we have an alternate, that means this is an update and we need\n        // to schedule a side-effect to do the updates.\n        updateHostText(current, workInProgress, oldText, newText);\n      } else {\n        if (typeof newText !== 'string') {\n          if (workInProgress.stateNode === null) {\n            throw new Error(\n              'We must have new props for new mounts. This error is likely ' +\n                'caused by a bug in React. Please file an issue.',\n            );\n          }\n          // This can happen when we abort work.\n        }\n        const rootContainerInstance = getRootHostContainer();\n        const currentHostContext = getHostContext();\n        const wasHydrated = popHydrationState(workInProgress);\n        if (wasHydrated) {\n          if (prepareToHydrateHostTextInstance(workInProgress)) {\n            markUpdate(workInProgress);\n          }\n        } else {\n          workInProgress.stateNode = createTextInstance(\n            newText,\n            rootContainerInstance,\n            currentHostContext,\n            workInProgress,\n          );\n        }\n      }\n      bubbleProperties(workInProgress);\n      return null;\n    }\n    case SuspenseComponent: {\n      popSuspenseContext(workInProgress);\n      const nextState: null | SuspenseState = workInProgress.memoizedState;\n\n      if (enableSuspenseServerRenderer) {\n        if (nextState !== null && nextState.dehydrated !== null) {\n          // We might be inside a hydration state the first time we're picking up this\n          // Suspense boundary, and also after we've reentered it for further hydration.\n          const wasHydrated = popHydrationState(workInProgress);\n          if (current === null) {\n            if (!wasHydrated) {\n              throw new Error(\n                'A dehydrated suspense component was completed without a hydrated node. ' +\n                  'This is probably a bug in React.',\n              );\n            }\n            prepareToHydrateHostSuspenseInstance(workInProgress);\n            bubbleProperties(workInProgress);\n            if (enableProfilerTimer) {\n              if ((workInProgress.mode & ProfileMode) !== NoMode) {\n                const isTimedOutSuspense = nextState !== null;\n                if (isTimedOutSuspense) {\n                  // Don't count time spent in a timed out Suspense subtree as part of the base duration.\n                  const primaryChildFragment = workInProgress.child;\n                  if (primaryChildFragment !== null) {\n                    // $FlowFixMe Flow doesn't support type casting in combination with the -= operator\n                    workInProgress.treeBaseDuration -= ((primaryChildFragment.treeBaseDuration: any): number);\n                  }\n                }\n              }\n            }\n            return null;\n          } else {\n            // We might have reentered this boundary to hydrate it. If so, we need to reset the hydration\n            // state since we're now exiting out of it. popHydrationState doesn't do that for us.\n            resetHydrationState();\n            if ((workInProgress.flags & DidCapture) === NoFlags) {\n              // This boundary did not suspend so it's now hydrated and unsuspended.\n              workInProgress.memoizedState = null;\n            }\n            // If nothing suspended, we need to schedule an effect to mark this boundary\n            // as having hydrated so events know that they're free to be invoked.\n            // It's also a signal to replay events and the suspense callback.\n            // If something suspended, schedule an effect to attach retry listeners.\n            // So we might as well always mark this.\n            workInProgress.flags |= Update;\n            bubbleProperties(workInProgress);\n            if (enableProfilerTimer) {\n              if ((workInProgress.mode & ProfileMode) !== NoMode) {\n                const isTimedOutSuspense = nextState !== null;\n                if (isTimedOutSuspense) {\n                  // Don't count time spent in a timed out Suspense subtree as part of the base duration.\n                  const primaryChildFragment = workInProgress.child;\n                  if (primaryChildFragment !== null) {\n                    // $FlowFixMe Flow doesn't support type casting in combination with the -= operator\n                    workInProgress.treeBaseDuration -= ((primaryChildFragment.treeBaseDuration: any): number);\n                  }\n                }\n              }\n            }\n            return null;\n          }\n        }\n      }\n\n      if ((workInProgress.flags & DidCapture) !== NoFlags) {\n        // Something suspended. Re-render with the fallback children.\n        workInProgress.lanes = renderLanes;\n        // Do not reset the effect list.\n        if (\n          enableProfilerTimer &&\n          (workInProgress.mode & ProfileMode) !== NoMode\n        ) {\n          transferActualDuration(workInProgress);\n        }\n        // Don't bubble properties in this case.\n        return workInProgress;\n      }\n\n      const nextDidTimeout = nextState !== null;\n      let prevDidTimeout = false;\n      if (current === null) {\n        popHydrationState(workInProgress);\n      } else {\n        const prevState: null | SuspenseState = current.memoizedState;\n        prevDidTimeout = prevState !== null;\n      }\n\n      if (enableCache && nextDidTimeout) {\n        const offscreenFiber: Fiber = (workInProgress.child: any);\n        let previousCache: Cache | null = null;\n        if (\n          offscreenFiber.alternate !== null &&\n          offscreenFiber.alternate.memoizedState !== null &&\n          offscreenFiber.alternate.memoizedState.cachePool !== null\n        ) {\n          previousCache = offscreenFiber.alternate.memoizedState.cachePool.pool;\n        }\n        let cache: Cache | null = null;\n        if (\n          offscreenFiber.memoizedState !== null &&\n          offscreenFiber.memoizedState.cachePool !== null\n        ) {\n          cache = offscreenFiber.memoizedState.cachePool.pool;\n        }\n        if (cache !== previousCache) {\n          // Run passive effects to retain/release the cache.\n          offscreenFiber.flags |= Passive;\n        }\n      }\n\n      // If the suspended state of the boundary changes, we need to schedule\n      // an effect to toggle the subtree's visibility. When we switch from\n      // fallback -> primary, the inner Offscreen fiber schedules this effect\n      // as part of its normal complete phase. But when we switch from\n      // primary -> fallback, the inner Offscreen fiber does not have a complete\n      // phase. So we need to schedule its effect here.\n      //\n      // We also use this flag to connect/disconnect the effects, but the same\n      // logic applies: when re-connecting, the Offscreen fiber's complete\n      // phase will handle scheduling the effect. It's only when the fallback\n      // is active that we have to do anything special.\n      if (nextDidTimeout && !prevDidTimeout) {\n        const offscreenFiber: Fiber = (workInProgress.child: any);\n        offscreenFiber.flags |= Visibility;\n\n        // TODO: This will still suspend a synchronous tree if anything\n        // in the concurrent tree already suspended during this render.\n        // This is a known bug.\n        if ((workInProgress.mode & ConcurrentMode) !== NoMode) {\n          // TODO: Move this back to throwException because this is too late\n          // if this is a large tree which is common for initial loads. We\n          // don't know if we should restart a render or not until we get\n          // this marker, and this is too late.\n          // If this render already had a ping or lower pri updates,\n          // and this is the first time we know we're going to suspend we\n          // should be able to immediately restart from within throwException.\n          const hasInvisibleChildContext =\n            current === null &&\n            workInProgress.memoizedProps.unstable_avoidThisFallback !== true;\n          if (\n            hasInvisibleChildContext ||\n            hasSuspenseContext(\n              suspenseStackCursor.current,\n              (InvisibleParentSuspenseContext: SuspenseContext),\n            )\n          ) {\n            // If this was in an invisible tree or a new render, then showing\n            // this boundary is ok.\n            renderDidSuspend();\n          } else {\n            // Otherwise, we're going to have to hide content so we should\n            // suspend for longer if possible.\n            renderDidSuspendDelayIfPossible();\n          }\n        }\n      }\n\n      const wakeables: Set<Wakeable> | null = (workInProgress.updateQueue: any);\n      if (wakeables !== null) {\n        // Schedule an effect to attach a retry listener to the promise.\n        // TODO: Move to passive phase\n        workInProgress.flags |= Update;\n      }\n\n      if (\n        enableSuspenseCallback &&\n        workInProgress.updateQueue !== null &&\n        workInProgress.memoizedProps.suspenseCallback != null\n      ) {\n        // Always notify the callback\n        // TODO: Move to passive phase\n        workInProgress.flags |= Update;\n      }\n      bubbleProperties(workInProgress);\n      if (enableProfilerTimer) {\n        if ((workInProgress.mode & ProfileMode) !== NoMode) {\n          if (nextDidTimeout) {\n            // Don't count time spent in a timed out Suspense subtree as part of the base duration.\n            const primaryChildFragment = workInProgress.child;\n            if (primaryChildFragment !== null) {\n              // $FlowFixMe Flow doesn't support type casting in combination with the -= operator\n              workInProgress.treeBaseDuration -= ((primaryChildFragment.treeBaseDuration: any): number);\n            }\n          }\n        }\n      }\n      return null;\n    }\n    case HostPortal:\n      popHostContainer(workInProgress);\n      updateHostContainer(current, workInProgress);\n      if (current === null) {\n        preparePortalMount(workInProgress.stateNode.containerInfo);\n      }\n      bubbleProperties(workInProgress);\n      return null;\n    case ContextProvider:\n      // Pop provider fiber\n      const context: ReactContext<any> = workInProgress.type._context;\n      popProvider(context, workInProgress);\n      bubbleProperties(workInProgress);\n      return null;\n    case IncompleteClassComponent: {\n      // Same as class component case. I put it down here so that the tags are\n      // sequential to ensure this switch is compiled to a jump table.\n      const Component = workInProgress.type;\n      if (isLegacyContextProvider(Component)) {\n        popLegacyContext(workInProgress);\n      }\n      bubbleProperties(workInProgress);\n      return null;\n    }\n    case SuspenseListComponent: {\n      popSuspenseContext(workInProgress);\n\n      const renderState: null | SuspenseListRenderState =\n        workInProgress.memoizedState;\n\n      if (renderState === null) {\n        // We're running in the default, \"independent\" mode.\n        // We don't do anything in this mode.\n        bubbleProperties(workInProgress);\n        return null;\n      }\n\n      let didSuspendAlready = (workInProgress.flags & DidCapture) !== NoFlags;\n\n      const renderedTail = renderState.rendering;\n      if (renderedTail === null) {\n        // We just rendered the head.\n        if (!didSuspendAlready) {\n          // This is the first pass. We need to figure out if anything is still\n          // suspended in the rendered set.\n\n          // If new content unsuspended, but there's still some content that\n          // didn't. Then we need to do a second pass that forces everything\n          // to keep showing their fallbacks.\n\n          // We might be suspended if something in this render pass suspended, or\n          // something in the previous committed pass suspended. Otherwise,\n          // there's no chance so we can skip the expensive call to\n          // findFirstSuspended.\n          const cannotBeSuspended =\n            renderHasNotSuspendedYet() &&\n            (current === null || (current.flags & DidCapture) === NoFlags);\n          if (!cannotBeSuspended) {\n            let row = workInProgress.child;\n            while (row !== null) {\n              const suspended = findFirstSuspended(row);\n              if (suspended !== null) {\n                didSuspendAlready = true;\n                workInProgress.flags |= DidCapture;\n                cutOffTailIfNeeded(renderState, false);\n\n                // If this is a newly suspended tree, it might not get committed as\n                // part of the second pass. In that case nothing will subscribe to\n                // its thenables. Instead, we'll transfer its thenables to the\n                // SuspenseList so that it can retry if they resolve.\n                // There might be multiple of these in the list but since we're\n                // going to wait for all of them anyway, it doesn't really matter\n                // which ones gets to ping. In theory we could get clever and keep\n                // track of how many dependencies remain but it gets tricky because\n                // in the meantime, we can add/remove/change items and dependencies.\n                // We might bail out of the loop before finding any but that\n                // doesn't matter since that means that the other boundaries that\n                // we did find already has their listeners attached.\n                const newThenables = suspended.updateQueue;\n                if (newThenables !== null) {\n                  workInProgress.updateQueue = newThenables;\n                  workInProgress.flags |= Update;\n                }\n\n                // Rerender the whole list, but this time, we'll force fallbacks\n                // to stay in place.\n                // Reset the effect flags before doing the second pass since that's now invalid.\n                // Reset the child fibers to their original state.\n                workInProgress.subtreeFlags = NoFlags;\n                resetChildFibers(workInProgress, renderLanes);\n\n                // Set up the Suspense Context to force suspense and immediately\n                // rerender the children.\n                pushSuspenseContext(\n                  workInProgress,\n                  setShallowSuspenseContext(\n                    suspenseStackCursor.current,\n                    ForceSuspenseFallback,\n                  ),\n                );\n                // Don't bubble properties in this case.\n                return workInProgress.child;\n              }\n              row = row.sibling;\n            }\n          }\n\n          if (renderState.tail !== null && now() > getRenderTargetTime()) {\n            // We have already passed our CPU deadline but we still have rows\n            // left in the tail. We'll just give up further attempts to render\n            // the main content and only render fallbacks.\n            workInProgress.flags |= DidCapture;\n            didSuspendAlready = true;\n\n            cutOffTailIfNeeded(renderState, false);\n\n            // Since nothing actually suspended, there will nothing to ping this\n            // to get it started back up to attempt the next item. While in terms\n            // of priority this work has the same priority as this current render,\n            // it's not part of the same transition once the transition has\n            // committed. If it's sync, we still want to yield so that it can be\n            // painted. Conceptually, this is really the same as pinging.\n            // We can use any RetryLane even if it's the one currently rendering\n            // since we're leaving it behind on this node.\n            workInProgress.lanes = SomeRetryLane;\n          }\n        } else {\n          cutOffTailIfNeeded(renderState, false);\n        }\n        // Next we're going to render the tail.\n      } else {\n        // Append the rendered row to the child list.\n        if (!didSuspendAlready) {\n          const suspended = findFirstSuspended(renderedTail);\n          if (suspended !== null) {\n            workInProgress.flags |= DidCapture;\n            didSuspendAlready = true;\n\n            // Ensure we transfer the update queue to the parent so that it doesn't\n            // get lost if this row ends up dropped during a second pass.\n            const newThenables = suspended.updateQueue;\n            if (newThenables !== null) {\n              workInProgress.updateQueue = newThenables;\n              workInProgress.flags |= Update;\n            }\n\n            cutOffTailIfNeeded(renderState, true);\n            // This might have been modified.\n            if (\n              renderState.tail === null &&\n              renderState.tailMode === 'hidden' &&\n              !renderedTail.alternate &&\n              !getIsHydrating() // We don't cut it if we're hydrating.\n            ) {\n              // We're done.\n              bubbleProperties(workInProgress);\n              return null;\n            }\n          } else if (\n            // The time it took to render last row is greater than the remaining\n            // time we have to render. So rendering one more row would likely\n            // exceed it.\n            now() * 2 - renderState.renderingStartTime >\n              getRenderTargetTime() &&\n            renderLanes !== OffscreenLane\n          ) {\n            // We have now passed our CPU deadline and we'll just give up further\n            // attempts to render the main content and only render fallbacks.\n            // The assumption is that this is usually faster.\n            workInProgress.flags |= DidCapture;\n            didSuspendAlready = true;\n\n            cutOffTailIfNeeded(renderState, false);\n\n            // Since nothing actually suspended, there will nothing to ping this\n            // to get it started back up to attempt the next item. While in terms\n            // of priority this work has the same priority as this current render,\n            // it's not part of the same transition once the transition has\n            // committed. If it's sync, we still want to yield so that it can be\n            // painted. Conceptually, this is really the same as pinging.\n            // We can use any RetryLane even if it's the one currently rendering\n            // since we're leaving it behind on this node.\n            workInProgress.lanes = SomeRetryLane;\n          }\n        }\n        if (renderState.isBackwards) {\n          // The effect list of the backwards tail will have been added\n          // to the end. This breaks the guarantee that life-cycles fire in\n          // sibling order but that isn't a strong guarantee promised by React.\n          // Especially since these might also just pop in during future commits.\n          // Append to the beginning of the list.\n          renderedTail.sibling = workInProgress.child;\n          workInProgress.child = renderedTail;\n        } else {\n          const previousSibling = renderState.last;\n          if (previousSibling !== null) {\n            previousSibling.sibling = renderedTail;\n          } else {\n            workInProgress.child = renderedTail;\n          }\n          renderState.last = renderedTail;\n        }\n      }\n\n      if (renderState.tail !== null) {\n        // We still have tail rows to render.\n        // Pop a row.\n        const next = renderState.tail;\n        renderState.rendering = next;\n        renderState.tail = next.sibling;\n        renderState.renderingStartTime = now();\n        next.sibling = null;\n\n        // Restore the context.\n        // TODO: We can probably just avoid popping it instead and only\n        // setting it the first time we go from not suspended to suspended.\n        let suspenseContext = suspenseStackCursor.current;\n        if (didSuspendAlready) {\n          suspenseContext = setShallowSuspenseContext(\n            suspenseContext,\n            ForceSuspenseFallback,\n          );\n        } else {\n          suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);\n        }\n        pushSuspenseContext(workInProgress, suspenseContext);\n        // Do a pass over the next row.\n        // Don't bubble properties in this case.\n        return next;\n      }\n      bubbleProperties(workInProgress);\n      return null;\n    }\n    case ScopeComponent: {\n      if (enableScopeAPI) {\n        if (current === null) {\n          const scopeInstance: ReactScopeInstance = createScopeInstance();\n          workInProgress.stateNode = scopeInstance;\n          prepareScopeUpdate(scopeInstance, workInProgress);\n          if (workInProgress.ref !== null) {\n            markRef(workInProgress);\n            markUpdate(workInProgress);\n          }\n        } else {\n          if (workInProgress.ref !== null) {\n            markUpdate(workInProgress);\n          }\n          if (current.ref !== workInProgress.ref) {\n            markRef(workInProgress);\n          }\n        }\n        bubbleProperties(workInProgress);\n        return null;\n      }\n      break;\n    }\n    case OffscreenComponent:\n    case LegacyHiddenComponent: {\n      popRenderLanes(workInProgress);\n      const nextState: OffscreenState | null = workInProgress.memoizedState;\n      const nextIsHidden = nextState !== null;\n\n      if (current !== null) {\n        const prevState: OffscreenState | null = current.memoizedState;\n        const prevIsHidden = prevState !== null;\n        if (\n          prevIsHidden !== nextIsHidden &&\n          newProps.mode !== 'unstable-defer-without-hiding' &&\n          // LegacyHidden doesn't do any hiding — it only pre-renders.\n          workInProgress.tag !== LegacyHiddenComponent\n        ) {\n          workInProgress.flags |= Visibility;\n        }\n      }\n\n      if (!nextIsHidden || (workInProgress.mode & ConcurrentMode) === NoMode) {\n        bubbleProperties(workInProgress);\n      } else {\n        // Don't bubble properties for hidden children unless we're rendering\n        // at offscreen priority.\n        if (includesSomeLane(subtreeRenderLanes, (OffscreenLane: Lane))) {\n          bubbleProperties(workInProgress);\n          if (supportsMutation) {\n            // Check if there was an insertion or update in the hidden subtree.\n            // If so, we need to hide those nodes in the commit phase, so\n            // schedule a visibility effect.\n            if (\n              workInProgress.tag !== LegacyHiddenComponent &&\n              workInProgress.subtreeFlags & (Placement | Update) &&\n              newProps.mode !== 'unstable-defer-without-hiding'\n            ) {\n              workInProgress.flags |= Visibility;\n            }\n          }\n        }\n      }\n\n      if (enableCache) {\n        let previousCache: Cache | null = null;\n        if (\n          workInProgress.alternate !== null &&\n          workInProgress.alternate.memoizedState !== null &&\n          workInProgress.alternate.memoizedState.cachePool !== null\n        ) {\n          previousCache = workInProgress.alternate.memoizedState.cachePool.pool;\n        }\n        let cache: Cache | null = null;\n        if (\n          workInProgress.memoizedState !== null &&\n          workInProgress.memoizedState.cachePool !== null\n        ) {\n          cache = workInProgress.memoizedState.cachePool.pool;\n        }\n        if (cache !== previousCache) {\n          // Run passive effects to retain/release the cache.\n          workInProgress.flags |= Passive;\n        }\n        const spawnedCachePool: SpawnedCachePool | null = (workInProgress.updateQueue: any);\n        if (spawnedCachePool !== null) {\n          popCachePool(workInProgress);\n        }\n      }\n\n      return null;\n    }\n    case CacheComponent: {\n      if (enableCache) {\n        let previousCache: Cache | null = null;\n        if (workInProgress.alternate !== null) {\n          previousCache = workInProgress.alternate.memoizedState.cache;\n        }\n        const cache: Cache = workInProgress.memoizedState.cache;\n        if (cache !== previousCache) {\n          // Run passive effects to retain/release the cache.\n          workInProgress.flags |= Passive;\n        }\n        popCacheProvider(workInProgress, cache);\n        bubbleProperties(workInProgress);\n        return null;\n      }\n    }\n  }\n\n  throw new Error(\n    `Unknown unit of work tag (${workInProgress.tag}). This error is likely caused by a bug in ` +\n      'React. Please file an issue.',\n  );\n}\n\nexport {completeWork};\n"]},"metadata":{},"sourceType":"module"}