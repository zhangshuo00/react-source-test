{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { enableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay } from 'shared/ReactFeatureFlags';\nimport { isDiscreteEventThatRequiresHydration, queueDiscreteEvent, hasQueuedDiscreteEvents, clearIfContinuousEvent, queueIfContinuousEvent, attemptSynchronousHydration } from './ReactDOMEventReplaying';\nimport { getNearestMountedFiber, getContainerFromFiber, getSuspenseInstanceFromFiber } from 'react-reconciler/src/ReactFiberTreeReflection';\nimport { HostRoot, SuspenseComponent } from 'react-reconciler/src/ReactWorkTags';\nimport { IS_CAPTURE_PHASE } from './EventSystemFlags';\nimport getEventTarget from './getEventTarget';\nimport { getInstanceFromNode, getClosestInstanceFromNode } from '../client/ReactDOMComponentTree';\nimport { dispatchEventForPluginEventSystem } from './DOMPluginEventSystem';\nimport { getCurrentPriorityLevel as getCurrentSchedulerPriorityLevel, IdlePriority as IdleSchedulerPriority, ImmediatePriority as ImmediateSchedulerPriority, LowPriority as LowSchedulerPriority, NormalPriority as NormalSchedulerPriority, UserBlockingPriority as UserBlockingSchedulerPriority } from 'react-reconciler/src/Scheduler';\nimport { DiscreteEventPriority, ContinuousEventPriority, DefaultEventPriority, IdleEventPriority, getCurrentUpdatePriority, setCurrentUpdatePriority } from 'react-reconciler/src/ReactEventPriorities';\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nconst {\n  ReactCurrentBatchConfig\n} = ReactSharedInternals; // TODO: can we stop exporting these?\n\nexport let _enabled = true; // This is exported in FB builds for use by legacy FB layer infra.\n// We'd like to remove this but it's not clear if this is safe.\n\nexport function setEnabled(enabled) {\n  _enabled = !!enabled;\n}\nexport function isEnabled() {\n  return _enabled;\n}\nexport function createEventListenerWrapper(targetContainer, domEventName, eventSystemFlags) {\n  return dispatchEvent.bind(null, domEventName, eventSystemFlags, targetContainer);\n}\nexport function createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags) {\n  const eventPriority = getEventPriority(domEventName);\n  let listenerWrapper;\n\n  switch (eventPriority) {\n    case DiscreteEventPriority:\n      listenerWrapper = dispatchDiscreteEvent;\n      break;\n\n    case ContinuousEventPriority:\n      listenerWrapper = dispatchContinuousEvent;\n      break;\n\n    case DefaultEventPriority:\n    default:\n      listenerWrapper = dispatchEvent;\n      break;\n  }\n\n  return listenerWrapper.bind(null, domEventName, eventSystemFlags, targetContainer);\n}\n\nfunction dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {\n  const previousPriority = getCurrentUpdatePriority();\n  const prevTransition = ReactCurrentBatchConfig.transition;\n  ReactCurrentBatchConfig.transition = 0;\n\n  try {\n    setCurrentUpdatePriority(DiscreteEventPriority);\n    dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);\n  } finally {\n    setCurrentUpdatePriority(previousPriority);\n    ReactCurrentBatchConfig.transition = prevTransition;\n  }\n}\n\nfunction dispatchContinuousEvent(domEventName, eventSystemFlags, container, nativeEvent) {\n  const previousPriority = getCurrentUpdatePriority();\n  const prevTransition = ReactCurrentBatchConfig.transition;\n  ReactCurrentBatchConfig.transition = 0;\n\n  try {\n    setCurrentUpdatePriority(ContinuousEventPriority);\n    dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);\n  } finally {\n    setCurrentUpdatePriority(previousPriority);\n    ReactCurrentBatchConfig.transition = prevTransition;\n  }\n}\n\nexport function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {\n  if (!_enabled) {\n    return;\n  } // TODO: replaying capture phase events is currently broken\n  // because we used to do it during top-level native bubble handlers\n  // but now we use different bubble and capture handlers.\n  // In eager mode, we attach capture listeners early, so we need\n  // to filter them out until we fix the logic to handle them correctly.\n\n\n  const allowReplay = (eventSystemFlags & IS_CAPTURE_PHASE) === 0;\n\n  if (allowReplay && hasQueuedDiscreteEvents() && isDiscreteEventThatRequiresHydration(domEventName)) {\n    // If we already have a queue of discrete events, and this is another discrete\n    // event, then we can't dispatch it regardless of its target, since they\n    // need to dispatch in order.\n    queueDiscreteEvent(null, // Flags that we're not actually blocked on anything as far as we know.\n    domEventName, eventSystemFlags, targetContainer, nativeEvent);\n    return;\n  }\n\n  let blockedOn = attemptToDispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent);\n\n  if (blockedOn === null) {\n    // We successfully dispatched this event.\n    if (allowReplay) {\n      clearIfContinuousEvent(domEventName, nativeEvent);\n    }\n\n    return;\n  }\n\n  if (allowReplay) {\n    if (!enableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay && isDiscreteEventThatRequiresHydration(domEventName)) {\n      // This this to be replayed later once the target is available.\n      queueDiscreteEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent);\n      return;\n    }\n\n    if (queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent)) {\n      return;\n    } // We need to clear only if we didn't queue because\n    // queueing is accumulative.\n\n\n    clearIfContinuousEvent(domEventName, nativeEvent);\n  }\n\n  if (enableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay && eventSystemFlags & IS_CAPTURE_PHASE && isDiscreteEventThatRequiresHydration(domEventName)) {\n    while (blockedOn !== null) {\n      const fiber = getInstanceFromNode(blockedOn);\n\n      if (fiber !== null) {\n        attemptSynchronousHydration(fiber);\n      }\n\n      const nextBlockedOn = attemptToDispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent);\n\n      if (nextBlockedOn === blockedOn) {\n        break;\n      }\n\n      blockedOn = nextBlockedOn;\n    }\n\n    if (blockedOn) {\n      nativeEvent.stopPropagation();\n      return;\n    }\n  } // This is not replayable so we'll invoke it but without a target,\n  // in case the event system needs to trace it.\n\n\n  dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, null, targetContainer);\n} // Attempt dispatching an event. Returns a SuspenseInstance or Container if it's blocked.\n\nexport function attemptToDispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {\n  // TODO: Warn if _enabled is false.\n  const nativeEventTarget = getEventTarget(nativeEvent);\n  let targetInst = getClosestInstanceFromNode(nativeEventTarget);\n\n  if (targetInst !== null) {\n    const nearestMounted = getNearestMountedFiber(targetInst);\n\n    if (nearestMounted === null) {\n      // This tree has been unmounted already. Dispatch without a target.\n      targetInst = null;\n    } else {\n      const tag = nearestMounted.tag;\n\n      if (tag === SuspenseComponent) {\n        const instance = getSuspenseInstanceFromFiber(nearestMounted);\n\n        if (instance !== null) {\n          // Queue the event to be replayed later. Abort dispatching since we\n          // don't want this event dispatched twice through the event system.\n          // TODO: If this is the first discrete event in the queue. Schedule an increased\n          // priority for this boundary.\n          return instance;\n        } // This shouldn't happen, something went wrong but to avoid blocking\n        // the whole system, dispatch the event without a target.\n        // TODO: Warn.\n\n\n        targetInst = null;\n      } else if (tag === HostRoot) {\n        const root = nearestMounted.stateNode;\n\n        if (root.isDehydrated) {\n          // If this happens during a replay something went wrong and it might block\n          // the whole system.\n          return getContainerFromFiber(nearestMounted);\n        }\n\n        targetInst = null;\n      } else if (nearestMounted !== targetInst) {\n        // If we get an event (ex: img onload) before committing that\n        // component's mount, ignore it for now (that is, treat it as if it was an\n        // event on a non-React tree). We might also consider queueing events and\n        // dispatching them after the mount.\n        targetInst = null;\n      }\n    }\n  }\n\n  dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer); // We're not blocked on anything.\n\n  return null;\n}\nexport function getEventPriority(domEventName) {\n  switch (domEventName) {\n    // Used by SimpleEventPlugin:\n    case 'cancel':\n    case 'click':\n    case 'close':\n    case 'contextmenu':\n    case 'copy':\n    case 'cut':\n    case 'auxclick':\n    case 'dblclick':\n    case 'dragend':\n    case 'dragstart':\n    case 'drop':\n    case 'focusin':\n    case 'focusout':\n    case 'input':\n    case 'invalid':\n    case 'keydown':\n    case 'keypress':\n    case 'keyup':\n    case 'mousedown':\n    case 'mouseup':\n    case 'paste':\n    case 'pause':\n    case 'play':\n    case 'pointercancel':\n    case 'pointerdown':\n    case 'pointerup':\n    case 'ratechange':\n    case 'reset':\n    case 'resize':\n    case 'seeked':\n    case 'submit':\n    case 'touchcancel':\n    case 'touchend':\n    case 'touchstart':\n    case 'volumechange': // Used by polyfills:\n    // eslint-disable-next-line no-fallthrough\n\n    case 'change':\n    case 'selectionchange':\n    case 'textInput':\n    case 'compositionstart':\n    case 'compositionend':\n    case 'compositionupdate': // Only enableCreateEventHandleAPI:\n    // eslint-disable-next-line no-fallthrough\n\n    case 'beforeblur':\n    case 'afterblur': // Not used by React but could be by user code:\n    // eslint-disable-next-line no-fallthrough\n\n    case 'beforeinput':\n    case 'blur':\n    case 'fullscreenchange':\n    case 'focus':\n    case 'hashchange':\n    case 'popstate':\n    case 'select':\n    case 'selectstart':\n      return DiscreteEventPriority;\n\n    case 'drag':\n    case 'dragenter':\n    case 'dragexit':\n    case 'dragleave':\n    case 'dragover':\n    case 'mousemove':\n    case 'mouseout':\n    case 'mouseover':\n    case 'pointermove':\n    case 'pointerout':\n    case 'pointerover':\n    case 'scroll':\n    case 'toggle':\n    case 'touchmove':\n    case 'wheel': // Not used by React but could be by user code:\n    // eslint-disable-next-line no-fallthrough\n\n    case 'mouseenter':\n    case 'mouseleave':\n    case 'pointerenter':\n    case 'pointerleave':\n      return ContinuousEventPriority;\n\n    case 'message':\n      {\n        // We might be in the Scheduler callback.\n        // Eventually this mechanism will be replaced by a check\n        // of the current priority on the native scheduler.\n        const schedulerPriority = getCurrentSchedulerPriorityLevel();\n\n        switch (schedulerPriority) {\n          case ImmediateSchedulerPriority:\n            return DiscreteEventPriority;\n\n          case UserBlockingSchedulerPriority:\n            return ContinuousEventPriority;\n\n          case NormalSchedulerPriority:\n          case LowSchedulerPriority:\n            // TODO: Handle LowSchedulerPriority, somehow. Maybe the same lane as hydration.\n            return DefaultEventPriority;\n\n          case IdleSchedulerPriority:\n            return IdleEventPriority;\n\n          default:\n            return DefaultEventPriority;\n        }\n      }\n\n    default:\n      return DefaultEventPriority;\n  }\n}","map":{"version":3,"sources":["/Users/zhangshuo/git/react-source-test/src/react/packages/react-dom/src/events/ReactDOMEventListener.js"],"names":["enableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay","isDiscreteEventThatRequiresHydration","queueDiscreteEvent","hasQueuedDiscreteEvents","clearIfContinuousEvent","queueIfContinuousEvent","attemptSynchronousHydration","getNearestMountedFiber","getContainerFromFiber","getSuspenseInstanceFromFiber","HostRoot","SuspenseComponent","IS_CAPTURE_PHASE","getEventTarget","getInstanceFromNode","getClosestInstanceFromNode","dispatchEventForPluginEventSystem","getCurrentPriorityLevel","getCurrentSchedulerPriorityLevel","IdlePriority","IdleSchedulerPriority","ImmediatePriority","ImmediateSchedulerPriority","LowPriority","LowSchedulerPriority","NormalPriority","NormalSchedulerPriority","UserBlockingPriority","UserBlockingSchedulerPriority","DiscreteEventPriority","ContinuousEventPriority","DefaultEventPriority","IdleEventPriority","getCurrentUpdatePriority","setCurrentUpdatePriority","ReactSharedInternals","ReactCurrentBatchConfig","_enabled","setEnabled","enabled","isEnabled","createEventListenerWrapper","targetContainer","domEventName","eventSystemFlags","dispatchEvent","bind","createEventListenerWrapperWithPriority","eventPriority","getEventPriority","listenerWrapper","dispatchDiscreteEvent","dispatchContinuousEvent","container","nativeEvent","previousPriority","prevTransition","transition","allowReplay","blockedOn","attemptToDispatchEvent","fiber","nextBlockedOn","stopPropagation","nativeEventTarget","targetInst","nearestMounted","tag","instance","root","stateNode","isDehydrated","schedulerPriority"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {AnyNativeEvent} from '../events/PluginModuleType';\nimport type {FiberRoot} from 'react-reconciler/src/ReactInternalTypes';\nimport type {Container, SuspenseInstance} from '../client/ReactDOMHostConfig';\nimport type {DOMEventName} from '../events/DOMEventNames';\nimport {enableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay} from 'shared/ReactFeatureFlags';\nimport {\n  isDiscreteEventThatRequiresHydration,\n  queueDiscreteEvent,\n  hasQueuedDiscreteEvents,\n  clearIfContinuousEvent,\n  queueIfContinuousEvent,\n  attemptSynchronousHydration,\n} from './ReactDOMEventReplaying';\nimport {\n  getNearestMountedFiber,\n  getContainerFromFiber,\n  getSuspenseInstanceFromFiber,\n} from 'react-reconciler/src/ReactFiberTreeReflection';\nimport {HostRoot, SuspenseComponent} from 'react-reconciler/src/ReactWorkTags';\nimport {type EventSystemFlags, IS_CAPTURE_PHASE} from './EventSystemFlags';\n\nimport getEventTarget from './getEventTarget';\nimport {\n  getInstanceFromNode,\n  getClosestInstanceFromNode,\n} from '../client/ReactDOMComponentTree';\n\nimport {dispatchEventForPluginEventSystem} from './DOMPluginEventSystem';\n\nimport {\n  getCurrentPriorityLevel as getCurrentSchedulerPriorityLevel,\n  IdlePriority as IdleSchedulerPriority,\n  ImmediatePriority as ImmediateSchedulerPriority,\n  LowPriority as LowSchedulerPriority,\n  NormalPriority as NormalSchedulerPriority,\n  UserBlockingPriority as UserBlockingSchedulerPriority,\n} from 'react-reconciler/src/Scheduler';\nimport {\n  DiscreteEventPriority,\n  ContinuousEventPriority,\n  DefaultEventPriority,\n  IdleEventPriority,\n  getCurrentUpdatePriority,\n  setCurrentUpdatePriority,\n} from 'react-reconciler/src/ReactEventPriorities';\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\n\nconst {ReactCurrentBatchConfig} = ReactSharedInternals;\n\n// TODO: can we stop exporting these?\nexport let _enabled = true;\n\n// This is exported in FB builds for use by legacy FB layer infra.\n// We'd like to remove this but it's not clear if this is safe.\nexport function setEnabled(enabled: ?boolean) {\n  _enabled = !!enabled;\n}\n\nexport function isEnabled() {\n  return _enabled;\n}\n\nexport function createEventListenerWrapper(\n  targetContainer: EventTarget,\n  domEventName: DOMEventName,\n  eventSystemFlags: EventSystemFlags,\n): Function {\n  return dispatchEvent.bind(\n    null,\n    domEventName,\n    eventSystemFlags,\n    targetContainer,\n  );\n}\n\nexport function createEventListenerWrapperWithPriority(\n  targetContainer: EventTarget,\n  domEventName: DOMEventName,\n  eventSystemFlags: EventSystemFlags,\n): Function {\n  const eventPriority = getEventPriority(domEventName);\n  let listenerWrapper;\n  switch (eventPriority) {\n    case DiscreteEventPriority:\n      listenerWrapper = dispatchDiscreteEvent;\n      break;\n    case ContinuousEventPriority:\n      listenerWrapper = dispatchContinuousEvent;\n      break;\n    case DefaultEventPriority:\n    default:\n      listenerWrapper = dispatchEvent;\n      break;\n  }\n  return listenerWrapper.bind(\n    null,\n    domEventName,\n    eventSystemFlags,\n    targetContainer,\n  );\n}\n\nfunction dispatchDiscreteEvent(\n  domEventName,\n  eventSystemFlags,\n  container,\n  nativeEvent,\n) {\n  const previousPriority = getCurrentUpdatePriority();\n  const prevTransition = ReactCurrentBatchConfig.transition;\n  ReactCurrentBatchConfig.transition = 0;\n  try {\n    setCurrentUpdatePriority(DiscreteEventPriority);\n    dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);\n  } finally {\n    setCurrentUpdatePriority(previousPriority);\n    ReactCurrentBatchConfig.transition = prevTransition;\n  }\n}\n\nfunction dispatchContinuousEvent(\n  domEventName,\n  eventSystemFlags,\n  container,\n  nativeEvent,\n) {\n  const previousPriority = getCurrentUpdatePriority();\n  const prevTransition = ReactCurrentBatchConfig.transition;\n  ReactCurrentBatchConfig.transition = 0;\n  try {\n    setCurrentUpdatePriority(ContinuousEventPriority);\n    dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);\n  } finally {\n    setCurrentUpdatePriority(previousPriority);\n    ReactCurrentBatchConfig.transition = prevTransition;\n  }\n}\n\nexport function dispatchEvent(\n  domEventName: DOMEventName,\n  eventSystemFlags: EventSystemFlags,\n  targetContainer: EventTarget,\n  nativeEvent: AnyNativeEvent,\n): void {\n  if (!_enabled) {\n    return;\n  }\n\n  // TODO: replaying capture phase events is currently broken\n  // because we used to do it during top-level native bubble handlers\n  // but now we use different bubble and capture handlers.\n  // In eager mode, we attach capture listeners early, so we need\n  // to filter them out until we fix the logic to handle them correctly.\n  const allowReplay = (eventSystemFlags & IS_CAPTURE_PHASE) === 0;\n\n  if (\n    allowReplay &&\n    hasQueuedDiscreteEvents() &&\n    isDiscreteEventThatRequiresHydration(domEventName)\n  ) {\n    // If we already have a queue of discrete events, and this is another discrete\n    // event, then we can't dispatch it regardless of its target, since they\n    // need to dispatch in order.\n    queueDiscreteEvent(\n      null, // Flags that we're not actually blocked on anything as far as we know.\n      domEventName,\n      eventSystemFlags,\n      targetContainer,\n      nativeEvent,\n    );\n    return;\n  }\n\n  let blockedOn = attemptToDispatchEvent(\n    domEventName,\n    eventSystemFlags,\n    targetContainer,\n    nativeEvent,\n  );\n\n  if (blockedOn === null) {\n    // We successfully dispatched this event.\n    if (allowReplay) {\n      clearIfContinuousEvent(domEventName, nativeEvent);\n    }\n    return;\n  }\n\n  if (allowReplay) {\n    if (\n      !enableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay &&\n      isDiscreteEventThatRequiresHydration(domEventName)\n    ) {\n      // This this to be replayed later once the target is available.\n      queueDiscreteEvent(\n        blockedOn,\n        domEventName,\n        eventSystemFlags,\n        targetContainer,\n        nativeEvent,\n      );\n      return;\n    }\n    if (\n      queueIfContinuousEvent(\n        blockedOn,\n        domEventName,\n        eventSystemFlags,\n        targetContainer,\n        nativeEvent,\n      )\n    ) {\n      return;\n    }\n    // We need to clear only if we didn't queue because\n    // queueing is accumulative.\n    clearIfContinuousEvent(domEventName, nativeEvent);\n  }\n\n  if (\n    enableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay &&\n    eventSystemFlags & IS_CAPTURE_PHASE &&\n    isDiscreteEventThatRequiresHydration(domEventName)\n  ) {\n    while (blockedOn !== null) {\n      const fiber = getInstanceFromNode(blockedOn);\n      if (fiber !== null) {\n        attemptSynchronousHydration(fiber);\n      }\n      const nextBlockedOn = attemptToDispatchEvent(\n        domEventName,\n        eventSystemFlags,\n        targetContainer,\n        nativeEvent,\n      );\n      if (nextBlockedOn === blockedOn) {\n        break;\n      }\n      blockedOn = nextBlockedOn;\n    }\n    if (blockedOn) {\n      nativeEvent.stopPropagation();\n      return;\n    }\n  }\n\n  // This is not replayable so we'll invoke it but without a target,\n  // in case the event system needs to trace it.\n  dispatchEventForPluginEventSystem(\n    domEventName,\n    eventSystemFlags,\n    nativeEvent,\n    null,\n    targetContainer,\n  );\n}\n\n// Attempt dispatching an event. Returns a SuspenseInstance or Container if it's blocked.\nexport function attemptToDispatchEvent(\n  domEventName: DOMEventName,\n  eventSystemFlags: EventSystemFlags,\n  targetContainer: EventTarget,\n  nativeEvent: AnyNativeEvent,\n): null | Container | SuspenseInstance {\n  // TODO: Warn if _enabled is false.\n\n  const nativeEventTarget = getEventTarget(nativeEvent);\n  let targetInst = getClosestInstanceFromNode(nativeEventTarget);\n\n  if (targetInst !== null) {\n    const nearestMounted = getNearestMountedFiber(targetInst);\n    if (nearestMounted === null) {\n      // This tree has been unmounted already. Dispatch without a target.\n      targetInst = null;\n    } else {\n      const tag = nearestMounted.tag;\n      if (tag === SuspenseComponent) {\n        const instance = getSuspenseInstanceFromFiber(nearestMounted);\n        if (instance !== null) {\n          // Queue the event to be replayed later. Abort dispatching since we\n          // don't want this event dispatched twice through the event system.\n          // TODO: If this is the first discrete event in the queue. Schedule an increased\n          // priority for this boundary.\n          return instance;\n        }\n        // This shouldn't happen, something went wrong but to avoid blocking\n        // the whole system, dispatch the event without a target.\n        // TODO: Warn.\n        targetInst = null;\n      } else if (tag === HostRoot) {\n        const root: FiberRoot = nearestMounted.stateNode;\n        if (root.isDehydrated) {\n          // If this happens during a replay something went wrong and it might block\n          // the whole system.\n          return getContainerFromFiber(nearestMounted);\n        }\n        targetInst = null;\n      } else if (nearestMounted !== targetInst) {\n        // If we get an event (ex: img onload) before committing that\n        // component's mount, ignore it for now (that is, treat it as if it was an\n        // event on a non-React tree). We might also consider queueing events and\n        // dispatching them after the mount.\n        targetInst = null;\n      }\n    }\n  }\n  dispatchEventForPluginEventSystem(\n    domEventName,\n    eventSystemFlags,\n    nativeEvent,\n    targetInst,\n    targetContainer,\n  );\n  // We're not blocked on anything.\n  return null;\n}\n\nexport function getEventPriority(domEventName: DOMEventName): * {\n  switch (domEventName) {\n    // Used by SimpleEventPlugin:\n    case 'cancel':\n    case 'click':\n    case 'close':\n    case 'contextmenu':\n    case 'copy':\n    case 'cut':\n    case 'auxclick':\n    case 'dblclick':\n    case 'dragend':\n    case 'dragstart':\n    case 'drop':\n    case 'focusin':\n    case 'focusout':\n    case 'input':\n    case 'invalid':\n    case 'keydown':\n    case 'keypress':\n    case 'keyup':\n    case 'mousedown':\n    case 'mouseup':\n    case 'paste':\n    case 'pause':\n    case 'play':\n    case 'pointercancel':\n    case 'pointerdown':\n    case 'pointerup':\n    case 'ratechange':\n    case 'reset':\n    case 'resize':\n    case 'seeked':\n    case 'submit':\n    case 'touchcancel':\n    case 'touchend':\n    case 'touchstart':\n    case 'volumechange':\n    // Used by polyfills:\n    // eslint-disable-next-line no-fallthrough\n    case 'change':\n    case 'selectionchange':\n    case 'textInput':\n    case 'compositionstart':\n    case 'compositionend':\n    case 'compositionupdate':\n    // Only enableCreateEventHandleAPI:\n    // eslint-disable-next-line no-fallthrough\n    case 'beforeblur':\n    case 'afterblur':\n    // Not used by React but could be by user code:\n    // eslint-disable-next-line no-fallthrough\n    case 'beforeinput':\n    case 'blur':\n    case 'fullscreenchange':\n    case 'focus':\n    case 'hashchange':\n    case 'popstate':\n    case 'select':\n    case 'selectstart':\n      return DiscreteEventPriority;\n    case 'drag':\n    case 'dragenter':\n    case 'dragexit':\n    case 'dragleave':\n    case 'dragover':\n    case 'mousemove':\n    case 'mouseout':\n    case 'mouseover':\n    case 'pointermove':\n    case 'pointerout':\n    case 'pointerover':\n    case 'scroll':\n    case 'toggle':\n    case 'touchmove':\n    case 'wheel':\n    // Not used by React but could be by user code:\n    // eslint-disable-next-line no-fallthrough\n    case 'mouseenter':\n    case 'mouseleave':\n    case 'pointerenter':\n    case 'pointerleave':\n      return ContinuousEventPriority;\n    case 'message': {\n      // We might be in the Scheduler callback.\n      // Eventually this mechanism will be replaced by a check\n      // of the current priority on the native scheduler.\n      const schedulerPriority = getCurrentSchedulerPriorityLevel();\n      switch (schedulerPriority) {\n        case ImmediateSchedulerPriority:\n          return DiscreteEventPriority;\n        case UserBlockingSchedulerPriority:\n          return ContinuousEventPriority;\n        case NormalSchedulerPriority:\n        case LowSchedulerPriority:\n          // TODO: Handle LowSchedulerPriority, somehow. Maybe the same lane as hydration.\n          return DefaultEventPriority;\n        case IdleSchedulerPriority:\n          return IdleEventPriority;\n        default:\n          return DefaultEventPriority;\n      }\n    }\n    default:\n      return DefaultEventPriority;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}