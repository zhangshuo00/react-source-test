{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport { shorthandToLonghand } from './CSSShorthandProperty';\nimport dangerousStyleValue from '../shared/dangerousStyleValue';\nimport hyphenateStyleName from '../shared/hyphenateStyleName';\nimport warnValidStyle from '../shared/warnValidStyle';\n/**\n * Operations for dealing with CSS properties.\n */\n\n/**\n * This creates a string that is expected to be equivalent to the style\n * attribute generated by server-side rendering. It by-passes warnings and\n * security checks so it's not safe to use this value for anything other than\n * comparison. It is only used in DEV for SSR validation.\n */\n\nexport function createDangerousStringForStyles(styles) {\n  if (__DEV__) {\n    let serialized = '';\n    let delimiter = '';\n\n    for (const styleName in styles) {\n      if (!styles.hasOwnProperty(styleName)) {\n        continue;\n      }\n\n      const styleValue = styles[styleName];\n\n      if (styleValue != null) {\n        const isCustomProperty = styleName.indexOf('--') === 0;\n        serialized += delimiter + (isCustomProperty ? styleName : hyphenateStyleName(styleName)) + ':';\n        serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty);\n        delimiter = ';';\n      }\n    }\n\n    return serialized || null;\n  }\n}\n/**\n * Sets the value for multiple styles on a node.  If a value is specified as\n * '' (empty string), the corresponding style property will be unset.\n *\n * @param {DOMElement} node\n * @param {object} styles\n */\n\nexport function setValueForStyles(node, styles) {\n  const style = node.style;\n\n  for (let styleName in styles) {\n    if (!styles.hasOwnProperty(styleName)) {\n      continue;\n    }\n\n    const isCustomProperty = styleName.indexOf('--') === 0;\n\n    if (__DEV__) {\n      if (!isCustomProperty) {\n        warnValidStyle(styleName, styles[styleName]);\n      }\n    }\n\n    const styleValue = dangerousStyleValue(styleName, styles[styleName], isCustomProperty);\n\n    if (styleName === 'float') {\n      styleName = 'cssFloat';\n    }\n\n    if (isCustomProperty) {\n      style.setProperty(styleName, styleValue);\n    } else {\n      style[styleName] = styleValue;\n    }\n  }\n}\n\nfunction isValueEmpty(value) {\n  return value == null || typeof value === 'boolean' || value === '';\n}\n/**\n * Given {color: 'red', overflow: 'hidden'} returns {\n *   color: 'color',\n *   overflowX: 'overflow',\n *   overflowY: 'overflow',\n * }. This can be read as \"the overflowY property was set by the overflow\n * shorthand\". That is, the values are the property that each was derived from.\n */\n\n\nfunction expandShorthandMap(styles) {\n  const expanded = {};\n\n  for (const key in styles) {\n    const longhands = shorthandToLonghand[key] || [key];\n\n    for (let i = 0; i < longhands.length; i++) {\n      expanded[longhands[i]] = key;\n    }\n  }\n\n  return expanded;\n}\n/**\n * When mixing shorthand and longhand property names, we warn during updates if\n * we expect an incorrect result to occur. In particular, we warn for:\n *\n * Updating a shorthand property (longhand gets overwritten):\n *   {font: 'foo', fontVariant: 'bar'} -> {font: 'baz', fontVariant: 'bar'}\n *   becomes .style.font = 'baz'\n * Removing a shorthand property (longhand gets lost too):\n *   {font: 'foo', fontVariant: 'bar'} -> {fontVariant: 'bar'}\n *   becomes .style.font = ''\n * Removing a longhand property (should revert to shorthand; doesn't):\n *   {font: 'foo', fontVariant: 'bar'} -> {font: 'foo'}\n *   becomes .style.fontVariant = ''\n */\n\n\nexport function validateShorthandPropertyCollisionInDev(styleUpdates, nextStyles) {\n  if (__DEV__) {\n    if (!nextStyles) {\n      return;\n    }\n\n    const expandedUpdates = expandShorthandMap(styleUpdates);\n    const expandedStyles = expandShorthandMap(nextStyles);\n    const warnedAbout = {};\n\n    for (const key in expandedUpdates) {\n      const originalKey = expandedUpdates[key];\n      const correctOriginalKey = expandedStyles[key];\n\n      if (correctOriginalKey && originalKey !== correctOriginalKey) {\n        const warningKey = originalKey + ',' + correctOriginalKey;\n\n        if (warnedAbout[warningKey]) {\n          continue;\n        }\n\n        warnedAbout[warningKey] = true;\n        console.error('%s a style property during rerender (%s) when a ' + 'conflicting property is set (%s) can lead to styling bugs. To ' + \"avoid this, don't mix shorthand and non-shorthand properties \" + 'for the same value; instead, replace the shorthand with ' + 'separate values.', isValueEmpty(styleUpdates[originalKey]) ? 'Removing' : 'Updating', originalKey, correctOriginalKey);\n      }\n    }\n  }\n}","map":{"version":3,"sources":["/Users/zhangshuo/git/react-source-test/src/react/packages/react-dom/src/client/CSSPropertyOperations.js"],"names":["shorthandToLonghand","dangerousStyleValue","hyphenateStyleName","warnValidStyle","createDangerousStringForStyles","styles","__DEV__","serialized","delimiter","styleName","hasOwnProperty","styleValue","isCustomProperty","indexOf","setValueForStyles","node","style","setProperty","isValueEmpty","value","expandShorthandMap","expanded","key","longhands","i","length","validateShorthandPropertyCollisionInDev","styleUpdates","nextStyles","expandedUpdates","expandedStyles","warnedAbout","originalKey","correctOriginalKey","warningKey","console","error"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {shorthandToLonghand} from './CSSShorthandProperty';\n\nimport dangerousStyleValue from '../shared/dangerousStyleValue';\nimport hyphenateStyleName from '../shared/hyphenateStyleName';\nimport warnValidStyle from '../shared/warnValidStyle';\n\n/**\n * Operations for dealing with CSS properties.\n */\n\n/**\n * This creates a string that is expected to be equivalent to the style\n * attribute generated by server-side rendering. It by-passes warnings and\n * security checks so it's not safe to use this value for anything other than\n * comparison. It is only used in DEV for SSR validation.\n */\nexport function createDangerousStringForStyles(styles) {\n  if (__DEV__) {\n    let serialized = '';\n    let delimiter = '';\n    for (const styleName in styles) {\n      if (!styles.hasOwnProperty(styleName)) {\n        continue;\n      }\n      const styleValue = styles[styleName];\n      if (styleValue != null) {\n        const isCustomProperty = styleName.indexOf('--') === 0;\n        serialized +=\n          delimiter +\n          (isCustomProperty ? styleName : hyphenateStyleName(styleName)) +\n          ':';\n        serialized += dangerousStyleValue(\n          styleName,\n          styleValue,\n          isCustomProperty,\n        );\n\n        delimiter = ';';\n      }\n    }\n    return serialized || null;\n  }\n}\n\n/**\n * Sets the value for multiple styles on a node.  If a value is specified as\n * '' (empty string), the corresponding style property will be unset.\n *\n * @param {DOMElement} node\n * @param {object} styles\n */\nexport function setValueForStyles(node, styles) {\n  const style = node.style;\n  for (let styleName in styles) {\n    if (!styles.hasOwnProperty(styleName)) {\n      continue;\n    }\n    const isCustomProperty = styleName.indexOf('--') === 0;\n    if (__DEV__) {\n      if (!isCustomProperty) {\n        warnValidStyle(styleName, styles[styleName]);\n      }\n    }\n    const styleValue = dangerousStyleValue(\n      styleName,\n      styles[styleName],\n      isCustomProperty,\n    );\n    if (styleName === 'float') {\n      styleName = 'cssFloat';\n    }\n    if (isCustomProperty) {\n      style.setProperty(styleName, styleValue);\n    } else {\n      style[styleName] = styleValue;\n    }\n  }\n}\n\nfunction isValueEmpty(value) {\n  return value == null || typeof value === 'boolean' || value === '';\n}\n\n/**\n * Given {color: 'red', overflow: 'hidden'} returns {\n *   color: 'color',\n *   overflowX: 'overflow',\n *   overflowY: 'overflow',\n * }. This can be read as \"the overflowY property was set by the overflow\n * shorthand\". That is, the values are the property that each was derived from.\n */\nfunction expandShorthandMap(styles) {\n  const expanded = {};\n  for (const key in styles) {\n    const longhands = shorthandToLonghand[key] || [key];\n    for (let i = 0; i < longhands.length; i++) {\n      expanded[longhands[i]] = key;\n    }\n  }\n  return expanded;\n}\n\n/**\n * When mixing shorthand and longhand property names, we warn during updates if\n * we expect an incorrect result to occur. In particular, we warn for:\n *\n * Updating a shorthand property (longhand gets overwritten):\n *   {font: 'foo', fontVariant: 'bar'} -> {font: 'baz', fontVariant: 'bar'}\n *   becomes .style.font = 'baz'\n * Removing a shorthand property (longhand gets lost too):\n *   {font: 'foo', fontVariant: 'bar'} -> {fontVariant: 'bar'}\n *   becomes .style.font = ''\n * Removing a longhand property (should revert to shorthand; doesn't):\n *   {font: 'foo', fontVariant: 'bar'} -> {font: 'foo'}\n *   becomes .style.fontVariant = ''\n */\nexport function validateShorthandPropertyCollisionInDev(\n  styleUpdates,\n  nextStyles,\n) {\n  if (__DEV__) {\n    if (!nextStyles) {\n      return;\n    }\n\n    const expandedUpdates = expandShorthandMap(styleUpdates);\n    const expandedStyles = expandShorthandMap(nextStyles);\n    const warnedAbout = {};\n    for (const key in expandedUpdates) {\n      const originalKey = expandedUpdates[key];\n      const correctOriginalKey = expandedStyles[key];\n      if (correctOriginalKey && originalKey !== correctOriginalKey) {\n        const warningKey = originalKey + ',' + correctOriginalKey;\n        if (warnedAbout[warningKey]) {\n          continue;\n        }\n        warnedAbout[warningKey] = true;\n        console.error(\n          '%s a style property during rerender (%s) when a ' +\n            'conflicting property is set (%s) can lead to styling bugs. To ' +\n            \"avoid this, don't mix shorthand and non-shorthand properties \" +\n            'for the same value; instead, replace the shorthand with ' +\n            'separate values.',\n          isValueEmpty(styleUpdates[originalKey]) ? 'Removing' : 'Updating',\n          originalKey,\n          correctOriginalKey,\n        );\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}