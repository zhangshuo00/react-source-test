{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport isArray from 'shared/isArray';\nimport { getIteratorFn, REACT_ELEMENT_TYPE, REACT_PORTAL_TYPE } from 'shared/ReactSymbols';\nimport { checkKeyStringCoercion } from 'shared/CheckStringCoercion';\nimport { isValidElement, cloneAndReplaceKey } from './ReactElement';\nconst SEPARATOR = '.';\nconst SUBSEPARATOR = ':';\n/**\n * Escape and wrap key so it is safe to use as a reactid\n *\n * @param {string} key to be escaped.\n * @return {string} the escaped key.\n */\n\nfunction escape(key) {\n  const escapeRegex = /[=:]/g;\n  const escaperLookup = {\n    '=': '=0',\n    ':': '=2'\n  };\n  const escapedString = key.replace(escapeRegex, function (match) {\n    return escaperLookup[match];\n  });\n  return '$' + escapedString;\n}\n/**\n * TODO: Test that a single child and an array with one item have the same key\n * pattern.\n */\n\n\nlet didWarnAboutMaps = false;\nconst userProvidedKeyEscapeRegex = /\\/+/g;\n\nfunction escapeUserProvidedKey(text) {\n  return text.replace(userProvidedKeyEscapeRegex, '$&/');\n}\n/**\n * Generate a key string that identifies a element within a set.\n *\n * @param {*} element A element that could contain a manual key.\n * @param {number} index Index that is used if a manual key is not provided.\n * @return {string}\n */\n\n\nfunction getElementKey(element, index) {\n  // Do some typechecking here since we call this blindly. We want to ensure\n  // that we don't block potential future ES APIs.\n  if (typeof element === 'object' && element !== null && element.key != null) {\n    // Explicit key\n    if (__DEV__) {\n      checkKeyStringCoercion(element.key);\n    }\n\n    return escape('' + element.key);\n  } // Implicit key determined by the index in the set\n\n\n  return index.toString(36);\n}\n\nfunction mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {\n  const type = typeof children;\n\n  if (type === 'undefined' || type === 'boolean') {\n    // All of the above are perceived as null.\n    children = null;\n  }\n\n  let invokeCallback = false;\n\n  if (children === null) {\n    invokeCallback = true;\n  } else {\n    switch (type) {\n      case 'string':\n      case 'number':\n        invokeCallback = true;\n        break;\n\n      case 'object':\n        switch (children.$$typeof) {\n          case REACT_ELEMENT_TYPE:\n          case REACT_PORTAL_TYPE:\n            invokeCallback = true;\n        }\n\n    }\n  }\n\n  if (invokeCallback) {\n    const child = children;\n    let mappedChild = callback(child); // If it's the only child, treat the name as if it was wrapped in an array\n    // so that it's consistent if the number of children grows:\n\n    const childKey = nameSoFar === '' ? SEPARATOR + getElementKey(child, 0) : nameSoFar;\n\n    if (isArray(mappedChild)) {\n      let escapedChildKey = '';\n\n      if (childKey != null) {\n        escapedChildKey = escapeUserProvidedKey(childKey) + '/';\n      }\n\n      mapIntoArray(mappedChild, array, escapedChildKey, '', c => c);\n    } else if (mappedChild != null) {\n      if (isValidElement(mappedChild)) {\n        if (__DEV__) {\n          // The `if` statement here prevents auto-disabling of the safe\n          // coercion ESLint rule, so we must manually disable it below.\n          // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key\n          if (mappedChild.key && (!child || child.key !== mappedChild.key)) {\n            checkKeyStringCoercion(mappedChild.key);\n          }\n        }\n\n        mappedChild = cloneAndReplaceKey(mappedChild, // Keep both the (mapped) and old keys if they differ, just as\n        // traverseAllChildren used to do for objects as children\n        escapedPrefix + ( // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key\n        mappedChild.key && (!child || child.key !== mappedChild.key) ? // $FlowFixMe Flow incorrectly thinks existing element's key can be a number\n        // eslint-disable-next-line react-internal/safe-string-coercion\n        escapeUserProvidedKey('' + mappedChild.key) + '/' : '') + childKey);\n      }\n\n      array.push(mappedChild);\n    }\n\n    return 1;\n  }\n\n  let child;\n  let nextName;\n  let subtreeCount = 0; // Count of children found in the current subtree.\n\n  const nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;\n\n  if (isArray(children)) {\n    for (let i = 0; i < children.length; i++) {\n      child = children[i];\n      nextName = nextNamePrefix + getElementKey(child, i);\n      subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);\n    }\n  } else {\n    const iteratorFn = getIteratorFn(children);\n\n    if (typeof iteratorFn === 'function') {\n      const iterableChildren = children;\n\n      if (__DEV__) {\n        // Warn about using Maps as children\n        if (iteratorFn === iterableChildren.entries) {\n          if (!didWarnAboutMaps) {\n            console.warn('Using Maps as children is not supported. ' + 'Use an array of keyed ReactElements instead.');\n          }\n\n          didWarnAboutMaps = true;\n        }\n      }\n\n      const iterator = iteratorFn.call(iterableChildren);\n      let step;\n      let ii = 0;\n\n      while (!(step = iterator.next()).done) {\n        child = step.value;\n        nextName = nextNamePrefix + getElementKey(child, ii++);\n        subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);\n      }\n    } else if (type === 'object') {\n      // eslint-disable-next-line react-internal/safe-string-coercion\n      const childrenString = String(children);\n      throw new Error(`Objects are not valid as a React child (found: ${childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString}). ` + 'If you meant to render a collection of children, use an array ' + 'instead.');\n    }\n  }\n\n  return subtreeCount;\n}\n\n/**\n * Maps children that are typically specified as `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrenmap\n *\n * The provided mapFunction(child, index) will be called for each\n * leaf child.\n *\n * @param {?*} children Children tree container.\n * @param {function(*, int)} func The map function.\n * @param {*} context Context for mapFunction.\n * @return {object} Object containing the ordered map of results.\n */\nfunction mapChildren(children, func, context) {\n  if (children == null) {\n    return children;\n  }\n\n  const result = [];\n  let count = 0;\n  mapIntoArray(children, result, '', '', function (child) {\n    return func.call(context, child, count++);\n  });\n  return result;\n}\n/**\n * Count the number of children that are typically specified as\n * `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrencount\n *\n * @param {?*} children Children tree container.\n * @return {number} The number of children.\n */\n\n\nfunction countChildren(children) {\n  let n = 0;\n  mapChildren(children, () => {\n    n++; // Don't return anything\n  });\n  return n;\n}\n\n/**\n * Iterates through children that are typically specified as `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrenforeach\n *\n * The provided forEachFunc(child, index) will be called for each\n * leaf child.\n *\n * @param {?*} children Children tree container.\n * @param {function(*, int)} forEachFunc\n * @param {*} forEachContext Context for forEachContext.\n */\nfunction forEachChildren(children, forEachFunc, forEachContext) {\n  mapChildren(children, function () {\n    forEachFunc.apply(this, arguments); // Don't return anything.\n  }, forEachContext);\n}\n/**\n * Flatten a children object (typically specified as `props.children`) and\n * return an array with appropriately re-keyed children.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrentoarray\n */\n\n\nfunction toArray(children) {\n  return mapChildren(children, child => child) || [];\n}\n/**\n * Returns the first child in a collection of children and verifies that there\n * is only one child in the collection.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrenonly\n *\n * The current implementation of this function assumes that a single child gets\n * passed without a wrapper, but the purpose of this helper function is to\n * abstract away the particular structure of children.\n *\n * @param {?object} children Child collection structure.\n * @return {ReactElement} The first and only `ReactElement` contained in the\n * structure.\n */\n\n\nfunction onlyChild(children) {\n  if (!isValidElement(children)) {\n    throw new Error('React.Children.only expected to receive a single React element child.');\n  }\n\n  return children;\n}\n\nexport { forEachChildren as forEach, mapChildren as map, countChildren as count, onlyChild as only, toArray };","map":{"version":3,"sources":["/Users/zhangshuo/git/react-source-test/src/react/packages/react/src/ReactChildren.js"],"names":["isArray","getIteratorFn","REACT_ELEMENT_TYPE","REACT_PORTAL_TYPE","checkKeyStringCoercion","isValidElement","cloneAndReplaceKey","SEPARATOR","SUBSEPARATOR","escape","key","escapeRegex","escaperLookup","escapedString","replace","match","didWarnAboutMaps","userProvidedKeyEscapeRegex","escapeUserProvidedKey","text","getElementKey","element","index","__DEV__","toString","mapIntoArray","children","array","escapedPrefix","nameSoFar","callback","type","invokeCallback","$$typeof","child","mappedChild","childKey","escapedChildKey","c","push","nextName","subtreeCount","nextNamePrefix","i","length","iteratorFn","iterableChildren","entries","console","warn","iterator","call","step","ii","next","done","value","childrenString","String","Error","Object","keys","join","mapChildren","func","context","result","count","countChildren","n","forEachChildren","forEachFunc","forEachContext","apply","arguments","toArray","onlyChild","forEach","map","only"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {ReactNodeList} from 'shared/ReactTypes';\n\nimport isArray from 'shared/isArray';\nimport {\n  getIteratorFn,\n  REACT_ELEMENT_TYPE,\n  REACT_PORTAL_TYPE,\n} from 'shared/ReactSymbols';\nimport {checkKeyStringCoercion} from 'shared/CheckStringCoercion';\n\nimport {isValidElement, cloneAndReplaceKey} from './ReactElement';\n\nconst SEPARATOR = '.';\nconst SUBSEPARATOR = ':';\n\n/**\n * Escape and wrap key so it is safe to use as a reactid\n *\n * @param {string} key to be escaped.\n * @return {string} the escaped key.\n */\nfunction escape(key: string): string {\n  const escapeRegex = /[=:]/g;\n  const escaperLookup = {\n    '=': '=0',\n    ':': '=2',\n  };\n  const escapedString = key.replace(escapeRegex, function(match) {\n    return escaperLookup[match];\n  });\n\n  return '$' + escapedString;\n}\n\n/**\n * TODO: Test that a single child and an array with one item have the same key\n * pattern.\n */\n\nlet didWarnAboutMaps = false;\n\nconst userProvidedKeyEscapeRegex = /\\/+/g;\nfunction escapeUserProvidedKey(text: string): string {\n  return text.replace(userProvidedKeyEscapeRegex, '$&/');\n}\n\n/**\n * Generate a key string that identifies a element within a set.\n *\n * @param {*} element A element that could contain a manual key.\n * @param {number} index Index that is used if a manual key is not provided.\n * @return {string}\n */\nfunction getElementKey(element: any, index: number): string {\n  // Do some typechecking here since we call this blindly. We want to ensure\n  // that we don't block potential future ES APIs.\n  if (typeof element === 'object' && element !== null && element.key != null) {\n    // Explicit key\n    if (__DEV__) {\n      checkKeyStringCoercion(element.key);\n    }\n    return escape('' + element.key);\n  }\n  // Implicit key determined by the index in the set\n  return index.toString(36);\n}\n\nfunction mapIntoArray(\n  children: ?ReactNodeList,\n  array: Array<React$Node>,\n  escapedPrefix: string,\n  nameSoFar: string,\n  callback: (?React$Node) => ?ReactNodeList,\n): number {\n  const type = typeof children;\n\n  if (type === 'undefined' || type === 'boolean') {\n    // All of the above are perceived as null.\n    children = null;\n  }\n\n  let invokeCallback = false;\n\n  if (children === null) {\n    invokeCallback = true;\n  } else {\n    switch (type) {\n      case 'string':\n      case 'number':\n        invokeCallback = true;\n        break;\n      case 'object':\n        switch ((children: any).$$typeof) {\n          case REACT_ELEMENT_TYPE:\n          case REACT_PORTAL_TYPE:\n            invokeCallback = true;\n        }\n    }\n  }\n\n  if (invokeCallback) {\n    const child = children;\n    let mappedChild = callback(child);\n    // If it's the only child, treat the name as if it was wrapped in an array\n    // so that it's consistent if the number of children grows:\n    const childKey =\n      nameSoFar === '' ? SEPARATOR + getElementKey(child, 0) : nameSoFar;\n    if (isArray(mappedChild)) {\n      let escapedChildKey = '';\n      if (childKey != null) {\n        escapedChildKey = escapeUserProvidedKey(childKey) + '/';\n      }\n      mapIntoArray(mappedChild, array, escapedChildKey, '', c => c);\n    } else if (mappedChild != null) {\n      if (isValidElement(mappedChild)) {\n        if (__DEV__) {\n          // The `if` statement here prevents auto-disabling of the safe\n          // coercion ESLint rule, so we must manually disable it below.\n          // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key\n          if (mappedChild.key && (!child || child.key !== mappedChild.key)) {\n            checkKeyStringCoercion(mappedChild.key);\n          }\n        }\n        mappedChild = cloneAndReplaceKey(\n          mappedChild,\n          // Keep both the (mapped) and old keys if they differ, just as\n          // traverseAllChildren used to do for objects as children\n          escapedPrefix +\n            // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key\n            (mappedChild.key && (!child || child.key !== mappedChild.key)\n              ? // $FlowFixMe Flow incorrectly thinks existing element's key can be a number\n                // eslint-disable-next-line react-internal/safe-string-coercion\n                escapeUserProvidedKey('' + mappedChild.key) + '/'\n              : '') +\n            childKey,\n        );\n      }\n      array.push(mappedChild);\n    }\n    return 1;\n  }\n\n  let child;\n  let nextName;\n  let subtreeCount = 0; // Count of children found in the current subtree.\n  const nextNamePrefix =\n    nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;\n\n  if (isArray(children)) {\n    for (let i = 0; i < children.length; i++) {\n      child = children[i];\n      nextName = nextNamePrefix + getElementKey(child, i);\n      subtreeCount += mapIntoArray(\n        child,\n        array,\n        escapedPrefix,\n        nextName,\n        callback,\n      );\n    }\n  } else {\n    const iteratorFn = getIteratorFn(children);\n    if (typeof iteratorFn === 'function') {\n      const iterableChildren: Iterable<React$Node> & {\n        entries: any,\n      } = (children: any);\n\n      if (__DEV__) {\n        // Warn about using Maps as children\n        if (iteratorFn === iterableChildren.entries) {\n          if (!didWarnAboutMaps) {\n            console.warn(\n              'Using Maps as children is not supported. ' +\n                'Use an array of keyed ReactElements instead.',\n            );\n          }\n          didWarnAboutMaps = true;\n        }\n      }\n\n      const iterator = iteratorFn.call(iterableChildren);\n      let step;\n      let ii = 0;\n      while (!(step = iterator.next()).done) {\n        child = step.value;\n        nextName = nextNamePrefix + getElementKey(child, ii++);\n        subtreeCount += mapIntoArray(\n          child,\n          array,\n          escapedPrefix,\n          nextName,\n          callback,\n        );\n      }\n    } else if (type === 'object') {\n      // eslint-disable-next-line react-internal/safe-string-coercion\n      const childrenString = String((children: any));\n\n      throw new Error(\n        `Objects are not valid as a React child (found: ${\n          childrenString === '[object Object]'\n            ? 'object with keys {' +\n              Object.keys((children: any)).join(', ') +\n              '}'\n            : childrenString\n        }). ` +\n          'If you meant to render a collection of children, use an array ' +\n          'instead.',\n      );\n    }\n  }\n\n  return subtreeCount;\n}\n\ntype MapFunc = (child: ?React$Node) => ?ReactNodeList;\n\n/**\n * Maps children that are typically specified as `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrenmap\n *\n * The provided mapFunction(child, index) will be called for each\n * leaf child.\n *\n * @param {?*} children Children tree container.\n * @param {function(*, int)} func The map function.\n * @param {*} context Context for mapFunction.\n * @return {object} Object containing the ordered map of results.\n */\nfunction mapChildren(\n  children: ?ReactNodeList,\n  func: MapFunc,\n  context: mixed,\n): ?Array<React$Node> {\n  if (children == null) {\n    return children;\n  }\n  const result = [];\n  let count = 0;\n  mapIntoArray(children, result, '', '', function(child) {\n    return func.call(context, child, count++);\n  });\n  return result;\n}\n\n/**\n * Count the number of children that are typically specified as\n * `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrencount\n *\n * @param {?*} children Children tree container.\n * @return {number} The number of children.\n */\nfunction countChildren(children: ?ReactNodeList): number {\n  let n = 0;\n  mapChildren(children, () => {\n    n++;\n    // Don't return anything\n  });\n  return n;\n}\n\ntype ForEachFunc = (child: ?React$Node) => void;\n\n/**\n * Iterates through children that are typically specified as `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrenforeach\n *\n * The provided forEachFunc(child, index) will be called for each\n * leaf child.\n *\n * @param {?*} children Children tree container.\n * @param {function(*, int)} forEachFunc\n * @param {*} forEachContext Context for forEachContext.\n */\nfunction forEachChildren(\n  children: ?ReactNodeList,\n  forEachFunc: ForEachFunc,\n  forEachContext: mixed,\n): void {\n  mapChildren(\n    children,\n    function() {\n      forEachFunc.apply(this, arguments);\n      // Don't return anything.\n    },\n    forEachContext,\n  );\n}\n\n/**\n * Flatten a children object (typically specified as `props.children`) and\n * return an array with appropriately re-keyed children.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrentoarray\n */\nfunction toArray(children: ?ReactNodeList): Array<React$Node> {\n  return mapChildren(children, child => child) || [];\n}\n\n/**\n * Returns the first child in a collection of children and verifies that there\n * is only one child in the collection.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrenonly\n *\n * The current implementation of this function assumes that a single child gets\n * passed without a wrapper, but the purpose of this helper function is to\n * abstract away the particular structure of children.\n *\n * @param {?object} children Child collection structure.\n * @return {ReactElement} The first and only `ReactElement` contained in the\n * structure.\n */\nfunction onlyChild<T>(children: T): T {\n  if (!isValidElement(children)) {\n    throw new Error(\n      'React.Children.only expected to receive a single React element child.',\n    );\n  }\n\n  return children;\n}\n\nexport {\n  forEachChildren as forEach,\n  mapChildren as map,\n  countChildren as count,\n  onlyChild as only,\n  toArray,\n};\n"]},"metadata":{},"sourceType":"module"}