{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { canUseDOM } from 'shared/ExecutionEnvironment';\nimport { registerTwoPhaseEvent } from '../EventRegistry';\nimport { getData as FallbackCompositionStateGetData, initialize as FallbackCompositionStateInitialize, reset as FallbackCompositionStateReset } from '../FallbackCompositionState';\nimport { SyntheticCompositionEvent, SyntheticInputEvent } from '../SyntheticEvent';\nimport { accumulateTwoPhaseListeners } from '../DOMPluginEventSystem';\nconst END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space\n\nconst START_KEYCODE = 229;\nconst canUseCompositionEvent = canUseDOM && 'CompositionEvent' in window;\nlet documentMode = null;\n\nif (canUseDOM && 'documentMode' in document) {\n  documentMode = document.documentMode;\n} // Webkit offers a very useful `textInput` event that can be used to\n// directly represent `beforeInput`. The IE `textinput` event is not as\n// useful, so we don't use it.\n\n\nconst canUseTextInputEvent = canUseDOM && 'TextEvent' in window && !documentMode; // In IE9+, we have access to composition events, but the data supplied\n// by the native compositionend event may be incorrect. Japanese ideographic\n// spaces, for instance (\\u3000) are not recorded correctly.\n\nconst useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);\nconst SPACEBAR_CODE = 32;\nconst SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);\n_c = SPACEBAR_CHAR;\n\nfunction registerEvents() {\n  registerTwoPhaseEvent('onBeforeInput', ['compositionend', 'keypress', 'textInput', 'paste']);\n  registerTwoPhaseEvent('onCompositionEnd', ['compositionend', 'focusout', 'keydown', 'keypress', 'keyup', 'mousedown']);\n  registerTwoPhaseEvent('onCompositionStart', ['compositionstart', 'focusout', 'keydown', 'keypress', 'keyup', 'mousedown']);\n  registerTwoPhaseEvent('onCompositionUpdate', ['compositionupdate', 'focusout', 'keydown', 'keypress', 'keyup', 'mousedown']);\n} // Track whether we've ever handled a keypress on the space key.\n\n\nlet hasSpaceKeypress = false;\n/**\n * Return whether a native keypress event is assumed to be a command.\n * This is required because Firefox fires `keypress` events for key commands\n * (cut, copy, select-all, etc.) even though no character is inserted.\n */\n\nfunction isKeypressCommand(nativeEvent) {\n  return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) && // ctrlKey && altKey is equivalent to AltGr, and is not a command.\n  !(nativeEvent.ctrlKey && nativeEvent.altKey);\n}\n/**\n * Translate native top level events into event types.\n */\n\n\nfunction getCompositionEventType(domEventName) {\n  switch (domEventName) {\n    case 'compositionstart':\n      return 'onCompositionStart';\n\n    case 'compositionend':\n      return 'onCompositionEnd';\n\n    case 'compositionupdate':\n      return 'onCompositionUpdate';\n  }\n}\n/**\n * Does our fallback best-guess model think this event signifies that\n * composition has begun?\n */\n\n\nfunction isFallbackCompositionStart(domEventName, nativeEvent) {\n  return domEventName === 'keydown' && nativeEvent.keyCode === START_KEYCODE;\n}\n/**\n * Does our fallback mode think that this event is the end of composition?\n */\n\n\nfunction isFallbackCompositionEnd(domEventName, nativeEvent) {\n  switch (domEventName) {\n    case 'keyup':\n      // Command keys insert or clear IME input.\n      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;\n\n    case 'keydown':\n      // Expect IME keyCode on each keydown. If we get any other\n      // code we must have exited earlier.\n      return nativeEvent.keyCode !== START_KEYCODE;\n\n    case 'keypress':\n    case 'mousedown':\n    case 'focusout':\n      // Events are not possible without cancelling IME.\n      return true;\n\n    default:\n      return false;\n  }\n}\n/**\n * Google Input Tools provides composition data via a CustomEvent,\n * with the `data` property populated in the `detail` object. If this\n * is available on the event object, use it. If not, this is a plain\n * composition event and we have nothing special to extract.\n *\n * @param {object} nativeEvent\n * @return {?string}\n */\n\n\nfunction getDataFromCustomEvent(nativeEvent) {\n  const detail = nativeEvent.detail;\n\n  if (typeof detail === 'object' && 'data' in detail) {\n    return detail.data;\n  }\n\n  return null;\n}\n/**\n * Check if a composition event was triggered by Korean IME.\n * Our fallback mode does not work well with IE's Korean IME,\n * so just use native composition events when Korean IME is used.\n * Although CompositionEvent.locale property is deprecated,\n * it is available in IE, where our fallback mode is enabled.\n *\n * @param {object} nativeEvent\n * @return {boolean}\n */\n\n\nfunction isUsingKoreanIME(nativeEvent) {\n  return nativeEvent.locale === 'ko';\n} // Track the current IME composition status, if any.\n\n\nlet isComposing = false;\n/**\n * @return {?object} A SyntheticCompositionEvent.\n */\n\nfunction extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {\n  let eventType;\n  let fallbackData;\n\n  if (canUseCompositionEvent) {\n    eventType = getCompositionEventType(domEventName);\n  } else if (!isComposing) {\n    if (isFallbackCompositionStart(domEventName, nativeEvent)) {\n      eventType = 'onCompositionStart';\n    }\n  } else if (isFallbackCompositionEnd(domEventName, nativeEvent)) {\n    eventType = 'onCompositionEnd';\n  }\n\n  if (!eventType) {\n    return null;\n  }\n\n  if (useFallbackCompositionData && !isUsingKoreanIME(nativeEvent)) {\n    // The current composition is stored statically and must not be\n    // overwritten while composition continues.\n    if (!isComposing && eventType === 'onCompositionStart') {\n      isComposing = FallbackCompositionStateInitialize(nativeEventTarget);\n    } else if (eventType === 'onCompositionEnd') {\n      if (isComposing) {\n        fallbackData = FallbackCompositionStateGetData();\n      }\n    }\n  }\n\n  const listeners = accumulateTwoPhaseListeners(targetInst, eventType);\n\n  if (listeners.length > 0) {\n    const event = new SyntheticCompositionEvent(eventType, domEventName, null, nativeEvent, nativeEventTarget);\n    dispatchQueue.push({\n      event,\n      listeners\n    });\n\n    if (fallbackData) {\n      // Inject data generated from fallback path into the synthetic event.\n      // This matches the property of native CompositionEventInterface.\n      event.data = fallbackData;\n    } else {\n      const customData = getDataFromCustomEvent(nativeEvent);\n\n      if (customData !== null) {\n        event.data = customData;\n      }\n    }\n  }\n}\n\nfunction getNativeBeforeInputChars(domEventName, nativeEvent) {\n  switch (domEventName) {\n    case 'compositionend':\n      return getDataFromCustomEvent(nativeEvent);\n\n    case 'keypress':\n      /**\n       * If native `textInput` events are available, our goal is to make\n       * use of them. However, there is a special case: the spacebar key.\n       * In Webkit, preventing default on a spacebar `textInput` event\n       * cancels character insertion, but it *also* causes the browser\n       * to fall back to its default spacebar behavior of scrolling the\n       * page.\n       *\n       * Tracking at:\n       * https://code.google.com/p/chromium/issues/detail?id=355103\n       *\n       * To avoid this issue, use the keypress event as if no `textInput`\n       * event is available.\n       */\n      const which = nativeEvent.which;\n\n      if (which !== SPACEBAR_CODE) {\n        return null;\n      }\n\n      hasSpaceKeypress = true;\n      return SPACEBAR_CHAR;\n\n    case 'textInput':\n      // Record the characters to be added to the DOM.\n      const chars = nativeEvent.data; // If it's a spacebar character, assume that we have already handled\n      // it at the keypress level and bail immediately. Android Chrome\n      // doesn't give us keycodes, so we need to ignore it.\n\n      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {\n        return null;\n      }\n\n      return chars;\n\n    default:\n      // For other native event types, do nothing.\n      return null;\n  }\n}\n/**\n * For browsers that do not provide the `textInput` event, extract the\n * appropriate string to use for SyntheticInputEvent.\n */\n\n\nfunction getFallbackBeforeInputChars(domEventName, nativeEvent) {\n  // If we are currently composing (IME) and using a fallback to do so,\n  // try to extract the composed characters from the fallback object.\n  // If composition event is available, we extract a string only at\n  // compositionevent, otherwise extract it at fallback events.\n  if (isComposing) {\n    if (domEventName === 'compositionend' || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent)) {\n      const chars = FallbackCompositionStateGetData();\n      FallbackCompositionStateReset();\n      isComposing = false;\n      return chars;\n    }\n\n    return null;\n  }\n\n  switch (domEventName) {\n    case 'paste':\n      // If a paste event occurs after a keypress, throw out the input\n      // chars. Paste events should not lead to BeforeInput events.\n      return null;\n\n    case 'keypress':\n      /**\n       * As of v27, Firefox may fire keypress events even when no character\n       * will be inserted. A few possibilities:\n       *\n       * - `which` is `0`. Arrow keys, Esc key, etc.\n       *\n       * - `which` is the pressed key code, but no char is available.\n       *   Ex: 'AltGr + d` in Polish. There is no modified character for\n       *   this key combination and no character is inserted into the\n       *   document, but FF fires the keypress for char code `100` anyway.\n       *   No `input` event will occur.\n       *\n       * - `which` is the pressed key code, but a command combination is\n       *   being used. Ex: `Cmd+C`. No character is inserted, and no\n       *   `input` event will occur.\n       */\n      if (!isKeypressCommand(nativeEvent)) {\n        // IE fires the `keypress` event when a user types an emoji via\n        // Touch keyboard of Windows.  In such a case, the `char` property\n        // holds an emoji character like `\\uD83D\\uDE0A`.  Because its length\n        // is 2, the property `which` does not represent an emoji correctly.\n        // In such a case, we directly return the `char` property instead of\n        // using `which`.\n        if (nativeEvent.char && nativeEvent.char.length > 1) {\n          return nativeEvent.char;\n        } else if (nativeEvent.which) {\n          return String.fromCharCode(nativeEvent.which);\n        }\n      }\n\n      return null;\n\n    case 'compositionend':\n      return useFallbackCompositionData && !isUsingKoreanIME(nativeEvent) ? null : nativeEvent.data;\n\n    default:\n      return null;\n  }\n}\n/**\n * Extract a SyntheticInputEvent for `beforeInput`, based on either native\n * `textInput` or fallback behavior.\n *\n * @return {?object} A SyntheticInputEvent.\n */\n\n\nfunction extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {\n  let chars;\n\n  if (canUseTextInputEvent) {\n    chars = getNativeBeforeInputChars(domEventName, nativeEvent);\n  } else {\n    chars = getFallbackBeforeInputChars(domEventName, nativeEvent);\n  } // If no characters are being inserted, no BeforeInput event should\n  // be fired.\n\n\n  if (!chars) {\n    return null;\n  }\n\n  const listeners = accumulateTwoPhaseListeners(targetInst, 'onBeforeInput');\n\n  if (listeners.length > 0) {\n    const event = new SyntheticInputEvent('onBeforeInput', 'beforeinput', null, nativeEvent, nativeEventTarget);\n    dispatchQueue.push({\n      event,\n      listeners\n    });\n    event.data = chars;\n  }\n}\n/**\n * Create an `onBeforeInput` event to match\n * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.\n *\n * This event plugin is based on the native `textInput` event\n * available in Chrome, Safari, Opera, and IE. This event fires after\n * `onKeyPress` and `onCompositionEnd`, but before `onInput`.\n *\n * `beforeInput` is spec'd but not implemented in any browsers, and\n * the `input` event does not provide any useful information about what has\n * actually been added, contrary to the spec. Thus, `textInput` is the best\n * available event to identify the characters that have actually been inserted\n * into the target node.\n *\n * This plugin is also responsible for emitting `composition` events, thus\n * allowing us to share composition fallback code for both `beforeInput` and\n * `composition` event types.\n */\n\n\nfunction extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {\n  extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);\n  extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);\n}\n\nexport { registerEvents, extractEvents };\n\nvar _c;\n\n$RefreshReg$(_c, \"SPACEBAR_CHAR\");","map":{"version":3,"sources":["/Users/zhangshuo/git/react-source-test/src/react/packages/react-dom/src/events/plugins/BeforeInputEventPlugin.js"],"names":["canUseDOM","registerTwoPhaseEvent","getData","FallbackCompositionStateGetData","initialize","FallbackCompositionStateInitialize","reset","FallbackCompositionStateReset","SyntheticCompositionEvent","SyntheticInputEvent","accumulateTwoPhaseListeners","END_KEYCODES","START_KEYCODE","canUseCompositionEvent","window","documentMode","document","canUseTextInputEvent","useFallbackCompositionData","SPACEBAR_CODE","SPACEBAR_CHAR","String","fromCharCode","registerEvents","hasSpaceKeypress","isKeypressCommand","nativeEvent","ctrlKey","altKey","metaKey","getCompositionEventType","domEventName","isFallbackCompositionStart","keyCode","isFallbackCompositionEnd","indexOf","getDataFromCustomEvent","detail","data","isUsingKoreanIME","locale","isComposing","extractCompositionEvent","dispatchQueue","targetInst","nativeEventTarget","eventType","fallbackData","listeners","length","event","push","customData","getNativeBeforeInputChars","which","chars","getFallbackBeforeInputChars","char","extractBeforeInputEvent","extractEvents","eventSystemFlags","targetContainer"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {DOMEventName} from '../../events/DOMEventNames';\nimport type {Fiber} from 'react-reconciler/src/ReactInternalTypes';\nimport type {AnyNativeEvent} from '../../events/PluginModuleType';\nimport type {DispatchQueue} from '../DOMPluginEventSystem';\nimport type {EventSystemFlags} from '../EventSystemFlags';\n\nimport {canUseDOM} from 'shared/ExecutionEnvironment';\n\nimport {registerTwoPhaseEvent} from '../EventRegistry';\nimport {\n  getData as FallbackCompositionStateGetData,\n  initialize as FallbackCompositionStateInitialize,\n  reset as FallbackCompositionStateReset,\n} from '../FallbackCompositionState';\nimport {\n  SyntheticCompositionEvent,\n  SyntheticInputEvent,\n} from '../SyntheticEvent';\nimport {accumulateTwoPhaseListeners} from '../DOMPluginEventSystem';\n\nconst END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space\nconst START_KEYCODE = 229;\n\nconst canUseCompositionEvent = canUseDOM && 'CompositionEvent' in window;\n\nlet documentMode = null;\nif (canUseDOM && 'documentMode' in document) {\n  documentMode = document.documentMode;\n}\n\n// Webkit offers a very useful `textInput` event that can be used to\n// directly represent `beforeInput`. The IE `textinput` event is not as\n// useful, so we don't use it.\nconst canUseTextInputEvent =\n  canUseDOM && 'TextEvent' in window && !documentMode;\n\n// In IE9+, we have access to composition events, but the data supplied\n// by the native compositionend event may be incorrect. Japanese ideographic\n// spaces, for instance (\\u3000) are not recorded correctly.\nconst useFallbackCompositionData =\n  canUseDOM &&\n  (!canUseCompositionEvent ||\n    (documentMode && documentMode > 8 && documentMode <= 11));\n\nconst SPACEBAR_CODE = 32;\nconst SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);\n\nfunction registerEvents() {\n  registerTwoPhaseEvent('onBeforeInput', [\n    'compositionend',\n    'keypress',\n    'textInput',\n    'paste',\n  ]);\n  registerTwoPhaseEvent('onCompositionEnd', [\n    'compositionend',\n    'focusout',\n    'keydown',\n    'keypress',\n    'keyup',\n    'mousedown',\n  ]);\n  registerTwoPhaseEvent('onCompositionStart', [\n    'compositionstart',\n    'focusout',\n    'keydown',\n    'keypress',\n    'keyup',\n    'mousedown',\n  ]);\n  registerTwoPhaseEvent('onCompositionUpdate', [\n    'compositionupdate',\n    'focusout',\n    'keydown',\n    'keypress',\n    'keyup',\n    'mousedown',\n  ]);\n}\n\n// Track whether we've ever handled a keypress on the space key.\nlet hasSpaceKeypress = false;\n\n/**\n * Return whether a native keypress event is assumed to be a command.\n * This is required because Firefox fires `keypress` events for key commands\n * (cut, copy, select-all, etc.) even though no character is inserted.\n */\nfunction isKeypressCommand(nativeEvent: any) {\n  return (\n    (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&\n    // ctrlKey && altKey is equivalent to AltGr, and is not a command.\n    !(nativeEvent.ctrlKey && nativeEvent.altKey)\n  );\n}\n\n/**\n * Translate native top level events into event types.\n */\nfunction getCompositionEventType(domEventName: DOMEventName) {\n  switch (domEventName) {\n    case 'compositionstart':\n      return 'onCompositionStart';\n    case 'compositionend':\n      return 'onCompositionEnd';\n    case 'compositionupdate':\n      return 'onCompositionUpdate';\n  }\n}\n\n/**\n * Does our fallback best-guess model think this event signifies that\n * composition has begun?\n */\nfunction isFallbackCompositionStart(\n  domEventName: DOMEventName,\n  nativeEvent: any,\n): boolean {\n  return domEventName === 'keydown' && nativeEvent.keyCode === START_KEYCODE;\n}\n\n/**\n * Does our fallback mode think that this event is the end of composition?\n */\nfunction isFallbackCompositionEnd(\n  domEventName: DOMEventName,\n  nativeEvent: any,\n): boolean {\n  switch (domEventName) {\n    case 'keyup':\n      // Command keys insert or clear IME input.\n      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;\n    case 'keydown':\n      // Expect IME keyCode on each keydown. If we get any other\n      // code we must have exited earlier.\n      return nativeEvent.keyCode !== START_KEYCODE;\n    case 'keypress':\n    case 'mousedown':\n    case 'focusout':\n      // Events are not possible without cancelling IME.\n      return true;\n    default:\n      return false;\n  }\n}\n\n/**\n * Google Input Tools provides composition data via a CustomEvent,\n * with the `data` property populated in the `detail` object. If this\n * is available on the event object, use it. If not, this is a plain\n * composition event and we have nothing special to extract.\n *\n * @param {object} nativeEvent\n * @return {?string}\n */\nfunction getDataFromCustomEvent(nativeEvent: any) {\n  const detail = nativeEvent.detail;\n  if (typeof detail === 'object' && 'data' in detail) {\n    return detail.data;\n  }\n  return null;\n}\n\n/**\n * Check if a composition event was triggered by Korean IME.\n * Our fallback mode does not work well with IE's Korean IME,\n * so just use native composition events when Korean IME is used.\n * Although CompositionEvent.locale property is deprecated,\n * it is available in IE, where our fallback mode is enabled.\n *\n * @param {object} nativeEvent\n * @return {boolean}\n */\nfunction isUsingKoreanIME(nativeEvent: any) {\n  return nativeEvent.locale === 'ko';\n}\n\n// Track the current IME composition status, if any.\nlet isComposing = false;\n\n/**\n * @return {?object} A SyntheticCompositionEvent.\n */\nfunction extractCompositionEvent(\n  dispatchQueue,\n  domEventName,\n  targetInst,\n  nativeEvent,\n  nativeEventTarget,\n) {\n  let eventType;\n  let fallbackData;\n\n  if (canUseCompositionEvent) {\n    eventType = getCompositionEventType(domEventName);\n  } else if (!isComposing) {\n    if (isFallbackCompositionStart(domEventName, nativeEvent)) {\n      eventType = 'onCompositionStart';\n    }\n  } else if (isFallbackCompositionEnd(domEventName, nativeEvent)) {\n    eventType = 'onCompositionEnd';\n  }\n\n  if (!eventType) {\n    return null;\n  }\n\n  if (useFallbackCompositionData && !isUsingKoreanIME(nativeEvent)) {\n    // The current composition is stored statically and must not be\n    // overwritten while composition continues.\n    if (!isComposing && eventType === 'onCompositionStart') {\n      isComposing = FallbackCompositionStateInitialize(nativeEventTarget);\n    } else if (eventType === 'onCompositionEnd') {\n      if (isComposing) {\n        fallbackData = FallbackCompositionStateGetData();\n      }\n    }\n  }\n\n  const listeners = accumulateTwoPhaseListeners(targetInst, eventType);\n  if (listeners.length > 0) {\n    const event = new SyntheticCompositionEvent(\n      eventType,\n      domEventName,\n      null,\n      nativeEvent,\n      nativeEventTarget,\n    );\n    dispatchQueue.push({event, listeners});\n    if (fallbackData) {\n      // Inject data generated from fallback path into the synthetic event.\n      // This matches the property of native CompositionEventInterface.\n      event.data = fallbackData;\n    } else {\n      const customData = getDataFromCustomEvent(nativeEvent);\n      if (customData !== null) {\n        event.data = customData;\n      }\n    }\n  }\n}\n\nfunction getNativeBeforeInputChars(\n  domEventName: DOMEventName,\n  nativeEvent: any,\n): ?string {\n  switch (domEventName) {\n    case 'compositionend':\n      return getDataFromCustomEvent(nativeEvent);\n    case 'keypress':\n      /**\n       * If native `textInput` events are available, our goal is to make\n       * use of them. However, there is a special case: the spacebar key.\n       * In Webkit, preventing default on a spacebar `textInput` event\n       * cancels character insertion, but it *also* causes the browser\n       * to fall back to its default spacebar behavior of scrolling the\n       * page.\n       *\n       * Tracking at:\n       * https://code.google.com/p/chromium/issues/detail?id=355103\n       *\n       * To avoid this issue, use the keypress event as if no `textInput`\n       * event is available.\n       */\n      const which = nativeEvent.which;\n      if (which !== SPACEBAR_CODE) {\n        return null;\n      }\n\n      hasSpaceKeypress = true;\n      return SPACEBAR_CHAR;\n\n    case 'textInput':\n      // Record the characters to be added to the DOM.\n      const chars = nativeEvent.data;\n\n      // If it's a spacebar character, assume that we have already handled\n      // it at the keypress level and bail immediately. Android Chrome\n      // doesn't give us keycodes, so we need to ignore it.\n      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {\n        return null;\n      }\n\n      return chars;\n\n    default:\n      // For other native event types, do nothing.\n      return null;\n  }\n}\n\n/**\n * For browsers that do not provide the `textInput` event, extract the\n * appropriate string to use for SyntheticInputEvent.\n */\nfunction getFallbackBeforeInputChars(\n  domEventName: DOMEventName,\n  nativeEvent: any,\n): ?string {\n  // If we are currently composing (IME) and using a fallback to do so,\n  // try to extract the composed characters from the fallback object.\n  // If composition event is available, we extract a string only at\n  // compositionevent, otherwise extract it at fallback events.\n  if (isComposing) {\n    if (\n      domEventName === 'compositionend' ||\n      (!canUseCompositionEvent &&\n        isFallbackCompositionEnd(domEventName, nativeEvent))\n    ) {\n      const chars = FallbackCompositionStateGetData();\n      FallbackCompositionStateReset();\n      isComposing = false;\n      return chars;\n    }\n    return null;\n  }\n\n  switch (domEventName) {\n    case 'paste':\n      // If a paste event occurs after a keypress, throw out the input\n      // chars. Paste events should not lead to BeforeInput events.\n      return null;\n    case 'keypress':\n      /**\n       * As of v27, Firefox may fire keypress events even when no character\n       * will be inserted. A few possibilities:\n       *\n       * - `which` is `0`. Arrow keys, Esc key, etc.\n       *\n       * - `which` is the pressed key code, but no char is available.\n       *   Ex: 'AltGr + d` in Polish. There is no modified character for\n       *   this key combination and no character is inserted into the\n       *   document, but FF fires the keypress for char code `100` anyway.\n       *   No `input` event will occur.\n       *\n       * - `which` is the pressed key code, but a command combination is\n       *   being used. Ex: `Cmd+C`. No character is inserted, and no\n       *   `input` event will occur.\n       */\n      if (!isKeypressCommand(nativeEvent)) {\n        // IE fires the `keypress` event when a user types an emoji via\n        // Touch keyboard of Windows.  In such a case, the `char` property\n        // holds an emoji character like `\\uD83D\\uDE0A`.  Because its length\n        // is 2, the property `which` does not represent an emoji correctly.\n        // In such a case, we directly return the `char` property instead of\n        // using `which`.\n        if (nativeEvent.char && nativeEvent.char.length > 1) {\n          return nativeEvent.char;\n        } else if (nativeEvent.which) {\n          return String.fromCharCode(nativeEvent.which);\n        }\n      }\n      return null;\n    case 'compositionend':\n      return useFallbackCompositionData && !isUsingKoreanIME(nativeEvent)\n        ? null\n        : nativeEvent.data;\n    default:\n      return null;\n  }\n}\n\n/**\n * Extract a SyntheticInputEvent for `beforeInput`, based on either native\n * `textInput` or fallback behavior.\n *\n * @return {?object} A SyntheticInputEvent.\n */\nfunction extractBeforeInputEvent(\n  dispatchQueue,\n  domEventName,\n  targetInst,\n  nativeEvent,\n  nativeEventTarget,\n) {\n  let chars;\n\n  if (canUseTextInputEvent) {\n    chars = getNativeBeforeInputChars(domEventName, nativeEvent);\n  } else {\n    chars = getFallbackBeforeInputChars(domEventName, nativeEvent);\n  }\n\n  // If no characters are being inserted, no BeforeInput event should\n  // be fired.\n  if (!chars) {\n    return null;\n  }\n\n  const listeners = accumulateTwoPhaseListeners(targetInst, 'onBeforeInput');\n  if (listeners.length > 0) {\n    const event = new SyntheticInputEvent(\n      'onBeforeInput',\n      'beforeinput',\n      null,\n      nativeEvent,\n      nativeEventTarget,\n    );\n    dispatchQueue.push({event, listeners});\n    event.data = chars;\n  }\n}\n\n/**\n * Create an `onBeforeInput` event to match\n * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.\n *\n * This event plugin is based on the native `textInput` event\n * available in Chrome, Safari, Opera, and IE. This event fires after\n * `onKeyPress` and `onCompositionEnd`, but before `onInput`.\n *\n * `beforeInput` is spec'd but not implemented in any browsers, and\n * the `input` event does not provide any useful information about what has\n * actually been added, contrary to the spec. Thus, `textInput` is the best\n * available event to identify the characters that have actually been inserted\n * into the target node.\n *\n * This plugin is also responsible for emitting `composition` events, thus\n * allowing us to share composition fallback code for both `beforeInput` and\n * `composition` event types.\n */\nfunction extractEvents(\n  dispatchQueue: DispatchQueue,\n  domEventName: DOMEventName,\n  targetInst: null | Fiber,\n  nativeEvent: AnyNativeEvent,\n  nativeEventTarget: null | EventTarget,\n  eventSystemFlags: EventSystemFlags,\n  targetContainer: EventTarget,\n): void {\n  extractCompositionEvent(\n    dispatchQueue,\n    domEventName,\n    targetInst,\n    nativeEvent,\n    nativeEventTarget,\n  );\n  extractBeforeInputEvent(\n    dispatchQueue,\n    domEventName,\n    targetInst,\n    nativeEvent,\n    nativeEventTarget,\n  );\n}\n\nexport {registerEvents, extractEvents};\n"]},"metadata":{},"sourceType":"module"}