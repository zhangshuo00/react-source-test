{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { SuspenseComponent, SuspenseListComponent } from './ReactWorkTags';\nimport { NoFlags, DidCapture } from './ReactFiberFlags';\nimport { isSuspenseInstancePending, isSuspenseInstanceFallback } from './ReactFiberHostConfig';\nexport function shouldCaptureSuspense(workInProgress, hasInvisibleParent) {\n  // If it was the primary children that just suspended, capture and render the\n  // fallback. Otherwise, don't capture and bubble to the next boundary.\n  const nextState = workInProgress.memoizedState;\n\n  if (nextState !== null) {\n    if (nextState.dehydrated !== null) {\n      // A dehydrated boundary always captures.\n      return true;\n    }\n\n    return false;\n  }\n\n  const props = workInProgress.memoizedProps; // Regular boundaries always capture.\n\n  if (props.unstable_avoidThisFallback !== true) {\n    return true;\n  } // If it's a boundary we should avoid, then we prefer to bubble up to the\n  // parent boundary if it is currently invisible.\n\n\n  if (hasInvisibleParent) {\n    return false;\n  } // If the parent is not able to handle it, we must handle it.\n\n\n  return true;\n}\nexport function findFirstSuspended(row) {\n  let node = row;\n\n  while (node !== null) {\n    if (node.tag === SuspenseComponent) {\n      const state = node.memoizedState;\n\n      if (state !== null) {\n        const dehydrated = state.dehydrated;\n\n        if (dehydrated === null || isSuspenseInstancePending(dehydrated) || isSuspenseInstanceFallback(dehydrated)) {\n          return node;\n        }\n      }\n    } else if (node.tag === SuspenseListComponent && // revealOrder undefined can't be trusted because it don't\n    // keep track of whether it suspended or not.\n    node.memoizedProps.revealOrder !== undefined) {\n      const didSuspend = (node.flags & DidCapture) !== NoFlags;\n\n      if (didSuspend) {\n        return node;\n      }\n    } else if (node.child !== null) {\n      node.child.return = node;\n      node = node.child;\n      continue;\n    }\n\n    if (node === row) {\n      return null;\n    }\n\n    while (node.sibling === null) {\n      if (node.return === null || node.return === row) {\n        return null;\n      }\n\n      node = node.return;\n    }\n\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n\n  return null;\n}","map":{"version":3,"sources":["/Users/zhangshuo/git/react-source-test/src/react/packages/react-reconciler/src/ReactFiberSuspenseComponent.new.js"],"names":["SuspenseComponent","SuspenseListComponent","NoFlags","DidCapture","isSuspenseInstancePending","isSuspenseInstanceFallback","shouldCaptureSuspense","workInProgress","hasInvisibleParent","nextState","memoizedState","dehydrated","props","memoizedProps","unstable_avoidThisFallback","findFirstSuspended","row","node","tag","state","revealOrder","undefined","didSuspend","flags","child","return","sibling"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA,SAAQA,iBAAR,EAA2BC,qBAA3B,QAAuD,iBAAvD;AACA,SAAQC,OAAR,EAAiBC,UAAjB,QAAkC,mBAAlC;AACA,SACEC,yBADF,EAEEC,0BAFF,QAGO,wBAHP;AAkDA,OAAO,SAASC,qBAAT,CACLC,cADK,EAELC,kBAFK,EAGI;AACT;AACA;AACA,QAAMC,SAA+B,GAAGF,cAAc,CAACG,aAAvD;;AACA,MAAID,SAAS,KAAK,IAAlB,EAAwB;AACtB,QAAIA,SAAS,CAACE,UAAV,KAAyB,IAA7B,EAAmC;AACjC;AACA,aAAO,IAAP;AACD;;AACD,WAAO,KAAP;AACD;;AACD,QAAMC,KAAK,GAAGL,cAAc,CAACM,aAA7B,CAXS,CAYT;;AACA,MAAID,KAAK,CAACE,0BAAN,KAAqC,IAAzC,EAA+C;AAC7C,WAAO,IAAP;AACD,GAfQ,CAgBT;AACA;;;AACA,MAAIN,kBAAJ,EAAwB;AACtB,WAAO,KAAP;AACD,GApBQ,CAqBT;;;AACA,SAAO,IAAP;AACD;AAED,OAAO,SAASO,kBAAT,CAA4BC,GAA5B,EAAsD;AAC3D,MAAIC,IAAI,GAAGD,GAAX;;AACA,SAAOC,IAAI,KAAK,IAAhB,EAAsB;AACpB,QAAIA,IAAI,CAACC,GAAL,KAAalB,iBAAjB,EAAoC;AAClC,YAAMmB,KAA2B,GAAGF,IAAI,CAACP,aAAzC;;AACA,UAAIS,KAAK,KAAK,IAAd,EAAoB;AAClB,cAAMR,UAAmC,GAAGQ,KAAK,CAACR,UAAlD;;AACA,YACEA,UAAU,KAAK,IAAf,IACAP,yBAAyB,CAACO,UAAD,CADzB,IAEAN,0BAA0B,CAACM,UAAD,CAH5B,EAIE;AACA,iBAAOM,IAAP;AACD;AACF;AACF,KAZD,MAYO,IACLA,IAAI,CAACC,GAAL,KAAajB,qBAAb,IACA;AACA;AACAgB,IAAAA,IAAI,CAACJ,aAAL,CAAmBO,WAAnB,KAAmCC,SAJ9B,EAKL;AACA,YAAMC,UAAU,GAAG,CAACL,IAAI,CAACM,KAAL,GAAapB,UAAd,MAA8BD,OAAjD;;AACA,UAAIoB,UAAJ,EAAgB;AACd,eAAOL,IAAP;AACD;AACF,KAVM,MAUA,IAAIA,IAAI,CAACO,KAAL,KAAe,IAAnB,EAAyB;AAC9BP,MAAAA,IAAI,CAACO,KAAL,CAAWC,MAAX,GAAoBR,IAApB;AACAA,MAAAA,IAAI,GAAGA,IAAI,CAACO,KAAZ;AACA;AACD;;AACD,QAAIP,IAAI,KAAKD,GAAb,EAAkB;AAChB,aAAO,IAAP;AACD;;AACD,WAAOC,IAAI,CAACS,OAAL,KAAiB,IAAxB,EAA8B;AAC5B,UAAIT,IAAI,CAACQ,MAAL,KAAgB,IAAhB,IAAwBR,IAAI,CAACQ,MAAL,KAAgBT,GAA5C,EAAiD;AAC/C,eAAO,IAAP;AACD;;AACDC,MAAAA,IAAI,GAAGA,IAAI,CAACQ,MAAZ;AACD;;AACDR,IAAAA,IAAI,CAACS,OAAL,CAAaD,MAAb,GAAsBR,IAAI,CAACQ,MAA3B;AACAR,IAAAA,IAAI,GAAGA,IAAI,CAACS,OAAZ;AACD;;AACD,SAAO,IAAP;AACD","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {ReactNodeList, Wakeable} from 'shared/ReactTypes';\nimport type {Fiber} from './ReactInternalTypes';\nimport type {SuspenseInstance} from './ReactFiberHostConfig';\nimport type {Lane} from './ReactFiberLane.new';\nimport type {TreeContext} from './ReactFiberTreeContext.new';\n\nimport {SuspenseComponent, SuspenseListComponent} from './ReactWorkTags';\nimport {NoFlags, DidCapture} from './ReactFiberFlags';\nimport {\n  isSuspenseInstancePending,\n  isSuspenseInstanceFallback,\n} from './ReactFiberHostConfig';\n\nexport type SuspenseProps = {|\n  children?: ReactNodeList,\n  fallback?: ReactNodeList,\n\n  // TODO: Add \"unstable_\" prefix?\n  suspenseCallback?: (Set<Wakeable> | null) => mixed,\n\n  unstable_expectedLoadTime?: number,\n|};\n\n// A null SuspenseState represents an unsuspended normal Suspense boundary.\n// A non-null SuspenseState means that it is blocked for one reason or another.\n// - A non-null dehydrated field means it's blocked pending hydration.\n//   - A non-null dehydrated field can use isSuspenseInstancePending or\n//     isSuspenseInstanceFallback to query the reason for being dehydrated.\n// - A null dehydrated field means it's blocked by something suspending and\n//   we're currently showing a fallback instead.\nexport type SuspenseState = {|\n  // If this boundary is still dehydrated, we store the SuspenseInstance\n  // here to indicate that it is dehydrated (flag) and for quick access\n  // to check things like isSuspenseInstancePending.\n  dehydrated: null | SuspenseInstance,\n  treeContext: null | TreeContext,\n  // Represents the lane we should attempt to hydrate a dehydrated boundary at.\n  // OffscreenLane is the default for dehydrated boundaries.\n  // NoLane is the default for normal boundaries, which turns into \"normal\" pri.\n  retryLane: Lane,\n|};\n\nexport type SuspenseListTailMode = 'collapsed' | 'hidden' | void;\n\nexport type SuspenseListRenderState = {|\n  isBackwards: boolean,\n  // The currently rendering tail row.\n  rendering: null | Fiber,\n  // The absolute time when we started rendering the most recent tail row.\n  renderingStartTime: number,\n  // The last of the already rendered children.\n  last: null | Fiber,\n  // Remaining rows on the tail of the list.\n  tail: null | Fiber,\n  // Tail insertions setting.\n  tailMode: SuspenseListTailMode,\n|};\n\nexport function shouldCaptureSuspense(\n  workInProgress: Fiber,\n  hasInvisibleParent: boolean,\n): boolean {\n  // If it was the primary children that just suspended, capture and render the\n  // fallback. Otherwise, don't capture and bubble to the next boundary.\n  const nextState: SuspenseState | null = workInProgress.memoizedState;\n  if (nextState !== null) {\n    if (nextState.dehydrated !== null) {\n      // A dehydrated boundary always captures.\n      return true;\n    }\n    return false;\n  }\n  const props = workInProgress.memoizedProps;\n  // Regular boundaries always capture.\n  if (props.unstable_avoidThisFallback !== true) {\n    return true;\n  }\n  // If it's a boundary we should avoid, then we prefer to bubble up to the\n  // parent boundary if it is currently invisible.\n  if (hasInvisibleParent) {\n    return false;\n  }\n  // If the parent is not able to handle it, we must handle it.\n  return true;\n}\n\nexport function findFirstSuspended(row: Fiber): null | Fiber {\n  let node = row;\n  while (node !== null) {\n    if (node.tag === SuspenseComponent) {\n      const state: SuspenseState | null = node.memoizedState;\n      if (state !== null) {\n        const dehydrated: null | SuspenseInstance = state.dehydrated;\n        if (\n          dehydrated === null ||\n          isSuspenseInstancePending(dehydrated) ||\n          isSuspenseInstanceFallback(dehydrated)\n        ) {\n          return node;\n        }\n      }\n    } else if (\n      node.tag === SuspenseListComponent &&\n      // revealOrder undefined can't be trusted because it don't\n      // keep track of whether it suspended or not.\n      node.memoizedProps.revealOrder !== undefined\n    ) {\n      const didSuspend = (node.flags & DidCapture) !== NoFlags;\n      if (didSuspend) {\n        return node;\n      }\n    } else if (node.child !== null) {\n      node.child.return = node;\n      node = node.child;\n      continue;\n    }\n    if (node === row) {\n      return null;\n    }\n    while (node.sibling === null) {\n      if (node.return === null || node.return === row) {\n        return null;\n      }\n      node = node.return;\n    }\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n  return null;\n}\n"]},"metadata":{},"sourceType":"module"}