{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport * as React from 'react';\nimport { LayoutStatic, MountLayoutDev, Update, Snapshot } from './ReactFiberFlags';\nimport { debugRenderPhaseSideEffectsForStrictMode, disableLegacyContext, enableDebugTracing, enableSchedulingProfiler, warnAboutDeprecatedLifecycles, enableStrictEffects, enableLazyContextPropagation, enableSuspenseLayoutEffectSemantics } from 'shared/ReactFeatureFlags';\nimport ReactStrictModeWarnings from './ReactStrictModeWarnings.old';\nimport { isMounted } from './ReactFiberTreeReflection';\nimport { get as getInstance, set as setInstance } from 'shared/ReactInstanceMap';\nimport shallowEqual from 'shared/shallowEqual';\nimport getComponentNameFromFiber from 'react-reconciler/src/getComponentNameFromFiber';\nimport getComponentNameFromType from 'shared/getComponentNameFromType';\nimport isArray from 'shared/isArray';\nimport { REACT_CONTEXT_TYPE, REACT_PROVIDER_TYPE } from 'shared/ReactSymbols';\nimport { setIsStrictModeForDevtools } from './ReactFiberDevToolsHook.old';\nimport { resolveDefaultProps } from './ReactFiberLazyComponent.old';\nimport { DebugTracingMode, NoMode, StrictLegacyMode, StrictEffectsMode } from './ReactTypeOfMode';\nimport { enqueueUpdate, entangleTransitions, processUpdateQueue, checkHasForceUpdateAfterProcessing, resetHasForceUpdateBeforeProcessing, createUpdate, ReplaceState, ForceUpdate, initializeUpdateQueue, cloneUpdateQueue } from './ReactUpdateQueue.old';\nimport { NoLanes } from './ReactFiberLane.old';\nimport { cacheContext, getMaskedContext, getUnmaskedContext, hasContextChanged, emptyContextObject } from './ReactFiberContext.old';\nimport { readContext, checkIfContextChanged } from './ReactFiberNewContext.old';\nimport { requestEventTime, requestUpdateLane, scheduleUpdateOnFiber } from './ReactFiberWorkLoop.old';\nimport { logForceUpdateScheduled, logStateUpdateScheduled } from './DebugTracing';\nimport { markForceUpdateScheduled, markStateUpdateScheduled } from './SchedulingProfiler';\nconst fakeInternalInstance = {}; // React.Component uses a shared frozen object by default.\n// We'll use it to determine whether we need to initialize legacy refs.\n\nexport const emptyRefsObject = new React.Component().refs;\nlet didWarnAboutStateAssignmentForComponent;\nlet didWarnAboutUninitializedState;\nlet didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;\nlet didWarnAboutLegacyLifecyclesAndDerivedState;\nlet didWarnAboutUndefinedDerivedState;\nlet warnOnUndefinedDerivedState;\nlet warnOnInvalidCallback;\nlet didWarnAboutDirectlyAssigningPropsToState;\nlet didWarnAboutContextTypeAndContextTypes;\nlet didWarnAboutInvalidateContextType;\n\nif (__DEV__) {\n  didWarnAboutStateAssignmentForComponent = new Set();\n  didWarnAboutUninitializedState = new Set();\n  didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();\n  didWarnAboutLegacyLifecyclesAndDerivedState = new Set();\n  didWarnAboutDirectlyAssigningPropsToState = new Set();\n  didWarnAboutUndefinedDerivedState = new Set();\n  didWarnAboutContextTypeAndContextTypes = new Set();\n  didWarnAboutInvalidateContextType = new Set();\n  const didWarnOnInvalidCallback = new Set();\n\n  warnOnInvalidCallback = function (callback, callerName) {\n    if (callback === null || typeof callback === 'function') {\n      return;\n    }\n\n    const key = callerName + '_' + callback;\n\n    if (!didWarnOnInvalidCallback.has(key)) {\n      didWarnOnInvalidCallback.add(key);\n      console.error('%s(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callerName, callback);\n    }\n  };\n\n  warnOnUndefinedDerivedState = function (type, partialState) {\n    if (partialState === undefined) {\n      const componentName = getComponentNameFromType(type) || 'Component';\n\n      if (!didWarnAboutUndefinedDerivedState.has(componentName)) {\n        didWarnAboutUndefinedDerivedState.add(componentName);\n        console.error('%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. ' + 'You have returned undefined.', componentName);\n      }\n    }\n  }; // This is so gross but it's at least non-critical and can be removed if\n  // it causes problems. This is meant to give a nicer error message for\n  // ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,\n  // ...)) which otherwise throws a \"_processChildContext is not a function\"\n  // exception.\n\n\n  Object.defineProperty(fakeInternalInstance, '_processChildContext', {\n    enumerable: false,\n    value: function () {\n      throw new Error('_processChildContext is not available in React 16+. This likely ' + 'means you have multiple copies of React and are attempting to nest ' + 'a React 15 tree inside a React 16 tree using ' + \"unstable_renderSubtreeIntoContainer, which isn't supported. Try \" + 'to make sure you have only one copy of React (and ideally, switch ' + 'to ReactDOM.createPortal).');\n    }\n  });\n  Object.freeze(fakeInternalInstance);\n}\n\nfunction applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, nextProps) {\n  const prevState = workInProgress.memoizedState;\n  let partialState = getDerivedStateFromProps(nextProps, prevState);\n\n  if (__DEV__) {\n    if (debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictLegacyMode) {\n      setIsStrictModeForDevtools(true);\n\n      try {\n        // Invoke the function an extra time to help detect side-effects.\n        partialState = getDerivedStateFromProps(nextProps, prevState);\n      } finally {\n        setIsStrictModeForDevtools(false);\n      }\n    }\n\n    warnOnUndefinedDerivedState(ctor, partialState);\n  } // Merge the partial state and the previous state.\n\n\n  const memoizedState = partialState === null || partialState === undefined ? prevState : Object.assign({}, prevState, partialState);\n  workInProgress.memoizedState = memoizedState; // Once the update queue is empty, persist the derived state onto the\n  // base state.\n\n  if (workInProgress.lanes === NoLanes) {\n    // Queue is always non-null for classes\n    const updateQueue = workInProgress.updateQueue;\n    updateQueue.baseState = memoizedState;\n  }\n}\n\nconst classComponentUpdater = {\n  isMounted,\n\n  enqueueSetState(inst, payload, callback) {\n    const fiber = getInstance(inst);\n    const eventTime = requestEventTime();\n    const lane = requestUpdateLane(fiber);\n    const update = createUpdate(eventTime, lane);\n    update.payload = payload;\n\n    if (callback !== undefined && callback !== null) {\n      if (__DEV__) {\n        warnOnInvalidCallback(callback, 'setState');\n      }\n\n      update.callback = callback;\n    }\n\n    enqueueUpdate(fiber, update, lane);\n    const root = scheduleUpdateOnFiber(fiber, lane, eventTime);\n\n    if (root !== null) {\n      entangleTransitions(root, fiber, lane);\n    }\n\n    if (__DEV__) {\n      if (enableDebugTracing) {\n        if (fiber.mode & DebugTracingMode) {\n          const name = getComponentNameFromFiber(fiber) || 'Unknown';\n          logStateUpdateScheduled(name, lane, payload);\n        }\n      }\n    }\n\n    if (enableSchedulingProfiler) {\n      markStateUpdateScheduled(fiber, lane);\n    }\n  },\n\n  enqueueReplaceState(inst, payload, callback) {\n    const fiber = getInstance(inst);\n    const eventTime = requestEventTime();\n    const lane = requestUpdateLane(fiber);\n    const update = createUpdate(eventTime, lane);\n    update.tag = ReplaceState;\n    update.payload = payload;\n\n    if (callback !== undefined && callback !== null) {\n      if (__DEV__) {\n        warnOnInvalidCallback(callback, 'replaceState');\n      }\n\n      update.callback = callback;\n    }\n\n    enqueueUpdate(fiber, update, lane);\n    const root = scheduleUpdateOnFiber(fiber, lane, eventTime);\n\n    if (root !== null) {\n      entangleTransitions(root, fiber, lane);\n    }\n\n    if (__DEV__) {\n      if (enableDebugTracing) {\n        if (fiber.mode & DebugTracingMode) {\n          const name = getComponentNameFromFiber(fiber) || 'Unknown';\n          logStateUpdateScheduled(name, lane, payload);\n        }\n      }\n    }\n\n    if (enableSchedulingProfiler) {\n      markStateUpdateScheduled(fiber, lane);\n    }\n  },\n\n  enqueueForceUpdate(inst, callback) {\n    const fiber = getInstance(inst);\n    const eventTime = requestEventTime();\n    const lane = requestUpdateLane(fiber);\n    const update = createUpdate(eventTime, lane);\n    update.tag = ForceUpdate;\n\n    if (callback !== undefined && callback !== null) {\n      if (__DEV__) {\n        warnOnInvalidCallback(callback, 'forceUpdate');\n      }\n\n      update.callback = callback;\n    }\n\n    enqueueUpdate(fiber, update, lane);\n    const root = scheduleUpdateOnFiber(fiber, lane, eventTime);\n\n    if (root !== null) {\n      entangleTransitions(root, fiber, lane);\n    }\n\n    if (__DEV__) {\n      if (enableDebugTracing) {\n        if (fiber.mode & DebugTracingMode) {\n          const name = getComponentNameFromFiber(fiber) || 'Unknown';\n          logForceUpdateScheduled(name, lane);\n        }\n      }\n    }\n\n    if (enableSchedulingProfiler) {\n      markForceUpdateScheduled(fiber, lane);\n    }\n  }\n\n};\n\nfunction checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) {\n  const instance = workInProgress.stateNode;\n\n  if (typeof instance.shouldComponentUpdate === 'function') {\n    let shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);\n\n    if (__DEV__) {\n      if (debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictLegacyMode) {\n        setIsStrictModeForDevtools(true);\n\n        try {\n          // Invoke the function an extra time to help detect side-effects.\n          shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);\n        } finally {\n          setIsStrictModeForDevtools(false);\n        }\n      }\n\n      if (shouldUpdate === undefined) {\n        console.error('%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', getComponentNameFromType(ctor) || 'Component');\n      }\n    }\n\n    return shouldUpdate;\n  }\n\n  if (ctor.prototype && ctor.prototype.isPureReactComponent) {\n    return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);\n  }\n\n  return true;\n}\n\nfunction checkClassInstance(workInProgress, ctor, newProps) {\n  const instance = workInProgress.stateNode;\n\n  if (__DEV__) {\n    const name = getComponentNameFromType(ctor) || 'Component';\n    const renderPresent = instance.render;\n\n    if (!renderPresent) {\n      if (ctor.prototype && typeof ctor.prototype.render === 'function') {\n        console.error('%s(...): No `render` method found on the returned component ' + 'instance: did you accidentally return an object from the constructor?', name);\n      } else {\n        console.error('%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', name);\n      }\n    }\n\n    if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {\n      console.error('getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', name);\n    }\n\n    if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {\n      console.error('getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', name);\n    }\n\n    if (instance.propTypes) {\n      console.error('propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', name);\n    }\n\n    if (instance.contextType) {\n      console.error('contextType was defined as an instance property on %s. Use a static ' + 'property to define contextType instead.', name);\n    }\n\n    if (disableLegacyContext) {\n      if (ctor.childContextTypes) {\n        console.error('%s uses the legacy childContextTypes API which is no longer supported. ' + 'Use React.createContext() instead.', name);\n      }\n\n      if (ctor.contextTypes) {\n        console.error('%s uses the legacy contextTypes API which is no longer supported. ' + 'Use React.createContext() with static contextType instead.', name);\n      }\n    } else {\n      if (instance.contextTypes) {\n        console.error('contextTypes was defined as an instance property on %s. Use a static ' + 'property to define contextTypes instead.', name);\n      }\n\n      if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {\n        didWarnAboutContextTypeAndContextTypes.add(ctor);\n        console.error('%s declares both contextTypes and contextType static properties. ' + 'The legacy contextTypes property will be ignored.', name);\n      }\n    }\n\n    if (typeof instance.componentShouldUpdate === 'function') {\n      console.error('%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', name);\n    }\n\n    if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== 'undefined') {\n      console.error('%s has a method called shouldComponentUpdate(). ' + 'shouldComponentUpdate should not be used when extending React.PureComponent. ' + 'Please extend React.Component if shouldComponentUpdate is used.', getComponentNameFromType(ctor) || 'A pure component');\n    }\n\n    if (typeof instance.componentDidUnmount === 'function') {\n      console.error('%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', name);\n    }\n\n    if (typeof instance.componentDidReceiveProps === 'function') {\n      console.error('%s has a method called ' + 'componentDidReceiveProps(). But there is no such lifecycle method. ' + 'If you meant to update the state in response to changing props, ' + 'use componentWillReceiveProps(). If you meant to fetch data or ' + 'run side-effects or mutations after React has updated the UI, use componentDidUpdate().', name);\n    }\n\n    if (typeof instance.componentWillRecieveProps === 'function') {\n      console.error('%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', name);\n    }\n\n    if (typeof instance.UNSAFE_componentWillRecieveProps === 'function') {\n      console.error('%s has a method called ' + 'UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?', name);\n    }\n\n    const hasMutatedProps = instance.props !== newProps;\n\n    if (instance.props !== undefined && hasMutatedProps) {\n      console.error('%s(...): When calling super() in `%s`, make sure to pass ' + \"up the same props that your component's constructor was passed.\", name, name);\n    }\n\n    if (instance.defaultProps) {\n      console.error('Setting defaultProps as an instance property on %s is not supported and will be ignored.' + ' Instead, define defaultProps as a static property on %s.', name, name);\n    }\n\n    if (typeof instance.getSnapshotBeforeUpdate === 'function' && typeof instance.componentDidUpdate !== 'function' && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {\n      didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);\n      console.error('%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). ' + 'This component defines getSnapshotBeforeUpdate() only.', getComponentNameFromType(ctor));\n    }\n\n    if (typeof instance.getDerivedStateFromProps === 'function') {\n      console.error('%s: getDerivedStateFromProps() is defined as an instance method ' + 'and will be ignored. Instead, declare it as a static method.', name);\n    }\n\n    if (typeof instance.getDerivedStateFromError === 'function') {\n      console.error('%s: getDerivedStateFromError() is defined as an instance method ' + 'and will be ignored. Instead, declare it as a static method.', name);\n    }\n\n    if (typeof ctor.getSnapshotBeforeUpdate === 'function') {\n      console.error('%s: getSnapshotBeforeUpdate() is defined as a static method ' + 'and will be ignored. Instead, declare it as an instance method.', name);\n    }\n\n    const state = instance.state;\n\n    if (state && (typeof state !== 'object' || isArray(state))) {\n      console.error('%s.state: must be set to an object or null', name);\n    }\n\n    if (typeof instance.getChildContext === 'function' && typeof ctor.childContextTypes !== 'object') {\n      console.error('%s.getChildContext(): childContextTypes must be defined in order to ' + 'use getChildContext().', name);\n    }\n  }\n}\n\nfunction adoptClassInstance(workInProgress, instance) {\n  instance.updater = classComponentUpdater;\n  workInProgress.stateNode = instance; // The instance needs access to the fiber so that it can schedule updates\n\n  setInstance(instance, workInProgress);\n\n  if (__DEV__) {\n    instance._reactInternalInstance = fakeInternalInstance;\n  }\n}\n\nfunction constructClassInstance(workInProgress, ctor, props) {\n  let isLegacyContextConsumer = false;\n  let unmaskedContext = emptyContextObject;\n  let context = emptyContextObject;\n  const contextType = ctor.contextType;\n\n  if (__DEV__) {\n    if ('contextType' in ctor) {\n      const isValid = // Allow null for conditional declaration\n      contextType === null || contextType !== undefined && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === undefined; // Not a <Context.Consumer>\n\n      if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {\n        didWarnAboutInvalidateContextType.add(ctor);\n        let addendum = '';\n\n        if (contextType === undefined) {\n          addendum = ' However, it is set to undefined. ' + 'This can be caused by a typo or by mixing up named and default imports. ' + 'This can also happen due to a circular dependency, so ' + 'try moving the createContext() call to a separate file.';\n        } else if (typeof contextType !== 'object') {\n          addendum = ' However, it is set to a ' + typeof contextType + '.';\n        } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {\n          addendum = ' Did you accidentally pass the Context.Provider instead?';\n        } else if (contextType._context !== undefined) {\n          // <Context.Consumer>\n          addendum = ' Did you accidentally pass the Context.Consumer instead?';\n        } else {\n          addendum = ' However, it is set to an object with keys {' + Object.keys(contextType).join(', ') + '}.';\n        }\n\n        console.error('%s defines an invalid contextType. ' + 'contextType should point to the Context object returned by React.createContext().%s', getComponentNameFromType(ctor) || 'Component', addendum);\n      }\n    }\n  }\n\n  if (typeof contextType === 'object' && contextType !== null) {\n    context = readContext(contextType);\n  } else if (!disableLegacyContext) {\n    unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\n    const contextTypes = ctor.contextTypes;\n    isLegacyContextConsumer = contextTypes !== null && contextTypes !== undefined;\n    context = isLegacyContextConsumer ? getMaskedContext(workInProgress, unmaskedContext) : emptyContextObject;\n  }\n\n  let instance = new ctor(props, context); // Instantiate twice to help detect side-effects.\n\n  if (__DEV__) {\n    if (debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictLegacyMode) {\n      setIsStrictModeForDevtools(true);\n\n      try {\n        instance = new ctor(props, context); // eslint-disable-line no-new\n      } finally {\n        setIsStrictModeForDevtools(false);\n      }\n    }\n  }\n\n  const state = workInProgress.memoizedState = instance.state !== null && instance.state !== undefined ? instance.state : null;\n  adoptClassInstance(workInProgress, instance);\n\n  if (__DEV__) {\n    if (typeof ctor.getDerivedStateFromProps === 'function' && state === null) {\n      const componentName = getComponentNameFromType(ctor) || 'Component';\n\n      if (!didWarnAboutUninitializedState.has(componentName)) {\n        didWarnAboutUninitializedState.add(componentName);\n        console.error('`%s` uses `getDerivedStateFromProps` but its initial state is ' + '%s. This is not recommended. Instead, define the initial state by ' + 'assigning an object to `this.state` in the constructor of `%s`. ' + 'This ensures that `getDerivedStateFromProps` arguments have a consistent shape.', componentName, instance.state === null ? 'null' : 'undefined', componentName);\n      }\n    } // If new component APIs are defined, \"unsafe\" lifecycles won't be called.\n    // Warn about these lifecycles if they are present.\n    // Don't warn about react-lifecycles-compat polyfilled methods though.\n\n\n    if (typeof ctor.getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function') {\n      let foundWillMountName = null;\n      let foundWillReceivePropsName = null;\n      let foundWillUpdateName = null;\n\n      if (typeof instance.componentWillMount === 'function' && instance.componentWillMount.__suppressDeprecationWarning !== true) {\n        foundWillMountName = 'componentWillMount';\n      } else if (typeof instance.UNSAFE_componentWillMount === 'function') {\n        foundWillMountName = 'UNSAFE_componentWillMount';\n      }\n\n      if (typeof instance.componentWillReceiveProps === 'function' && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {\n        foundWillReceivePropsName = 'componentWillReceiveProps';\n      } else if (typeof instance.UNSAFE_componentWillReceiveProps === 'function') {\n        foundWillReceivePropsName = 'UNSAFE_componentWillReceiveProps';\n      }\n\n      if (typeof instance.componentWillUpdate === 'function' && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {\n        foundWillUpdateName = 'componentWillUpdate';\n      } else if (typeof instance.UNSAFE_componentWillUpdate === 'function') {\n        foundWillUpdateName = 'UNSAFE_componentWillUpdate';\n      }\n\n      if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {\n        const componentName = getComponentNameFromType(ctor) || 'Component';\n        const newApiName = typeof ctor.getDerivedStateFromProps === 'function' ? 'getDerivedStateFromProps()' : 'getSnapshotBeforeUpdate()';\n\n        if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(componentName)) {\n          didWarnAboutLegacyLifecyclesAndDerivedState.add(componentName);\n          console.error('Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n' + '%s uses %s but also contains the following legacy lifecycles:%s%s%s\\n\\n' + 'The above lifecycles should be removed. Learn more about this warning here:\\n' + 'https://reactjs.org/link/unsafe-component-lifecycles', componentName, newApiName, foundWillMountName !== null ? `\\n  ${foundWillMountName}` : '', foundWillReceivePropsName !== null ? `\\n  ${foundWillReceivePropsName}` : '', foundWillUpdateName !== null ? `\\n  ${foundWillUpdateName}` : '');\n        }\n      }\n    }\n  } // Cache unmasked context so we can avoid recreating masked context unless necessary.\n  // ReactFiberContext usually updates this cache but can't for newly-created instances.\n\n\n  if (isLegacyContextConsumer) {\n    cacheContext(workInProgress, unmaskedContext, context);\n  }\n\n  return instance;\n}\n\nfunction callComponentWillMount(workInProgress, instance) {\n  const oldState = instance.state;\n\n  if (typeof instance.componentWillMount === 'function') {\n    instance.componentWillMount();\n  }\n\n  if (typeof instance.UNSAFE_componentWillMount === 'function') {\n    instance.UNSAFE_componentWillMount();\n  }\n\n  if (oldState !== instance.state) {\n    if (__DEV__) {\n      console.error('%s.componentWillMount(): Assigning directly to this.state is ' + \"deprecated (except inside a component's \" + 'constructor). Use setState instead.', getComponentNameFromFiber(workInProgress) || 'Component');\n    }\n\n    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\n  }\n}\n\nfunction callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext) {\n  const oldState = instance.state;\n\n  if (typeof instance.componentWillReceiveProps === 'function') {\n    instance.componentWillReceiveProps(newProps, nextContext);\n  }\n\n  if (typeof instance.UNSAFE_componentWillReceiveProps === 'function') {\n    instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);\n  }\n\n  if (instance.state !== oldState) {\n    if (__DEV__) {\n      const componentName = getComponentNameFromFiber(workInProgress) || 'Component';\n\n      if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {\n        didWarnAboutStateAssignmentForComponent.add(componentName);\n        console.error('%s.componentWillReceiveProps(): Assigning directly to ' + \"this.state is deprecated (except inside a component's \" + 'constructor). Use setState instead.', componentName);\n      }\n    }\n\n    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\n  }\n} // Invokes the mount life-cycles on a previously never rendered instance.\n\n\nfunction mountClassInstance(workInProgress, ctor, newProps, renderLanes) {\n  if (__DEV__) {\n    checkClassInstance(workInProgress, ctor, newProps);\n  }\n\n  const instance = workInProgress.stateNode;\n  instance.props = newProps;\n  instance.state = workInProgress.memoizedState;\n  instance.refs = emptyRefsObject;\n  initializeUpdateQueue(workInProgress);\n  const contextType = ctor.contextType;\n\n  if (typeof contextType === 'object' && contextType !== null) {\n    instance.context = readContext(contextType);\n  } else if (disableLegacyContext) {\n    instance.context = emptyContextObject;\n  } else {\n    const unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\n    instance.context = getMaskedContext(workInProgress, unmaskedContext);\n  }\n\n  if (__DEV__) {\n    if (instance.state === newProps) {\n      const componentName = getComponentNameFromType(ctor) || 'Component';\n\n      if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {\n        didWarnAboutDirectlyAssigningPropsToState.add(componentName);\n        console.error('%s: It is not recommended to assign props directly to state ' + \"because updates to props won't be reflected in state. \" + 'In most cases, it is better to use props directly.', componentName);\n      }\n    }\n\n    if (workInProgress.mode & StrictLegacyMode) {\n      ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, instance);\n    }\n\n    if (warnAboutDeprecatedLifecycles) {\n      ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress, instance);\n    }\n  }\n\n  instance.state = workInProgress.memoizedState;\n  const getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n\n  if (typeof getDerivedStateFromProps === 'function') {\n    applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);\n    instance.state = workInProgress.memoizedState;\n  } // In order to support react-lifecycles-compat polyfilled components,\n  // Unsafe lifecycles should not be invoked for components using the new APIs.\n\n\n  if (typeof ctor.getDerivedStateFromProps !== 'function' && typeof instance.getSnapshotBeforeUpdate !== 'function' && (typeof instance.UNSAFE_componentWillMount === 'function' || typeof instance.componentWillMount === 'function')) {\n    callComponentWillMount(workInProgress, instance); // If we had additional state updates during this life-cycle, let's\n    // process them now.\n\n    processUpdateQueue(workInProgress, newProps, instance, renderLanes);\n    instance.state = workInProgress.memoizedState;\n  }\n\n  if (typeof instance.componentDidMount === 'function') {\n    let fiberFlags = Update;\n\n    if (enableSuspenseLayoutEffectSemantics) {\n      fiberFlags |= LayoutStatic;\n    }\n\n    if (__DEV__ && enableStrictEffects && (workInProgress.mode & StrictEffectsMode) !== NoMode) {\n      fiberFlags |= MountLayoutDev;\n    }\n\n    workInProgress.flags |= fiberFlags;\n  }\n}\n\nfunction resumeMountClassInstance(workInProgress, ctor, newProps, renderLanes) {\n  const instance = workInProgress.stateNode;\n  const oldProps = workInProgress.memoizedProps;\n  instance.props = oldProps;\n  const oldContext = instance.context;\n  const contextType = ctor.contextType;\n  let nextContext = emptyContextObject;\n\n  if (typeof contextType === 'object' && contextType !== null) {\n    nextContext = readContext(contextType);\n  } else if (!disableLegacyContext) {\n    const nextLegacyUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\n    nextContext = getMaskedContext(workInProgress, nextLegacyUnmaskedContext);\n  }\n\n  const getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n  const hasNewLifecycles = typeof getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function'; // Note: During these life-cycles, instance.props/instance.state are what\n  // ever the previously attempted to render - not the \"current\". However,\n  // during componentDidUpdate we pass the \"current\" props.\n  // In order to support react-lifecycles-compat polyfilled components,\n  // Unsafe lifecycles should not be invoked for components using the new APIs.\n\n  if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === 'function' || typeof instance.componentWillReceiveProps === 'function')) {\n    if (oldProps !== newProps || oldContext !== nextContext) {\n      callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext);\n    }\n  }\n\n  resetHasForceUpdateBeforeProcessing();\n  const oldState = workInProgress.memoizedState;\n  let newState = instance.state = oldState;\n  processUpdateQueue(workInProgress, newProps, instance, renderLanes);\n  newState = workInProgress.memoizedState;\n\n  if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {\n    // If an update was already in progress, we should schedule an Update\n    // effect even though we're bailing out, so that cWU/cDU are called.\n    if (typeof instance.componentDidMount === 'function') {\n      let fiberFlags = Update;\n\n      if (enableSuspenseLayoutEffectSemantics) {\n        fiberFlags |= LayoutStatic;\n      }\n\n      if (__DEV__ && enableStrictEffects && (workInProgress.mode & StrictEffectsMode) !== NoMode) {\n        fiberFlags |= MountLayoutDev;\n      }\n\n      workInProgress.flags |= fiberFlags;\n    }\n\n    return false;\n  }\n\n  if (typeof getDerivedStateFromProps === 'function') {\n    applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);\n    newState = workInProgress.memoizedState;\n  }\n\n  const shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext);\n\n  if (shouldUpdate) {\n    // In order to support react-lifecycles-compat polyfilled components,\n    // Unsafe lifecycles should not be invoked for components using the new APIs.\n    if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillMount === 'function' || typeof instance.componentWillMount === 'function')) {\n      if (typeof instance.componentWillMount === 'function') {\n        instance.componentWillMount();\n      }\n\n      if (typeof instance.UNSAFE_componentWillMount === 'function') {\n        instance.UNSAFE_componentWillMount();\n      }\n    }\n\n    if (typeof instance.componentDidMount === 'function') {\n      let fiberFlags = Update;\n\n      if (enableSuspenseLayoutEffectSemantics) {\n        fiberFlags |= LayoutStatic;\n      }\n\n      if (__DEV__ && enableStrictEffects && (workInProgress.mode & StrictEffectsMode) !== NoMode) {\n        fiberFlags |= MountLayoutDev;\n      }\n\n      workInProgress.flags |= fiberFlags;\n    }\n  } else {\n    // If an update was already in progress, we should schedule an Update\n    // effect even though we're bailing out, so that cWU/cDU are called.\n    if (typeof instance.componentDidMount === 'function') {\n      let fiberFlags = Update;\n\n      if (enableSuspenseLayoutEffectSemantics) {\n        fiberFlags |= LayoutStatic;\n      }\n\n      if (__DEV__ && enableStrictEffects && (workInProgress.mode & StrictEffectsMode) !== NoMode) {\n        fiberFlags |= MountLayoutDev;\n      }\n\n      workInProgress.flags |= fiberFlags;\n    } // If shouldComponentUpdate returned false, we should still update the\n    // memoized state to indicate that this work can be reused.\n\n\n    workInProgress.memoizedProps = newProps;\n    workInProgress.memoizedState = newState;\n  } // Update the existing instance's state, props, and context pointers even\n  // if shouldComponentUpdate returns false.\n\n\n  instance.props = newProps;\n  instance.state = newState;\n  instance.context = nextContext;\n  return shouldUpdate;\n} // Invokes the update life-cycles and returns false if it shouldn't rerender.\n\n\nfunction updateClassInstance(current, workInProgress, ctor, newProps, renderLanes) {\n  const instance = workInProgress.stateNode;\n  cloneUpdateQueue(current, workInProgress);\n  const unresolvedOldProps = workInProgress.memoizedProps;\n  const oldProps = workInProgress.type === workInProgress.elementType ? unresolvedOldProps : resolveDefaultProps(workInProgress.type, unresolvedOldProps);\n  instance.props = oldProps;\n  const unresolvedNewProps = workInProgress.pendingProps;\n  const oldContext = instance.context;\n  const contextType = ctor.contextType;\n  let nextContext = emptyContextObject;\n\n  if (typeof contextType === 'object' && contextType !== null) {\n    nextContext = readContext(contextType);\n  } else if (!disableLegacyContext) {\n    const nextUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\n    nextContext = getMaskedContext(workInProgress, nextUnmaskedContext);\n  }\n\n  const getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n  const hasNewLifecycles = typeof getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function'; // Note: During these life-cycles, instance.props/instance.state are what\n  // ever the previously attempted to render - not the \"current\". However,\n  // during componentDidUpdate we pass the \"current\" props.\n  // In order to support react-lifecycles-compat polyfilled components,\n  // Unsafe lifecycles should not be invoked for components using the new APIs.\n\n  if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === 'function' || typeof instance.componentWillReceiveProps === 'function')) {\n    if (unresolvedOldProps !== unresolvedNewProps || oldContext !== nextContext) {\n      callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext);\n    }\n  }\n\n  resetHasForceUpdateBeforeProcessing();\n  const oldState = workInProgress.memoizedState;\n  let newState = instance.state = oldState;\n  processUpdateQueue(workInProgress, newProps, instance, renderLanes);\n  newState = workInProgress.memoizedState;\n\n  if (unresolvedOldProps === unresolvedNewProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing() && !(enableLazyContextPropagation && current !== null && current.dependencies !== null && checkIfContextChanged(current.dependencies))) {\n    // If an update was already in progress, we should schedule an Update\n    // effect even though we're bailing out, so that cWU/cDU are called.\n    if (typeof instance.componentDidUpdate === 'function') {\n      if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n        workInProgress.flags |= Update;\n      }\n    }\n\n    if (typeof instance.getSnapshotBeforeUpdate === 'function') {\n      if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n        workInProgress.flags |= Snapshot;\n      }\n    }\n\n    return false;\n  }\n\n  if (typeof getDerivedStateFromProps === 'function') {\n    applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);\n    newState = workInProgress.memoizedState;\n  }\n\n  const shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) || // TODO: In some cases, we'll end up checking if context has changed twice,\n  // both before and after `shouldComponentUpdate` has been called. Not ideal,\n  // but I'm loath to refactor this function. This only happens for memoized\n  // components so it's not that common.\n  enableLazyContextPropagation && current !== null && current.dependencies !== null && checkIfContextChanged(current.dependencies);\n\n  if (shouldUpdate) {\n    // In order to support react-lifecycles-compat polyfilled components,\n    // Unsafe lifecycles should not be invoked for components using the new APIs.\n    if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillUpdate === 'function' || typeof instance.componentWillUpdate === 'function')) {\n      if (typeof instance.componentWillUpdate === 'function') {\n        instance.componentWillUpdate(newProps, newState, nextContext);\n      }\n\n      if (typeof instance.UNSAFE_componentWillUpdate === 'function') {\n        instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext);\n      }\n    }\n\n    if (typeof instance.componentDidUpdate === 'function') {\n      workInProgress.flags |= Update;\n    }\n\n    if (typeof instance.getSnapshotBeforeUpdate === 'function') {\n      workInProgress.flags |= Snapshot;\n    }\n  } else {\n    // If an update was already in progress, we should schedule an Update\n    // effect even though we're bailing out, so that cWU/cDU are called.\n    if (typeof instance.componentDidUpdate === 'function') {\n      if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n        workInProgress.flags |= Update;\n      }\n    }\n\n    if (typeof instance.getSnapshotBeforeUpdate === 'function') {\n      if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n        workInProgress.flags |= Snapshot;\n      }\n    } // If shouldComponentUpdate returned false, we should still update the\n    // memoized props/state to indicate that this work can be reused.\n\n\n    workInProgress.memoizedProps = newProps;\n    workInProgress.memoizedState = newState;\n  } // Update the existing instance's state, props, and context pointers even\n  // if shouldComponentUpdate returns false.\n\n\n  instance.props = newProps;\n  instance.state = newState;\n  instance.context = nextContext;\n  return shouldUpdate;\n}\n\nexport { adoptClassInstance, constructClassInstance, mountClassInstance, resumeMountClassInstance, updateClassInstance };","map":{"version":3,"sources":["/Users/zhangshuo/git/react-source-test/src/react/packages/react-reconciler/src/ReactFiberClassComponent.old.js"],"names":["React","LayoutStatic","MountLayoutDev","Update","Snapshot","debugRenderPhaseSideEffectsForStrictMode","disableLegacyContext","enableDebugTracing","enableSchedulingProfiler","warnAboutDeprecatedLifecycles","enableStrictEffects","enableLazyContextPropagation","enableSuspenseLayoutEffectSemantics","ReactStrictModeWarnings","isMounted","get","getInstance","set","setInstance","shallowEqual","getComponentNameFromFiber","getComponentNameFromType","isArray","REACT_CONTEXT_TYPE","REACT_PROVIDER_TYPE","setIsStrictModeForDevtools","resolveDefaultProps","DebugTracingMode","NoMode","StrictLegacyMode","StrictEffectsMode","enqueueUpdate","entangleTransitions","processUpdateQueue","checkHasForceUpdateAfterProcessing","resetHasForceUpdateBeforeProcessing","createUpdate","ReplaceState","ForceUpdate","initializeUpdateQueue","cloneUpdateQueue","NoLanes","cacheContext","getMaskedContext","getUnmaskedContext","hasContextChanged","emptyContextObject","readContext","checkIfContextChanged","requestEventTime","requestUpdateLane","scheduleUpdateOnFiber","logForceUpdateScheduled","logStateUpdateScheduled","markForceUpdateScheduled","markStateUpdateScheduled","fakeInternalInstance","emptyRefsObject","Component","refs","didWarnAboutStateAssignmentForComponent","didWarnAboutUninitializedState","didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate","didWarnAboutLegacyLifecyclesAndDerivedState","didWarnAboutUndefinedDerivedState","warnOnUndefinedDerivedState","warnOnInvalidCallback","didWarnAboutDirectlyAssigningPropsToState","didWarnAboutContextTypeAndContextTypes","didWarnAboutInvalidateContextType","__DEV__","Set","didWarnOnInvalidCallback","callback","callerName","key","has","add","console","error","type","partialState","undefined","componentName","Object","defineProperty","enumerable","value","Error","freeze","applyDerivedStateFromProps","workInProgress","ctor","getDerivedStateFromProps","nextProps","prevState","memoizedState","mode","assign","lanes","updateQueue","baseState","classComponentUpdater","enqueueSetState","inst","payload","fiber","eventTime","lane","update","root","name","enqueueReplaceState","tag","enqueueForceUpdate","checkShouldComponentUpdate","oldProps","newProps","oldState","newState","nextContext","instance","stateNode","shouldComponentUpdate","shouldUpdate","prototype","isPureReactComponent","checkClassInstance","renderPresent","render","getInitialState","isReactClassApproved","state","getDefaultProps","propTypes","contextType","childContextTypes","contextTypes","componentShouldUpdate","componentDidUnmount","componentDidReceiveProps","componentWillRecieveProps","UNSAFE_componentWillRecieveProps","hasMutatedProps","props","defaultProps","getSnapshotBeforeUpdate","componentDidUpdate","getDerivedStateFromError","getChildContext","adoptClassInstance","updater","_reactInternalInstance","constructClassInstance","isLegacyContextConsumer","unmaskedContext","context","isValid","$$typeof","_context","addendum","keys","join","foundWillMountName","foundWillReceivePropsName","foundWillUpdateName","componentWillMount","__suppressDeprecationWarning","UNSAFE_componentWillMount","componentWillReceiveProps","UNSAFE_componentWillReceiveProps","componentWillUpdate","UNSAFE_componentWillUpdate","newApiName","callComponentWillMount","callComponentWillReceiveProps","mountClassInstance","renderLanes","recordLegacyContextWarning","recordUnsafeLifecycleWarnings","componentDidMount","fiberFlags","flags","resumeMountClassInstance","memoizedProps","oldContext","nextLegacyUnmaskedContext","hasNewLifecycles","updateClassInstance","current","unresolvedOldProps","elementType","unresolvedNewProps","pendingProps","nextUnmaskedContext","dependencies"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Fiber} from './ReactInternalTypes';\nimport type {Lanes} from './ReactFiberLane.old';\nimport type {UpdateQueue} from './ReactUpdateQueue.old';\nimport type {Flags} from './ReactFiberFlags';\n\nimport * as React from 'react';\nimport {\n  LayoutStatic,\n  MountLayoutDev,\n  Update,\n  Snapshot,\n} from './ReactFiberFlags';\nimport {\n  debugRenderPhaseSideEffectsForStrictMode,\n  disableLegacyContext,\n  enableDebugTracing,\n  enableSchedulingProfiler,\n  warnAboutDeprecatedLifecycles,\n  enableStrictEffects,\n  enableLazyContextPropagation,\n  enableSuspenseLayoutEffectSemantics,\n} from 'shared/ReactFeatureFlags';\nimport ReactStrictModeWarnings from './ReactStrictModeWarnings.old';\nimport {isMounted} from './ReactFiberTreeReflection';\nimport {get as getInstance, set as setInstance} from 'shared/ReactInstanceMap';\nimport shallowEqual from 'shared/shallowEqual';\nimport getComponentNameFromFiber from 'react-reconciler/src/getComponentNameFromFiber';\nimport getComponentNameFromType from 'shared/getComponentNameFromType';\nimport isArray from 'shared/isArray';\nimport {REACT_CONTEXT_TYPE, REACT_PROVIDER_TYPE} from 'shared/ReactSymbols';\nimport {setIsStrictModeForDevtools} from './ReactFiberDevToolsHook.old';\n\nimport {resolveDefaultProps} from './ReactFiberLazyComponent.old';\nimport {\n  DebugTracingMode,\n  NoMode,\n  StrictLegacyMode,\n  StrictEffectsMode,\n} from './ReactTypeOfMode';\n\nimport {\n  enqueueUpdate,\n  entangleTransitions,\n  processUpdateQueue,\n  checkHasForceUpdateAfterProcessing,\n  resetHasForceUpdateBeforeProcessing,\n  createUpdate,\n  ReplaceState,\n  ForceUpdate,\n  initializeUpdateQueue,\n  cloneUpdateQueue,\n} from './ReactUpdateQueue.old';\nimport {NoLanes} from './ReactFiberLane.old';\nimport {\n  cacheContext,\n  getMaskedContext,\n  getUnmaskedContext,\n  hasContextChanged,\n  emptyContextObject,\n} from './ReactFiberContext.old';\nimport {readContext, checkIfContextChanged} from './ReactFiberNewContext.old';\nimport {\n  requestEventTime,\n  requestUpdateLane,\n  scheduleUpdateOnFiber,\n} from './ReactFiberWorkLoop.old';\nimport {logForceUpdateScheduled, logStateUpdateScheduled} from './DebugTracing';\n\nimport {\n  markForceUpdateScheduled,\n  markStateUpdateScheduled,\n} from './SchedulingProfiler';\n\nconst fakeInternalInstance = {};\n\n// React.Component uses a shared frozen object by default.\n// We'll use it to determine whether we need to initialize legacy refs.\nexport const emptyRefsObject = new React.Component().refs;\n\nlet didWarnAboutStateAssignmentForComponent;\nlet didWarnAboutUninitializedState;\nlet didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;\nlet didWarnAboutLegacyLifecyclesAndDerivedState;\nlet didWarnAboutUndefinedDerivedState;\nlet warnOnUndefinedDerivedState;\nlet warnOnInvalidCallback;\nlet didWarnAboutDirectlyAssigningPropsToState;\nlet didWarnAboutContextTypeAndContextTypes;\nlet didWarnAboutInvalidateContextType;\n\nif (__DEV__) {\n  didWarnAboutStateAssignmentForComponent = new Set();\n  didWarnAboutUninitializedState = new Set();\n  didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();\n  didWarnAboutLegacyLifecyclesAndDerivedState = new Set();\n  didWarnAboutDirectlyAssigningPropsToState = new Set();\n  didWarnAboutUndefinedDerivedState = new Set();\n  didWarnAboutContextTypeAndContextTypes = new Set();\n  didWarnAboutInvalidateContextType = new Set();\n\n  const didWarnOnInvalidCallback = new Set();\n\n  warnOnInvalidCallback = function(callback: mixed, callerName: string) {\n    if (callback === null || typeof callback === 'function') {\n      return;\n    }\n    const key = callerName + '_' + (callback: any);\n    if (!didWarnOnInvalidCallback.has(key)) {\n      didWarnOnInvalidCallback.add(key);\n      console.error(\n        '%s(...): Expected the last optional `callback` argument to be a ' +\n          'function. Instead received: %s.',\n        callerName,\n        callback,\n      );\n    }\n  };\n\n  warnOnUndefinedDerivedState = function(type, partialState) {\n    if (partialState === undefined) {\n      const componentName = getComponentNameFromType(type) || 'Component';\n      if (!didWarnAboutUndefinedDerivedState.has(componentName)) {\n        didWarnAboutUndefinedDerivedState.add(componentName);\n        console.error(\n          '%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. ' +\n            'You have returned undefined.',\n          componentName,\n        );\n      }\n    }\n  };\n\n  // This is so gross but it's at least non-critical and can be removed if\n  // it causes problems. This is meant to give a nicer error message for\n  // ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,\n  // ...)) which otherwise throws a \"_processChildContext is not a function\"\n  // exception.\n  Object.defineProperty(fakeInternalInstance, '_processChildContext', {\n    enumerable: false,\n    value: function() {\n      throw new Error(\n        '_processChildContext is not available in React 16+. This likely ' +\n          'means you have multiple copies of React and are attempting to nest ' +\n          'a React 15 tree inside a React 16 tree using ' +\n          \"unstable_renderSubtreeIntoContainer, which isn't supported. Try \" +\n          'to make sure you have only one copy of React (and ideally, switch ' +\n          'to ReactDOM.createPortal).',\n      );\n    },\n  });\n  Object.freeze(fakeInternalInstance);\n}\n\nfunction applyDerivedStateFromProps(\n  workInProgress: Fiber,\n  ctor: any,\n  getDerivedStateFromProps: (props: any, state: any) => any,\n  nextProps: any,\n) {\n  const prevState = workInProgress.memoizedState;\n  let partialState = getDerivedStateFromProps(nextProps, prevState);\n  if (__DEV__) {\n    if (\n      debugRenderPhaseSideEffectsForStrictMode &&\n      workInProgress.mode & StrictLegacyMode\n    ) {\n      setIsStrictModeForDevtools(true);\n      try {\n        // Invoke the function an extra time to help detect side-effects.\n        partialState = getDerivedStateFromProps(nextProps, prevState);\n      } finally {\n        setIsStrictModeForDevtools(false);\n      }\n    }\n    warnOnUndefinedDerivedState(ctor, partialState);\n  }\n  // Merge the partial state and the previous state.\n  const memoizedState =\n    partialState === null || partialState === undefined\n      ? prevState\n      : Object.assign({}, prevState, partialState);\n  workInProgress.memoizedState = memoizedState;\n\n  // Once the update queue is empty, persist the derived state onto the\n  // base state.\n  if (workInProgress.lanes === NoLanes) {\n    // Queue is always non-null for classes\n    const updateQueue: UpdateQueue<any> = (workInProgress.updateQueue: any);\n    updateQueue.baseState = memoizedState;\n  }\n}\n\nconst classComponentUpdater = {\n  isMounted,\n  enqueueSetState(inst, payload, callback) {\n    const fiber = getInstance(inst);\n    const eventTime = requestEventTime();\n    const lane = requestUpdateLane(fiber);\n\n    const update = createUpdate(eventTime, lane);\n    update.payload = payload;\n    if (callback !== undefined && callback !== null) {\n      if (__DEV__) {\n        warnOnInvalidCallback(callback, 'setState');\n      }\n      update.callback = callback;\n    }\n\n    enqueueUpdate(fiber, update, lane);\n    const root = scheduleUpdateOnFiber(fiber, lane, eventTime);\n    if (root !== null) {\n      entangleTransitions(root, fiber, lane);\n    }\n\n    if (__DEV__) {\n      if (enableDebugTracing) {\n        if (fiber.mode & DebugTracingMode) {\n          const name = getComponentNameFromFiber(fiber) || 'Unknown';\n          logStateUpdateScheduled(name, lane, payload);\n        }\n      }\n    }\n\n    if (enableSchedulingProfiler) {\n      markStateUpdateScheduled(fiber, lane);\n    }\n  },\n  enqueueReplaceState(inst, payload, callback) {\n    const fiber = getInstance(inst);\n    const eventTime = requestEventTime();\n    const lane = requestUpdateLane(fiber);\n\n    const update = createUpdate(eventTime, lane);\n    update.tag = ReplaceState;\n    update.payload = payload;\n\n    if (callback !== undefined && callback !== null) {\n      if (__DEV__) {\n        warnOnInvalidCallback(callback, 'replaceState');\n      }\n      update.callback = callback;\n    }\n\n    enqueueUpdate(fiber, update, lane);\n    const root = scheduleUpdateOnFiber(fiber, lane, eventTime);\n    if (root !== null) {\n      entangleTransitions(root, fiber, lane);\n    }\n\n    if (__DEV__) {\n      if (enableDebugTracing) {\n        if (fiber.mode & DebugTracingMode) {\n          const name = getComponentNameFromFiber(fiber) || 'Unknown';\n          logStateUpdateScheduled(name, lane, payload);\n        }\n      }\n    }\n\n    if (enableSchedulingProfiler) {\n      markStateUpdateScheduled(fiber, lane);\n    }\n  },\n  enqueueForceUpdate(inst, callback) {\n    const fiber = getInstance(inst);\n    const eventTime = requestEventTime();\n    const lane = requestUpdateLane(fiber);\n\n    const update = createUpdate(eventTime, lane);\n    update.tag = ForceUpdate;\n\n    if (callback !== undefined && callback !== null) {\n      if (__DEV__) {\n        warnOnInvalidCallback(callback, 'forceUpdate');\n      }\n      update.callback = callback;\n    }\n\n    enqueueUpdate(fiber, update, lane);\n    const root = scheduleUpdateOnFiber(fiber, lane, eventTime);\n    if (root !== null) {\n      entangleTransitions(root, fiber, lane);\n    }\n\n    if (__DEV__) {\n      if (enableDebugTracing) {\n        if (fiber.mode & DebugTracingMode) {\n          const name = getComponentNameFromFiber(fiber) || 'Unknown';\n          logForceUpdateScheduled(name, lane);\n        }\n      }\n    }\n\n    if (enableSchedulingProfiler) {\n      markForceUpdateScheduled(fiber, lane);\n    }\n  },\n};\n\nfunction checkShouldComponentUpdate(\n  workInProgress,\n  ctor,\n  oldProps,\n  newProps,\n  oldState,\n  newState,\n  nextContext,\n) {\n  const instance = workInProgress.stateNode;\n  if (typeof instance.shouldComponentUpdate === 'function') {\n    let shouldUpdate = instance.shouldComponentUpdate(\n      newProps,\n      newState,\n      nextContext,\n    );\n    if (__DEV__) {\n      if (\n        debugRenderPhaseSideEffectsForStrictMode &&\n        workInProgress.mode & StrictLegacyMode\n      ) {\n        setIsStrictModeForDevtools(true);\n        try {\n          // Invoke the function an extra time to help detect side-effects.\n          shouldUpdate = instance.shouldComponentUpdate(\n            newProps,\n            newState,\n            nextContext,\n          );\n        } finally {\n          setIsStrictModeForDevtools(false);\n        }\n      }\n      if (shouldUpdate === undefined) {\n        console.error(\n          '%s.shouldComponentUpdate(): Returned undefined instead of a ' +\n            'boolean value. Make sure to return true or false.',\n          getComponentNameFromType(ctor) || 'Component',\n        );\n      }\n    }\n\n    return shouldUpdate;\n  }\n\n  if (ctor.prototype && ctor.prototype.isPureReactComponent) {\n    return (\n      !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)\n    );\n  }\n\n  return true;\n}\n\nfunction checkClassInstance(workInProgress: Fiber, ctor: any, newProps: any) {\n  const instance = workInProgress.stateNode;\n  if (__DEV__) {\n    const name = getComponentNameFromType(ctor) || 'Component';\n    const renderPresent = instance.render;\n\n    if (!renderPresent) {\n      if (ctor.prototype && typeof ctor.prototype.render === 'function') {\n        console.error(\n          '%s(...): No `render` method found on the returned component ' +\n            'instance: did you accidentally return an object from the constructor?',\n          name,\n        );\n      } else {\n        console.error(\n          '%s(...): No `render` method found on the returned component ' +\n            'instance: you may have forgotten to define `render`.',\n          name,\n        );\n      }\n    }\n\n    if (\n      instance.getInitialState &&\n      !instance.getInitialState.isReactClassApproved &&\n      !instance.state\n    ) {\n      console.error(\n        'getInitialState was defined on %s, a plain JavaScript class. ' +\n          'This is only supported for classes created using React.createClass. ' +\n          'Did you mean to define a state property instead?',\n        name,\n      );\n    }\n    if (\n      instance.getDefaultProps &&\n      !instance.getDefaultProps.isReactClassApproved\n    ) {\n      console.error(\n        'getDefaultProps was defined on %s, a plain JavaScript class. ' +\n          'This is only supported for classes created using React.createClass. ' +\n          'Use a static property to define defaultProps instead.',\n        name,\n      );\n    }\n    if (instance.propTypes) {\n      console.error(\n        'propTypes was defined as an instance property on %s. Use a static ' +\n          'property to define propTypes instead.',\n        name,\n      );\n    }\n    if (instance.contextType) {\n      console.error(\n        'contextType was defined as an instance property on %s. Use a static ' +\n          'property to define contextType instead.',\n        name,\n      );\n    }\n\n    if (disableLegacyContext) {\n      if (ctor.childContextTypes) {\n        console.error(\n          '%s uses the legacy childContextTypes API which is no longer supported. ' +\n            'Use React.createContext() instead.',\n          name,\n        );\n      }\n      if (ctor.contextTypes) {\n        console.error(\n          '%s uses the legacy contextTypes API which is no longer supported. ' +\n            'Use React.createContext() with static contextType instead.',\n          name,\n        );\n      }\n    } else {\n      if (instance.contextTypes) {\n        console.error(\n          'contextTypes was defined as an instance property on %s. Use a static ' +\n            'property to define contextTypes instead.',\n          name,\n        );\n      }\n\n      if (\n        ctor.contextType &&\n        ctor.contextTypes &&\n        !didWarnAboutContextTypeAndContextTypes.has(ctor)\n      ) {\n        didWarnAboutContextTypeAndContextTypes.add(ctor);\n        console.error(\n          '%s declares both contextTypes and contextType static properties. ' +\n            'The legacy contextTypes property will be ignored.',\n          name,\n        );\n      }\n    }\n\n    if (typeof instance.componentShouldUpdate === 'function') {\n      console.error(\n        '%s has a method called ' +\n          'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' +\n          'The name is phrased as a question because the function is ' +\n          'expected to return a value.',\n        name,\n      );\n    }\n    if (\n      ctor.prototype &&\n      ctor.prototype.isPureReactComponent &&\n      typeof instance.shouldComponentUpdate !== 'undefined'\n    ) {\n      console.error(\n        '%s has a method called shouldComponentUpdate(). ' +\n          'shouldComponentUpdate should not be used when extending React.PureComponent. ' +\n          'Please extend React.Component if shouldComponentUpdate is used.',\n        getComponentNameFromType(ctor) || 'A pure component',\n      );\n    }\n    if (typeof instance.componentDidUnmount === 'function') {\n      console.error(\n        '%s has a method called ' +\n          'componentDidUnmount(). But there is no such lifecycle method. ' +\n          'Did you mean componentWillUnmount()?',\n        name,\n      );\n    }\n    if (typeof instance.componentDidReceiveProps === 'function') {\n      console.error(\n        '%s has a method called ' +\n          'componentDidReceiveProps(). But there is no such lifecycle method. ' +\n          'If you meant to update the state in response to changing props, ' +\n          'use componentWillReceiveProps(). If you meant to fetch data or ' +\n          'run side-effects or mutations after React has updated the UI, use componentDidUpdate().',\n        name,\n      );\n    }\n    if (typeof instance.componentWillRecieveProps === 'function') {\n      console.error(\n        '%s has a method called ' +\n          'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?',\n        name,\n      );\n    }\n    if (typeof instance.UNSAFE_componentWillRecieveProps === 'function') {\n      console.error(\n        '%s has a method called ' +\n          'UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?',\n        name,\n      );\n    }\n    const hasMutatedProps = instance.props !== newProps;\n    if (instance.props !== undefined && hasMutatedProps) {\n      console.error(\n        '%s(...): When calling super() in `%s`, make sure to pass ' +\n          \"up the same props that your component's constructor was passed.\",\n        name,\n        name,\n      );\n    }\n    if (instance.defaultProps) {\n      console.error(\n        'Setting defaultProps as an instance property on %s is not supported and will be ignored.' +\n          ' Instead, define defaultProps as a static property on %s.',\n        name,\n        name,\n      );\n    }\n\n    if (\n      typeof instance.getSnapshotBeforeUpdate === 'function' &&\n      typeof instance.componentDidUpdate !== 'function' &&\n      !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)\n    ) {\n      didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);\n      console.error(\n        '%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). ' +\n          'This component defines getSnapshotBeforeUpdate() only.',\n        getComponentNameFromType(ctor),\n      );\n    }\n\n    if (typeof instance.getDerivedStateFromProps === 'function') {\n      console.error(\n        '%s: getDerivedStateFromProps() is defined as an instance method ' +\n          'and will be ignored. Instead, declare it as a static method.',\n        name,\n      );\n    }\n    if (typeof instance.getDerivedStateFromError === 'function') {\n      console.error(\n        '%s: getDerivedStateFromError() is defined as an instance method ' +\n          'and will be ignored. Instead, declare it as a static method.',\n        name,\n      );\n    }\n    if (typeof ctor.getSnapshotBeforeUpdate === 'function') {\n      console.error(\n        '%s: getSnapshotBeforeUpdate() is defined as a static method ' +\n          'and will be ignored. Instead, declare it as an instance method.',\n        name,\n      );\n    }\n    const state = instance.state;\n    if (state && (typeof state !== 'object' || isArray(state))) {\n      console.error('%s.state: must be set to an object or null', name);\n    }\n    if (\n      typeof instance.getChildContext === 'function' &&\n      typeof ctor.childContextTypes !== 'object'\n    ) {\n      console.error(\n        '%s.getChildContext(): childContextTypes must be defined in order to ' +\n          'use getChildContext().',\n        name,\n      );\n    }\n  }\n}\n\nfunction adoptClassInstance(workInProgress: Fiber, instance: any): void {\n  instance.updater = classComponentUpdater;\n  workInProgress.stateNode = instance;\n  // The instance needs access to the fiber so that it can schedule updates\n  setInstance(instance, workInProgress);\n  if (__DEV__) {\n    instance._reactInternalInstance = fakeInternalInstance;\n  }\n}\n\nfunction constructClassInstance(\n  workInProgress: Fiber,\n  ctor: any,\n  props: any,\n): any {\n  let isLegacyContextConsumer = false;\n  let unmaskedContext = emptyContextObject;\n  let context = emptyContextObject;\n  const contextType = ctor.contextType;\n\n  if (__DEV__) {\n    if ('contextType' in ctor) {\n      const isValid =\n        // Allow null for conditional declaration\n        contextType === null ||\n        (contextType !== undefined &&\n          contextType.$$typeof === REACT_CONTEXT_TYPE &&\n          contextType._context === undefined); // Not a <Context.Consumer>\n\n      if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {\n        didWarnAboutInvalidateContextType.add(ctor);\n\n        let addendum = '';\n        if (contextType === undefined) {\n          addendum =\n            ' However, it is set to undefined. ' +\n            'This can be caused by a typo or by mixing up named and default imports. ' +\n            'This can also happen due to a circular dependency, so ' +\n            'try moving the createContext() call to a separate file.';\n        } else if (typeof contextType !== 'object') {\n          addendum = ' However, it is set to a ' + typeof contextType + '.';\n        } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {\n          addendum = ' Did you accidentally pass the Context.Provider instead?';\n        } else if (contextType._context !== undefined) {\n          // <Context.Consumer>\n          addendum = ' Did you accidentally pass the Context.Consumer instead?';\n        } else {\n          addendum =\n            ' However, it is set to an object with keys {' +\n            Object.keys(contextType).join(', ') +\n            '}.';\n        }\n        console.error(\n          '%s defines an invalid contextType. ' +\n            'contextType should point to the Context object returned by React.createContext().%s',\n          getComponentNameFromType(ctor) || 'Component',\n          addendum,\n        );\n      }\n    }\n  }\n\n  if (typeof contextType === 'object' && contextType !== null) {\n    context = readContext((contextType: any));\n  } else if (!disableLegacyContext) {\n    unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\n    const contextTypes = ctor.contextTypes;\n    isLegacyContextConsumer =\n      contextTypes !== null && contextTypes !== undefined;\n    context = isLegacyContextConsumer\n      ? getMaskedContext(workInProgress, unmaskedContext)\n      : emptyContextObject;\n  }\n\n  let instance = new ctor(props, context);\n  // Instantiate twice to help detect side-effects.\n  if (__DEV__) {\n    if (\n      debugRenderPhaseSideEffectsForStrictMode &&\n      workInProgress.mode & StrictLegacyMode\n    ) {\n      setIsStrictModeForDevtools(true);\n      try {\n        instance = new ctor(props, context); // eslint-disable-line no-new\n      } finally {\n        setIsStrictModeForDevtools(false);\n      }\n    }\n  }\n\n  const state = (workInProgress.memoizedState =\n    instance.state !== null && instance.state !== undefined\n      ? instance.state\n      : null);\n  adoptClassInstance(workInProgress, instance);\n\n  if (__DEV__) {\n    if (typeof ctor.getDerivedStateFromProps === 'function' && state === null) {\n      const componentName = getComponentNameFromType(ctor) || 'Component';\n      if (!didWarnAboutUninitializedState.has(componentName)) {\n        didWarnAboutUninitializedState.add(componentName);\n        console.error(\n          '`%s` uses `getDerivedStateFromProps` but its initial state is ' +\n            '%s. This is not recommended. Instead, define the initial state by ' +\n            'assigning an object to `this.state` in the constructor of `%s`. ' +\n            'This ensures that `getDerivedStateFromProps` arguments have a consistent shape.',\n          componentName,\n          instance.state === null ? 'null' : 'undefined',\n          componentName,\n        );\n      }\n    }\n\n    // If new component APIs are defined, \"unsafe\" lifecycles won't be called.\n    // Warn about these lifecycles if they are present.\n    // Don't warn about react-lifecycles-compat polyfilled methods though.\n    if (\n      typeof ctor.getDerivedStateFromProps === 'function' ||\n      typeof instance.getSnapshotBeforeUpdate === 'function'\n    ) {\n      let foundWillMountName = null;\n      let foundWillReceivePropsName = null;\n      let foundWillUpdateName = null;\n      if (\n        typeof instance.componentWillMount === 'function' &&\n        instance.componentWillMount.__suppressDeprecationWarning !== true\n      ) {\n        foundWillMountName = 'componentWillMount';\n      } else if (typeof instance.UNSAFE_componentWillMount === 'function') {\n        foundWillMountName = 'UNSAFE_componentWillMount';\n      }\n      if (\n        typeof instance.componentWillReceiveProps === 'function' &&\n        instance.componentWillReceiveProps.__suppressDeprecationWarning !== true\n      ) {\n        foundWillReceivePropsName = 'componentWillReceiveProps';\n      } else if (\n        typeof instance.UNSAFE_componentWillReceiveProps === 'function'\n      ) {\n        foundWillReceivePropsName = 'UNSAFE_componentWillReceiveProps';\n      }\n      if (\n        typeof instance.componentWillUpdate === 'function' &&\n        instance.componentWillUpdate.__suppressDeprecationWarning !== true\n      ) {\n        foundWillUpdateName = 'componentWillUpdate';\n      } else if (typeof instance.UNSAFE_componentWillUpdate === 'function') {\n        foundWillUpdateName = 'UNSAFE_componentWillUpdate';\n      }\n      if (\n        foundWillMountName !== null ||\n        foundWillReceivePropsName !== null ||\n        foundWillUpdateName !== null\n      ) {\n        const componentName = getComponentNameFromType(ctor) || 'Component';\n        const newApiName =\n          typeof ctor.getDerivedStateFromProps === 'function'\n            ? 'getDerivedStateFromProps()'\n            : 'getSnapshotBeforeUpdate()';\n        if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(componentName)) {\n          didWarnAboutLegacyLifecyclesAndDerivedState.add(componentName);\n          console.error(\n            'Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n' +\n              '%s uses %s but also contains the following legacy lifecycles:%s%s%s\\n\\n' +\n              'The above lifecycles should be removed. Learn more about this warning here:\\n' +\n              'https://reactjs.org/link/unsafe-component-lifecycles',\n            componentName,\n            newApiName,\n            foundWillMountName !== null ? `\\n  ${foundWillMountName}` : '',\n            foundWillReceivePropsName !== null\n              ? `\\n  ${foundWillReceivePropsName}`\n              : '',\n            foundWillUpdateName !== null ? `\\n  ${foundWillUpdateName}` : '',\n          );\n        }\n      }\n    }\n  }\n\n  // Cache unmasked context so we can avoid recreating masked context unless necessary.\n  // ReactFiberContext usually updates this cache but can't for newly-created instances.\n  if (isLegacyContextConsumer) {\n    cacheContext(workInProgress, unmaskedContext, context);\n  }\n\n  return instance;\n}\n\nfunction callComponentWillMount(workInProgress, instance) {\n  const oldState = instance.state;\n\n  if (typeof instance.componentWillMount === 'function') {\n    instance.componentWillMount();\n  }\n  if (typeof instance.UNSAFE_componentWillMount === 'function') {\n    instance.UNSAFE_componentWillMount();\n  }\n\n  if (oldState !== instance.state) {\n    if (__DEV__) {\n      console.error(\n        '%s.componentWillMount(): Assigning directly to this.state is ' +\n          \"deprecated (except inside a component's \" +\n          'constructor). Use setState instead.',\n        getComponentNameFromFiber(workInProgress) || 'Component',\n      );\n    }\n    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\n  }\n}\n\nfunction callComponentWillReceiveProps(\n  workInProgress,\n  instance,\n  newProps,\n  nextContext,\n) {\n  const oldState = instance.state;\n  if (typeof instance.componentWillReceiveProps === 'function') {\n    instance.componentWillReceiveProps(newProps, nextContext);\n  }\n  if (typeof instance.UNSAFE_componentWillReceiveProps === 'function') {\n    instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);\n  }\n\n  if (instance.state !== oldState) {\n    if (__DEV__) {\n      const componentName =\n        getComponentNameFromFiber(workInProgress) || 'Component';\n      if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {\n        didWarnAboutStateAssignmentForComponent.add(componentName);\n        console.error(\n          '%s.componentWillReceiveProps(): Assigning directly to ' +\n            \"this.state is deprecated (except inside a component's \" +\n            'constructor). Use setState instead.',\n          componentName,\n        );\n      }\n    }\n    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\n  }\n}\n\n// Invokes the mount life-cycles on a previously never rendered instance.\nfunction mountClassInstance(\n  workInProgress: Fiber,\n  ctor: any,\n  newProps: any,\n  renderLanes: Lanes,\n): void {\n  if (__DEV__) {\n    checkClassInstance(workInProgress, ctor, newProps);\n  }\n\n  const instance = workInProgress.stateNode;\n  instance.props = newProps;\n  instance.state = workInProgress.memoizedState;\n  instance.refs = emptyRefsObject;\n\n  initializeUpdateQueue(workInProgress);\n\n  const contextType = ctor.contextType;\n  if (typeof contextType === 'object' && contextType !== null) {\n    instance.context = readContext(contextType);\n  } else if (disableLegacyContext) {\n    instance.context = emptyContextObject;\n  } else {\n    const unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\n    instance.context = getMaskedContext(workInProgress, unmaskedContext);\n  }\n\n  if (__DEV__) {\n    if (instance.state === newProps) {\n      const componentName = getComponentNameFromType(ctor) || 'Component';\n      if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {\n        didWarnAboutDirectlyAssigningPropsToState.add(componentName);\n        console.error(\n          '%s: It is not recommended to assign props directly to state ' +\n            \"because updates to props won't be reflected in state. \" +\n            'In most cases, it is better to use props directly.',\n          componentName,\n        );\n      }\n    }\n\n    if (workInProgress.mode & StrictLegacyMode) {\n      ReactStrictModeWarnings.recordLegacyContextWarning(\n        workInProgress,\n        instance,\n      );\n    }\n\n    if (warnAboutDeprecatedLifecycles) {\n      ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(\n        workInProgress,\n        instance,\n      );\n    }\n  }\n\n  instance.state = workInProgress.memoizedState;\n\n  const getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n  if (typeof getDerivedStateFromProps === 'function') {\n    applyDerivedStateFromProps(\n      workInProgress,\n      ctor,\n      getDerivedStateFromProps,\n      newProps,\n    );\n    instance.state = workInProgress.memoizedState;\n  }\n\n  // In order to support react-lifecycles-compat polyfilled components,\n  // Unsafe lifecycles should not be invoked for components using the new APIs.\n  if (\n    typeof ctor.getDerivedStateFromProps !== 'function' &&\n    typeof instance.getSnapshotBeforeUpdate !== 'function' &&\n    (typeof instance.UNSAFE_componentWillMount === 'function' ||\n      typeof instance.componentWillMount === 'function')\n  ) {\n    callComponentWillMount(workInProgress, instance);\n    // If we had additional state updates during this life-cycle, let's\n    // process them now.\n    processUpdateQueue(workInProgress, newProps, instance, renderLanes);\n    instance.state = workInProgress.memoizedState;\n  }\n\n  if (typeof instance.componentDidMount === 'function') {\n    let fiberFlags: Flags = Update;\n    if (enableSuspenseLayoutEffectSemantics) {\n      fiberFlags |= LayoutStatic;\n    }\n    if (\n      __DEV__ &&\n      enableStrictEffects &&\n      (workInProgress.mode & StrictEffectsMode) !== NoMode\n    ) {\n      fiberFlags |= MountLayoutDev;\n    }\n    workInProgress.flags |= fiberFlags;\n  }\n}\n\nfunction resumeMountClassInstance(\n  workInProgress: Fiber,\n  ctor: any,\n  newProps: any,\n  renderLanes: Lanes,\n): boolean {\n  const instance = workInProgress.stateNode;\n\n  const oldProps = workInProgress.memoizedProps;\n  instance.props = oldProps;\n\n  const oldContext = instance.context;\n  const contextType = ctor.contextType;\n  let nextContext = emptyContextObject;\n  if (typeof contextType === 'object' && contextType !== null) {\n    nextContext = readContext(contextType);\n  } else if (!disableLegacyContext) {\n    const nextLegacyUnmaskedContext = getUnmaskedContext(\n      workInProgress,\n      ctor,\n      true,\n    );\n    nextContext = getMaskedContext(workInProgress, nextLegacyUnmaskedContext);\n  }\n\n  const getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n  const hasNewLifecycles =\n    typeof getDerivedStateFromProps === 'function' ||\n    typeof instance.getSnapshotBeforeUpdate === 'function';\n\n  // Note: During these life-cycles, instance.props/instance.state are what\n  // ever the previously attempted to render - not the \"current\". However,\n  // during componentDidUpdate we pass the \"current\" props.\n\n  // In order to support react-lifecycles-compat polyfilled components,\n  // Unsafe lifecycles should not be invoked for components using the new APIs.\n  if (\n    !hasNewLifecycles &&\n    (typeof instance.UNSAFE_componentWillReceiveProps === 'function' ||\n      typeof instance.componentWillReceiveProps === 'function')\n  ) {\n    if (oldProps !== newProps || oldContext !== nextContext) {\n      callComponentWillReceiveProps(\n        workInProgress,\n        instance,\n        newProps,\n        nextContext,\n      );\n    }\n  }\n\n  resetHasForceUpdateBeforeProcessing();\n\n  const oldState = workInProgress.memoizedState;\n  let newState = (instance.state = oldState);\n  processUpdateQueue(workInProgress, newProps, instance, renderLanes);\n  newState = workInProgress.memoizedState;\n  if (\n    oldProps === newProps &&\n    oldState === newState &&\n    !hasContextChanged() &&\n    !checkHasForceUpdateAfterProcessing()\n  ) {\n    // If an update was already in progress, we should schedule an Update\n    // effect even though we're bailing out, so that cWU/cDU are called.\n    if (typeof instance.componentDidMount === 'function') {\n      let fiberFlags: Flags = Update;\n      if (enableSuspenseLayoutEffectSemantics) {\n        fiberFlags |= LayoutStatic;\n      }\n      if (\n        __DEV__ &&\n        enableStrictEffects &&\n        (workInProgress.mode & StrictEffectsMode) !== NoMode\n      ) {\n        fiberFlags |= MountLayoutDev;\n      }\n      workInProgress.flags |= fiberFlags;\n    }\n    return false;\n  }\n\n  if (typeof getDerivedStateFromProps === 'function') {\n    applyDerivedStateFromProps(\n      workInProgress,\n      ctor,\n      getDerivedStateFromProps,\n      newProps,\n    );\n    newState = workInProgress.memoizedState;\n  }\n\n  const shouldUpdate =\n    checkHasForceUpdateAfterProcessing() ||\n    checkShouldComponentUpdate(\n      workInProgress,\n      ctor,\n      oldProps,\n      newProps,\n      oldState,\n      newState,\n      nextContext,\n    );\n\n  if (shouldUpdate) {\n    // In order to support react-lifecycles-compat polyfilled components,\n    // Unsafe lifecycles should not be invoked for components using the new APIs.\n    if (\n      !hasNewLifecycles &&\n      (typeof instance.UNSAFE_componentWillMount === 'function' ||\n        typeof instance.componentWillMount === 'function')\n    ) {\n      if (typeof instance.componentWillMount === 'function') {\n        instance.componentWillMount();\n      }\n      if (typeof instance.UNSAFE_componentWillMount === 'function') {\n        instance.UNSAFE_componentWillMount();\n      }\n    }\n    if (typeof instance.componentDidMount === 'function') {\n      let fiberFlags: Flags = Update;\n      if (enableSuspenseLayoutEffectSemantics) {\n        fiberFlags |= LayoutStatic;\n      }\n      if (\n        __DEV__ &&\n        enableStrictEffects &&\n        (workInProgress.mode & StrictEffectsMode) !== NoMode\n      ) {\n        fiberFlags |= MountLayoutDev;\n      }\n      workInProgress.flags |= fiberFlags;\n    }\n  } else {\n    // If an update was already in progress, we should schedule an Update\n    // effect even though we're bailing out, so that cWU/cDU are called.\n    if (typeof instance.componentDidMount === 'function') {\n      let fiberFlags: Flags = Update;\n      if (enableSuspenseLayoutEffectSemantics) {\n        fiberFlags |= LayoutStatic;\n      }\n      if (\n        __DEV__ &&\n        enableStrictEffects &&\n        (workInProgress.mode & StrictEffectsMode) !== NoMode\n      ) {\n        fiberFlags |= MountLayoutDev;\n      }\n      workInProgress.flags |= fiberFlags;\n    }\n\n    // If shouldComponentUpdate returned false, we should still update the\n    // memoized state to indicate that this work can be reused.\n    workInProgress.memoizedProps = newProps;\n    workInProgress.memoizedState = newState;\n  }\n\n  // Update the existing instance's state, props, and context pointers even\n  // if shouldComponentUpdate returns false.\n  instance.props = newProps;\n  instance.state = newState;\n  instance.context = nextContext;\n\n  return shouldUpdate;\n}\n\n// Invokes the update life-cycles and returns false if it shouldn't rerender.\nfunction updateClassInstance(\n  current: Fiber,\n  workInProgress: Fiber,\n  ctor: any,\n  newProps: any,\n  renderLanes: Lanes,\n): boolean {\n  const instance = workInProgress.stateNode;\n\n  cloneUpdateQueue(current, workInProgress);\n\n  const unresolvedOldProps = workInProgress.memoizedProps;\n  const oldProps =\n    workInProgress.type === workInProgress.elementType\n      ? unresolvedOldProps\n      : resolveDefaultProps(workInProgress.type, unresolvedOldProps);\n  instance.props = oldProps;\n  const unresolvedNewProps = workInProgress.pendingProps;\n\n  const oldContext = instance.context;\n  const contextType = ctor.contextType;\n  let nextContext = emptyContextObject;\n  if (typeof contextType === 'object' && contextType !== null) {\n    nextContext = readContext(contextType);\n  } else if (!disableLegacyContext) {\n    const nextUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\n    nextContext = getMaskedContext(workInProgress, nextUnmaskedContext);\n  }\n\n  const getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n  const hasNewLifecycles =\n    typeof getDerivedStateFromProps === 'function' ||\n    typeof instance.getSnapshotBeforeUpdate === 'function';\n\n  // Note: During these life-cycles, instance.props/instance.state are what\n  // ever the previously attempted to render - not the \"current\". However,\n  // during componentDidUpdate we pass the \"current\" props.\n\n  // In order to support react-lifecycles-compat polyfilled components,\n  // Unsafe lifecycles should not be invoked for components using the new APIs.\n  if (\n    !hasNewLifecycles &&\n    (typeof instance.UNSAFE_componentWillReceiveProps === 'function' ||\n      typeof instance.componentWillReceiveProps === 'function')\n  ) {\n    if (\n      unresolvedOldProps !== unresolvedNewProps ||\n      oldContext !== nextContext\n    ) {\n      callComponentWillReceiveProps(\n        workInProgress,\n        instance,\n        newProps,\n        nextContext,\n      );\n    }\n  }\n\n  resetHasForceUpdateBeforeProcessing();\n\n  const oldState = workInProgress.memoizedState;\n  let newState = (instance.state = oldState);\n  processUpdateQueue(workInProgress, newProps, instance, renderLanes);\n  newState = workInProgress.memoizedState;\n\n  if (\n    unresolvedOldProps === unresolvedNewProps &&\n    oldState === newState &&\n    !hasContextChanged() &&\n    !checkHasForceUpdateAfterProcessing() &&\n    !(\n      enableLazyContextPropagation &&\n      current !== null &&\n      current.dependencies !== null &&\n      checkIfContextChanged(current.dependencies)\n    )\n  ) {\n    // If an update was already in progress, we should schedule an Update\n    // effect even though we're bailing out, so that cWU/cDU are called.\n    if (typeof instance.componentDidUpdate === 'function') {\n      if (\n        unresolvedOldProps !== current.memoizedProps ||\n        oldState !== current.memoizedState\n      ) {\n        workInProgress.flags |= Update;\n      }\n    }\n    if (typeof instance.getSnapshotBeforeUpdate === 'function') {\n      if (\n        unresolvedOldProps !== current.memoizedProps ||\n        oldState !== current.memoizedState\n      ) {\n        workInProgress.flags |= Snapshot;\n      }\n    }\n    return false;\n  }\n\n  if (typeof getDerivedStateFromProps === 'function') {\n    applyDerivedStateFromProps(\n      workInProgress,\n      ctor,\n      getDerivedStateFromProps,\n      newProps,\n    );\n    newState = workInProgress.memoizedState;\n  }\n\n  const shouldUpdate =\n    checkHasForceUpdateAfterProcessing() ||\n    checkShouldComponentUpdate(\n      workInProgress,\n      ctor,\n      oldProps,\n      newProps,\n      oldState,\n      newState,\n      nextContext,\n    ) ||\n    // TODO: In some cases, we'll end up checking if context has changed twice,\n    // both before and after `shouldComponentUpdate` has been called. Not ideal,\n    // but I'm loath to refactor this function. This only happens for memoized\n    // components so it's not that common.\n    (enableLazyContextPropagation &&\n      current !== null &&\n      current.dependencies !== null &&\n      checkIfContextChanged(current.dependencies));\n\n  if (shouldUpdate) {\n    // In order to support react-lifecycles-compat polyfilled components,\n    // Unsafe lifecycles should not be invoked for components using the new APIs.\n    if (\n      !hasNewLifecycles &&\n      (typeof instance.UNSAFE_componentWillUpdate === 'function' ||\n        typeof instance.componentWillUpdate === 'function')\n    ) {\n      if (typeof instance.componentWillUpdate === 'function') {\n        instance.componentWillUpdate(newProps, newState, nextContext);\n      }\n      if (typeof instance.UNSAFE_componentWillUpdate === 'function') {\n        instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext);\n      }\n    }\n    if (typeof instance.componentDidUpdate === 'function') {\n      workInProgress.flags |= Update;\n    }\n    if (typeof instance.getSnapshotBeforeUpdate === 'function') {\n      workInProgress.flags |= Snapshot;\n    }\n  } else {\n    // If an update was already in progress, we should schedule an Update\n    // effect even though we're bailing out, so that cWU/cDU are called.\n    if (typeof instance.componentDidUpdate === 'function') {\n      if (\n        unresolvedOldProps !== current.memoizedProps ||\n        oldState !== current.memoizedState\n      ) {\n        workInProgress.flags |= Update;\n      }\n    }\n    if (typeof instance.getSnapshotBeforeUpdate === 'function') {\n      if (\n        unresolvedOldProps !== current.memoizedProps ||\n        oldState !== current.memoizedState\n      ) {\n        workInProgress.flags |= Snapshot;\n      }\n    }\n\n    // If shouldComponentUpdate returned false, we should still update the\n    // memoized props/state to indicate that this work can be reused.\n    workInProgress.memoizedProps = newProps;\n    workInProgress.memoizedState = newState;\n  }\n\n  // Update the existing instance's state, props, and context pointers even\n  // if shouldComponentUpdate returns false.\n  instance.props = newProps;\n  instance.state = newState;\n  instance.context = nextContext;\n\n  return shouldUpdate;\n}\n\nexport {\n  adoptClassInstance,\n  constructClassInstance,\n  mountClassInstance,\n  resumeMountClassInstance,\n  updateClassInstance,\n};\n"]},"metadata":{},"sourceType":"module"}