{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/**\n * ReactElementValidator provides a wrapper around a element factory\n * which validates the props passed to the element. This is intended to be\n * used only in DEV and could be replaced by a static type checker for languages\n * that support it.\n */\nimport isValidElementType from 'shared/isValidElementType';\nimport getComponentNameFromType from 'shared/getComponentNameFromType';\nimport checkPropTypes from 'shared/checkPropTypes';\nimport { getIteratorFn, REACT_FORWARD_REF_TYPE, REACT_MEMO_TYPE, REACT_FRAGMENT_TYPE, REACT_ELEMENT_TYPE } from 'shared/ReactSymbols';\nimport { warnAboutSpreadingKeyToJSX } from 'shared/ReactFeatureFlags';\nimport hasOwnProperty from 'shared/hasOwnProperty';\nimport isArray from 'shared/isArray';\nimport { jsxDEV } from './ReactJSXElement';\nimport { describeUnknownElementTypeFrameInDEV } from 'shared/ReactComponentStackFrame';\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nconst ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nconst ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction setCurrentlyValidatingElement(element) {\n  if (__DEV__) {\n    if (element) {\n      const owner = element._owner;\n      const stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nlet propTypesMisspellWarningShown;\n\nif (__DEV__) {\n  propTypesMisspellWarningShown = false;\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\n\nexport function isValidElement(object) {\n  if (__DEV__) {\n    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n  }\n}\n\nfunction getDeclarationErrorAddendum() {\n  if (__DEV__) {\n    if (ReactCurrentOwner.current) {\n      const name = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (name) {\n        return '\\n\\nCheck the render method of `' + name + '`.';\n      }\n    }\n\n    return '';\n  }\n}\n\nfunction getSourceInfoErrorAddendum(source) {\n  if (__DEV__) {\n    if (source !== undefined) {\n      const fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n      const lineNumber = source.lineNumber;\n      return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n    }\n\n    return '';\n  }\n}\n/**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */\n\n\nconst ownerHasKeyUseWarning = {};\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  if (__DEV__) {\n    let info = getDeclarationErrorAddendum();\n\n    if (!info) {\n      const parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n\n      if (parentName) {\n        info = `\\n\\nCheck the top-level render call using <${parentName}>.`;\n      }\n    }\n\n    return info;\n  }\n}\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\n\nfunction validateExplicitKey(element, parentType) {\n  if (__DEV__) {\n    if (!element._store || element._store.validated || element.key != null) {\n      return;\n    }\n\n    element._store.validated = true;\n    const currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n    // property, it may be the creator of the child that's responsible for\n    // assigning it a key.\n\n    let childOwner = '';\n\n    if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n      // Give the component that originally created this child.\n      childOwner = ` It was passed a child from ${getComponentNameFromType(element._owner.type)}.`;\n    }\n\n    setCurrentlyValidatingElement(element);\n    console.error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n    setCurrentlyValidatingElement(null);\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  if (__DEV__) {\n    if (typeof node !== 'object') {\n      return;\n    }\n\n    if (isArray(node)) {\n      for (let i = 0; i < node.length; i++) {\n        const child = node[i];\n\n        if (isValidElement(child)) {\n          validateExplicitKey(child, parentType);\n        }\n      }\n    } else if (isValidElement(node)) {\n      // This element was passed in a valid location.\n      if (node._store) {\n        node._store.validated = true;\n      }\n    } else if (node) {\n      const iteratorFn = getIteratorFn(node);\n\n      if (typeof iteratorFn === 'function') {\n        // Entry iterators used to provide implicit keys,\n        // but now we print a separate warning for them later.\n        if (iteratorFn !== node.entries) {\n          const iterator = iteratorFn.call(node);\n          let step;\n\n          while (!(step = iterator.next()).done) {\n            if (isValidElement(step.value)) {\n              validateExplicitKey(step.value, parentType);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */\n\n\nfunction validatePropTypes(element) {\n  if (__DEV__) {\n    const type = element.type;\n\n    if (type === null || type === undefined || typeof type === 'string') {\n      return;\n    }\n\n    let propTypes;\n\n    if (typeof type === 'function') {\n      propTypes = type.propTypes;\n    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n    // Inner props are checked in the reconciler.\n    type.$$typeof === REACT_MEMO_TYPE)) {\n      propTypes = type.propTypes;\n    } else {\n      return;\n    }\n\n    if (propTypes) {\n      // Intentionally inside to avoid triggering lazy initializers:\n      const name = getComponentNameFromType(type);\n      checkPropTypes(propTypes, element.props, 'prop', name, element);\n    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n\n      const name = getComponentNameFromType(type);\n      console.error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', name || 'Unknown');\n    }\n\n    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {\n      console.error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\n    }\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  if (__DEV__) {\n    const keys = Object.keys(fragment.props);\n\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement(fragment);\n        console.error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n        setCurrentlyValidatingElement(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement(fragment);\n      console.error('Invalid attribute `ref` supplied to `React.Fragment`.');\n      setCurrentlyValidatingElement(null);\n    }\n  }\n}\n\nexport function jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n  if (__DEV__) {\n    const validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n    // succeed and there will likely be errors in render.\n\n    if (!validType) {\n      let info = '';\n\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      const sourceInfo = getSourceInfoErrorAddendum(source);\n\n      if (sourceInfo) {\n        info += sourceInfo;\n      } else {\n        info += getDeclarationErrorAddendum();\n      }\n\n      let typeString;\n\n      if (type === null) {\n        typeString = 'null';\n      } else if (isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = `<${getComponentNameFromType(type.type) || 'Unknown'} />`;\n        info = ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      console.error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    }\n\n    const element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n    // TODO: Drop this when these are no longer allowed as the type argument.\n\n    if (element == null) {\n      return element;\n    } // Skip key warning if the type isn't valid since our key validation logic\n    // doesn't expect a non-string/function type and can throw confusing errors.\n    // We don't want exception behavior to differ between dev and prod.\n    // (Rendering will throw with a helpful message and as soon as the type is\n    // fixed, the key warnings will appear.)\n\n\n    if (validType) {\n      const children = props.children;\n\n      if (children !== undefined) {\n        if (isStaticChildren) {\n          if (isArray(children)) {\n            for (let i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            console.error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    }\n\n    if (warnAboutSpreadingKeyToJSX) {\n      if (hasOwnProperty.call(props, 'key')) {\n        console.error('React.jsx: Spreading a key to JSX is a deprecated pattern. ' + 'Explicitly pass a key after spreading props in your JSX call. ' + 'E.g. <%s {...props} key={key} />', getComponentNameFromType(type) || 'ComponentName');\n      }\n    }\n\n    if (type === REACT_FRAGMENT_TYPE) {\n      validateFragmentProps(element);\n    } else {\n      validatePropTypes(element);\n    }\n\n    return element;\n  }\n} // These two functions exist to still get child warnings in dev\n// even with the prod transform. This means that jsxDEV is purely\n// opt-in behavior for better messages but that we won't stop\n// giving you warnings if you use production apis.\n\nexport function jsxWithValidationStatic(type, props, key) {\n  if (__DEV__) {\n    return jsxWithValidation(type, props, key, true);\n  }\n}\nexport function jsxWithValidationDynamic(type, props, key) {\n  if (__DEV__) {\n    return jsxWithValidation(type, props, key, false);\n  }\n}","map":{"version":3,"sources":["/Users/zhangshuo/git/react-source-test/src/react/packages/react/src/jsx/ReactJSXElementValidator.js"],"names":["isValidElementType","getComponentNameFromType","checkPropTypes","getIteratorFn","REACT_FORWARD_REF_TYPE","REACT_MEMO_TYPE","REACT_FRAGMENT_TYPE","REACT_ELEMENT_TYPE","warnAboutSpreadingKeyToJSX","hasOwnProperty","isArray","jsxDEV","describeUnknownElementTypeFrameInDEV","ReactSharedInternals","ReactCurrentOwner","ReactDebugCurrentFrame","setCurrentlyValidatingElement","element","__DEV__","owner","_owner","stack","type","_source","setExtraStackFrame","propTypesMisspellWarningShown","isValidElement","object","$$typeof","getDeclarationErrorAddendum","current","name","getSourceInfoErrorAddendum","source","undefined","fileName","replace","lineNumber","ownerHasKeyUseWarning","getCurrentComponentErrorInfo","parentType","info","parentName","displayName","validateExplicitKey","_store","validated","key","currentComponentErrorInfo","childOwner","console","error","validateChildKeys","node","i","length","child","iteratorFn","entries","iterator","call","step","next","done","value","validatePropTypes","propTypes","props","PropTypes","getDefaultProps","isReactClassApproved","validateFragmentProps","fragment","keys","Object","ref","jsxWithValidation","isStaticChildren","self","validType","sourceInfo","typeString","children","freeze","jsxWithValidationStatic","jsxWithValidationDynamic"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/**\n * ReactElementValidator provides a wrapper around a element factory\n * which validates the props passed to the element. This is intended to be\n * used only in DEV and could be replaced by a static type checker for languages\n * that support it.\n */\nimport isValidElementType from 'shared/isValidElementType';\nimport getComponentNameFromType from 'shared/getComponentNameFromType';\nimport checkPropTypes from 'shared/checkPropTypes';\nimport {\n  getIteratorFn,\n  REACT_FORWARD_REF_TYPE,\n  REACT_MEMO_TYPE,\n  REACT_FRAGMENT_TYPE,\n  REACT_ELEMENT_TYPE,\n} from 'shared/ReactSymbols';\nimport {warnAboutSpreadingKeyToJSX} from 'shared/ReactFeatureFlags';\nimport hasOwnProperty from 'shared/hasOwnProperty';\nimport isArray from 'shared/isArray';\nimport {jsxDEV} from './ReactJSXElement';\n\nimport {describeUnknownElementTypeFrameInDEV} from 'shared/ReactComponentStackFrame';\n\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\n\nconst ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nconst ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction setCurrentlyValidatingElement(element) {\n  if (__DEV__) {\n    if (element) {\n      const owner = element._owner;\n      const stack = describeUnknownElementTypeFrameInDEV(\n        element.type,\n        element._source,\n        owner ? owner.type : null,\n      );\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nlet propTypesMisspellWarningShown;\n\nif (__DEV__) {\n  propTypesMisspellWarningShown = false;\n}\n\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\nexport function isValidElement(object) {\n  if (__DEV__) {\n    return (\n      typeof object === 'object' &&\n      object !== null &&\n      object.$$typeof === REACT_ELEMENT_TYPE\n    );\n  }\n}\n\nfunction getDeclarationErrorAddendum() {\n  if (__DEV__) {\n    if (ReactCurrentOwner.current) {\n      const name = getComponentNameFromType(ReactCurrentOwner.current.type);\n      if (name) {\n        return '\\n\\nCheck the render method of `' + name + '`.';\n      }\n    }\n    return '';\n  }\n}\n\nfunction getSourceInfoErrorAddendum(source) {\n  if (__DEV__) {\n    if (source !== undefined) {\n      const fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n      const lineNumber = source.lineNumber;\n      return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n    }\n    return '';\n  }\n}\n\n/**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */\nconst ownerHasKeyUseWarning = {};\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  if (__DEV__) {\n    let info = getDeclarationErrorAddendum();\n\n    if (!info) {\n      const parentName =\n        typeof parentType === 'string'\n          ? parentType\n          : parentType.displayName || parentType.name;\n      if (parentName) {\n        info = `\\n\\nCheck the top-level render call using <${parentName}>.`;\n      }\n    }\n    return info;\n  }\n}\n\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\nfunction validateExplicitKey(element, parentType) {\n  if (__DEV__) {\n    if (!element._store || element._store.validated || element.key != null) {\n      return;\n    }\n    element._store.validated = true;\n\n    const currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true;\n\n    // Usually the current owner is the offender, but if it accepts children as a\n    // property, it may be the creator of the child that's responsible for\n    // assigning it a key.\n    let childOwner = '';\n    if (\n      element &&\n      element._owner &&\n      element._owner !== ReactCurrentOwner.current\n    ) {\n      // Give the component that originally created this child.\n      childOwner = ` It was passed a child from ${getComponentNameFromType(\n        element._owner.type,\n      )}.`;\n    }\n\n    setCurrentlyValidatingElement(element);\n    console.error(\n      'Each child in a list should have a unique \"key\" prop.' +\n        '%s%s See https://reactjs.org/link/warning-keys for more information.',\n      currentComponentErrorInfo,\n      childOwner,\n    );\n    setCurrentlyValidatingElement(null);\n  }\n}\n\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\nfunction validateChildKeys(node, parentType) {\n  if (__DEV__) {\n    if (typeof node !== 'object') {\n      return;\n    }\n    if (isArray(node)) {\n      for (let i = 0; i < node.length; i++) {\n        const child = node[i];\n        if (isValidElement(child)) {\n          validateExplicitKey(child, parentType);\n        }\n      }\n    } else if (isValidElement(node)) {\n      // This element was passed in a valid location.\n      if (node._store) {\n        node._store.validated = true;\n      }\n    } else if (node) {\n      const iteratorFn = getIteratorFn(node);\n      if (typeof iteratorFn === 'function') {\n        // Entry iterators used to provide implicit keys,\n        // but now we print a separate warning for them later.\n        if (iteratorFn !== node.entries) {\n          const iterator = iteratorFn.call(node);\n          let step;\n          while (!(step = iterator.next()).done) {\n            if (isValidElement(step.value)) {\n              validateExplicitKey(step.value, parentType);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\n/**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */\nfunction validatePropTypes(element) {\n  if (__DEV__) {\n    const type = element.type;\n    if (type === null || type === undefined || typeof type === 'string') {\n      return;\n    }\n    let propTypes;\n    if (typeof type === 'function') {\n      propTypes = type.propTypes;\n    } else if (\n      typeof type === 'object' &&\n      (type.$$typeof === REACT_FORWARD_REF_TYPE ||\n        // Note: Memo only checks outer props here.\n        // Inner props are checked in the reconciler.\n        type.$$typeof === REACT_MEMO_TYPE)\n    ) {\n      propTypes = type.propTypes;\n    } else {\n      return;\n    }\n    if (propTypes) {\n      // Intentionally inside to avoid triggering lazy initializers:\n      const name = getComponentNameFromType(type);\n      checkPropTypes(propTypes, element.props, 'prop', name, element);\n    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n      propTypesMisspellWarningShown = true;\n      // Intentionally inside to avoid triggering lazy initializers:\n      const name = getComponentNameFromType(type);\n      console.error(\n        'Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?',\n        name || 'Unknown',\n      );\n    }\n    if (\n      typeof type.getDefaultProps === 'function' &&\n      !type.getDefaultProps.isReactClassApproved\n    ) {\n      console.error(\n        'getDefaultProps is only used on classic React.createClass ' +\n          'definitions. Use a static property named `defaultProps` instead.',\n      );\n    }\n  }\n}\n\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\nfunction validateFragmentProps(fragment) {\n  if (__DEV__) {\n    const keys = Object.keys(fragment.props);\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement(fragment);\n        console.error(\n          'Invalid prop `%s` supplied to `React.Fragment`. ' +\n            'React.Fragment can only have `key` and `children` props.',\n          key,\n        );\n        setCurrentlyValidatingElement(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement(fragment);\n      console.error('Invalid attribute `ref` supplied to `React.Fragment`.');\n      setCurrentlyValidatingElement(null);\n    }\n  }\n}\n\nexport function jsxWithValidation(\n  type,\n  props,\n  key,\n  isStaticChildren,\n  source,\n  self,\n) {\n  if (__DEV__) {\n    const validType = isValidElementType(type);\n\n    // We warn in this case but don't throw. We expect the element creation to\n    // succeed and there will likely be errors in render.\n    if (!validType) {\n      let info = '';\n      if (\n        type === undefined ||\n        (typeof type === 'object' &&\n          type !== null &&\n          Object.keys(type).length === 0)\n      ) {\n        info +=\n          ' You likely forgot to export your component from the file ' +\n          \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      const sourceInfo = getSourceInfoErrorAddendum(source);\n      if (sourceInfo) {\n        info += sourceInfo;\n      } else {\n        info += getDeclarationErrorAddendum();\n      }\n\n      let typeString;\n      if (type === null) {\n        typeString = 'null';\n      } else if (isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = `<${getComponentNameFromType(type.type) || 'Unknown'} />`;\n        info =\n          ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      console.error(\n        'React.jsx: type is invalid -- expected a string (for ' +\n          'built-in components) or a class/function (for composite ' +\n          'components) but got: %s.%s',\n        typeString,\n        info,\n      );\n    }\n\n    const element = jsxDEV(type, props, key, source, self);\n\n    // The result can be nullish if a mock or a custom function is used.\n    // TODO: Drop this when these are no longer allowed as the type argument.\n    if (element == null) {\n      return element;\n    }\n\n    // Skip key warning if the type isn't valid since our key validation logic\n    // doesn't expect a non-string/function type and can throw confusing errors.\n    // We don't want exception behavior to differ between dev and prod.\n    // (Rendering will throw with a helpful message and as soon as the type is\n    // fixed, the key warnings will appear.)\n\n    if (validType) {\n      const children = props.children;\n      if (children !== undefined) {\n        if (isStaticChildren) {\n          if (isArray(children)) {\n            for (let i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            console.error(\n              'React.jsx: Static children should always be an array. ' +\n                'You are likely explicitly calling React.jsxs or React.jsxDEV. ' +\n                'Use the Babel transform instead.',\n            );\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    }\n\n    if (warnAboutSpreadingKeyToJSX) {\n      if (hasOwnProperty.call(props, 'key')) {\n        console.error(\n          'React.jsx: Spreading a key to JSX is a deprecated pattern. ' +\n            'Explicitly pass a key after spreading props in your JSX call. ' +\n            'E.g. <%s {...props} key={key} />',\n          getComponentNameFromType(type) || 'ComponentName',\n        );\n      }\n    }\n\n    if (type === REACT_FRAGMENT_TYPE) {\n      validateFragmentProps(element);\n    } else {\n      validatePropTypes(element);\n    }\n\n    return element;\n  }\n}\n\n// These two functions exist to still get child warnings in dev\n// even with the prod transform. This means that jsxDEV is purely\n// opt-in behavior for better messages but that we won't stop\n// giving you warnings if you use production apis.\nexport function jsxWithValidationStatic(type, props, key) {\n  if (__DEV__) {\n    return jsxWithValidation(type, props, key, true);\n  }\n}\n\nexport function jsxWithValidationDynamic(type, props, key) {\n  if (__DEV__) {\n    return jsxWithValidation(type, props, key, false);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}