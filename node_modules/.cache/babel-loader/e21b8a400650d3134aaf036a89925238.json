{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport checkPropTypes from 'shared/checkPropTypes';\nimport { markComponentRenderStarted, markComponentRenderStopped } from './SchedulingProfiler';\nimport { IndeterminateComponent, FunctionComponent, ClassComponent, HostRoot, HostComponent, HostText, HostPortal, ForwardRef, Fragment, Mode, ContextProvider, ContextConsumer, Profiler, SuspenseComponent, SuspenseListComponent, MemoComponent, SimpleMemoComponent, LazyComponent, IncompleteClassComponent, ScopeComponent, OffscreenComponent, LegacyHiddenComponent, CacheComponent } from './ReactWorkTags';\nimport { NoFlags, PerformedWork, Placement, Hydrating, ContentReset, DidCapture, Update, Ref, RefStatic, ChildDeletion, ForceUpdateForLegacySuspense, StaticMask, ShouldCapture, ForceClientRender } from './ReactFiberFlags';\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nimport { debugRenderPhaseSideEffectsForStrictMode, disableLegacyContext, disableModulePatternComponents, enableProfilerCommitHooks, enableProfilerTimer, enableSuspenseServerRenderer, warnAboutDefaultPropsOnFunctionComponents, enableScopeAPI, enableCache, enableLazyContextPropagation, enableSuspenseLayoutEffectSemantics, enableSchedulingProfiler, enablePersistentOffscreenHostContainer } from 'shared/ReactFeatureFlags';\nimport isArray from 'shared/isArray';\nimport shallowEqual from 'shared/shallowEqual';\nimport getComponentNameFromFiber from 'react-reconciler/src/getComponentNameFromFiber';\nimport getComponentNameFromType from 'shared/getComponentNameFromType';\nimport ReactStrictModeWarnings from './ReactStrictModeWarnings.new';\nimport { REACT_LAZY_TYPE, getIteratorFn } from 'shared/ReactSymbols';\nimport { getCurrentFiberOwnerNameInDevOrNull, setIsRendering } from './ReactCurrentFiber';\nimport { resolveFunctionForHotReloading, resolveForwardRefForHotReloading, resolveClassForHotReloading } from './ReactFiberHotReloading.new';\nimport { mountChildFibers, reconcileChildFibers, cloneChildFibers } from './ReactChildFiber.new';\nimport { processUpdateQueue, cloneUpdateQueue, initializeUpdateQueue, enqueueCapturedUpdate } from './ReactUpdateQueue.new';\nimport { NoLane, NoLanes, SyncLane, OffscreenLane, DefaultHydrationLane, SomeRetryLane, NoTimestamp, includesSomeLane, laneToLanes, removeLanes, mergeLanes, getBumpedLaneForHydration, pickArbitraryLane } from './ReactFiberLane.new';\nimport { ConcurrentMode, NoMode, ProfileMode, StrictLegacyMode } from './ReactTypeOfMode';\nimport { shouldSetTextContent, isSuspenseInstancePending, isSuspenseInstanceFallback, registerSuspenseInstanceRetry, supportsHydration, isPrimaryRenderer, supportsPersistence, getOffscreenContainerProps } from './ReactFiberHostConfig';\nimport { shouldError, shouldSuspend } from './ReactFiberReconciler';\nimport { pushHostContext, pushHostContainer } from './ReactFiberHostContext.new';\nimport { suspenseStackCursor, pushSuspenseContext, InvisibleParentSuspenseContext, ForceSuspenseFallback, hasSuspenseContext, setDefaultShallowSuspenseContext, addSubtreeSuspenseContext, setShallowSuspenseContext } from './ReactFiberSuspenseContext.new';\nimport { findFirstSuspended } from './ReactFiberSuspenseComponent.new';\nimport { pushProvider, propagateContextChange, lazilyPropagateParentContextChanges, propagateParentContextChangesToDeferredTree, checkIfContextChanged, readContext, prepareToReadContext, scheduleWorkOnParentPath } from './ReactFiberNewContext.new';\nimport { renderWithHooks, checkDidRenderIdHook, bailoutHooks } from './ReactFiberHooks.new';\nimport { stopProfilerTimerIfRunning } from './ReactProfilerTimer.new';\nimport { getMaskedContext, getUnmaskedContext, hasContextChanged as hasLegacyContextChanged, pushContextProvider as pushLegacyContextProvider, isContextProvider as isLegacyContextProvider, pushTopLevelContextObject, invalidateContextProvider } from './ReactFiberContext.new';\nimport { getIsHydrating, enterHydrationState, reenterHydrationStateFromDehydratedSuspenseInstance, resetHydrationState, tryToClaimNextHydratableInstance, warnIfHydrating } from './ReactFiberHydrationContext.new';\nimport { adoptClassInstance, constructClassInstance, mountClassInstance, resumeMountClassInstance, updateClassInstance } from './ReactFiberClassComponent.new';\nimport { resolveDefaultProps } from './ReactFiberLazyComponent.new';\nimport { resolveLazyComponentTag, createFiberFromTypeAndProps, createFiberFromFragment, createFiberFromOffscreen, createWorkInProgress, createOffscreenHostContainerFiber, isSimpleFunctionComponent } from './ReactFiber.new';\nimport { retryDehydratedSuspenseBoundary, scheduleUpdateOnFiber, renderDidSuspendDelayIfPossible, markSkippedUpdateLanes, getWorkInProgressRoot, pushRenderLanes, getExecutionContext, RetryAfterError, NoContext } from './ReactFiberWorkLoop.new';\nimport { setWorkInProgressVersion } from './ReactMutableSource.new';\nimport { requestCacheFromPool, pushCacheProvider, pushRootCachePool, CacheContext, getSuspendedCachePool, restoreSpawnedCachePool, getOffscreenDeferredCachePool } from './ReactFiberCacheComponent.new';\nimport { createCapturedValue } from './ReactCapturedValue';\nimport { createClassErrorUpdate } from './ReactFiberThrow.new';\nimport { completeSuspendedOffscreenHostContainer } from './ReactFiberCompleteWork.new';\nimport is from 'shared/objectIs';\nimport { setIsStrictModeForDevtools } from './ReactFiberDevToolsHook.new';\nimport { getForksAtLevel, isForkedChild, pushTreeId, pushMaterializedTreeId } from './ReactFiberTreeContext.new';\nconst ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nlet didReceiveUpdate = false;\nlet didWarnAboutBadClass;\nlet didWarnAboutModulePatternComponent;\nlet didWarnAboutContextTypeOnFunctionComponent;\nlet didWarnAboutGetDerivedStateOnFunctionComponent;\nlet didWarnAboutFunctionRefs;\nexport let didWarnAboutReassigningProps;\nlet didWarnAboutRevealOrder;\nlet didWarnAboutTailOptions;\nlet didWarnAboutDefaultPropsOnFunctionComponent;\n\nif (__DEV__) {\n  didWarnAboutBadClass = {};\n  didWarnAboutModulePatternComponent = {};\n  didWarnAboutContextTypeOnFunctionComponent = {};\n  didWarnAboutGetDerivedStateOnFunctionComponent = {};\n  didWarnAboutFunctionRefs = {};\n  didWarnAboutReassigningProps = false;\n  didWarnAboutRevealOrder = {};\n  didWarnAboutTailOptions = {};\n  didWarnAboutDefaultPropsOnFunctionComponent = {};\n}\n\nexport function reconcileChildren(current, workInProgress, nextChildren, renderLanes) {\n  if (current === null) {\n    // If this is a fresh new component that hasn't been rendered yet, we\n    // won't update its child set by applying minimal side-effects. Instead,\n    // we will add them all to the child before it gets rendered. That means\n    // we can optimize this reconciliation pass by not tracking side-effects.\n    workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderLanes);\n  } else {\n    // If the current child is the same as the work in progress, it means that\n    // we haven't yet started any work on these children. Therefore, we use\n    // the clone algorithm to create a copy of all the current children.\n    // If we had any progressed work already, that is invalid at this point so\n    // let's throw it out.\n    workInProgress.child = reconcileChildFibers(workInProgress, current.child, nextChildren, renderLanes);\n  }\n}\n\nfunction forceUnmountCurrentAndReconcile(current, workInProgress, nextChildren, renderLanes) {\n  // This function is fork of reconcileChildren. It's used in cases where we\n  // want to reconcile without matching against the existing set. This has the\n  // effect of all current children being unmounted; even if the type and key\n  // are the same, the old child is unmounted and a new child is created.\n  //\n  // To do this, we're going to go through the reconcile algorithm twice. In\n  // the first pass, we schedule a deletion for all the current children by\n  // passing null.\n  workInProgress.child = reconcileChildFibers(workInProgress, current.child, null, renderLanes); // In the second pass, we mount the new children. The trick here is that we\n  // pass null in place of where we usually pass the current child set. This has\n  // the effect of remounting all children regardless of whether their\n  // identities match.\n\n  workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderLanes);\n}\n\nfunction updateForwardRef(current, workInProgress, Component, nextProps, renderLanes) {\n  // TODO: current can be non-null here even if the component\n  // hasn't yet mounted. This happens after the first render suspends.\n  // We'll need to figure out if this is fine or can cause issues.\n  if (__DEV__) {\n    if (workInProgress.type !== workInProgress.elementType) {\n      // Lazy component props can't be validated in createElement\n      // because they're only guaranteed to be resolved here.\n      const innerPropTypes = Component.propTypes;\n\n      if (innerPropTypes) {\n        checkPropTypes(innerPropTypes, nextProps, // Resolved props\n        'prop', getComponentNameFromType(Component));\n      }\n    }\n  }\n\n  const render = Component.render;\n  const ref = workInProgress.ref; // The rest is a fork of updateFunctionComponent\n\n  let nextChildren;\n  let hasId;\n  prepareToReadContext(workInProgress, renderLanes);\n\n  if (enableSchedulingProfiler) {\n    markComponentRenderStarted(workInProgress);\n  }\n\n  if (__DEV__) {\n    ReactCurrentOwner.current = workInProgress;\n    setIsRendering(true);\n    nextChildren = renderWithHooks(current, workInProgress, render, nextProps, ref, renderLanes);\n    hasId = checkDidRenderIdHook();\n\n    if (debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictLegacyMode) {\n      setIsStrictModeForDevtools(true);\n\n      try {\n        nextChildren = renderWithHooks(current, workInProgress, render, nextProps, ref, renderLanes);\n        hasId = checkDidRenderIdHook();\n      } finally {\n        setIsStrictModeForDevtools(false);\n      }\n    }\n\n    setIsRendering(false);\n  } else {\n    nextChildren = renderWithHooks(current, workInProgress, render, nextProps, ref, renderLanes);\n    hasId = checkDidRenderIdHook();\n  }\n\n  if (enableSchedulingProfiler) {\n    markComponentRenderStopped();\n  }\n\n  if (current !== null && !didReceiveUpdate) {\n    bailoutHooks(current, workInProgress, renderLanes);\n    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n  }\n\n  if (getIsHydrating() && hasId) {\n    pushMaterializedTreeId(workInProgress);\n  } // React DevTools reads this flag.\n\n\n  workInProgress.flags |= PerformedWork;\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\nfunction updateMemoComponent(current, workInProgress, Component, nextProps, renderLanes) {\n  if (current === null) {\n    const type = Component.type;\n\n    if (isSimpleFunctionComponent(type) && Component.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.\n    Component.defaultProps === undefined) {\n      let resolvedType = type;\n\n      if (__DEV__) {\n        resolvedType = resolveFunctionForHotReloading(type);\n      } // If this is a plain function component without default props,\n      // and with only the default shallow comparison, we upgrade it\n      // to a SimpleMemoComponent to allow fast path updates.\n\n\n      workInProgress.tag = SimpleMemoComponent;\n      workInProgress.type = resolvedType;\n\n      if (__DEV__) {\n        validateFunctionComponentInDev(workInProgress, type);\n      }\n\n      return updateSimpleMemoComponent(current, workInProgress, resolvedType, nextProps, renderLanes);\n    }\n\n    if (__DEV__) {\n      const innerPropTypes = type.propTypes;\n\n      if (innerPropTypes) {\n        // Inner memo component props aren't currently validated in createElement.\n        // We could move it there, but we'd still need this for lazy code path.\n        checkPropTypes(innerPropTypes, nextProps, // Resolved props\n        'prop', getComponentNameFromType(type));\n      }\n    }\n\n    const child = createFiberFromTypeAndProps(Component.type, null, nextProps, workInProgress, workInProgress.mode, renderLanes);\n    child.ref = workInProgress.ref;\n    child.return = workInProgress;\n    workInProgress.child = child;\n    return child;\n  }\n\n  if (__DEV__) {\n    const type = Component.type;\n    const innerPropTypes = type.propTypes;\n\n    if (innerPropTypes) {\n      // Inner memo component props aren't currently validated in createElement.\n      // We could move it there, but we'd still need this for lazy code path.\n      checkPropTypes(innerPropTypes, nextProps, // Resolved props\n      'prop', getComponentNameFromType(type));\n    }\n  }\n\n  const currentChild = current.child; // This is always exactly one child\n\n  const hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current, renderLanes);\n\n  if (!hasScheduledUpdateOrContext) {\n    // This will be the props with resolved defaultProps,\n    // unlike current.memoizedProps which will be the unresolved ones.\n    const prevProps = currentChild.memoizedProps; // Default to shallow comparison\n\n    let compare = Component.compare;\n    compare = compare !== null ? compare : shallowEqual;\n\n    if (compare(prevProps, nextProps) && current.ref === workInProgress.ref) {\n      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n    }\n  } // React DevTools reads this flag.\n\n\n  workInProgress.flags |= PerformedWork;\n  const newChild = createWorkInProgress(currentChild, nextProps);\n  newChild.ref = workInProgress.ref;\n  newChild.return = workInProgress;\n  workInProgress.child = newChild;\n  return newChild;\n}\n\nfunction updateSimpleMemoComponent(current, workInProgress, Component, nextProps, renderLanes) {\n  // TODO: current can be non-null here even if the component\n  // hasn't yet mounted. This happens when the inner render suspends.\n  // We'll need to figure out if this is fine or can cause issues.\n  if (__DEV__) {\n    if (workInProgress.type !== workInProgress.elementType) {\n      // Lazy component props can't be validated in createElement\n      // because they're only guaranteed to be resolved here.\n      let outerMemoType = workInProgress.elementType;\n\n      if (outerMemoType.$$typeof === REACT_LAZY_TYPE) {\n        // We warn when you define propTypes on lazy()\n        // so let's just skip over it to find memo() outer wrapper.\n        // Inner props for memo are validated later.\n        const lazyComponent = outerMemoType;\n        const payload = lazyComponent._payload;\n        const init = lazyComponent._init;\n\n        try {\n          outerMemoType = init(payload);\n        } catch (x) {\n          outerMemoType = null;\n        } // Inner propTypes will be validated in the function component path.\n\n\n        const outerPropTypes = outerMemoType && outerMemoType.propTypes;\n\n        if (outerPropTypes) {\n          checkPropTypes(outerPropTypes, nextProps, // Resolved (SimpleMemoComponent has no defaultProps)\n          'prop', getComponentNameFromType(outerMemoType));\n        }\n      }\n    }\n  }\n\n  if (current !== null) {\n    const prevProps = current.memoizedProps;\n\n    if (shallowEqual(prevProps, nextProps) && current.ref === workInProgress.ref && ( // Prevent bailout if the implementation changed due to hot reload.\n    __DEV__ ? workInProgress.type === current.type : true)) {\n      didReceiveUpdate = false;\n\n      if (!checkScheduledUpdateOrContext(current, renderLanes)) {\n        // The pending lanes were cleared at the beginning of beginWork. We're\n        // about to bail out, but there might be other lanes that weren't\n        // included in the current render. Usually, the priority level of the\n        // remaining updates is accumulated during the evaluation of the\n        // component (i.e. when processing the update queue). But since since\n        // we're bailing out early *without* evaluating the component, we need\n        // to account for it here, too. Reset to the value of the current fiber.\n        // NOTE: This only applies to SimpleMemoComponent, not MemoComponent,\n        // because a MemoComponent fiber does not have hooks or an update queue;\n        // rather, it wraps around an inner component, which may or may not\n        // contains hooks.\n        // TODO: Move the reset at in beginWork out of the common path so that\n        // this is no longer necessary.\n        workInProgress.lanes = current.lanes;\n        return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n      } else if ((current.flags & ForceUpdateForLegacySuspense) !== NoFlags) {\n        // This is a special case that only exists for legacy mode.\n        // See https://github.com/facebook/react/pull/19216.\n        didReceiveUpdate = true;\n      }\n    }\n  }\n\n  return updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes);\n}\n\nfunction updateOffscreenComponent(current, workInProgress, renderLanes) {\n  const nextProps = workInProgress.pendingProps;\n  const nextChildren = nextProps.children;\n  const prevState = current !== null ? current.memoizedState : null; // If this is not null, this is a cache pool that was carried over from the\n  // previous render. We will push this to the cache pool context so that we can\n  // resume in-flight requests.\n\n  let spawnedCachePool = null;\n\n  if (nextProps.mode === 'hidden' || nextProps.mode === 'unstable-defer-without-hiding') {\n    // Rendering a hidden tree.\n    if ((workInProgress.mode & ConcurrentMode) === NoMode) {\n      // In legacy sync mode, don't defer the subtree. Render it now.\n      const nextState = {\n        baseLanes: NoLanes,\n        cachePool: null\n      };\n      workInProgress.memoizedState = nextState;\n      pushRenderLanes(workInProgress, renderLanes);\n    } else if (!includesSomeLane(renderLanes, OffscreenLane)) {\n      // We're hidden, and we're not rendering at Offscreen. We will bail out\n      // and resume this tree later.\n      let nextBaseLanes;\n\n      if (prevState !== null) {\n        const prevBaseLanes = prevState.baseLanes;\n        nextBaseLanes = mergeLanes(prevBaseLanes, renderLanes);\n\n        if (enableCache) {\n          // Save the cache pool so we can resume later.\n          spawnedCachePool = getOffscreenDeferredCachePool(); // We don't need to push to the cache pool because we're about to\n          // bail out. There won't be a context mismatch because we only pop\n          // the cache pool if `updateQueue` is non-null.\n        }\n      } else {\n        nextBaseLanes = renderLanes;\n      } // Schedule this fiber to re-render at offscreen priority. Then bailout.\n\n\n      workInProgress.lanes = workInProgress.childLanes = laneToLanes(OffscreenLane);\n      const nextState = {\n        baseLanes: nextBaseLanes,\n        cachePool: spawnedCachePool\n      };\n      workInProgress.memoizedState = nextState;\n      workInProgress.updateQueue = null; // We're about to bail out, but we need to push this to the stack anyway\n      // to avoid a push/pop misalignment.\n\n      pushRenderLanes(workInProgress, nextBaseLanes);\n\n      if (enableLazyContextPropagation && current !== null) {\n        // Since this tree will resume rendering in a separate render, we need\n        // to propagate parent contexts now so we don't lose track of which\n        // ones changed.\n        propagateParentContextChangesToDeferredTree(current, workInProgress, renderLanes);\n      }\n\n      return null;\n    } else {\n      // This is the second render. The surrounding visible content has already\n      // committed. Now we resume rendering the hidden tree.\n      if (enableCache && prevState !== null) {\n        // If the render that spawned this one accessed the cache pool, resume\n        // using the same cache. Unless the parent changed, since that means\n        // there was a refresh.\n        const prevCachePool = prevState.cachePool;\n\n        if (prevCachePool !== null) {\n          spawnedCachePool = restoreSpawnedCachePool(workInProgress, prevCachePool);\n        }\n      } // Rendering at offscreen, so we can clear the base lanes.\n\n\n      const nextState = {\n        baseLanes: NoLanes,\n        cachePool: null\n      };\n      workInProgress.memoizedState = nextState; // Push the lanes that were skipped when we bailed out.\n\n      const subtreeRenderLanes = prevState !== null ? prevState.baseLanes : renderLanes;\n      pushRenderLanes(workInProgress, subtreeRenderLanes);\n    }\n  } else {\n    // Rendering a visible tree.\n    let subtreeRenderLanes;\n\n    if (prevState !== null) {\n      // We're going from hidden -> visible.\n      subtreeRenderLanes = mergeLanes(prevState.baseLanes, renderLanes);\n\n      if (enableCache) {\n        // If the render that spawned this one accessed the cache pool, resume\n        // using the same cache. Unless the parent changed, since that means\n        // there was a refresh.\n        const prevCachePool = prevState.cachePool;\n\n        if (prevCachePool !== null) {\n          spawnedCachePool = restoreSpawnedCachePool(workInProgress, prevCachePool);\n        }\n      } // Since we're not hidden anymore, reset the state\n\n\n      workInProgress.memoizedState = null;\n    } else {\n      // We weren't previously hidden, and we still aren't, so there's nothing\n      // special to do. Need to push to the stack regardless, though, to avoid\n      // a push/pop misalignment.\n      subtreeRenderLanes = renderLanes;\n    }\n\n    pushRenderLanes(workInProgress, subtreeRenderLanes);\n  }\n\n  if (enableCache) {\n    // If we have a cache pool from a previous render attempt, then this will be\n    // non-null. We use this to infer whether to push/pop the cache context.\n    workInProgress.updateQueue = spawnedCachePool;\n  }\n\n  if (enablePersistentOffscreenHostContainer && supportsPersistence) {\n    // In persistent mode, the offscreen children are wrapped in a host node.\n    // TODO: Optimize this to use the OffscreenComponent fiber instead of\n    // an extra HostComponent fiber. Need to make sure this doesn't break Fabric\n    // or some other infra that expects a HostComponent.\n    const isHidden = nextProps.mode === 'hidden' && workInProgress.tag !== LegacyHiddenComponent;\n    const offscreenContainer = reconcileOffscreenHostContainer(current, workInProgress, isHidden, nextChildren, renderLanes);\n    return offscreenContainer;\n  } else {\n    reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n    return workInProgress.child;\n  }\n}\n\nfunction reconcileOffscreenHostContainer(currentOffscreen, offscreen, isHidden, children, renderLanes) {\n  const containerProps = getOffscreenContainerProps(isHidden ? 'hidden' : 'visible', children);\n  let hostContainer;\n\n  if (currentOffscreen === null) {\n    hostContainer = createOffscreenHostContainerFiber(containerProps, offscreen.mode, renderLanes, null);\n  } else {\n    const currentHostContainer = currentOffscreen.child;\n\n    if (currentHostContainer === null) {\n      hostContainer = createOffscreenHostContainerFiber(containerProps, offscreen.mode, renderLanes, null);\n      hostContainer.flags |= Placement;\n    } else {\n      hostContainer = createWorkInProgress(currentHostContainer, containerProps);\n    }\n  }\n\n  hostContainer.return = offscreen;\n  offscreen.child = hostContainer;\n  return hostContainer;\n} // Note: These happen to have identical begin phases, for now. We shouldn't hold\n// ourselves to this constraint, though. If the behavior diverges, we should\n// fork the function.\n\n\nconst updateLegacyHiddenComponent = updateOffscreenComponent;\n\nfunction updateCacheComponent(current, workInProgress, renderLanes) {\n  if (!enableCache) {\n    return null;\n  }\n\n  prepareToReadContext(workInProgress, renderLanes);\n  const parentCache = readContext(CacheContext);\n\n  if (current === null) {\n    // Initial mount. Request a fresh cache from the pool.\n    const freshCache = requestCacheFromPool(renderLanes);\n    const initialState = {\n      parent: parentCache,\n      cache: freshCache\n    };\n    workInProgress.memoizedState = initialState;\n    initializeUpdateQueue(workInProgress);\n    pushCacheProvider(workInProgress, freshCache);\n  } else {\n    // Check for updates\n    if (includesSomeLane(current.lanes, renderLanes)) {\n      cloneUpdateQueue(current, workInProgress);\n      processUpdateQueue(workInProgress, null, null, renderLanes);\n    }\n\n    const prevState = current.memoizedState;\n    const nextState = workInProgress.memoizedState; // Compare the new parent cache to the previous to see detect there was\n    // a refresh.\n\n    if (prevState.parent !== parentCache) {\n      // Refresh in parent. Update the parent.\n      const derivedState = {\n        parent: parentCache,\n        cache: parentCache\n      }; // Copied from getDerivedStateFromProps implementation. Once the update\n      // queue is empty, persist the derived state onto the base state.\n\n      workInProgress.memoizedState = derivedState;\n\n      if (workInProgress.lanes === NoLanes) {\n        const updateQueue = workInProgress.updateQueue;\n        workInProgress.memoizedState = updateQueue.baseState = derivedState;\n      }\n\n      pushCacheProvider(workInProgress, parentCache); // No need to propagate a context change because the refreshed parent\n      // already did.\n    } else {\n      // The parent didn't refresh. Now check if this cache did.\n      const nextCache = nextState.cache;\n      pushCacheProvider(workInProgress, nextCache);\n\n      if (nextCache !== prevState.cache) {\n        // This cache refreshed. Propagate a context change.\n        propagateContextChange(workInProgress, CacheContext, renderLanes);\n      }\n    }\n  }\n\n  const nextChildren = workInProgress.pendingProps.children;\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\nfunction updateFragment(current, workInProgress, renderLanes) {\n  const nextChildren = workInProgress.pendingProps;\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\nfunction updateMode(current, workInProgress, renderLanes) {\n  const nextChildren = workInProgress.pendingProps.children;\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\nfunction updateProfiler(current, workInProgress, renderLanes) {\n  if (enableProfilerTimer) {\n    workInProgress.flags |= Update;\n\n    if (enableProfilerCommitHooks) {\n      // Reset effect durations for the next eventual effect phase.\n      // These are reset during render to allow the DevTools commit hook a chance to read them,\n      const stateNode = workInProgress.stateNode;\n      stateNode.effectDuration = 0;\n      stateNode.passiveEffectDuration = 0;\n    }\n  }\n\n  const nextProps = workInProgress.pendingProps;\n  const nextChildren = nextProps.children;\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\nfunction markRef(current, workInProgress) {\n  const ref = workInProgress.ref;\n\n  if (current === null && ref !== null || current !== null && current.ref !== ref) {\n    // Schedule a Ref effect\n    workInProgress.flags |= Ref;\n\n    if (enableSuspenseLayoutEffectSemantics) {\n      workInProgress.flags |= RefStatic;\n    }\n  }\n}\n\nfunction updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes) {\n  if (__DEV__) {\n    if (workInProgress.type !== workInProgress.elementType) {\n      // Lazy component props can't be validated in createElement\n      // because they're only guaranteed to be resolved here.\n      const innerPropTypes = Component.propTypes;\n\n      if (innerPropTypes) {\n        checkPropTypes(innerPropTypes, nextProps, // Resolved props\n        'prop', getComponentNameFromType(Component));\n      }\n    }\n  }\n\n  let context;\n\n  if (!disableLegacyContext) {\n    const unmaskedContext = getUnmaskedContext(workInProgress, Component, true);\n    context = getMaskedContext(workInProgress, unmaskedContext);\n  }\n\n  let nextChildren;\n  let hasId;\n  prepareToReadContext(workInProgress, renderLanes);\n\n  if (enableSchedulingProfiler) {\n    markComponentRenderStarted(workInProgress);\n  }\n\n  if (__DEV__) {\n    ReactCurrentOwner.current = workInProgress;\n    setIsRendering(true);\n    nextChildren = renderWithHooks(current, workInProgress, Component, nextProps, context, renderLanes);\n    hasId = checkDidRenderIdHook();\n\n    if (debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictLegacyMode) {\n      setIsStrictModeForDevtools(true);\n\n      try {\n        nextChildren = renderWithHooks(current, workInProgress, Component, nextProps, context, renderLanes);\n        hasId = checkDidRenderIdHook();\n      } finally {\n        setIsStrictModeForDevtools(false);\n      }\n    }\n\n    setIsRendering(false);\n  } else {\n    nextChildren = renderWithHooks(current, workInProgress, Component, nextProps, context, renderLanes);\n    hasId = checkDidRenderIdHook();\n  }\n\n  if (enableSchedulingProfiler) {\n    markComponentRenderStopped();\n  }\n\n  if (current !== null && !didReceiveUpdate) {\n    bailoutHooks(current, workInProgress, renderLanes);\n    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n  }\n\n  if (getIsHydrating() && hasId) {\n    pushMaterializedTreeId(workInProgress);\n  } // React DevTools reads this flag.\n\n\n  workInProgress.flags |= PerformedWork;\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\nfunction updateClassComponent(current, workInProgress, Component, nextProps, renderLanes) {\n  if (__DEV__) {\n    // This is used by DevTools to force a boundary to error.\n    switch (shouldError(workInProgress)) {\n      case false:\n        {\n          const instance = workInProgress.stateNode;\n          const ctor = workInProgress.type; // TODO This way of resetting the error boundary state is a hack.\n          // Is there a better way to do this?\n\n          const tempInstance = new ctor(workInProgress.memoizedProps, instance.context);\n          const state = tempInstance.state;\n          instance.updater.enqueueSetState(instance, state, null);\n          break;\n        }\n\n      case true:\n        {\n          workInProgress.flags |= DidCapture;\n          workInProgress.flags |= ShouldCapture; // eslint-disable-next-line react-internal/prod-error-codes\n\n          const error = new Error('Simulated error coming from DevTools');\n          const lane = pickArbitraryLane(renderLanes);\n          workInProgress.lanes = mergeLanes(workInProgress.lanes, lane); // Schedule the error boundary to re-render using updated state\n\n          const update = createClassErrorUpdate(workInProgress, createCapturedValue(error, workInProgress), lane);\n          enqueueCapturedUpdate(workInProgress, update);\n          break;\n        }\n    }\n\n    if (workInProgress.type !== workInProgress.elementType) {\n      // Lazy component props can't be validated in createElement\n      // because they're only guaranteed to be resolved here.\n      const innerPropTypes = Component.propTypes;\n\n      if (innerPropTypes) {\n        checkPropTypes(innerPropTypes, nextProps, // Resolved props\n        'prop', getComponentNameFromType(Component));\n      }\n    }\n  } // Push context providers early to prevent context stack mismatches.\n  // During mounting we don't know the child context yet as the instance doesn't exist.\n  // We will invalidate the child context in finishClassComponent() right after rendering.\n\n\n  let hasContext;\n\n  if (isLegacyContextProvider(Component)) {\n    hasContext = true;\n    pushLegacyContextProvider(workInProgress);\n  } else {\n    hasContext = false;\n  }\n\n  prepareToReadContext(workInProgress, renderLanes);\n  const instance = workInProgress.stateNode;\n  let shouldUpdate;\n\n  if (instance === null) {\n    if (current !== null) {\n      // A class component without an instance only mounts if it suspended\n      // inside a non-concurrent tree, in an inconsistent state. We want to\n      // treat it like a new mount, even though an empty version of it already\n      // committed. Disconnect the alternate pointers.\n      current.alternate = null;\n      workInProgress.alternate = null; // Since this is conceptually a new fiber, schedule a Placement effect\n\n      workInProgress.flags |= Placement;\n    } // In the initial pass we might need to construct the instance.\n\n\n    constructClassInstance(workInProgress, Component, nextProps);\n    mountClassInstance(workInProgress, Component, nextProps, renderLanes);\n    shouldUpdate = true;\n  } else if (current === null) {\n    // In a resume, we'll already have an instance we can reuse.\n    shouldUpdate = resumeMountClassInstance(workInProgress, Component, nextProps, renderLanes);\n  } else {\n    shouldUpdate = updateClassInstance(current, workInProgress, Component, nextProps, renderLanes);\n  }\n\n  const nextUnitOfWork = finishClassComponent(current, workInProgress, Component, shouldUpdate, hasContext, renderLanes);\n\n  if (__DEV__) {\n    const inst = workInProgress.stateNode;\n\n    if (shouldUpdate && inst.props !== nextProps) {\n      if (!didWarnAboutReassigningProps) {\n        console.error('It looks like %s is reassigning its own `this.props` while rendering. ' + 'This is not supported and can lead to confusing bugs.', getComponentNameFromFiber(workInProgress) || 'a component');\n      }\n\n      didWarnAboutReassigningProps = true;\n    }\n  }\n\n  return nextUnitOfWork;\n}\n\nfunction finishClassComponent(current, workInProgress, Component, shouldUpdate, hasContext, renderLanes) {\n  // Refs should update even if shouldComponentUpdate returns false\n  markRef(current, workInProgress);\n  const didCaptureError = (workInProgress.flags & DidCapture) !== NoFlags;\n\n  if (!shouldUpdate && !didCaptureError) {\n    // Context providers should defer to sCU for rendering\n    if (hasContext) {\n      invalidateContextProvider(workInProgress, Component, false);\n    }\n\n    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n  }\n\n  const instance = workInProgress.stateNode; // Rerender\n\n  ReactCurrentOwner.current = workInProgress;\n  let nextChildren;\n\n  if (didCaptureError && typeof Component.getDerivedStateFromError !== 'function') {\n    // If we captured an error, but getDerivedStateFromError is not defined,\n    // unmount all the children. componentDidCatch will schedule an update to\n    // re-render a fallback. This is temporary until we migrate everyone to\n    // the new API.\n    // TODO: Warn in a future release.\n    nextChildren = null;\n\n    if (enableProfilerTimer) {\n      stopProfilerTimerIfRunning(workInProgress);\n    }\n  } else {\n    if (enableSchedulingProfiler) {\n      markComponentRenderStarted(workInProgress);\n    }\n\n    if (__DEV__) {\n      setIsRendering(true);\n      nextChildren = instance.render();\n\n      if (debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictLegacyMode) {\n        setIsStrictModeForDevtools(true);\n\n        try {\n          instance.render();\n        } finally {\n          setIsStrictModeForDevtools(false);\n        }\n      }\n\n      setIsRendering(false);\n    } else {\n      nextChildren = instance.render();\n    }\n\n    if (enableSchedulingProfiler) {\n      markComponentRenderStopped();\n    }\n  } // React DevTools reads this flag.\n\n\n  workInProgress.flags |= PerformedWork;\n\n  if (current !== null && didCaptureError) {\n    // If we're recovering from an error, reconcile without reusing any of\n    // the existing children. Conceptually, the normal children and the children\n    // that are shown on error are two different sets, so we shouldn't reuse\n    // normal children even if their identities match.\n    forceUnmountCurrentAndReconcile(current, workInProgress, nextChildren, renderLanes);\n  } else {\n    reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  } // Memoize state using the values we just used to render.\n  // TODO: Restructure so we never read values from the instance.\n\n\n  workInProgress.memoizedState = instance.state; // The context might have changed so we need to recalculate it.\n\n  if (hasContext) {\n    invalidateContextProvider(workInProgress, Component, true);\n  }\n\n  return workInProgress.child;\n}\n\nfunction pushHostRootContext(workInProgress) {\n  const root = workInProgress.stateNode;\n\n  if (root.pendingContext) {\n    pushTopLevelContextObject(workInProgress, root.pendingContext, root.pendingContext !== root.context);\n  } else if (root.context) {\n    // Should always be set\n    pushTopLevelContextObject(workInProgress, root.context, false);\n  }\n\n  pushHostContainer(workInProgress, root.containerInfo);\n}\n\nfunction updateHostRoot(current, workInProgress, renderLanes) {\n  pushHostRootContext(workInProgress);\n  const updateQueue = workInProgress.updateQueue;\n\n  if (current === null || updateQueue === null) {\n    throw new Error('If the root does not have an updateQueue, we should have already ' + 'bailed out. This error is likely caused by a bug in React. Please ' + 'file an issue.');\n  }\n\n  const nextProps = workInProgress.pendingProps;\n  const prevState = workInProgress.memoizedState;\n  const prevChildren = prevState.element;\n  cloneUpdateQueue(current, workInProgress);\n  processUpdateQueue(workInProgress, nextProps, null, renderLanes);\n  const nextState = workInProgress.memoizedState;\n  const root = workInProgress.stateNode;\n\n  if (enableCache) {\n    const nextCache = nextState.cache;\n    pushRootCachePool(root);\n    pushCacheProvider(workInProgress, nextCache);\n\n    if (nextCache !== prevState.cache) {\n      // The root cache refreshed.\n      propagateContextChange(workInProgress, CacheContext, renderLanes);\n    }\n  } // Caution: React DevTools currently depends on this property\n  // being called \"element\".\n\n\n  const nextChildren = nextState.element;\n\n  if (nextChildren === prevChildren) {\n    resetHydrationState();\n    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n  }\n\n  if (root.isDehydrated && enterHydrationState(workInProgress)) {\n    // If we don't have any current children this might be the first pass.\n    // We always try to hydrate. If this isn't a hydration pass there won't\n    // be any children to hydrate which is effectively the same thing as\n    // not hydrating.\n    if (supportsHydration) {\n      const mutableSourceEagerHydrationData = root.mutableSourceEagerHydrationData;\n\n      if (mutableSourceEagerHydrationData != null) {\n        for (let i = 0; i < mutableSourceEagerHydrationData.length; i += 2) {\n          const mutableSource = mutableSourceEagerHydrationData[i];\n          const version = mutableSourceEagerHydrationData[i + 1];\n          setWorkInProgressVersion(mutableSource, version);\n        }\n      }\n    }\n\n    const child = mountChildFibers(workInProgress, null, nextChildren, renderLanes);\n    workInProgress.child = child;\n    let node = child;\n\n    while (node) {\n      // Mark each child as hydrating. This is a fast path to know whether this\n      // tree is part of a hydrating tree. This is used to determine if a child\n      // node has fully mounted yet, and for scheduling event replaying.\n      // Conceptually this is similar to Placement in that a new subtree is\n      // inserted into the React tree here. It just happens to not need DOM\n      // mutations because it already exists.\n      node.flags = node.flags & ~Placement | Hydrating;\n      node = node.sibling;\n    }\n  } else {\n    // Otherwise reset hydration state in case we aborted and resumed another\n    // root.\n    reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n    resetHydrationState();\n  }\n\n  return workInProgress.child;\n}\n\nfunction updateHostComponent(current, workInProgress, renderLanes) {\n  pushHostContext(workInProgress);\n\n  if (current === null) {\n    tryToClaimNextHydratableInstance(workInProgress);\n  }\n\n  const type = workInProgress.type;\n  const nextProps = workInProgress.pendingProps;\n  const prevProps = current !== null ? current.memoizedProps : null;\n  let nextChildren = nextProps.children;\n  const isDirectTextChild = shouldSetTextContent(type, nextProps);\n\n  if (isDirectTextChild) {\n    // We special case a direct text child of a host node. This is a common\n    // case. We won't handle it as a reified child. We will instead handle\n    // this in the host environment that also has access to this prop. That\n    // avoids allocating another HostText fiber and traversing it.\n    nextChildren = null;\n  } else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {\n    // If we're switching from a direct text child to a normal child, or to\n    // empty, we need to schedule the text content to be reset.\n    workInProgress.flags |= ContentReset;\n  }\n\n  markRef(current, workInProgress);\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\nfunction updateHostText(current, workInProgress) {\n  if (current === null) {\n    tryToClaimNextHydratableInstance(workInProgress);\n  } // Nothing to do here. This is terminal. We'll do the completion step\n  // immediately after.\n\n\n  return null;\n}\n\nfunction mountLazyComponent(_current, workInProgress, elementType, renderLanes) {\n  if (_current !== null) {\n    // A lazy component only mounts if it suspended inside a non-\n    // concurrent tree, in an inconsistent state. We want to treat it like\n    // a new mount, even though an empty version of it already committed.\n    // Disconnect the alternate pointers.\n    _current.alternate = null;\n    workInProgress.alternate = null; // Since this is conceptually a new fiber, schedule a Placement effect\n\n    workInProgress.flags |= Placement;\n  }\n\n  const props = workInProgress.pendingProps;\n  const lazyComponent = elementType;\n  const payload = lazyComponent._payload;\n  const init = lazyComponent._init;\n  let Component = init(payload); // Store the unwrapped component in the type.\n\n  workInProgress.type = Component;\n  const resolvedTag = workInProgress.tag = resolveLazyComponentTag(Component);\n  const resolvedProps = resolveDefaultProps(Component, props);\n  let child;\n\n  switch (resolvedTag) {\n    case FunctionComponent:\n      {\n        if (__DEV__) {\n          validateFunctionComponentInDev(workInProgress, Component);\n          workInProgress.type = Component = resolveFunctionForHotReloading(Component);\n        }\n\n        child = updateFunctionComponent(null, workInProgress, Component, resolvedProps, renderLanes);\n        return child;\n      }\n\n    case ClassComponent:\n      {\n        if (__DEV__) {\n          workInProgress.type = Component = resolveClassForHotReloading(Component);\n        }\n\n        child = updateClassComponent(null, workInProgress, Component, resolvedProps, renderLanes);\n        return child;\n      }\n\n    case ForwardRef:\n      {\n        if (__DEV__) {\n          workInProgress.type = Component = resolveForwardRefForHotReloading(Component);\n        }\n\n        child = updateForwardRef(null, workInProgress, Component, resolvedProps, renderLanes);\n        return child;\n      }\n\n    case MemoComponent:\n      {\n        if (__DEV__) {\n          if (workInProgress.type !== workInProgress.elementType) {\n            const outerPropTypes = Component.propTypes;\n\n            if (outerPropTypes) {\n              checkPropTypes(outerPropTypes, resolvedProps, // Resolved for outer only\n              'prop', getComponentNameFromType(Component));\n            }\n          }\n        }\n\n        child = updateMemoComponent(null, workInProgress, Component, resolveDefaultProps(Component.type, resolvedProps), // The inner type can have defaults too\n        renderLanes);\n        return child;\n      }\n  }\n\n  let hint = '';\n\n  if (__DEV__) {\n    if (Component !== null && typeof Component === 'object' && Component.$$typeof === REACT_LAZY_TYPE) {\n      hint = ' Did you wrap a component in React.lazy() more than once?';\n    }\n  } // This message intentionally doesn't mention ForwardRef or MemoComponent\n  // because the fact that it's a separate type of work is an\n  // implementation detail.\n\n\n  throw new Error(`Element type is invalid. Received a promise that resolves to: ${Component}. ` + `Lazy element type must resolve to a class or function.${hint}`);\n}\n\nfunction mountIncompleteClassComponent(_current, workInProgress, Component, nextProps, renderLanes) {\n  if (_current !== null) {\n    // An incomplete component only mounts if it suspended inside a non-\n    // concurrent tree, in an inconsistent state. We want to treat it like\n    // a new mount, even though an empty version of it already committed.\n    // Disconnect the alternate pointers.\n    _current.alternate = null;\n    workInProgress.alternate = null; // Since this is conceptually a new fiber, schedule a Placement effect\n\n    workInProgress.flags |= Placement;\n  } // Promote the fiber to a class and try rendering again.\n\n\n  workInProgress.tag = ClassComponent; // The rest of this function is a fork of `updateClassComponent`\n  // Push context providers early to prevent context stack mismatches.\n  // During mounting we don't know the child context yet as the instance doesn't exist.\n  // We will invalidate the child context in finishClassComponent() right after rendering.\n\n  let hasContext;\n\n  if (isLegacyContextProvider(Component)) {\n    hasContext = true;\n    pushLegacyContextProvider(workInProgress);\n  } else {\n    hasContext = false;\n  }\n\n  prepareToReadContext(workInProgress, renderLanes);\n  constructClassInstance(workInProgress, Component, nextProps);\n  mountClassInstance(workInProgress, Component, nextProps, renderLanes);\n  return finishClassComponent(null, workInProgress, Component, true, hasContext, renderLanes);\n}\n\nfunction mountIndeterminateComponent(_current, workInProgress, Component, renderLanes) {\n  if (_current !== null) {\n    // An indeterminate component only mounts if it suspended inside a non-\n    // concurrent tree, in an inconsistent state. We want to treat it like\n    // a new mount, even though an empty version of it already committed.\n    // Disconnect the alternate pointers.\n    _current.alternate = null;\n    workInProgress.alternate = null; // Since this is conceptually a new fiber, schedule a Placement effect\n\n    workInProgress.flags |= Placement;\n  }\n\n  const props = workInProgress.pendingProps;\n  let context;\n\n  if (!disableLegacyContext) {\n    const unmaskedContext = getUnmaskedContext(workInProgress, Component, false);\n    context = getMaskedContext(workInProgress, unmaskedContext);\n  }\n\n  prepareToReadContext(workInProgress, renderLanes);\n  let value;\n  let hasId;\n\n  if (enableSchedulingProfiler) {\n    markComponentRenderStarted(workInProgress);\n  }\n\n  if (__DEV__) {\n    if (Component.prototype && typeof Component.prototype.render === 'function') {\n      const componentName = getComponentNameFromType(Component) || 'Unknown';\n\n      if (!didWarnAboutBadClass[componentName]) {\n        console.error(\"The <%s /> component appears to have a render method, but doesn't extend React.Component. \" + 'This is likely to cause errors. Change %s to extend React.Component instead.', componentName, componentName);\n        didWarnAboutBadClass[componentName] = true;\n      }\n    }\n\n    if (workInProgress.mode & StrictLegacyMode) {\n      ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, null);\n    }\n\n    setIsRendering(true);\n    ReactCurrentOwner.current = workInProgress;\n    value = renderWithHooks(null, workInProgress, Component, props, context, renderLanes);\n    hasId = checkDidRenderIdHook();\n    setIsRendering(false);\n  } else {\n    value = renderWithHooks(null, workInProgress, Component, props, context, renderLanes);\n    hasId = checkDidRenderIdHook();\n  }\n\n  if (enableSchedulingProfiler) {\n    markComponentRenderStopped();\n  } // React DevTools reads this flag.\n\n\n  workInProgress.flags |= PerformedWork;\n\n  if (__DEV__) {\n    // Support for module components is deprecated and is removed behind a flag.\n    // Whether or not it would crash later, we want to show a good message in DEV first.\n    if (typeof value === 'object' && value !== null && typeof value.render === 'function' && value.$$typeof === undefined) {\n      const componentName = getComponentNameFromType(Component) || 'Unknown';\n\n      if (!didWarnAboutModulePatternComponent[componentName]) {\n        console.error('The <%s /> component appears to be a function component that returns a class instance. ' + 'Change %s to a class that extends React.Component instead. ' + \"If you can't use a class try assigning the prototype on the function as a workaround. \" + \"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it \" + 'cannot be called with `new` by React.', componentName, componentName, componentName);\n        didWarnAboutModulePatternComponent[componentName] = true;\n      }\n    }\n  }\n\n  if ( // Run these checks in production only if the flag is off.\n  // Eventually we'll delete this branch altogether.\n  !disableModulePatternComponents && typeof value === 'object' && value !== null && typeof value.render === 'function' && value.$$typeof === undefined) {\n    if (__DEV__) {\n      const componentName = getComponentNameFromType(Component) || 'Unknown';\n\n      if (!didWarnAboutModulePatternComponent[componentName]) {\n        console.error('The <%s /> component appears to be a function component that returns a class instance. ' + 'Change %s to a class that extends React.Component instead. ' + \"If you can't use a class try assigning the prototype on the function as a workaround. \" + \"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it \" + 'cannot be called with `new` by React.', componentName, componentName, componentName);\n        didWarnAboutModulePatternComponent[componentName] = true;\n      }\n    } // Proceed under the assumption that this is a class instance\n\n\n    workInProgress.tag = ClassComponent; // Throw out any hooks that were used.\n\n    workInProgress.memoizedState = null;\n    workInProgress.updateQueue = null; // Push context providers early to prevent context stack mismatches.\n    // During mounting we don't know the child context yet as the instance doesn't exist.\n    // We will invalidate the child context in finishClassComponent() right after rendering.\n\n    let hasContext = false;\n\n    if (isLegacyContextProvider(Component)) {\n      hasContext = true;\n      pushLegacyContextProvider(workInProgress);\n    } else {\n      hasContext = false;\n    }\n\n    workInProgress.memoizedState = value.state !== null && value.state !== undefined ? value.state : null;\n    initializeUpdateQueue(workInProgress);\n    adoptClassInstance(workInProgress, value);\n    mountClassInstance(workInProgress, Component, props, renderLanes);\n    return finishClassComponent(null, workInProgress, Component, true, hasContext, renderLanes);\n  } else {\n    // Proceed under the assumption that this is a function component\n    workInProgress.tag = FunctionComponent;\n\n    if (__DEV__) {\n      if (disableLegacyContext && Component.contextTypes) {\n        console.error('%s uses the legacy contextTypes API which is no longer supported. ' + 'Use React.createContext() with React.useContext() instead.', getComponentNameFromType(Component) || 'Unknown');\n      }\n\n      if (debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictLegacyMode) {\n        setIsStrictModeForDevtools(true);\n\n        try {\n          value = renderWithHooks(null, workInProgress, Component, props, context, renderLanes);\n          hasId = checkDidRenderIdHook();\n        } finally {\n          setIsStrictModeForDevtools(false);\n        }\n      }\n    }\n\n    if (getIsHydrating() && hasId) {\n      pushMaterializedTreeId(workInProgress);\n    }\n\n    reconcileChildren(null, workInProgress, value, renderLanes);\n\n    if (__DEV__) {\n      validateFunctionComponentInDev(workInProgress, Component);\n    }\n\n    return workInProgress.child;\n  }\n}\n\nfunction validateFunctionComponentInDev(workInProgress, Component) {\n  if (__DEV__) {\n    if (Component) {\n      if (Component.childContextTypes) {\n        console.error('%s(...): childContextTypes cannot be defined on a function component.', Component.displayName || Component.name || 'Component');\n      }\n    }\n\n    if (workInProgress.ref !== null) {\n      let info = '';\n      const ownerName = getCurrentFiberOwnerNameInDevOrNull();\n\n      if (ownerName) {\n        info += '\\n\\nCheck the render method of `' + ownerName + '`.';\n      }\n\n      let warningKey = ownerName || '';\n      const debugSource = workInProgress._debugSource;\n\n      if (debugSource) {\n        warningKey = debugSource.fileName + ':' + debugSource.lineNumber;\n      }\n\n      if (!didWarnAboutFunctionRefs[warningKey]) {\n        didWarnAboutFunctionRefs[warningKey] = true;\n        console.error('Function components cannot be given refs. ' + 'Attempts to access this ref will fail. ' + 'Did you mean to use React.forwardRef()?%s', info);\n      }\n    }\n\n    if (warnAboutDefaultPropsOnFunctionComponents && Component.defaultProps !== undefined) {\n      const componentName = getComponentNameFromType(Component) || 'Unknown';\n\n      if (!didWarnAboutDefaultPropsOnFunctionComponent[componentName]) {\n        console.error('%s: Support for defaultProps will be removed from function components ' + 'in a future major release. Use JavaScript default parameters instead.', componentName);\n        didWarnAboutDefaultPropsOnFunctionComponent[componentName] = true;\n      }\n    }\n\n    if (typeof Component.getDerivedStateFromProps === 'function') {\n      const componentName = getComponentNameFromType(Component) || 'Unknown';\n\n      if (!didWarnAboutGetDerivedStateOnFunctionComponent[componentName]) {\n        console.error('%s: Function components do not support getDerivedStateFromProps.', componentName);\n        didWarnAboutGetDerivedStateOnFunctionComponent[componentName] = true;\n      }\n    }\n\n    if (typeof Component.contextType === 'object' && Component.contextType !== null) {\n      const componentName = getComponentNameFromType(Component) || 'Unknown';\n\n      if (!didWarnAboutContextTypeOnFunctionComponent[componentName]) {\n        console.error('%s: Function components do not support contextType.', componentName);\n        didWarnAboutContextTypeOnFunctionComponent[componentName] = true;\n      }\n    }\n  }\n}\n\nconst SUSPENDED_MARKER = {\n  dehydrated: null,\n  treeContext: null,\n  retryLane: NoLane\n};\n\nfunction mountSuspenseOffscreenState(renderLanes) {\n  return {\n    baseLanes: renderLanes,\n    cachePool: getSuspendedCachePool()\n  };\n}\n\nfunction updateSuspenseOffscreenState(prevOffscreenState, renderLanes) {\n  let cachePool = null;\n\n  if (enableCache) {\n    const prevCachePool = prevOffscreenState.cachePool;\n\n    if (prevCachePool !== null) {\n      const parentCache = isPrimaryRenderer ? CacheContext._currentValue : CacheContext._currentValue2;\n\n      if (prevCachePool.parent !== parentCache) {\n        // Detected a refresh in the parent. This overrides any previously\n        // suspended cache.\n        cachePool = {\n          parent: parentCache,\n          pool: parentCache\n        };\n      } else {\n        // We can reuse the cache from last time. The only thing that would have\n        // overridden it is a parent refresh, which we checked for above.\n        cachePool = prevCachePool;\n      }\n    } else {\n      // If there's no previous cache pool, grab the current one.\n      cachePool = getSuspendedCachePool();\n    }\n  }\n\n  return {\n    baseLanes: mergeLanes(prevOffscreenState.baseLanes, renderLanes),\n    cachePool\n  };\n} // TODO: Probably should inline this back\n\n\nfunction shouldRemainOnFallback(suspenseContext, current, workInProgress, renderLanes) {\n  // If we're already showing a fallback, there are cases where we need to\n  // remain on that fallback regardless of whether the content has resolved.\n  // For example, SuspenseList coordinates when nested content appears.\n  if (current !== null) {\n    const suspenseState = current.memoizedState;\n\n    if (suspenseState === null) {\n      // Currently showing content. Don't hide it, even if ForceSuspenseFallback\n      // is true. More precise name might be \"ForceRemainSuspenseFallback\".\n      // Note: This is a factoring smell. Can't remain on a fallback if there's\n      // no fallback to remain on.\n      return false;\n    }\n  } // Not currently showing content. Consult the Suspense context.\n\n\n  return hasSuspenseContext(suspenseContext, ForceSuspenseFallback);\n}\n\nfunction getRemainingWorkInPrimaryTree(current, renderLanes) {\n  // TODO: Should not remove render lanes that were pinged during this render\n  return removeLanes(current.childLanes, renderLanes);\n}\n\nfunction updateSuspenseComponent(current, workInProgress, renderLanes) {\n  const nextProps = workInProgress.pendingProps; // This is used by DevTools to force a boundary to suspend.\n\n  if (__DEV__) {\n    if (shouldSuspend(workInProgress)) {\n      workInProgress.flags |= DidCapture;\n    }\n  }\n\n  let suspenseContext = suspenseStackCursor.current;\n  let showFallback = false;\n  const didSuspend = (workInProgress.flags & DidCapture) !== NoFlags;\n\n  if (didSuspend || shouldRemainOnFallback(suspenseContext, current, workInProgress, renderLanes)) {\n    // Something in this boundary's subtree already suspended. Switch to\n    // rendering the fallback children.\n    showFallback = true;\n    workInProgress.flags &= ~DidCapture;\n  } else {\n    // Attempting the main content\n    if (current === null || current.memoizedState !== null) {\n      // This is a new mount or this boundary is already showing a fallback state.\n      // Mark this subtree context as having at least one invisible parent that could\n      // handle the fallback state.\n      // Avoided boundaries are not considered since they cannot handle preferred fallback states.\n      if (nextProps.unstable_avoidThisFallback !== true) {\n        suspenseContext = addSubtreeSuspenseContext(suspenseContext, InvisibleParentSuspenseContext);\n      }\n    }\n  }\n\n  suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);\n  pushSuspenseContext(workInProgress, suspenseContext); // OK, the next part is confusing. We're about to reconcile the Suspense\n  // boundary's children. This involves some custom reconciliation logic. Two\n  // main reasons this is so complicated.\n  //\n  // First, Legacy Mode has different semantics for backwards compatibility. The\n  // primary tree will commit in an inconsistent state, so when we do the\n  // second pass to render the fallback, we do some exceedingly, uh, clever\n  // hacks to make that not totally break. Like transferring effects and\n  // deletions from hidden tree. In Concurrent Mode, it's much simpler,\n  // because we bailout on the primary tree completely and leave it in its old\n  // state, no effects. Same as what we do for Offscreen (except that\n  // Offscreen doesn't have the first render pass).\n  //\n  // Second is hydration. During hydration, the Suspense fiber has a slightly\n  // different layout, where the child points to a dehydrated fragment, which\n  // contains the DOM rendered by the server.\n  //\n  // Third, even if you set all that aside, Suspense is like error boundaries in\n  // that we first we try to render one tree, and if that fails, we render again\n  // and switch to a different tree. Like a try/catch block. So we have to track\n  // which branch we're currently rendering. Ideally we would model this using\n  // a stack.\n\n  if (current === null) {\n    // Initial mount\n    // If we're currently hydrating, try to hydrate this boundary.\n    tryToClaimNextHydratableInstance(workInProgress); // This could've been a dehydrated suspense component.\n\n    if (enableSuspenseServerRenderer) {\n      const suspenseState = workInProgress.memoizedState;\n\n      if (suspenseState !== null) {\n        const dehydrated = suspenseState.dehydrated;\n\n        if (dehydrated !== null) {\n          return mountDehydratedSuspenseComponent(workInProgress, dehydrated, renderLanes);\n        }\n      }\n    }\n\n    const nextPrimaryChildren = nextProps.children;\n    const nextFallbackChildren = nextProps.fallback;\n\n    if (showFallback) {\n      const fallbackFragment = mountSuspenseFallbackChildren(workInProgress, nextPrimaryChildren, nextFallbackChildren, renderLanes);\n      const primaryChildFragment = workInProgress.child;\n      primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes);\n      workInProgress.memoizedState = SUSPENDED_MARKER;\n      return fallbackFragment;\n    } else if (typeof nextProps.unstable_expectedLoadTime === 'number') {\n      // This is a CPU-bound tree. Skip this tree and show a placeholder to\n      // unblock the surrounding content. Then immediately retry after the\n      // initial commit.\n      const fallbackFragment = mountSuspenseFallbackChildren(workInProgress, nextPrimaryChildren, nextFallbackChildren, renderLanes);\n      const primaryChildFragment = workInProgress.child;\n      primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes);\n      workInProgress.memoizedState = SUSPENDED_MARKER; // Since nothing actually suspended, there will nothing to ping this to\n      // get it started back up to attempt the next item. While in terms of\n      // priority this work has the same priority as this current render, it's\n      // not part of the same transition once the transition has committed. If\n      // it's sync, we still want to yield so that it can be painted.\n      // Conceptually, this is really the same as pinging. We can use any\n      // RetryLane even if it's the one currently rendering since we're leaving\n      // it behind on this node.\n\n      workInProgress.lanes = SomeRetryLane;\n      return fallbackFragment;\n    } else {\n      return mountSuspensePrimaryChildren(workInProgress, nextPrimaryChildren, renderLanes);\n    }\n  } else {\n    // This is an update.\n    // If the current fiber has a SuspenseState, that means it's already showing\n    // a fallback.\n    const prevState = current.memoizedState;\n\n    if (prevState !== null) {\n      // The current tree is already showing a fallback\n      // Special path for hydration\n      if (enableSuspenseServerRenderer) {\n        const dehydrated = prevState.dehydrated;\n\n        if (dehydrated !== null) {\n          if (!didSuspend) {\n            return updateDehydratedSuspenseComponent(current, workInProgress, dehydrated, prevState, renderLanes);\n          } else if (workInProgress.flags & ForceClientRender) {\n            // Something errored during hydration. Try again without hydrating.\n            workInProgress.flags &= ~ForceClientRender;\n            return retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes);\n          } else if (workInProgress.memoizedState !== null) {\n            // Something suspended and we should still be in dehydrated mode.\n            // Leave the existing child in place.\n            workInProgress.child = current.child; // The dehydrated completion pass expects this flag to be there\n            // but the normal suspense pass doesn't.\n\n            workInProgress.flags |= DidCapture;\n            return null;\n          } else {\n            // Suspended but we should no longer be in dehydrated mode.\n            // Therefore we now have to render the fallback.\n            const nextPrimaryChildren = nextProps.children;\n            const nextFallbackChildren = nextProps.fallback;\n            const fallbackChildFragment = mountSuspenseFallbackAfterRetryWithoutHydrating(current, workInProgress, nextPrimaryChildren, nextFallbackChildren, renderLanes);\n            const primaryChildFragment = workInProgress.child;\n            primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes);\n            workInProgress.memoizedState = SUSPENDED_MARKER;\n            return fallbackChildFragment;\n          }\n        }\n      }\n\n      if (showFallback) {\n        const nextFallbackChildren = nextProps.fallback;\n        const nextPrimaryChildren = nextProps.children;\n        const fallbackChildFragment = updateSuspenseFallbackChildren(current, workInProgress, nextPrimaryChildren, nextFallbackChildren, renderLanes);\n        const primaryChildFragment = workInProgress.child;\n        const prevOffscreenState = current.child.memoizedState;\n        primaryChildFragment.memoizedState = prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes) : updateSuspenseOffscreenState(prevOffscreenState, renderLanes);\n        primaryChildFragment.childLanes = getRemainingWorkInPrimaryTree(current, renderLanes);\n        workInProgress.memoizedState = SUSPENDED_MARKER;\n        return fallbackChildFragment;\n      } else {\n        const nextPrimaryChildren = nextProps.children;\n        const primaryChildFragment = updateSuspensePrimaryChildren(current, workInProgress, nextPrimaryChildren, renderLanes);\n        workInProgress.memoizedState = null;\n        return primaryChildFragment;\n      }\n    } else {\n      // The current tree is not already showing a fallback.\n      if (showFallback) {\n        // Timed out.\n        const nextFallbackChildren = nextProps.fallback;\n        const nextPrimaryChildren = nextProps.children;\n        const fallbackChildFragment = updateSuspenseFallbackChildren(current, workInProgress, nextPrimaryChildren, nextFallbackChildren, renderLanes);\n        const primaryChildFragment = workInProgress.child;\n        const prevOffscreenState = current.child.memoizedState;\n        primaryChildFragment.memoizedState = prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes) : updateSuspenseOffscreenState(prevOffscreenState, renderLanes);\n        primaryChildFragment.childLanes = getRemainingWorkInPrimaryTree(current, renderLanes); // Skip the primary children, and continue working on the\n        // fallback children.\n\n        workInProgress.memoizedState = SUSPENDED_MARKER;\n        return fallbackChildFragment;\n      } else {\n        // Still haven't timed out. Continue rendering the children, like we\n        // normally do.\n        const nextPrimaryChildren = nextProps.children;\n        const primaryChildFragment = updateSuspensePrimaryChildren(current, workInProgress, nextPrimaryChildren, renderLanes);\n        workInProgress.memoizedState = null;\n        return primaryChildFragment;\n      }\n    }\n  }\n}\n\nfunction mountSuspensePrimaryChildren(workInProgress, primaryChildren, renderLanes) {\n  const mode = workInProgress.mode;\n  const primaryChildProps = {\n    mode: 'visible',\n    children: primaryChildren\n  };\n  const primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode, renderLanes);\n  primaryChildFragment.return = workInProgress;\n  workInProgress.child = primaryChildFragment;\n  return primaryChildFragment;\n}\n\nfunction mountSuspenseFallbackChildren(workInProgress, primaryChildren, fallbackChildren, renderLanes) {\n  const mode = workInProgress.mode;\n  const progressedPrimaryFragment = workInProgress.child;\n  const primaryChildProps = {\n    mode: 'hidden',\n    children: primaryChildren\n  };\n  let primaryChildFragment;\n  let fallbackChildFragment;\n\n  if ((mode & ConcurrentMode) === NoMode && progressedPrimaryFragment !== null) {\n    // In legacy mode, we commit the primary tree as if it successfully\n    // completed, even though it's in an inconsistent state.\n    primaryChildFragment = progressedPrimaryFragment;\n    primaryChildFragment.childLanes = NoLanes;\n    primaryChildFragment.pendingProps = primaryChildProps;\n\n    if (enableProfilerTimer && workInProgress.mode & ProfileMode) {\n      // Reset the durations from the first pass so they aren't included in the\n      // final amounts. This seems counterintuitive, since we're intentionally\n      // not measuring part of the render phase, but this makes it match what we\n      // do in Concurrent Mode.\n      primaryChildFragment.actualDuration = 0;\n      primaryChildFragment.actualStartTime = -1;\n      primaryChildFragment.selfBaseDuration = 0;\n      primaryChildFragment.treeBaseDuration = 0;\n    }\n\n    fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes, null);\n  } else {\n    primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode, NoLanes);\n    fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes, null);\n  }\n\n  primaryChildFragment.return = workInProgress;\n  fallbackChildFragment.return = workInProgress;\n  primaryChildFragment.sibling = fallbackChildFragment;\n  workInProgress.child = primaryChildFragment;\n  return fallbackChildFragment;\n}\n\nfunction mountWorkInProgressOffscreenFiber(offscreenProps, mode, renderLanes) {\n  // The props argument to `createFiberFromOffscreen` is `any` typed, so we use\n  // this wrapper function to constrain it.\n  return createFiberFromOffscreen(offscreenProps, mode, NoLanes, null);\n}\n\nfunction updateWorkInProgressOffscreenFiber(current, offscreenProps) {\n  // The props argument to `createWorkInProgress` is `any` typed, so we use this\n  // wrapper function to constrain it.\n  return createWorkInProgress(current, offscreenProps);\n}\n\nfunction updateSuspensePrimaryChildren(current, workInProgress, primaryChildren, renderLanes) {\n  const currentPrimaryChildFragment = current.child;\n  const currentFallbackChildFragment = currentPrimaryChildFragment.sibling;\n  const primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, {\n    mode: 'visible',\n    children: primaryChildren\n  });\n\n  if ((workInProgress.mode & ConcurrentMode) === NoMode) {\n    primaryChildFragment.lanes = renderLanes;\n  }\n\n  primaryChildFragment.return = workInProgress;\n  primaryChildFragment.sibling = null;\n\n  if (currentFallbackChildFragment !== null) {\n    // Delete the fallback child fragment\n    const deletions = workInProgress.deletions;\n\n    if (deletions === null) {\n      workInProgress.deletions = [currentFallbackChildFragment];\n      workInProgress.flags |= ChildDeletion;\n    } else {\n      deletions.push(currentFallbackChildFragment);\n    }\n  }\n\n  workInProgress.child = primaryChildFragment;\n  return primaryChildFragment;\n}\n\nfunction updateSuspenseFallbackChildren(current, workInProgress, primaryChildren, fallbackChildren, renderLanes) {\n  const mode = workInProgress.mode;\n  const currentPrimaryChildFragment = current.child;\n  const currentFallbackChildFragment = currentPrimaryChildFragment.sibling;\n  const primaryChildProps = {\n    mode: 'hidden',\n    children: primaryChildren\n  };\n  let primaryChildFragment;\n\n  if ( // In legacy mode, we commit the primary tree as if it successfully\n  // completed, even though it's in an inconsistent state.\n  (mode & ConcurrentMode) === NoMode && // Make sure we're on the second pass, i.e. the primary child fragment was\n  // already cloned. In legacy mode, the only case where this isn't true is\n  // when DevTools forces us to display a fallback; we skip the first render\n  // pass entirely and go straight to rendering the fallback. (In Concurrent\n  // Mode, SuspenseList can also trigger this scenario, but this is a legacy-\n  // only codepath.)\n  workInProgress.child !== currentPrimaryChildFragment) {\n    const progressedPrimaryFragment = workInProgress.child;\n    primaryChildFragment = progressedPrimaryFragment;\n    primaryChildFragment.childLanes = NoLanes;\n    primaryChildFragment.pendingProps = primaryChildProps;\n\n    if (enableProfilerTimer && workInProgress.mode & ProfileMode) {\n      // Reset the durations from the first pass so they aren't included in the\n      // final amounts. This seems counterintuitive, since we're intentionally\n      // not measuring part of the render phase, but this makes it match what we\n      // do in Concurrent Mode.\n      primaryChildFragment.actualDuration = 0;\n      primaryChildFragment.actualStartTime = -1;\n      primaryChildFragment.selfBaseDuration = currentPrimaryChildFragment.selfBaseDuration;\n      primaryChildFragment.treeBaseDuration = currentPrimaryChildFragment.treeBaseDuration;\n    }\n\n    if (enablePersistentOffscreenHostContainer && supportsPersistence) {\n      // In persistent mode, the offscreen children are wrapped in a host node.\n      // We need to complete it now, because we're going to skip over its normal\n      // complete phase and go straight to rendering the fallback.\n      const currentOffscreenContainer = currentPrimaryChildFragment.child;\n      const offscreenContainer = primaryChildFragment.child;\n      const containerProps = getOffscreenContainerProps('hidden', primaryChildren);\n      offscreenContainer.pendingProps = containerProps;\n      offscreenContainer.memoizedProps = containerProps;\n      completeSuspendedOffscreenHostContainer(currentOffscreenContainer, offscreenContainer);\n    } // The fallback fiber was added as a deletion during the first pass.\n    // However, since we're going to remain on the fallback, we no longer want\n    // to delete it.\n\n\n    workInProgress.deletions = null;\n  } else {\n    primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, primaryChildProps);\n\n    if (enablePersistentOffscreenHostContainer && supportsPersistence) {\n      // In persistent mode, the offscreen children are wrapped in a host node.\n      // We need to complete it now, because we're going to skip over its normal\n      // complete phase and go straight to rendering the fallback.\n      const currentOffscreenContainer = currentPrimaryChildFragment.child;\n\n      if (currentOffscreenContainer !== null) {\n        const isHidden = true;\n        const offscreenContainer = reconcileOffscreenHostContainer(currentPrimaryChildFragment, primaryChildFragment, isHidden, primaryChildren, renderLanes);\n        offscreenContainer.memoizedProps = offscreenContainer.pendingProps;\n        completeSuspendedOffscreenHostContainer(currentOffscreenContainer, offscreenContainer);\n      }\n    } // Since we're reusing a current tree, we need to reuse the flags, too.\n    // (We don't do this in legacy mode, because in legacy mode we don't re-use\n    // the current tree; see previous branch.)\n\n\n    primaryChildFragment.subtreeFlags = currentPrimaryChildFragment.subtreeFlags & StaticMask;\n  }\n\n  let fallbackChildFragment;\n\n  if (currentFallbackChildFragment !== null) {\n    fallbackChildFragment = createWorkInProgress(currentFallbackChildFragment, fallbackChildren);\n  } else {\n    fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes, null); // Needs a placement effect because the parent (the Suspense boundary) already\n    // mounted but this is a new fiber.\n\n    fallbackChildFragment.flags |= Placement;\n  }\n\n  fallbackChildFragment.return = workInProgress;\n  primaryChildFragment.return = workInProgress;\n  primaryChildFragment.sibling = fallbackChildFragment;\n  workInProgress.child = primaryChildFragment;\n  return fallbackChildFragment;\n}\n\nfunction retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes) {\n  // This will add the old fiber to the deletion list\n  reconcileChildFibers(workInProgress, current.child, null, renderLanes); // We're now not suspended nor dehydrated.\n\n  const nextProps = workInProgress.pendingProps;\n  const primaryChildren = nextProps.children;\n  const primaryChildFragment = mountSuspensePrimaryChildren(workInProgress, primaryChildren, renderLanes); // Needs a placement effect because the parent (the Suspense boundary) already\n  // mounted but this is a new fiber.\n\n  primaryChildFragment.flags |= Placement;\n  workInProgress.memoizedState = null;\n  return primaryChildFragment;\n}\n\nfunction mountSuspenseFallbackAfterRetryWithoutHydrating(current, workInProgress, primaryChildren, fallbackChildren, renderLanes) {\n  const fiberMode = workInProgress.mode;\n  const primaryChildProps = {\n    mode: 'visible',\n    children: primaryChildren\n  };\n  const primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, fiberMode, NoLanes);\n  const fallbackChildFragment = createFiberFromFragment(fallbackChildren, fiberMode, renderLanes, null); // Needs a placement effect because the parent (the Suspense\n  // boundary) already mounted but this is a new fiber.\n\n  fallbackChildFragment.flags |= Placement;\n  primaryChildFragment.return = workInProgress;\n  fallbackChildFragment.return = workInProgress;\n  primaryChildFragment.sibling = fallbackChildFragment;\n  workInProgress.child = primaryChildFragment;\n\n  if ((workInProgress.mode & ConcurrentMode) !== NoMode) {\n    // We will have dropped the effect list which contains the\n    // deletion. We need to reconcile to delete the current child.\n    reconcileChildFibers(workInProgress, current.child, null, renderLanes);\n  }\n\n  return fallbackChildFragment;\n}\n\nfunction mountDehydratedSuspenseComponent(workInProgress, suspenseInstance, renderLanes) {\n  // During the first pass, we'll bail out and not drill into the children.\n  // Instead, we'll leave the content in place and try to hydrate it later.\n  if ((workInProgress.mode & ConcurrentMode) === NoMode) {\n    if (__DEV__) {\n      console.error('Cannot hydrate Suspense in legacy mode. Switch from ' + 'ReactDOM.hydrate(element, container) to ' + 'ReactDOM.createRoot(container, { hydrate: true })' + '.render(element) or remove the Suspense components from ' + 'the server rendered components.');\n    }\n\n    workInProgress.lanes = laneToLanes(SyncLane);\n  } else if (isSuspenseInstanceFallback(suspenseInstance)) {\n    // This is a client-only boundary. Since we won't get any content from the server\n    // for this, we need to schedule that at a higher priority based on when it would\n    // have timed out. In theory we could render it in this pass but it would have the\n    // wrong priority associated with it and will prevent hydration of parent path.\n    // Instead, we'll leave work left on it to render it in a separate commit.\n    // TODO This time should be the time at which the server rendered response that is\n    // a parent to this boundary was displayed. However, since we currently don't have\n    // a protocol to transfer that time, we'll just estimate it by using the current\n    // time. This will mean that Suspense timeouts are slightly shifted to later than\n    // they should be.\n    // Schedule a normal pri update to render this content.\n    workInProgress.lanes = laneToLanes(DefaultHydrationLane);\n  } else {\n    // We'll continue hydrating the rest at offscreen priority since we'll already\n    // be showing the right content coming from the server, it is no rush.\n    workInProgress.lanes = laneToLanes(OffscreenLane);\n  }\n\n  return null;\n}\n\nfunction updateDehydratedSuspenseComponent(current, workInProgress, suspenseInstance, suspenseState, renderLanes) {\n  // We should never be hydrating at this point because it is the first pass,\n  // but after we've already committed once.\n  warnIfHydrating();\n\n  if ((getExecutionContext() & RetryAfterError) !== NoContext) {\n    return retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes);\n  }\n\n  if ((workInProgress.mode & ConcurrentMode) === NoMode) {\n    return retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes);\n  }\n\n  if (isSuspenseInstanceFallback(suspenseInstance)) {\n    // This boundary is in a permanent fallback state. In this case, we'll never\n    // get an update and we'll never be able to hydrate the final content. Let's just try the\n    // client side render instead.\n    return retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes);\n  }\n\n  if (enableLazyContextPropagation && // TODO: Factoring is a little weird, since we check this right below, too.\n  // But don't want to re-arrange the if-else chain until/unless this\n  // feature lands.\n  !didReceiveUpdate) {\n    // We need to check if any children have context before we decide to bail\n    // out, so propagate the changes now.\n    lazilyPropagateParentContextChanges(current, workInProgress, renderLanes);\n  } // We use lanes to indicate that a child might depend on context, so if\n  // any context has changed, we need to treat is as if the input might have changed.\n\n\n  const hasContextChanged = includesSomeLane(renderLanes, current.childLanes);\n\n  if (didReceiveUpdate || hasContextChanged) {\n    // This boundary has changed since the first render. This means that we are now unable to\n    // hydrate it. We might still be able to hydrate it using a higher priority lane.\n    const root = getWorkInProgressRoot();\n\n    if (root !== null) {\n      const attemptHydrationAtLane = getBumpedLaneForHydration(root, renderLanes);\n\n      if (attemptHydrationAtLane !== NoLane && attemptHydrationAtLane !== suspenseState.retryLane) {\n        // Intentionally mutating since this render will get interrupted. This\n        // is one of the very rare times where we mutate the current tree\n        // during the render phase.\n        suspenseState.retryLane = attemptHydrationAtLane; // TODO: Ideally this would inherit the event time of the current render\n\n        const eventTime = NoTimestamp;\n        scheduleUpdateOnFiber(current, attemptHydrationAtLane, eventTime);\n      } else {// We have already tried to ping at a higher priority than we're rendering with\n        // so if we got here, we must have failed to hydrate at those levels. We must\n        // now give up. Instead, we're going to delete the whole subtree and instead inject\n        // a new real Suspense boundary to take its place, which may render content\n        // or fallback. This might suspend for a while and if it does we might still have\n        // an opportunity to hydrate before this pass commits.\n      }\n    } // If we have scheduled higher pri work above, this will probably just abort the render\n    // since we now have higher priority work, but in case it doesn't, we need to prepare to\n    // render something, if we time out. Even if that requires us to delete everything and\n    // skip hydration.\n    // Delay having to do this as long as the suspense timeout allows us.\n\n\n    renderDidSuspendDelayIfPossible();\n    return retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes);\n  } else if (isSuspenseInstancePending(suspenseInstance)) {\n    // This component is still pending more data from the server, so we can't hydrate its\n    // content. We treat it as if this component suspended itself. It might seem as if\n    // we could just try to render it client-side instead. However, this will perform a\n    // lot of unnecessary work and is unlikely to complete since it often will suspend\n    // on missing data anyway. Additionally, the server might be able to render more\n    // than we can on the client yet. In that case we'd end up with more fallback states\n    // on the client than if we just leave it alone. If the server times out or errors\n    // these should update this boundary to the permanent Fallback state instead.\n    // Mark it as having captured (i.e. suspended).\n    workInProgress.flags |= DidCapture; // Leave the child in place. I.e. the dehydrated fragment.\n\n    workInProgress.child = current.child; // Register a callback to retry this boundary once the server has sent the result.\n\n    const retry = retryDehydratedSuspenseBoundary.bind(null, current);\n    registerSuspenseInstanceRetry(suspenseInstance, retry);\n    return null;\n  } else {\n    // This is the first attempt.\n    reenterHydrationStateFromDehydratedSuspenseInstance(workInProgress, suspenseInstance, suspenseState.treeContext);\n    const nextProps = workInProgress.pendingProps;\n    const primaryChildren = nextProps.children;\n    const primaryChildFragment = mountSuspensePrimaryChildren(workInProgress, primaryChildren, renderLanes); // Mark the children as hydrating. This is a fast path to know whether this\n    // tree is part of a hydrating tree. This is used to determine if a child\n    // node has fully mounted yet, and for scheduling event replaying.\n    // Conceptually this is similar to Placement in that a new subtree is\n    // inserted into the React tree here. It just happens to not need DOM\n    // mutations because it already exists.\n\n    primaryChildFragment.flags |= Hydrating;\n    return primaryChildFragment;\n  }\n}\n\nfunction scheduleWorkOnFiber(fiber, renderLanes) {\n  fiber.lanes = mergeLanes(fiber.lanes, renderLanes);\n  const alternate = fiber.alternate;\n\n  if (alternate !== null) {\n    alternate.lanes = mergeLanes(alternate.lanes, renderLanes);\n  }\n\n  scheduleWorkOnParentPath(fiber.return, renderLanes);\n}\n\nfunction propagateSuspenseContextChange(workInProgress, firstChild, renderLanes) {\n  // Mark any Suspense boundaries with fallbacks as having work to do.\n  // If they were previously forced into fallbacks, they may now be able\n  // to unblock.\n  let node = firstChild;\n\n  while (node !== null) {\n    if (node.tag === SuspenseComponent) {\n      const state = node.memoizedState;\n\n      if (state !== null) {\n        scheduleWorkOnFiber(node, renderLanes);\n      }\n    } else if (node.tag === SuspenseListComponent) {\n      // If the tail is hidden there might not be an Suspense boundaries\n      // to schedule work on. In this case we have to schedule it on the\n      // list itself.\n      // We don't have to traverse to the children of the list since\n      // the list will propagate the change when it rerenders.\n      scheduleWorkOnFiber(node, renderLanes);\n    } else if (node.child !== null) {\n      node.child.return = node;\n      node = node.child;\n      continue;\n    }\n\n    if (node === workInProgress) {\n      return;\n    }\n\n    while (node.sibling === null) {\n      if (node.return === null || node.return === workInProgress) {\n        return;\n      }\n\n      node = node.return;\n    }\n\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n}\n\nfunction findLastContentRow(firstChild) {\n  // This is going to find the last row among these children that is already\n  // showing content on the screen, as opposed to being in fallback state or\n  // new. If a row has multiple Suspense boundaries, any of them being in the\n  // fallback state, counts as the whole row being in a fallback state.\n  // Note that the \"rows\" will be workInProgress, but any nested children\n  // will still be current since we haven't rendered them yet. The mounted\n  // order may not be the same as the new order. We use the new order.\n  let row = firstChild;\n  let lastContentRow = null;\n\n  while (row !== null) {\n    const currentRow = row.alternate; // New rows can't be content rows.\n\n    if (currentRow !== null && findFirstSuspended(currentRow) === null) {\n      lastContentRow = row;\n    }\n\n    row = row.sibling;\n  }\n\n  return lastContentRow;\n}\n\nfunction validateRevealOrder(revealOrder) {\n  if (__DEV__) {\n    if (revealOrder !== undefined && revealOrder !== 'forwards' && revealOrder !== 'backwards' && revealOrder !== 'together' && !didWarnAboutRevealOrder[revealOrder]) {\n      didWarnAboutRevealOrder[revealOrder] = true;\n\n      if (typeof revealOrder === 'string') {\n        switch (revealOrder.toLowerCase()) {\n          case 'together':\n          case 'forwards':\n          case 'backwards':\n            {\n              console.error('\"%s\" is not a valid value for revealOrder on <SuspenseList />. ' + 'Use lowercase \"%s\" instead.', revealOrder, revealOrder.toLowerCase());\n              break;\n            }\n\n          case 'forward':\n          case 'backward':\n            {\n              console.error('\"%s\" is not a valid value for revealOrder on <SuspenseList />. ' + 'React uses the -s suffix in the spelling. Use \"%ss\" instead.', revealOrder, revealOrder.toLowerCase());\n              break;\n            }\n\n          default:\n            console.error('\"%s\" is not a supported revealOrder on <SuspenseList />. ' + 'Did you mean \"together\", \"forwards\" or \"backwards\"?', revealOrder);\n            break;\n        }\n      } else {\n        console.error('%s is not a supported value for revealOrder on <SuspenseList />. ' + 'Did you mean \"together\", \"forwards\" or \"backwards\"?', revealOrder);\n      }\n    }\n  }\n}\n\nfunction validateTailOptions(tailMode, revealOrder) {\n  if (__DEV__) {\n    if (tailMode !== undefined && !didWarnAboutTailOptions[tailMode]) {\n      if (tailMode !== 'collapsed' && tailMode !== 'hidden') {\n        didWarnAboutTailOptions[tailMode] = true;\n        console.error('\"%s\" is not a supported value for tail on <SuspenseList />. ' + 'Did you mean \"collapsed\" or \"hidden\"?', tailMode);\n      } else if (revealOrder !== 'forwards' && revealOrder !== 'backwards') {\n        didWarnAboutTailOptions[tailMode] = true;\n        console.error('<SuspenseList tail=\"%s\" /> is only valid if revealOrder is ' + '\"forwards\" or \"backwards\". ' + 'Did you mean to specify revealOrder=\"forwards\"?', tailMode);\n      }\n    }\n  }\n}\n\nfunction validateSuspenseListNestedChild(childSlot, index) {\n  if (__DEV__) {\n    const isAnArray = isArray(childSlot);\n    const isIterable = !isAnArray && typeof getIteratorFn(childSlot) === 'function';\n\n    if (isAnArray || isIterable) {\n      const type = isAnArray ? 'array' : 'iterable';\n      console.error('A nested %s was passed to row #%s in <SuspenseList />. Wrap it in ' + 'an additional SuspenseList to configure its revealOrder: ' + '<SuspenseList revealOrder=...> ... ' + '<SuspenseList revealOrder=...>{%s}</SuspenseList> ... ' + '</SuspenseList>', type, index, type);\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction validateSuspenseListChildren(children, revealOrder) {\n  if (__DEV__) {\n    if ((revealOrder === 'forwards' || revealOrder === 'backwards') && children !== undefined && children !== null && children !== false) {\n      if (isArray(children)) {\n        for (let i = 0; i < children.length; i++) {\n          if (!validateSuspenseListNestedChild(children[i], i)) {\n            return;\n          }\n        }\n      } else {\n        const iteratorFn = getIteratorFn(children);\n\n        if (typeof iteratorFn === 'function') {\n          const childrenIterator = iteratorFn.call(children);\n\n          if (childrenIterator) {\n            let step = childrenIterator.next();\n            let i = 0;\n\n            for (; !step.done; step = childrenIterator.next()) {\n              if (!validateSuspenseListNestedChild(step.value, i)) {\n                return;\n              }\n\n              i++;\n            }\n          }\n        } else {\n          console.error('A single row was passed to a <SuspenseList revealOrder=\"%s\" />. ' + 'This is not useful since it needs multiple rows. ' + 'Did you mean to pass multiple children or an array?', revealOrder);\n        }\n      }\n    }\n  }\n}\n\nfunction initSuspenseListRenderState(workInProgress, isBackwards, tail, lastContentRow, tailMode) {\n  const renderState = workInProgress.memoizedState;\n\n  if (renderState === null) {\n    workInProgress.memoizedState = {\n      isBackwards: isBackwards,\n      rendering: null,\n      renderingStartTime: 0,\n      last: lastContentRow,\n      tail: tail,\n      tailMode: tailMode\n    };\n  } else {\n    // We can reuse the existing object from previous renders.\n    renderState.isBackwards = isBackwards;\n    renderState.rendering = null;\n    renderState.renderingStartTime = 0;\n    renderState.last = lastContentRow;\n    renderState.tail = tail;\n    renderState.tailMode = tailMode;\n  }\n} // This can end up rendering this component multiple passes.\n// The first pass splits the children fibers into two sets. A head and tail.\n// We first render the head. If anything is in fallback state, we do another\n// pass through beginWork to rerender all children (including the tail) with\n// the force suspend context. If the first render didn't have anything in\n// in fallback state. Then we render each row in the tail one-by-one.\n// That happens in the completeWork phase without going back to beginWork.\n\n\nfunction updateSuspenseListComponent(current, workInProgress, renderLanes) {\n  const nextProps = workInProgress.pendingProps;\n  const revealOrder = nextProps.revealOrder;\n  const tailMode = nextProps.tail;\n  const newChildren = nextProps.children;\n  validateRevealOrder(revealOrder);\n  validateTailOptions(tailMode, revealOrder);\n  validateSuspenseListChildren(newChildren, revealOrder);\n  reconcileChildren(current, workInProgress, newChildren, renderLanes);\n  let suspenseContext = suspenseStackCursor.current;\n  const shouldForceFallback = hasSuspenseContext(suspenseContext, ForceSuspenseFallback);\n\n  if (shouldForceFallback) {\n    suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);\n    workInProgress.flags |= DidCapture;\n  } else {\n    const didSuspendBefore = current !== null && (current.flags & DidCapture) !== NoFlags;\n\n    if (didSuspendBefore) {\n      // If we previously forced a fallback, we need to schedule work\n      // on any nested boundaries to let them know to try to render\n      // again. This is the same as context updating.\n      propagateSuspenseContextChange(workInProgress, workInProgress.child, renderLanes);\n    }\n\n    suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);\n  }\n\n  pushSuspenseContext(workInProgress, suspenseContext);\n\n  if ((workInProgress.mode & ConcurrentMode) === NoMode) {\n    // In legacy mode, SuspenseList doesn't work so we just\n    // use make it a noop by treating it as the default revealOrder.\n    workInProgress.memoizedState = null;\n  } else {\n    switch (revealOrder) {\n      case 'forwards':\n        {\n          const lastContentRow = findLastContentRow(workInProgress.child);\n          let tail;\n\n          if (lastContentRow === null) {\n            // The whole list is part of the tail.\n            // TODO: We could fast path by just rendering the tail now.\n            tail = workInProgress.child;\n            workInProgress.child = null;\n          } else {\n            // Disconnect the tail rows after the content row.\n            // We're going to render them separately later.\n            tail = lastContentRow.sibling;\n            lastContentRow.sibling = null;\n          }\n\n          initSuspenseListRenderState(workInProgress, false, // isBackwards\n          tail, lastContentRow, tailMode);\n          break;\n        }\n\n      case 'backwards':\n        {\n          // We're going to find the first row that has existing content.\n          // At the same time we're going to reverse the list of everything\n          // we pass in the meantime. That's going to be our tail in reverse\n          // order.\n          let tail = null;\n          let row = workInProgress.child;\n          workInProgress.child = null;\n\n          while (row !== null) {\n            const currentRow = row.alternate; // New rows can't be content rows.\n\n            if (currentRow !== null && findFirstSuspended(currentRow) === null) {\n              // This is the beginning of the main content.\n              workInProgress.child = row;\n              break;\n            }\n\n            const nextRow = row.sibling;\n            row.sibling = tail;\n            tail = row;\n            row = nextRow;\n          } // TODO: If workInProgress.child is null, we can continue on the tail immediately.\n\n\n          initSuspenseListRenderState(workInProgress, true, // isBackwards\n          tail, null, // last\n          tailMode);\n          break;\n        }\n\n      case 'together':\n        {\n          initSuspenseListRenderState(workInProgress, false, // isBackwards\n          null, // tail\n          null, // last\n          undefined);\n          break;\n        }\n\n      default:\n        {\n          // The default reveal order is the same as not having\n          // a boundary.\n          workInProgress.memoizedState = null;\n        }\n    }\n  }\n\n  return workInProgress.child;\n}\n\nfunction updatePortalComponent(current, workInProgress, renderLanes) {\n  pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n  const nextChildren = workInProgress.pendingProps;\n\n  if (current === null) {\n    // Portals are special because we don't append the children during mount\n    // but at commit. Therefore we need to track insertions which the normal\n    // flow doesn't do during mount. This doesn't happen at the root because\n    // the root always starts with a \"current\" with a null child.\n    // TODO: Consider unifying this with how the root works.\n    workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderLanes);\n  } else {\n    reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  }\n\n  return workInProgress.child;\n}\n\nlet hasWarnedAboutUsingNoValuePropOnContextProvider = false;\n\nfunction updateContextProvider(current, workInProgress, renderLanes) {\n  const providerType = workInProgress.type;\n  const context = providerType._context;\n  const newProps = workInProgress.pendingProps;\n  const oldProps = workInProgress.memoizedProps;\n  const newValue = newProps.value;\n\n  if (__DEV__) {\n    if (!('value' in newProps)) {\n      if (!hasWarnedAboutUsingNoValuePropOnContextProvider) {\n        hasWarnedAboutUsingNoValuePropOnContextProvider = true;\n        console.error('The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?');\n      }\n    }\n\n    const providerPropTypes = workInProgress.type.propTypes;\n\n    if (providerPropTypes) {\n      checkPropTypes(providerPropTypes, newProps, 'prop', 'Context.Provider');\n    }\n  }\n\n  pushProvider(workInProgress, context, newValue);\n\n  if (enableLazyContextPropagation) {// In the lazy propagation implementation, we don't scan for matching\n    // consumers until something bails out, because until something bails out\n    // we're going to visit those nodes, anyway. The trade-off is that it shifts\n    // responsibility to the consumer to track whether something has changed.\n  } else {\n    if (oldProps !== null) {\n      const oldValue = oldProps.value;\n\n      if (is(oldValue, newValue)) {\n        // No change. Bailout early if children are the same.\n        if (oldProps.children === newProps.children && !hasLegacyContextChanged()) {\n          return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n        }\n      } else {\n        // The context value changed. Search for matching consumers and schedule\n        // them to update.\n        propagateContextChange(workInProgress, context, renderLanes);\n      }\n    }\n  }\n\n  const newChildren = newProps.children;\n  reconcileChildren(current, workInProgress, newChildren, renderLanes);\n  return workInProgress.child;\n}\n\nlet hasWarnedAboutUsingContextAsConsumer = false;\n\nfunction updateContextConsumer(current, workInProgress, renderLanes) {\n  let context = workInProgress.type; // The logic below for Context differs depending on PROD or DEV mode. In\n  // DEV mode, we create a separate object for Context.Consumer that acts\n  // like a proxy to Context. This proxy object adds unnecessary code in PROD\n  // so we use the old behaviour (Context.Consumer references Context) to\n  // reduce size and overhead. The separate object references context via\n  // a property called \"_context\", which also gives us the ability to check\n  // in DEV mode if this property exists or not and warn if it does not.\n\n  if (__DEV__) {\n    if (context._context === undefined) {\n      // This may be because it's a Context (rather than a Consumer).\n      // Or it may be because it's older React where they're the same thing.\n      // We only want to warn if we're sure it's a new React.\n      if (context !== context.Consumer) {\n        if (!hasWarnedAboutUsingContextAsConsumer) {\n          hasWarnedAboutUsingContextAsConsumer = true;\n          console.error('Rendering <Context> directly is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');\n        }\n      }\n    } else {\n      context = context._context;\n    }\n  }\n\n  const newProps = workInProgress.pendingProps;\n  const render = newProps.children;\n\n  if (__DEV__) {\n    if (typeof render !== 'function') {\n      console.error('A context consumer was rendered with multiple children, or a child ' + \"that isn't a function. A context consumer expects a single child \" + 'that is a function. If you did pass a function, make sure there ' + 'is no trailing or leading whitespace around it.');\n    }\n  }\n\n  prepareToReadContext(workInProgress, renderLanes);\n  const newValue = readContext(context);\n\n  if (enableSchedulingProfiler) {\n    markComponentRenderStarted(workInProgress);\n  }\n\n  let newChildren;\n\n  if (__DEV__) {\n    ReactCurrentOwner.current = workInProgress;\n    setIsRendering(true);\n    newChildren = render(newValue);\n    setIsRendering(false);\n  } else {\n    newChildren = render(newValue);\n  }\n\n  if (enableSchedulingProfiler) {\n    markComponentRenderStopped();\n  } // React DevTools reads this flag.\n\n\n  workInProgress.flags |= PerformedWork;\n  reconcileChildren(current, workInProgress, newChildren, renderLanes);\n  return workInProgress.child;\n}\n\nfunction updateScopeComponent(current, workInProgress, renderLanes) {\n  const nextProps = workInProgress.pendingProps;\n  const nextChildren = nextProps.children;\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\nexport function markWorkInProgressReceivedUpdate() {\n  didReceiveUpdate = true;\n}\nexport function checkIfWorkInProgressReceivedUpdate() {\n  return didReceiveUpdate;\n}\n\nfunction bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes) {\n  if (current !== null) {\n    // Reuse previous dependencies\n    workInProgress.dependencies = current.dependencies;\n  }\n\n  if (enableProfilerTimer) {\n    // Don't update \"base\" render times for bailouts.\n    stopProfilerTimerIfRunning(workInProgress);\n  }\n\n  markSkippedUpdateLanes(workInProgress.lanes); // Check if the children have any pending work.\n\n  if (!includesSomeLane(renderLanes, workInProgress.childLanes)) {\n    // The children don't have any work either. We can skip them.\n    // TODO: Once we add back resuming, we should check if the children are\n    // a work-in-progress set. If so, we need to transfer their effects.\n    if (enableLazyContextPropagation && current !== null) {\n      // Before bailing out, check if there are any context changes in\n      // the children.\n      lazilyPropagateParentContextChanges(current, workInProgress, renderLanes);\n\n      if (!includesSomeLane(renderLanes, workInProgress.childLanes)) {\n        return null;\n      }\n    } else {\n      return null;\n    }\n  } // This fiber doesn't have work, but its subtree does. Clone the child\n  // fibers and continue.\n\n\n  cloneChildFibers(current, workInProgress);\n  return workInProgress.child;\n}\n\nfunction remountFiber(current, oldWorkInProgress, newWorkInProgress) {\n  if (__DEV__) {\n    const returnFiber = oldWorkInProgress.return;\n\n    if (returnFiber === null) {\n      // eslint-disable-next-line react-internal/prod-error-codes\n      throw new Error('Cannot swap the root fiber.');\n    } // Disconnect from the old current.\n    // It will get deleted.\n\n\n    current.alternate = null;\n    oldWorkInProgress.alternate = null; // Connect to the new tree.\n\n    newWorkInProgress.index = oldWorkInProgress.index;\n    newWorkInProgress.sibling = oldWorkInProgress.sibling;\n    newWorkInProgress.return = oldWorkInProgress.return;\n    newWorkInProgress.ref = oldWorkInProgress.ref; // Replace the child/sibling pointers above it.\n\n    if (oldWorkInProgress === returnFiber.child) {\n      returnFiber.child = newWorkInProgress;\n    } else {\n      let prevSibling = returnFiber.child;\n\n      if (prevSibling === null) {\n        // eslint-disable-next-line react-internal/prod-error-codes\n        throw new Error('Expected parent to have a child.');\n      }\n\n      while (prevSibling.sibling !== oldWorkInProgress) {\n        prevSibling = prevSibling.sibling;\n\n        if (prevSibling === null) {\n          // eslint-disable-next-line react-internal/prod-error-codes\n          throw new Error('Expected to find the previous sibling.');\n        }\n      }\n\n      prevSibling.sibling = newWorkInProgress;\n    } // Delete the old fiber and place the new one.\n    // Since the old fiber is disconnected, we have to schedule it manually.\n\n\n    const deletions = returnFiber.deletions;\n\n    if (deletions === null) {\n      returnFiber.deletions = [current];\n      returnFiber.flags |= ChildDeletion;\n    } else {\n      deletions.push(current);\n    }\n\n    newWorkInProgress.flags |= Placement; // Restart work from the new fiber.\n\n    return newWorkInProgress;\n  } else {\n    throw new Error('Did not expect this call in production. ' + 'This is a bug in React. Please file an issue.');\n  }\n}\n\nfunction checkScheduledUpdateOrContext(current, renderLanes) {\n  // Before performing an early bailout, we must check if there are pending\n  // updates or context.\n  const updateLanes = current.lanes;\n\n  if (includesSomeLane(updateLanes, renderLanes)) {\n    return true;\n  } // No pending update, but because context is propagated lazily, we need\n  // to check for a context change before we bail out.\n\n\n  if (enableLazyContextPropagation) {\n    const dependencies = current.dependencies;\n\n    if (dependencies !== null && checkIfContextChanged(dependencies)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress, renderLanes) {\n  // This fiber does not have any pending work. Bailout without entering\n  // the begin phase. There's still some bookkeeping we that needs to be done\n  // in this optimized path, mostly pushing stuff onto the stack.\n  switch (workInProgress.tag) {\n    case HostRoot:\n      pushHostRootContext(workInProgress);\n\n      if (enableCache) {\n        const root = workInProgress.stateNode;\n        const cache = current.memoizedState.cache;\n        pushCacheProvider(workInProgress, cache);\n        pushRootCachePool(root);\n      }\n\n      resetHydrationState();\n      break;\n\n    case HostComponent:\n      pushHostContext(workInProgress);\n      break;\n\n    case ClassComponent:\n      {\n        const Component = workInProgress.type;\n\n        if (isLegacyContextProvider(Component)) {\n          pushLegacyContextProvider(workInProgress);\n        }\n\n        break;\n      }\n\n    case HostPortal:\n      pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n      break;\n\n    case ContextProvider:\n      {\n        const newValue = workInProgress.memoizedProps.value;\n        const context = workInProgress.type._context;\n        pushProvider(workInProgress, context, newValue);\n        break;\n      }\n\n    case Profiler:\n      if (enableProfilerTimer) {\n        // Profiler should only call onRender when one of its descendants actually rendered.\n        const hasChildWork = includesSomeLane(renderLanes, workInProgress.childLanes);\n\n        if (hasChildWork) {\n          workInProgress.flags |= Update;\n        }\n\n        if (enableProfilerCommitHooks) {\n          // Reset effect durations for the next eventual effect phase.\n          // These are reset during render to allow the DevTools commit hook a chance to read them,\n          const stateNode = workInProgress.stateNode;\n          stateNode.effectDuration = 0;\n          stateNode.passiveEffectDuration = 0;\n        }\n      }\n\n      break;\n\n    case SuspenseComponent:\n      {\n        const state = workInProgress.memoizedState;\n\n        if (state !== null) {\n          if (enableSuspenseServerRenderer) {\n            if (state.dehydrated !== null) {\n              pushSuspenseContext(workInProgress, setDefaultShallowSuspenseContext(suspenseStackCursor.current)); // We know that this component will suspend again because if it has\n              // been unsuspended it has committed as a resolved Suspense component.\n              // If it needs to be retried, it should have work scheduled on it.\n\n              workInProgress.flags |= DidCapture; // We should never render the children of a dehydrated boundary until we\n              // upgrade it. We return null instead of bailoutOnAlreadyFinishedWork.\n\n              return null;\n            }\n          } // If this boundary is currently timed out, we need to decide\n          // whether to retry the primary children, or to skip over it and\n          // go straight to the fallback. Check the priority of the primary\n          // child fragment.\n\n\n          const primaryChildFragment = workInProgress.child;\n          const primaryChildLanes = primaryChildFragment.childLanes;\n\n          if (includesSomeLane(renderLanes, primaryChildLanes)) {\n            // The primary children have pending work. Use the normal path\n            // to attempt to render the primary children again.\n            return updateSuspenseComponent(current, workInProgress, renderLanes);\n          } else {\n            // The primary child fragment does not have pending work marked\n            // on it\n            pushSuspenseContext(workInProgress, setDefaultShallowSuspenseContext(suspenseStackCursor.current)); // The primary children do not have pending work with sufficient\n            // priority. Bailout.\n\n            const child = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n\n            if (child !== null) {\n              // The fallback children have pending work. Skip over the\n              // primary children and work on the fallback.\n              return child.sibling;\n            } else {\n              // Note: We can return `null` here because we already checked\n              // whether there were nested context consumers, via the call to\n              // `bailoutOnAlreadyFinishedWork` above.\n              return null;\n            }\n          }\n        } else {\n          pushSuspenseContext(workInProgress, setDefaultShallowSuspenseContext(suspenseStackCursor.current));\n        }\n\n        break;\n      }\n\n    case SuspenseListComponent:\n      {\n        const didSuspendBefore = (current.flags & DidCapture) !== NoFlags;\n        let hasChildWork = includesSomeLane(renderLanes, workInProgress.childLanes);\n\n        if (enableLazyContextPropagation && !hasChildWork) {\n          // Context changes may not have been propagated yet. We need to do\n          // that now, before we can decide whether to bail out.\n          // TODO: We use `childLanes` as a heuristic for whether there is\n          // remaining work in a few places, including\n          // `bailoutOnAlreadyFinishedWork` and\n          // `updateDehydratedSuspenseComponent`. We should maybe extract this\n          // into a dedicated function.\n          lazilyPropagateParentContextChanges(current, workInProgress, renderLanes);\n          hasChildWork = includesSomeLane(renderLanes, workInProgress.childLanes);\n        }\n\n        if (didSuspendBefore) {\n          if (hasChildWork) {\n            // If something was in fallback state last time, and we have all the\n            // same children then we're still in progressive loading state.\n            // Something might get unblocked by state updates or retries in the\n            // tree which will affect the tail. So we need to use the normal\n            // path to compute the correct tail.\n            return updateSuspenseListComponent(current, workInProgress, renderLanes);\n          } // If none of the children had any work, that means that none of\n          // them got retried so they'll still be blocked in the same way\n          // as before. We can fast bail out.\n\n\n          workInProgress.flags |= DidCapture;\n        } // If nothing suspended before and we're rendering the same children,\n        // then the tail doesn't matter. Anything new that suspends will work\n        // in the \"together\" mode, so we can continue from the state we had.\n\n\n        const renderState = workInProgress.memoizedState;\n\n        if (renderState !== null) {\n          // Reset to the \"together\" mode in case we've started a different\n          // update in the past but didn't complete it.\n          renderState.rendering = null;\n          renderState.tail = null;\n          renderState.lastEffect = null;\n        }\n\n        pushSuspenseContext(workInProgress, suspenseStackCursor.current);\n\n        if (hasChildWork) {\n          break;\n        } else {\n          // If none of the children had any work, that means that none of\n          // them got retried so they'll still be blocked in the same way\n          // as before. We can fast bail out.\n          return null;\n        }\n      }\n\n    case OffscreenComponent:\n    case LegacyHiddenComponent:\n      {\n        // Need to check if the tree still needs to be deferred. This is\n        // almost identical to the logic used in the normal update path,\n        // so we'll just enter that. The only difference is we'll bail out\n        // at the next level instead of this one, because the child props\n        // have not changed. Which is fine.\n        // TODO: Probably should refactor `beginWork` to split the bailout\n        // path from the normal path. I'm tempted to do a labeled break here\n        // but I won't :)\n        workInProgress.lanes = NoLanes;\n        return updateOffscreenComponent(current, workInProgress, renderLanes);\n      }\n\n    case CacheComponent:\n      {\n        if (enableCache) {\n          const cache = current.memoizedState.cache;\n          pushCacheProvider(workInProgress, cache);\n        }\n\n        break;\n      }\n  }\n\n  return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n}\n\nfunction beginWork(current, workInProgress, renderLanes) {\n  if (__DEV__) {\n    if (workInProgress._debugNeedsRemount && current !== null) {\n      // This will restart the begin phase with a new fiber.\n      return remountFiber(current, workInProgress, createFiberFromTypeAndProps(workInProgress.type, workInProgress.key, workInProgress.pendingProps, workInProgress._debugOwner || null, workInProgress.mode, workInProgress.lanes));\n    }\n  }\n\n  if (current !== null) {\n    const oldProps = current.memoizedProps;\n    const newProps = workInProgress.pendingProps;\n\n    if (oldProps !== newProps || hasLegacyContextChanged() || ( // Force a re-render if the implementation changed due to hot reload:\n    __DEV__ ? workInProgress.type !== current.type : false)) {\n      // If props or context changed, mark the fiber as having performed work.\n      // This may be unset if the props are determined to be equal later (memo).\n      didReceiveUpdate = true;\n    } else {\n      // Neither props nor legacy context changes. Check if there's a pending\n      // update or context change.\n      const hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current, renderLanes);\n\n      if (!hasScheduledUpdateOrContext && // If this is the second pass of an error or suspense boundary, there\n      // may not be work scheduled on `current`, so we check for this flag.\n      (workInProgress.flags & DidCapture) === NoFlags) {\n        // No pending updates or context. Bail out now.\n        didReceiveUpdate = false;\n        return attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress, renderLanes);\n      }\n\n      if ((current.flags & ForceUpdateForLegacySuspense) !== NoFlags) {\n        // This is a special case that only exists for legacy mode.\n        // See https://github.com/facebook/react/pull/19216.\n        didReceiveUpdate = true;\n      } else {\n        // An update was scheduled on this fiber, but there are no new props\n        // nor legacy context. Set this to false. If an update queue or context\n        // consumer produces a changed value, it will set this to true. Otherwise,\n        // the component will assume the children have not changed and bail out.\n        didReceiveUpdate = false;\n      }\n    }\n  } else {\n    didReceiveUpdate = false;\n\n    if (getIsHydrating() && isForkedChild(workInProgress)) {\n      // Check if this child belongs to a list of muliple children in\n      // its parent.\n      //\n      // In a true multi-threaded implementation, we would render children on\n      // parallel threads. This would represent the beginning of a new render\n      // thread for this subtree.\n      //\n      // We only use this for id generation during hydration, which is why the\n      // logic is located in this special branch.\n      const slotIndex = workInProgress.index;\n      const numberOfForks = getForksAtLevel(workInProgress);\n      pushTreeId(workInProgress, numberOfForks, slotIndex);\n    }\n  } // Before entering the begin phase, clear pending update priority.\n  // TODO: This assumes that we're about to evaluate the component and process\n  // the update queue. However, there's an exception: SimpleMemoComponent\n  // sometimes bails out later in the begin phase. This indicates that we should\n  // move this assignment out of the common path and into each branch.\n\n\n  workInProgress.lanes = NoLanes;\n\n  switch (workInProgress.tag) {\n    case IndeterminateComponent:\n      {\n        return mountIndeterminateComponent(current, workInProgress, workInProgress.type, renderLanes);\n      }\n\n    case LazyComponent:\n      {\n        const elementType = workInProgress.elementType;\n        return mountLazyComponent(current, workInProgress, elementType, renderLanes);\n      }\n\n    case FunctionComponent:\n      {\n        const Component = workInProgress.type;\n        const unresolvedProps = workInProgress.pendingProps;\n        const resolvedProps = workInProgress.elementType === Component ? unresolvedProps : resolveDefaultProps(Component, unresolvedProps);\n        return updateFunctionComponent(current, workInProgress, Component, resolvedProps, renderLanes);\n      }\n\n    case ClassComponent:\n      {\n        const Component = workInProgress.type;\n        const unresolvedProps = workInProgress.pendingProps;\n        const resolvedProps = workInProgress.elementType === Component ? unresolvedProps : resolveDefaultProps(Component, unresolvedProps);\n        return updateClassComponent(current, workInProgress, Component, resolvedProps, renderLanes);\n      }\n\n    case HostRoot:\n      return updateHostRoot(current, workInProgress, renderLanes);\n\n    case HostComponent:\n      return updateHostComponent(current, workInProgress, renderLanes);\n\n    case HostText:\n      return updateHostText(current, workInProgress);\n\n    case SuspenseComponent:\n      return updateSuspenseComponent(current, workInProgress, renderLanes);\n\n    case HostPortal:\n      return updatePortalComponent(current, workInProgress, renderLanes);\n\n    case ForwardRef:\n      {\n        const type = workInProgress.type;\n        const unresolvedProps = workInProgress.pendingProps;\n        const resolvedProps = workInProgress.elementType === type ? unresolvedProps : resolveDefaultProps(type, unresolvedProps);\n        return updateForwardRef(current, workInProgress, type, resolvedProps, renderLanes);\n      }\n\n    case Fragment:\n      return updateFragment(current, workInProgress, renderLanes);\n\n    case Mode:\n      return updateMode(current, workInProgress, renderLanes);\n\n    case Profiler:\n      return updateProfiler(current, workInProgress, renderLanes);\n\n    case ContextProvider:\n      return updateContextProvider(current, workInProgress, renderLanes);\n\n    case ContextConsumer:\n      return updateContextConsumer(current, workInProgress, renderLanes);\n\n    case MemoComponent:\n      {\n        const type = workInProgress.type;\n        const unresolvedProps = workInProgress.pendingProps; // Resolve outer props first, then resolve inner props.\n\n        let resolvedProps = resolveDefaultProps(type, unresolvedProps);\n\n        if (__DEV__) {\n          if (workInProgress.type !== workInProgress.elementType) {\n            const outerPropTypes = type.propTypes;\n\n            if (outerPropTypes) {\n              checkPropTypes(outerPropTypes, resolvedProps, // Resolved for outer only\n              'prop', getComponentNameFromType(type));\n            }\n          }\n        }\n\n        resolvedProps = resolveDefaultProps(type.type, resolvedProps);\n        return updateMemoComponent(current, workInProgress, type, resolvedProps, renderLanes);\n      }\n\n    case SimpleMemoComponent:\n      {\n        return updateSimpleMemoComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);\n      }\n\n    case IncompleteClassComponent:\n      {\n        const Component = workInProgress.type;\n        const unresolvedProps = workInProgress.pendingProps;\n        const resolvedProps = workInProgress.elementType === Component ? unresolvedProps : resolveDefaultProps(Component, unresolvedProps);\n        return mountIncompleteClassComponent(current, workInProgress, Component, resolvedProps, renderLanes);\n      }\n\n    case SuspenseListComponent:\n      {\n        return updateSuspenseListComponent(current, workInProgress, renderLanes);\n      }\n\n    case ScopeComponent:\n      {\n        if (enableScopeAPI) {\n          return updateScopeComponent(current, workInProgress, renderLanes);\n        }\n\n        break;\n      }\n\n    case OffscreenComponent:\n      {\n        return updateOffscreenComponent(current, workInProgress, renderLanes);\n      }\n\n    case LegacyHiddenComponent:\n      {\n        return updateLegacyHiddenComponent(current, workInProgress, renderLanes);\n      }\n\n    case CacheComponent:\n      {\n        if (enableCache) {\n          return updateCacheComponent(current, workInProgress, renderLanes);\n        }\n\n        break;\n      }\n  }\n\n  throw new Error(`Unknown unit of work tag (${workInProgress.tag}). This error is likely caused by a bug in ` + 'React. Please file an issue.');\n}\n\nexport { beginWork };","map":{"version":3,"sources":["/Users/zhangshuo/git/my-app/src/react/packages/react-reconciler/src/ReactFiberBeginWork.new.js"],"names":["checkPropTypes","markComponentRenderStarted","markComponentRenderStopped","IndeterminateComponent","FunctionComponent","ClassComponent","HostRoot","HostComponent","HostText","HostPortal","ForwardRef","Fragment","Mode","ContextProvider","ContextConsumer","Profiler","SuspenseComponent","SuspenseListComponent","MemoComponent","SimpleMemoComponent","LazyComponent","IncompleteClassComponent","ScopeComponent","OffscreenComponent","LegacyHiddenComponent","CacheComponent","NoFlags","PerformedWork","Placement","Hydrating","ContentReset","DidCapture","Update","Ref","RefStatic","ChildDeletion","ForceUpdateForLegacySuspense","StaticMask","ShouldCapture","ForceClientRender","ReactSharedInternals","debugRenderPhaseSideEffectsForStrictMode","disableLegacyContext","disableModulePatternComponents","enableProfilerCommitHooks","enableProfilerTimer","enableSuspenseServerRenderer","warnAboutDefaultPropsOnFunctionComponents","enableScopeAPI","enableCache","enableLazyContextPropagation","enableSuspenseLayoutEffectSemantics","enableSchedulingProfiler","enablePersistentOffscreenHostContainer","isArray","shallowEqual","getComponentNameFromFiber","getComponentNameFromType","ReactStrictModeWarnings","REACT_LAZY_TYPE","getIteratorFn","getCurrentFiberOwnerNameInDevOrNull","setIsRendering","resolveFunctionForHotReloading","resolveForwardRefForHotReloading","resolveClassForHotReloading","mountChildFibers","reconcileChildFibers","cloneChildFibers","processUpdateQueue","cloneUpdateQueue","initializeUpdateQueue","enqueueCapturedUpdate","NoLane","NoLanes","SyncLane","OffscreenLane","DefaultHydrationLane","SomeRetryLane","NoTimestamp","includesSomeLane","laneToLanes","removeLanes","mergeLanes","getBumpedLaneForHydration","pickArbitraryLane","ConcurrentMode","NoMode","ProfileMode","StrictLegacyMode","shouldSetTextContent","isSuspenseInstancePending","isSuspenseInstanceFallback","registerSuspenseInstanceRetry","supportsHydration","isPrimaryRenderer","supportsPersistence","getOffscreenContainerProps","shouldError","shouldSuspend","pushHostContext","pushHostContainer","suspenseStackCursor","pushSuspenseContext","InvisibleParentSuspenseContext","ForceSuspenseFallback","hasSuspenseContext","setDefaultShallowSuspenseContext","addSubtreeSuspenseContext","setShallowSuspenseContext","findFirstSuspended","pushProvider","propagateContextChange","lazilyPropagateParentContextChanges","propagateParentContextChangesToDeferredTree","checkIfContextChanged","readContext","prepareToReadContext","scheduleWorkOnParentPath","renderWithHooks","checkDidRenderIdHook","bailoutHooks","stopProfilerTimerIfRunning","getMaskedContext","getUnmaskedContext","hasContextChanged","hasLegacyContextChanged","pushContextProvider","pushLegacyContextProvider","isContextProvider","isLegacyContextProvider","pushTopLevelContextObject","invalidateContextProvider","getIsHydrating","enterHydrationState","reenterHydrationStateFromDehydratedSuspenseInstance","resetHydrationState","tryToClaimNextHydratableInstance","warnIfHydrating","adoptClassInstance","constructClassInstance","mountClassInstance","resumeMountClassInstance","updateClassInstance","resolveDefaultProps","resolveLazyComponentTag","createFiberFromTypeAndProps","createFiberFromFragment","createFiberFromOffscreen","createWorkInProgress","createOffscreenHostContainerFiber","isSimpleFunctionComponent","retryDehydratedSuspenseBoundary","scheduleUpdateOnFiber","renderDidSuspendDelayIfPossible","markSkippedUpdateLanes","getWorkInProgressRoot","pushRenderLanes","getExecutionContext","RetryAfterError","NoContext","setWorkInProgressVersion","requestCacheFromPool","pushCacheProvider","pushRootCachePool","CacheContext","getSuspendedCachePool","restoreSpawnedCachePool","getOffscreenDeferredCachePool","createCapturedValue","createClassErrorUpdate","completeSuspendedOffscreenHostContainer","is","setIsStrictModeForDevtools","getForksAtLevel","isForkedChild","pushTreeId","pushMaterializedTreeId","ReactCurrentOwner","didReceiveUpdate","didWarnAboutBadClass","didWarnAboutModulePatternComponent","didWarnAboutContextTypeOnFunctionComponent","didWarnAboutGetDerivedStateOnFunctionComponent","didWarnAboutFunctionRefs","didWarnAboutReassigningProps","didWarnAboutRevealOrder","didWarnAboutTailOptions","didWarnAboutDefaultPropsOnFunctionComponent","__DEV__","reconcileChildren","current","workInProgress","nextChildren","renderLanes","child","forceUnmountCurrentAndReconcile","updateForwardRef","Component","nextProps","type","elementType","innerPropTypes","propTypes","render","ref","hasId","mode","bailoutOnAlreadyFinishedWork","flags","updateMemoComponent","compare","defaultProps","undefined","resolvedType","tag","validateFunctionComponentInDev","updateSimpleMemoComponent","return","currentChild","hasScheduledUpdateOrContext","checkScheduledUpdateOrContext","prevProps","memoizedProps","newChild","outerMemoType","$$typeof","lazyComponent","payload","_payload","init","_init","x","outerPropTypes","lanes","updateFunctionComponent","updateOffscreenComponent","pendingProps","children","prevState","memoizedState","spawnedCachePool","nextState","baseLanes","cachePool","nextBaseLanes","prevBaseLanes","childLanes","updateQueue","prevCachePool","subtreeRenderLanes","isHidden","offscreenContainer","reconcileOffscreenHostContainer","currentOffscreen","offscreen","containerProps","hostContainer","currentHostContainer","updateLegacyHiddenComponent","updateCacheComponent","parentCache","freshCache","initialState","parent","cache","derivedState","baseState","nextCache","updateFragment","updateMode","updateProfiler","stateNode","effectDuration","passiveEffectDuration","markRef","context","unmaskedContext","updateClassComponent","instance","ctor","tempInstance","state","updater","enqueueSetState","error","Error","lane","update","hasContext","shouldUpdate","alternate","nextUnitOfWork","finishClassComponent","inst","props","console","didCaptureError","getDerivedStateFromError","pushHostRootContext","root","pendingContext","containerInfo","updateHostRoot","prevChildren","element","isDehydrated","mutableSourceEagerHydrationData","i","length","mutableSource","version","node","sibling","updateHostComponent","isDirectTextChild","updateHostText","mountLazyComponent","_current","resolvedTag","resolvedProps","hint","mountIncompleteClassComponent","mountIndeterminateComponent","value","prototype","componentName","recordLegacyContextWarning","contextTypes","childContextTypes","displayName","name","info","ownerName","warningKey","debugSource","_debugSource","fileName","lineNumber","getDerivedStateFromProps","contextType","SUSPENDED_MARKER","dehydrated","treeContext","retryLane","mountSuspenseOffscreenState","updateSuspenseOffscreenState","prevOffscreenState","_currentValue","_currentValue2","pool","shouldRemainOnFallback","suspenseContext","suspenseState","getRemainingWorkInPrimaryTree","updateSuspenseComponent","showFallback","didSuspend","unstable_avoidThisFallback","mountDehydratedSuspenseComponent","nextPrimaryChildren","nextFallbackChildren","fallback","fallbackFragment","mountSuspenseFallbackChildren","primaryChildFragment","unstable_expectedLoadTime","mountSuspensePrimaryChildren","updateDehydratedSuspenseComponent","retrySuspenseComponentWithoutHydrating","fallbackChildFragment","mountSuspenseFallbackAfterRetryWithoutHydrating","updateSuspenseFallbackChildren","updateSuspensePrimaryChildren","primaryChildren","primaryChildProps","mountWorkInProgressOffscreenFiber","fallbackChildren","progressedPrimaryFragment","actualDuration","actualStartTime","selfBaseDuration","treeBaseDuration","offscreenProps","updateWorkInProgressOffscreenFiber","currentPrimaryChildFragment","currentFallbackChildFragment","deletions","push","currentOffscreenContainer","subtreeFlags","fiberMode","suspenseInstance","attemptHydrationAtLane","eventTime","retry","bind","scheduleWorkOnFiber","fiber","propagateSuspenseContextChange","firstChild","findLastContentRow","row","lastContentRow","currentRow","validateRevealOrder","revealOrder","toLowerCase","validateTailOptions","tailMode","validateSuspenseListNestedChild","childSlot","index","isAnArray","isIterable","validateSuspenseListChildren","iteratorFn","childrenIterator","call","step","next","done","initSuspenseListRenderState","isBackwards","tail","renderState","rendering","renderingStartTime","last","updateSuspenseListComponent","newChildren","shouldForceFallback","didSuspendBefore","nextRow","updatePortalComponent","hasWarnedAboutUsingNoValuePropOnContextProvider","updateContextProvider","providerType","_context","newProps","oldProps","newValue","providerPropTypes","oldValue","hasWarnedAboutUsingContextAsConsumer","updateContextConsumer","Consumer","updateScopeComponent","markWorkInProgressReceivedUpdate","checkIfWorkInProgressReceivedUpdate","dependencies","remountFiber","oldWorkInProgress","newWorkInProgress","returnFiber","prevSibling","updateLanes","attemptEarlyBailoutIfNoScheduledUpdate","hasChildWork","primaryChildLanes","lastEffect","beginWork","_debugNeedsRemount","key","_debugOwner","slotIndex","numberOfForks","unresolvedProps"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAyBA,OAAOA,cAAP,MAA2B,uBAA3B;AACA,SACEC,0BADF,EAEEC,0BAFF,QAGO,sBAHP;AAIA,SACEC,sBADF,EAEEC,iBAFF,EAGEC,cAHF,EAIEC,QAJF,EAKEC,aALF,EAMEC,QANF,EAOEC,UAPF,EAQEC,UARF,EASEC,QATF,EAUEC,IAVF,EAWEC,eAXF,EAYEC,eAZF,EAaEC,QAbF,EAcEC,iBAdF,EAeEC,qBAfF,EAgBEC,aAhBF,EAiBEC,mBAjBF,EAkBEC,aAlBF,EAmBEC,wBAnBF,EAoBEC,cApBF,EAqBEC,kBArBF,EAsBEC,qBAtBF,EAuBEC,cAvBF,QAwBO,iBAxBP;AAyBA,SACEC,OADF,EAEEC,aAFF,EAGEC,SAHF,EAIEC,SAJF,EAKEC,YALF,EAMEC,UANF,EAOEC,MAPF,EAQEC,GARF,EASEC,SATF,EAUEC,aAVF,EAWEC,4BAXF,EAYEC,UAZF,EAaEC,aAbF,EAcEC,iBAdF,QAeO,mBAfP;AAgBA,OAAOC,oBAAP,MAAiC,6BAAjC;AACA,SACEC,wCADF,EAEEC,oBAFF,EAGEC,8BAHF,EAIEC,yBAJF,EAKEC,mBALF,EAMEC,4BANF,EAOEC,yCAPF,EAQEC,cARF,EASEC,WATF,EAUEC,4BAVF,EAWEC,mCAXF,EAYEC,wBAZF,EAaEC,sCAbF,QAcO,0BAdP;AAeA,OAAOC,OAAP,MAAoB,gBAApB;AACA,OAAOC,YAAP,MAAyB,qBAAzB;AACA,OAAOC,yBAAP,MAAsC,gDAAtC;AACA,OAAOC,wBAAP,MAAqC,iCAArC;AACA,OAAOC,uBAAP,MAAoC,+BAApC;AACA,SAAQC,eAAR,EAAyBC,aAAzB,QAA6C,qBAA7C;AACA,SACEC,mCADF,EAEEC,cAFF,QAGO,qBAHP;AAIA,SACEC,8BADF,EAEEC,gCAFF,EAGEC,2BAHF,QAIO,8BAJP;AAMA,SACEC,gBADF,EAEEC,oBAFF,EAGEC,gBAHF,QAIO,uBAJP;AAKA,SACEC,kBADF,EAEEC,gBAFF,EAGEC,qBAHF,EAIEC,qBAJF,QAKO,wBALP;AAMA,SACEC,MADF,EAEEC,OAFF,EAGEC,QAHF,EAIEC,aAJF,EAKEC,oBALF,EAMEC,aANF,EAOEC,WAPF,EAQEC,gBARF,EASEC,WATF,EAUEC,WAVF,EAWEC,UAXF,EAYEC,yBAZF,EAaEC,iBAbF,QAcO,sBAdP;AAeA,SACEC,cADF,EAEEC,MAFF,EAGEC,WAHF,EAIEC,gBAJF,QAKO,mBALP;AAMA,SACEC,oBADF,EAEEC,yBAFF,EAGEC,0BAHF,EAIEC,6BAJF,EAKEC,iBALF,EAMEC,iBANF,EAOEC,mBAPF,EAQEC,0BARF,QASO,wBATP;AAWA,SAAQC,WAAR,EAAqBC,aAArB,QAAyC,wBAAzC;AACA,SAAQC,eAAR,EAAyBC,iBAAzB,QAAiD,6BAAjD;AACA,SACEC,mBADF,EAEEC,mBAFF,EAGEC,8BAHF,EAIEC,qBAJF,EAKEC,kBALF,EAMEC,gCANF,EAOEC,yBAPF,EAQEC,yBARF,QASO,iCATP;AAUA,SAAQC,kBAAR,QAAiC,mCAAjC;AACA,SACEC,YADF,EAEEC,sBAFF,EAGEC,mCAHF,EAIEC,2CAJF,EAKEC,qBALF,EAMEC,WANF,EAOEC,oBAPF,EAQEC,wBARF,QASO,4BATP;AAUA,SACEC,eADF,EAEEC,oBAFF,EAGEC,YAHF,QAIO,uBAJP;AAKA,SAAQC,0BAAR,QAAyC,0BAAzC;AACA,SACEC,gBADF,EAEEC,kBAFF,EAGEC,iBAAiB,IAAIC,uBAHvB,EAIEC,mBAAmB,IAAIC,yBAJzB,EAKEC,iBAAiB,IAAIC,uBALvB,EAMEC,yBANF,EAOEC,yBAPF,QAQO,yBARP;AASA,SACEC,cADF,EAEEC,mBAFF,EAGEC,mDAHF,EAIEC,mBAJF,EAKEC,gCALF,EAMEC,eANF,QAOO,kCAPP;AAQA,SACEC,kBADF,EAEEC,sBAFF,EAGEC,kBAHF,EAIEC,wBAJF,EAKEC,mBALF,QAMO,gCANP;AAOA,SAAQC,mBAAR,QAAkC,+BAAlC;AACA,SACEC,uBADF,EAEEC,2BAFF,EAGEC,uBAHF,EAIEC,wBAJF,EAKEC,oBALF,EAMEC,iCANF,EAOEC,yBAPF,QAQO,kBARP;AASA,SACEC,+BADF,EAEEC,qBAFF,EAGEC,+BAHF,EAIEC,sBAJF,EAKEC,qBALF,EAMEC,eANF,EAOEC,mBAPF,EAQEC,eARF,EASEC,SATF,QAUO,0BAVP;AAWA,SAAQC,wBAAR,QAAuC,0BAAvC;AACA,SACEC,oBADF,EAEEC,iBAFF,EAGEC,iBAHF,EAIEC,YAJF,EAKEC,qBALF,EAMEC,uBANF,EAOEC,6BAPF,QAQO,gCARP;AASA,SAAQC,mBAAR,QAAkC,sBAAlC;AACA,SAAQC,sBAAR,QAAqC,uBAArC;AACA,SAAQC,uCAAR,QAAsD,8BAAtD;AACA,OAAOC,EAAP,MAAe,iBAAf;AACA,SAAQC,0BAAR,QAAyC,8BAAzC;AACA,SACEC,eADF,EAEEC,aAFF,EAGEC,UAHF,EAIEC,sBAJF,QAKO,6BALP;AAOA,MAAMC,iBAAiB,GAAG1I,oBAAoB,CAAC0I,iBAA/C;AAEA,IAAIC,gBAAyB,GAAG,KAAhC;AAEA,IAAIC,oBAAJ;AACA,IAAIC,kCAAJ;AACA,IAAIC,0CAAJ;AACA,IAAIC,8CAAJ;AACA,IAAIC,wBAAJ;AACA,OAAO,IAAIC,4BAAJ;AACP,IAAIC,uBAAJ;AACA,IAAIC,uBAAJ;AACA,IAAIC,2CAAJ;;AAEA,IAAIC,OAAJ,EAAa;AACXT,EAAAA,oBAAoB,GAAG,EAAvB;AACAC,EAAAA,kCAAkC,GAAG,EAArC;AACAC,EAAAA,0CAA0C,GAAG,EAA7C;AACAC,EAAAA,8CAA8C,GAAG,EAAjD;AACAC,EAAAA,wBAAwB,GAAG,EAA3B;AACAC,EAAAA,4BAA4B,GAAG,KAA/B;AACAC,EAAAA,uBAAuB,GAAG,EAA1B;AACAC,EAAAA,uBAAuB,GAAG,EAA1B;AACAC,EAAAA,2CAA2C,GAAG,EAA9C;AACD;;AAED,OAAO,SAASE,iBAAT,CACLC,OADK,EAELC,cAFK,EAGLC,YAHK,EAILC,WAJK,EAKL;AACA,MAAIH,OAAO,KAAK,IAAhB,EAAsB;AACpB;AACA;AACA;AACA;AACAC,IAAAA,cAAc,CAACG,KAAf,GAAuBjI,gBAAgB,CACrC8H,cADqC,EAErC,IAFqC,EAGrCC,YAHqC,EAIrCC,WAJqC,CAAvC;AAMD,GAXD,MAWO;AACL;AACA;AACA;AAEA;AACA;AACAF,IAAAA,cAAc,CAACG,KAAf,GAAuBhI,oBAAoB,CACzC6H,cADyC,EAEzCD,OAAO,CAACI,KAFiC,EAGzCF,YAHyC,EAIzCC,WAJyC,CAA3C;AAMD;AACF;;AAED,SAASE,+BAAT,CACEL,OADF,EAEEC,cAFF,EAGEC,YAHF,EAIEC,WAJF,EAKE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAF,EAAAA,cAAc,CAACG,KAAf,GAAuBhI,oBAAoB,CACzC6H,cADyC,EAEzCD,OAAO,CAACI,KAFiC,EAGzC,IAHyC,EAIzCD,WAJyC,CAA3C,CATA,CAeA;AACA;AACA;AACA;;AACAF,EAAAA,cAAc,CAACG,KAAf,GAAuBhI,oBAAoB,CACzC6H,cADyC,EAEzC,IAFyC,EAGzCC,YAHyC,EAIzCC,WAJyC,CAA3C;AAMD;;AAED,SAASG,gBAAT,CACEN,OADF,EAEEC,cAFF,EAGEM,SAHF,EAIEC,SAJF,EAKEL,WALF,EAME;AACA;AACA;AACA;AAEA,MAAIL,OAAJ,EAAa;AACX,QAAIG,cAAc,CAACQ,IAAf,KAAwBR,cAAc,CAACS,WAA3C,EAAwD;AACtD;AACA;AACA,YAAMC,cAAc,GAAGJ,SAAS,CAACK,SAAjC;;AACA,UAAID,cAAJ,EAAoB;AAClB1M,QAAAA,cAAc,CACZ0M,cADY,EAEZH,SAFY,EAED;AACX,cAHY,EAIZ9I,wBAAwB,CAAC6I,SAAD,CAJZ,CAAd;AAMD;AACF;AACF;;AAED,QAAMM,MAAM,GAAGN,SAAS,CAACM,MAAzB;AACA,QAAMC,GAAG,GAAGb,cAAc,CAACa,GAA3B,CAtBA,CAwBA;;AACA,MAAIZ,YAAJ;AACA,MAAIa,KAAJ;AACAzF,EAAAA,oBAAoB,CAAC2E,cAAD,EAAiBE,WAAjB,CAApB;;AACA,MAAI9I,wBAAJ,EAA8B;AAC5BnD,IAAAA,0BAA0B,CAAC+L,cAAD,CAA1B;AACD;;AACD,MAAIH,OAAJ,EAAa;AACXX,IAAAA,iBAAiB,CAACa,OAAlB,GAA4BC,cAA5B;AACAlI,IAAAA,cAAc,CAAC,IAAD,CAAd;AACAmI,IAAAA,YAAY,GAAG1E,eAAe,CAC5BwE,OAD4B,EAE5BC,cAF4B,EAG5BY,MAH4B,EAI5BL,SAJ4B,EAK5BM,GAL4B,EAM5BX,WAN4B,CAA9B;AAQAY,IAAAA,KAAK,GAAGtF,oBAAoB,EAA5B;;AACA,QACE/E,wCAAwC,IACxCuJ,cAAc,CAACe,IAAf,GAAsBtH,gBAFxB,EAGE;AACAoF,MAAAA,0BAA0B,CAAC,IAAD,CAA1B;;AACA,UAAI;AACFoB,QAAAA,YAAY,GAAG1E,eAAe,CAC5BwE,OAD4B,EAE5BC,cAF4B,EAG5BY,MAH4B,EAI5BL,SAJ4B,EAK5BM,GAL4B,EAM5BX,WAN4B,CAA9B;AAQAY,QAAAA,KAAK,GAAGtF,oBAAoB,EAA5B;AACD,OAVD,SAUU;AACRqD,QAAAA,0BAA0B,CAAC,KAAD,CAA1B;AACD;AACF;;AACD/G,IAAAA,cAAc,CAAC,KAAD,CAAd;AACD,GAhCD,MAgCO;AACLmI,IAAAA,YAAY,GAAG1E,eAAe,CAC5BwE,OAD4B,EAE5BC,cAF4B,EAG5BY,MAH4B,EAI5BL,SAJ4B,EAK5BM,GAL4B,EAM5BX,WAN4B,CAA9B;AAQAY,IAAAA,KAAK,GAAGtF,oBAAoB,EAA5B;AACD;;AACD,MAAIpE,wBAAJ,EAA8B;AAC5BlD,IAAAA,0BAA0B;AAC3B;;AAED,MAAI6L,OAAO,KAAK,IAAZ,IAAoB,CAACZ,gBAAzB,EAA2C;AACzC1D,IAAAA,YAAY,CAACsE,OAAD,EAAUC,cAAV,EAA0BE,WAA1B,CAAZ;AACA,WAAOc,4BAA4B,CAACjB,OAAD,EAAUC,cAAV,EAA0BE,WAA1B,CAAnC;AACD;;AAED,MAAI7D,cAAc,MAAMyE,KAAxB,EAA+B;AAC7B7B,IAAAA,sBAAsB,CAACe,cAAD,CAAtB;AACD,GArFD,CAuFA;;;AACAA,EAAAA,cAAc,CAACiB,KAAf,IAAwBtL,aAAxB;AACAmK,EAAAA,iBAAiB,CAACC,OAAD,EAAUC,cAAV,EAA0BC,YAA1B,EAAwCC,WAAxC,CAAjB;AACA,SAAOF,cAAc,CAACG,KAAtB;AACD;;AAED,SAASe,mBAAT,CACEnB,OADF,EAEEC,cAFF,EAGEM,SAHF,EAIEC,SAJF,EAKEL,WALF,EAMgB;AACd,MAAIH,OAAO,KAAK,IAAhB,EAAsB;AACpB,UAAMS,IAAI,GAAGF,SAAS,CAACE,IAAvB;;AACA,QACEjD,yBAAyB,CAACiD,IAAD,CAAzB,IACAF,SAAS,CAACa,OAAV,KAAsB,IADtB,IAEA;AACAb,IAAAA,SAAS,CAACc,YAAV,KAA2BC,SAJ7B,EAKE;AACA,UAAIC,YAAY,GAAGd,IAAnB;;AACA,UAAIX,OAAJ,EAAa;AACXyB,QAAAA,YAAY,GAAGvJ,8BAA8B,CAACyI,IAAD,CAA7C;AACD,OAJD,CAKA;AACA;AACA;;;AACAR,MAAAA,cAAc,CAACuB,GAAf,GAAqBpM,mBAArB;AACA6K,MAAAA,cAAc,CAACQ,IAAf,GAAsBc,YAAtB;;AACA,UAAIzB,OAAJ,EAAa;AACX2B,QAAAA,8BAA8B,CAACxB,cAAD,EAAiBQ,IAAjB,CAA9B;AACD;;AACD,aAAOiB,yBAAyB,CAC9B1B,OAD8B,EAE9BC,cAF8B,EAG9BsB,YAH8B,EAI9Bf,SAJ8B,EAK9BL,WAL8B,CAAhC;AAOD;;AACD,QAAIL,OAAJ,EAAa;AACX,YAAMa,cAAc,GAAGF,IAAI,CAACG,SAA5B;;AACA,UAAID,cAAJ,EAAoB;AAClB;AACA;AACA1M,QAAAA,cAAc,CACZ0M,cADY,EAEZH,SAFY,EAED;AACX,cAHY,EAIZ9I,wBAAwB,CAAC+I,IAAD,CAJZ,CAAd;AAMD;AACF;;AACD,UAAML,KAAK,GAAGjD,2BAA2B,CACvCoD,SAAS,CAACE,IAD6B,EAEvC,IAFuC,EAGvCD,SAHuC,EAIvCP,cAJuC,EAKvCA,cAAc,CAACe,IALwB,EAMvCb,WANuC,CAAzC;AAQAC,IAAAA,KAAK,CAACU,GAAN,GAAYb,cAAc,CAACa,GAA3B;AACAV,IAAAA,KAAK,CAACuB,MAAN,GAAe1B,cAAf;AACAA,IAAAA,cAAc,CAACG,KAAf,GAAuBA,KAAvB;AACA,WAAOA,KAAP;AACD;;AACD,MAAIN,OAAJ,EAAa;AACX,UAAMW,IAAI,GAAGF,SAAS,CAACE,IAAvB;AACA,UAAME,cAAc,GAAGF,IAAI,CAACG,SAA5B;;AACA,QAAID,cAAJ,EAAoB;AAClB;AACA;AACA1M,MAAAA,cAAc,CACZ0M,cADY,EAEZH,SAFY,EAED;AACX,YAHY,EAIZ9I,wBAAwB,CAAC+I,IAAD,CAJZ,CAAd;AAMD;AACF;;AACD,QAAMmB,YAAY,GAAK5B,OAAO,CAACI,KAA/B,CArEc,CAqEsC;;AACpD,QAAMyB,2BAA2B,GAAGC,6BAA6B,CAC/D9B,OAD+D,EAE/DG,WAF+D,CAAjE;;AAIA,MAAI,CAAC0B,2BAAL,EAAkC;AAChC;AACA;AACA,UAAME,SAAS,GAAGH,YAAY,CAACI,aAA/B,CAHgC,CAIhC;;AACA,QAAIZ,OAAO,GAAGb,SAAS,CAACa,OAAxB;AACAA,IAAAA,OAAO,GAAGA,OAAO,KAAK,IAAZ,GAAmBA,OAAnB,GAA6B5J,YAAvC;;AACA,QAAI4J,OAAO,CAACW,SAAD,EAAYvB,SAAZ,CAAP,IAAiCR,OAAO,CAACc,GAAR,KAAgBb,cAAc,CAACa,GAApE,EAAyE;AACvE,aAAOG,4BAA4B,CAACjB,OAAD,EAAUC,cAAV,EAA0BE,WAA1B,CAAnC;AACD;AACF,GApFa,CAqFd;;;AACAF,EAAAA,cAAc,CAACiB,KAAf,IAAwBtL,aAAxB;AACA,QAAMqM,QAAQ,GAAG3E,oBAAoB,CAACsE,YAAD,EAAepB,SAAf,CAArC;AACAyB,EAAAA,QAAQ,CAACnB,GAAT,GAAeb,cAAc,CAACa,GAA9B;AACAmB,EAAAA,QAAQ,CAACN,MAAT,GAAkB1B,cAAlB;AACAA,EAAAA,cAAc,CAACG,KAAf,GAAuB6B,QAAvB;AACA,SAAOA,QAAP;AACD;;AAED,SAASP,yBAAT,CACE1B,OADF,EAEEC,cAFF,EAGEM,SAHF,EAIEC,SAJF,EAKEL,WALF,EAMgB;AACd;AACA;AACA;AAEA,MAAIL,OAAJ,EAAa;AACX,QAAIG,cAAc,CAACQ,IAAf,KAAwBR,cAAc,CAACS,WAA3C,EAAwD;AACtD;AACA;AACA,UAAIwB,aAAa,GAAGjC,cAAc,CAACS,WAAnC;;AACA,UAAIwB,aAAa,CAACC,QAAd,KAA2BvK,eAA/B,EAAgD;AAC9C;AACA;AACA;AACA,cAAMwK,aAA0C,GAAGF,aAAnD;AACA,cAAMG,OAAO,GAAGD,aAAa,CAACE,QAA9B;AACA,cAAMC,IAAI,GAAGH,aAAa,CAACI,KAA3B;;AACA,YAAI;AACFN,UAAAA,aAAa,GAAGK,IAAI,CAACF,OAAD,CAApB;AACD,SAFD,CAEE,OAAOI,CAAP,EAAU;AACVP,UAAAA,aAAa,GAAG,IAAhB;AACD,SAX6C,CAY9C;;;AACA,cAAMQ,cAAc,GAAGR,aAAa,IAAKA,aAAD,CAAqBtB,SAA7D;;AACA,YAAI8B,cAAJ,EAAoB;AAClBzO,UAAAA,cAAc,CACZyO,cADY,EAEZlC,SAFY,EAED;AACX,gBAHY,EAIZ9I,wBAAwB,CAACwK,aAAD,CAJZ,CAAd;AAMD;AACF;AACF;AACF;;AACD,MAAIlC,OAAO,KAAK,IAAhB,EAAsB;AACpB,UAAM+B,SAAS,GAAG/B,OAAO,CAACgC,aAA1B;;AACA,QACExK,YAAY,CAACuK,SAAD,EAAYvB,SAAZ,CAAZ,IACAR,OAAO,CAACc,GAAR,KAAgBb,cAAc,CAACa,GAD/B,MAEA;AACChB,IAAAA,OAAO,GAAGG,cAAc,CAACQ,IAAf,KAAwBT,OAAO,CAACS,IAAnC,GAA0C,IAHlD,CADF,EAKE;AACArB,MAAAA,gBAAgB,GAAG,KAAnB;;AACA,UAAI,CAAC0C,6BAA6B,CAAC9B,OAAD,EAAUG,WAAV,CAAlC,EAA0D;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAF,QAAAA,cAAc,CAAC0C,KAAf,GAAuB3C,OAAO,CAAC2C,KAA/B;AACA,eAAO1B,4BAA4B,CACjCjB,OADiC,EAEjCC,cAFiC,EAGjCE,WAHiC,CAAnC;AAKD,OApBD,MAoBO,IAAI,CAACH,OAAO,CAACkB,KAAR,GAAgB7K,4BAAjB,MAAmDV,OAAvD,EAAgE;AACrE;AACA;AACAyJ,QAAAA,gBAAgB,GAAG,IAAnB;AACD;AACF;AACF;;AACD,SAAOwD,uBAAuB,CAC5B5C,OAD4B,EAE5BC,cAF4B,EAG5BM,SAH4B,EAI5BC,SAJ4B,EAK5BL,WAL4B,CAA9B;AAOD;;AAED,SAAS0C,wBAAT,CACE7C,OADF,EAEEC,cAFF,EAGEE,WAHF,EAIE;AACA,QAAMK,SAAyB,GAAGP,cAAc,CAAC6C,YAAjD;AACA,QAAM5C,YAAY,GAAGM,SAAS,CAACuC,QAA/B;AAEA,QAAMC,SAAgC,GACpChD,OAAO,KAAK,IAAZ,GAAmBA,OAAO,CAACiD,aAA3B,GAA2C,IAD7C,CAJA,CAOA;AACA;AACA;;AACA,MAAIC,gBAAyC,GAAG,IAAhD;;AAEA,MACE1C,SAAS,CAACQ,IAAV,KAAmB,QAAnB,IACAR,SAAS,CAACQ,IAAV,KAAmB,+BAFrB,EAGE;AACA;AACA,QAAI,CAACf,cAAc,CAACe,IAAf,GAAsBzH,cAAvB,MAA2CC,MAA/C,EAAuD;AACrD;AACA,YAAM2J,SAAyB,GAAG;AAChCC,QAAAA,SAAS,EAAEzK,OADqB;AAEhC0K,QAAAA,SAAS,EAAE;AAFqB,OAAlC;AAIApD,MAAAA,cAAc,CAACgD,aAAf,GAA+BE,SAA/B;AACArF,MAAAA,eAAe,CAACmC,cAAD,EAAiBE,WAAjB,CAAf;AACD,KARD,MAQO,IAAI,CAAClH,gBAAgB,CAACkH,WAAD,EAAetH,aAAf,CAArB,EAA2D;AAChE;AACA;AACA,UAAIyK,aAAJ;;AACA,UAAIN,SAAS,KAAK,IAAlB,EAAwB;AACtB,cAAMO,aAAa,GAAGP,SAAS,CAACI,SAAhC;AACAE,QAAAA,aAAa,GAAGlK,UAAU,CAACmK,aAAD,EAAgBpD,WAAhB,CAA1B;;AACA,YAAIjJ,WAAJ,EAAiB;AACf;AACAgM,UAAAA,gBAAgB,GAAGzE,6BAA6B,EAAhD,CAFe,CAGf;AACA;AACA;AACD;AACF,OAVD,MAUO;AACL6E,QAAAA,aAAa,GAAGnD,WAAhB;AACD,OAhB+D,CAkBhE;;;AACAF,MAAAA,cAAc,CAAC0C,KAAf,GAAuB1C,cAAc,CAACuD,UAAf,GAA4BtK,WAAW,CAC5DL,aAD4D,CAA9D;AAGA,YAAMsK,SAAyB,GAAG;AAChCC,QAAAA,SAAS,EAAEE,aADqB;AAEhCD,QAAAA,SAAS,EAAEH;AAFqB,OAAlC;AAIAjD,MAAAA,cAAc,CAACgD,aAAf,GAA+BE,SAA/B;AACAlD,MAAAA,cAAc,CAACwD,WAAf,GAA6B,IAA7B,CA3BgE,CA4BhE;AACA;;AACA3F,MAAAA,eAAe,CAACmC,cAAD,EAAiBqD,aAAjB,CAAf;;AAEA,UAAInM,4BAA4B,IAAI6I,OAAO,KAAK,IAAhD,EAAsD;AACpD;AACA;AACA;AACA7E,QAAAA,2CAA2C,CACzC6E,OADyC,EAEzCC,cAFyC,EAGzCE,WAHyC,CAA3C;AAKD;;AAED,aAAO,IAAP;AACD,KA5CM,MA4CA;AACL;AACA;AAEA,UAAIjJ,WAAW,IAAI8L,SAAS,KAAK,IAAjC,EAAuC;AACrC;AACA;AACA;AACA,cAAMU,aAAa,GAAGV,SAAS,CAACK,SAAhC;;AACA,YAAIK,aAAa,KAAK,IAAtB,EAA4B;AAC1BR,UAAAA,gBAAgB,GAAG1E,uBAAuB,CACxCyB,cADwC,EAExCyD,aAFwC,CAA1C;AAID;AACF,OAfI,CAiBL;;;AACA,YAAMP,SAAyB,GAAG;AAChCC,QAAAA,SAAS,EAAEzK,OADqB;AAEhC0K,QAAAA,SAAS,EAAE;AAFqB,OAAlC;AAIApD,MAAAA,cAAc,CAACgD,aAAf,GAA+BE,SAA/B,CAtBK,CAuBL;;AACA,YAAMQ,kBAAkB,GACtBX,SAAS,KAAK,IAAd,GAAqBA,SAAS,CAACI,SAA/B,GAA2CjD,WAD7C;AAEArC,MAAAA,eAAe,CAACmC,cAAD,EAAiB0D,kBAAjB,CAAf;AACD;AACF,GArFD,MAqFO;AACL;AACA,QAAIA,kBAAJ;;AACA,QAAIX,SAAS,KAAK,IAAlB,EAAwB;AACtB;AAEAW,MAAAA,kBAAkB,GAAGvK,UAAU,CAAC4J,SAAS,CAACI,SAAX,EAAsBjD,WAAtB,CAA/B;;AAEA,UAAIjJ,WAAJ,EAAiB;AACf;AACA;AACA;AACA,cAAMwM,aAAa,GAAGV,SAAS,CAACK,SAAhC;;AACA,YAAIK,aAAa,KAAK,IAAtB,EAA4B;AAC1BR,UAAAA,gBAAgB,GAAG1E,uBAAuB,CACxCyB,cADwC,EAExCyD,aAFwC,CAA1C;AAID;AACF,OAhBqB,CAkBtB;;;AACAzD,MAAAA,cAAc,CAACgD,aAAf,GAA+B,IAA/B;AACD,KApBD,MAoBO;AACL;AACA;AACA;AACAU,MAAAA,kBAAkB,GAAGxD,WAArB;AACD;;AACDrC,IAAAA,eAAe,CAACmC,cAAD,EAAiB0D,kBAAjB,CAAf;AACD;;AAED,MAAIzM,WAAJ,EAAiB;AACf;AACA;AACA+I,IAAAA,cAAc,CAACwD,WAAf,GAA6BP,gBAA7B;AACD;;AAED,MAAI5L,sCAAsC,IAAI2C,mBAA9C,EAAmE;AACjE;AACA;AACA;AACA;AACA,UAAM2J,QAAQ,GACZpD,SAAS,CAACQ,IAAV,KAAmB,QAAnB,IACAf,cAAc,CAACuB,GAAf,KAAuB/L,qBAFzB;AAGA,UAAMoO,kBAAkB,GAAGC,+BAA+B,CACxD9D,OADwD,EAExDC,cAFwD,EAGxD2D,QAHwD,EAIxD1D,YAJwD,EAKxDC,WALwD,CAA1D;AAOA,WAAO0D,kBAAP;AACD,GAhBD,MAgBO;AACL9D,IAAAA,iBAAiB,CAACC,OAAD,EAAUC,cAAV,EAA0BC,YAA1B,EAAwCC,WAAxC,CAAjB;AACA,WAAOF,cAAc,CAACG,KAAtB;AACD;AACF;;AAED,SAAS0D,+BAAT,CACEC,gBADF,EAEEC,SAFF,EAGEJ,QAHF,EAIEb,QAJF,EAKE5C,WALF,EAME;AACA,QAAM8D,cAAc,GAAG/J,0BAA0B,CAC/C0J,QAAQ,GAAG,QAAH,GAAc,SADyB,EAE/Cb,QAF+C,CAAjD;AAIA,MAAImB,aAAJ;;AACA,MAAIH,gBAAgB,KAAK,IAAzB,EAA+B;AAC7BG,IAAAA,aAAa,GAAG3G,iCAAiC,CAC/C0G,cAD+C,EAE/CD,SAAS,CAAChD,IAFqC,EAG/Cb,WAH+C,EAI/C,IAJ+C,CAAjD;AAMD,GAPD,MAOO;AACL,UAAMgE,oBAAoB,GAAGJ,gBAAgB,CAAC3D,KAA9C;;AACA,QAAI+D,oBAAoB,KAAK,IAA7B,EAAmC;AACjCD,MAAAA,aAAa,GAAG3G,iCAAiC,CAC/C0G,cAD+C,EAE/CD,SAAS,CAAChD,IAFqC,EAG/Cb,WAH+C,EAI/C,IAJ+C,CAAjD;AAMA+D,MAAAA,aAAa,CAAChD,KAAd,IAAuBrL,SAAvB;AACD,KARD,MAQO;AACLqO,MAAAA,aAAa,GAAG5G,oBAAoB,CAClC6G,oBADkC,EAElCF,cAFkC,CAApC;AAID;AACF;;AACDC,EAAAA,aAAa,CAACvC,MAAd,GAAuBqC,SAAvB;AACAA,EAAAA,SAAS,CAAC5D,KAAV,GAAkB8D,aAAlB;AACA,SAAOA,aAAP;AACD,C,CAED;AACA;AACA;;;AACA,MAAME,2BAA2B,GAAGvB,wBAApC;;AAEA,SAASwB,oBAAT,CACErE,OADF,EAEEC,cAFF,EAGEE,WAHF,EAIE;AACA,MAAI,CAACjJ,WAAL,EAAkB;AAChB,WAAO,IAAP;AACD;;AAEDoE,EAAAA,oBAAoB,CAAC2E,cAAD,EAAiBE,WAAjB,CAApB;AACA,QAAMmE,WAAW,GAAGjJ,WAAW,CAACiD,YAAD,CAA/B;;AAEA,MAAI0B,OAAO,KAAK,IAAhB,EAAsB;AACpB;AACA,UAAMuE,UAAU,GAAGpG,oBAAoB,CAACgC,WAAD,CAAvC;AACA,UAAMqE,YAAiC,GAAG;AACxCC,MAAAA,MAAM,EAAEH,WADgC;AAExCI,MAAAA,KAAK,EAAEH;AAFiC,KAA1C;AAIAtE,IAAAA,cAAc,CAACgD,aAAf,GAA+BuB,YAA/B;AACAhM,IAAAA,qBAAqB,CAACyH,cAAD,CAArB;AACA7B,IAAAA,iBAAiB,CAAC6B,cAAD,EAAiBsE,UAAjB,CAAjB;AACD,GAVD,MAUO;AACL;AACA,QAAItL,gBAAgB,CAAC+G,OAAO,CAAC2C,KAAT,EAAgBxC,WAAhB,CAApB,EAAkD;AAChD5H,MAAAA,gBAAgB,CAACyH,OAAD,EAAUC,cAAV,CAAhB;AACA3H,MAAAA,kBAAkB,CAAC2H,cAAD,EAAiB,IAAjB,EAAuB,IAAvB,EAA6BE,WAA7B,CAAlB;AACD;;AACD,UAAM6C,SAA8B,GAAGhD,OAAO,CAACiD,aAA/C;AACA,UAAME,SAA8B,GAAGlD,cAAc,CAACgD,aAAtD,CAPK,CASL;AACA;;AACA,QAAID,SAAS,CAACyB,MAAV,KAAqBH,WAAzB,EAAsC;AACpC;AACA,YAAMK,YAAiC,GAAG;AACxCF,QAAAA,MAAM,EAAEH,WADgC;AAExCI,QAAAA,KAAK,EAAEJ;AAFiC,OAA1C,CAFoC,CAOpC;AACA;;AACArE,MAAAA,cAAc,CAACgD,aAAf,GAA+B0B,YAA/B;;AACA,UAAI1E,cAAc,CAAC0C,KAAf,KAAyBhK,OAA7B,EAAsC;AACpC,cAAM8K,WAA6B,GAAIxD,cAAc,CAACwD,WAAtD;AACAxD,QAAAA,cAAc,CAACgD,aAAf,GAA+BQ,WAAW,CAACmB,SAAZ,GAAwBD,YAAvD;AACD;;AAEDvG,MAAAA,iBAAiB,CAAC6B,cAAD,EAAiBqE,WAAjB,CAAjB,CAfoC,CAgBpC;AACA;AACD,KAlBD,MAkBO;AACL;AACA,YAAMO,SAAS,GAAG1B,SAAS,CAACuB,KAA5B;AACAtG,MAAAA,iBAAiB,CAAC6B,cAAD,EAAiB4E,SAAjB,CAAjB;;AACA,UAAIA,SAAS,KAAK7B,SAAS,CAAC0B,KAA5B,EAAmC;AACjC;AACAzJ,QAAAA,sBAAsB,CAACgF,cAAD,EAAiB3B,YAAjB,EAA+B6B,WAA/B,CAAtB;AACD;AACF;AACF;;AAED,QAAMD,YAAY,GAAGD,cAAc,CAAC6C,YAAf,CAA4BC,QAAjD;AACAhD,EAAAA,iBAAiB,CAACC,OAAD,EAAUC,cAAV,EAA0BC,YAA1B,EAAwCC,WAAxC,CAAjB;AACA,SAAOF,cAAc,CAACG,KAAtB;AACD;;AAED,SAAS0E,cAAT,CACE9E,OADF,EAEEC,cAFF,EAGEE,WAHF,EAIE;AACA,QAAMD,YAAY,GAAGD,cAAc,CAAC6C,YAApC;AACA/C,EAAAA,iBAAiB,CAACC,OAAD,EAAUC,cAAV,EAA0BC,YAA1B,EAAwCC,WAAxC,CAAjB;AACA,SAAOF,cAAc,CAACG,KAAtB;AACD;;AAED,SAAS2E,UAAT,CACE/E,OADF,EAEEC,cAFF,EAGEE,WAHF,EAIE;AACA,QAAMD,YAAY,GAAGD,cAAc,CAAC6C,YAAf,CAA4BC,QAAjD;AACAhD,EAAAA,iBAAiB,CAACC,OAAD,EAAUC,cAAV,EAA0BC,YAA1B,EAAwCC,WAAxC,CAAjB;AACA,SAAOF,cAAc,CAACG,KAAtB;AACD;;AAED,SAAS4E,cAAT,CACEhF,OADF,EAEEC,cAFF,EAGEE,WAHF,EAIE;AACA,MAAIrJ,mBAAJ,EAAyB;AACvBmJ,IAAAA,cAAc,CAACiB,KAAf,IAAwBjL,MAAxB;;AAEA,QAAIY,yBAAJ,EAA+B;AAC7B;AACA;AACA,YAAMoO,SAAS,GAAGhF,cAAc,CAACgF,SAAjC;AACAA,MAAAA,SAAS,CAACC,cAAV,GAA2B,CAA3B;AACAD,MAAAA,SAAS,CAACE,qBAAV,GAAkC,CAAlC;AACD;AACF;;AACD,QAAM3E,SAAS,GAAGP,cAAc,CAAC6C,YAAjC;AACA,QAAM5C,YAAY,GAAGM,SAAS,CAACuC,QAA/B;AACAhD,EAAAA,iBAAiB,CAACC,OAAD,EAAUC,cAAV,EAA0BC,YAA1B,EAAwCC,WAAxC,CAAjB;AACA,SAAOF,cAAc,CAACG,KAAtB;AACD;;AAED,SAASgF,OAAT,CAAiBpF,OAAjB,EAAwCC,cAAxC,EAA+D;AAC7D,QAAMa,GAAG,GAAGb,cAAc,CAACa,GAA3B;;AACA,MACGd,OAAO,KAAK,IAAZ,IAAoBc,GAAG,KAAK,IAA7B,IACCd,OAAO,KAAK,IAAZ,IAAoBA,OAAO,CAACc,GAAR,KAAgBA,GAFvC,EAGE;AACA;AACAb,IAAAA,cAAc,CAACiB,KAAf,IAAwBhL,GAAxB;;AACA,QAAIkB,mCAAJ,EAAyC;AACvC6I,MAAAA,cAAc,CAACiB,KAAf,IAAwB/K,SAAxB;AACD;AACF;AACF;;AAED,SAASyM,uBAAT,CACE5C,OADF,EAEEC,cAFF,EAGEM,SAHF,EAIEC,SAJF,EAKEL,WALF,EAME;AACA,MAAIL,OAAJ,EAAa;AACX,QAAIG,cAAc,CAACQ,IAAf,KAAwBR,cAAc,CAACS,WAA3C,EAAwD;AACtD;AACA;AACA,YAAMC,cAAc,GAAGJ,SAAS,CAACK,SAAjC;;AACA,UAAID,cAAJ,EAAoB;AAClB1M,QAAAA,cAAc,CACZ0M,cADY,EAEZH,SAFY,EAED;AACX,cAHY,EAIZ9I,wBAAwB,CAAC6I,SAAD,CAJZ,CAAd;AAMD;AACF;AACF;;AAED,MAAI8E,OAAJ;;AACA,MAAI,CAAC1O,oBAAL,EAA2B;AACzB,UAAM2O,eAAe,GAAGzJ,kBAAkB,CAACoE,cAAD,EAAiBM,SAAjB,EAA4B,IAA5B,CAA1C;AACA8E,IAAAA,OAAO,GAAGzJ,gBAAgB,CAACqE,cAAD,EAAiBqF,eAAjB,CAA1B;AACD;;AAED,MAAIpF,YAAJ;AACA,MAAIa,KAAJ;AACAzF,EAAAA,oBAAoB,CAAC2E,cAAD,EAAiBE,WAAjB,CAApB;;AACA,MAAI9I,wBAAJ,EAA8B;AAC5BnD,IAAAA,0BAA0B,CAAC+L,cAAD,CAA1B;AACD;;AACD,MAAIH,OAAJ,EAAa;AACXX,IAAAA,iBAAiB,CAACa,OAAlB,GAA4BC,cAA5B;AACAlI,IAAAA,cAAc,CAAC,IAAD,CAAd;AACAmI,IAAAA,YAAY,GAAG1E,eAAe,CAC5BwE,OAD4B,EAE5BC,cAF4B,EAG5BM,SAH4B,EAI5BC,SAJ4B,EAK5B6E,OAL4B,EAM5BlF,WAN4B,CAA9B;AAQAY,IAAAA,KAAK,GAAGtF,oBAAoB,EAA5B;;AACA,QACE/E,wCAAwC,IACxCuJ,cAAc,CAACe,IAAf,GAAsBtH,gBAFxB,EAGE;AACAoF,MAAAA,0BAA0B,CAAC,IAAD,CAA1B;;AACA,UAAI;AACFoB,QAAAA,YAAY,GAAG1E,eAAe,CAC5BwE,OAD4B,EAE5BC,cAF4B,EAG5BM,SAH4B,EAI5BC,SAJ4B,EAK5B6E,OAL4B,EAM5BlF,WAN4B,CAA9B;AAQAY,QAAAA,KAAK,GAAGtF,oBAAoB,EAA5B;AACD,OAVD,SAUU;AACRqD,QAAAA,0BAA0B,CAAC,KAAD,CAA1B;AACD;AACF;;AACD/G,IAAAA,cAAc,CAAC,KAAD,CAAd;AACD,GAhCD,MAgCO;AACLmI,IAAAA,YAAY,GAAG1E,eAAe,CAC5BwE,OAD4B,EAE5BC,cAF4B,EAG5BM,SAH4B,EAI5BC,SAJ4B,EAK5B6E,OAL4B,EAM5BlF,WAN4B,CAA9B;AAQAY,IAAAA,KAAK,GAAGtF,oBAAoB,EAA5B;AACD;;AACD,MAAIpE,wBAAJ,EAA8B;AAC5BlD,IAAAA,0BAA0B;AAC3B;;AAED,MAAI6L,OAAO,KAAK,IAAZ,IAAoB,CAACZ,gBAAzB,EAA2C;AACzC1D,IAAAA,YAAY,CAACsE,OAAD,EAAUC,cAAV,EAA0BE,WAA1B,CAAZ;AACA,WAAOc,4BAA4B,CAACjB,OAAD,EAAUC,cAAV,EAA0BE,WAA1B,CAAnC;AACD;;AAED,MAAI7D,cAAc,MAAMyE,KAAxB,EAA+B;AAC7B7B,IAAAA,sBAAsB,CAACe,cAAD,CAAtB;AACD,GAnFD,CAqFA;;;AACAA,EAAAA,cAAc,CAACiB,KAAf,IAAwBtL,aAAxB;AACAmK,EAAAA,iBAAiB,CAACC,OAAD,EAAUC,cAAV,EAA0BC,YAA1B,EAAwCC,WAAxC,CAAjB;AACA,SAAOF,cAAc,CAACG,KAAtB;AACD;;AAED,SAASmF,oBAAT,CACEvF,OADF,EAEEC,cAFF,EAGEM,SAHF,EAIEC,SAJF,EAKEL,WALF,EAME;AACA,MAAIL,OAAJ,EAAa;AACX;AACA,YAAQ3F,WAAW,CAAC8F,cAAD,CAAnB;AACE,WAAK,KAAL;AAAY;AACV,gBAAMuF,QAAQ,GAAGvF,cAAc,CAACgF,SAAhC;AACA,gBAAMQ,IAAI,GAAGxF,cAAc,CAACQ,IAA5B,CAFU,CAGV;AACA;;AACA,gBAAMiF,YAAY,GAAG,IAAID,IAAJ,CACnBxF,cAAc,CAAC+B,aADI,EAEnBwD,QAAQ,CAACH,OAFU,CAArB;AAIA,gBAAMM,KAAK,GAAGD,YAAY,CAACC,KAA3B;AACAH,UAAAA,QAAQ,CAACI,OAAT,CAAiBC,eAAjB,CAAiCL,QAAjC,EAA2CG,KAA3C,EAAkD,IAAlD;AACA;AACD;;AACD,WAAK,IAAL;AAAW;AACT1F,UAAAA,cAAc,CAACiB,KAAf,IAAwBlL,UAAxB;AACAiK,UAAAA,cAAc,CAACiB,KAAf,IAAwB3K,aAAxB,CAFS,CAGT;;AACA,gBAAMuP,KAAK,GAAG,IAAIC,KAAJ,CAAU,sCAAV,CAAd;AACA,gBAAMC,IAAI,GAAG1M,iBAAiB,CAAC6G,WAAD,CAA9B;AACAF,UAAAA,cAAc,CAAC0C,KAAf,GAAuBvJ,UAAU,CAAC6G,cAAc,CAAC0C,KAAhB,EAAuBqD,IAAvB,CAAjC,CANS,CAOT;;AACA,gBAAMC,MAAM,GAAGtH,sBAAsB,CACnCsB,cADmC,EAEnCvB,mBAAmB,CAACoH,KAAD,EAAQ7F,cAAR,CAFgB,EAGnC+F,IAHmC,CAArC;AAKAvN,UAAAA,qBAAqB,CAACwH,cAAD,EAAiBgG,MAAjB,CAArB;AACA;AACD;AA7BH;;AAgCA,QAAIhG,cAAc,CAACQ,IAAf,KAAwBR,cAAc,CAACS,WAA3C,EAAwD;AACtD;AACA;AACA,YAAMC,cAAc,GAAGJ,SAAS,CAACK,SAAjC;;AACA,UAAID,cAAJ,EAAoB;AAClB1M,QAAAA,cAAc,CACZ0M,cADY,EAEZH,SAFY,EAED;AACX,cAHY,EAIZ9I,wBAAwB,CAAC6I,SAAD,CAJZ,CAAd;AAMD;AACF;AACF,GAhDD,CAkDA;AACA;AACA;;;AACA,MAAI2F,UAAJ;;AACA,MAAI/J,uBAAuB,CAACoE,SAAD,CAA3B,EAAwC;AACtC2F,IAAAA,UAAU,GAAG,IAAb;AACAjK,IAAAA,yBAAyB,CAACgE,cAAD,CAAzB;AACD,GAHD,MAGO;AACLiG,IAAAA,UAAU,GAAG,KAAb;AACD;;AACD5K,EAAAA,oBAAoB,CAAC2E,cAAD,EAAiBE,WAAjB,CAApB;AAEA,QAAMqF,QAAQ,GAAGvF,cAAc,CAACgF,SAAhC;AACA,MAAIkB,YAAJ;;AACA,MAAIX,QAAQ,KAAK,IAAjB,EAAuB;AACrB,QAAIxF,OAAO,KAAK,IAAhB,EAAsB;AACpB;AACA;AACA;AACA;AACAA,MAAAA,OAAO,CAACoG,SAAR,GAAoB,IAApB;AACAnG,MAAAA,cAAc,CAACmG,SAAf,GAA2B,IAA3B,CANoB,CAOpB;;AACAnG,MAAAA,cAAc,CAACiB,KAAf,IAAwBrL,SAAxB;AACD,KAVoB,CAWrB;;;AACAgH,IAAAA,sBAAsB,CAACoD,cAAD,EAAiBM,SAAjB,EAA4BC,SAA5B,CAAtB;AACA1D,IAAAA,kBAAkB,CAACmD,cAAD,EAAiBM,SAAjB,EAA4BC,SAA5B,EAAuCL,WAAvC,CAAlB;AACAgG,IAAAA,YAAY,GAAG,IAAf;AACD,GAfD,MAeO,IAAInG,OAAO,KAAK,IAAhB,EAAsB;AAC3B;AACAmG,IAAAA,YAAY,GAAGpJ,wBAAwB,CACrCkD,cADqC,EAErCM,SAFqC,EAGrCC,SAHqC,EAIrCL,WAJqC,CAAvC;AAMD,GARM,MAQA;AACLgG,IAAAA,YAAY,GAAGnJ,mBAAmB,CAChCgD,OADgC,EAEhCC,cAFgC,EAGhCM,SAHgC,EAIhCC,SAJgC,EAKhCL,WALgC,CAAlC;AAOD;;AACD,QAAMkG,cAAc,GAAGC,oBAAoB,CACzCtG,OADyC,EAEzCC,cAFyC,EAGzCM,SAHyC,EAIzC4F,YAJyC,EAKzCD,UALyC,EAMzC/F,WANyC,CAA3C;;AAQA,MAAIL,OAAJ,EAAa;AACX,UAAMyG,IAAI,GAAGtG,cAAc,CAACgF,SAA5B;;AACA,QAAIkB,YAAY,IAAII,IAAI,CAACC,KAAL,KAAehG,SAAnC,EAA8C;AAC5C,UAAI,CAACd,4BAAL,EAAmC;AACjC+G,QAAAA,OAAO,CAACX,KAAR,CACE,2EACE,uDAFJ,EAGErO,yBAAyB,CAACwI,cAAD,CAAzB,IAA6C,aAH/C;AAKD;;AACDP,MAAAA,4BAA4B,GAAG,IAA/B;AACD;AACF;;AACD,SAAO2G,cAAP;AACD;;AAED,SAASC,oBAAT,CACEtG,OADF,EAEEC,cAFF,EAGEM,SAHF,EAIE4F,YAJF,EAKED,UALF,EAME/F,WANF,EAOE;AACA;AACAiF,EAAAA,OAAO,CAACpF,OAAD,EAAUC,cAAV,CAAP;AAEA,QAAMyG,eAAe,GAAG,CAACzG,cAAc,CAACiB,KAAf,GAAuBlL,UAAxB,MAAwCL,OAAhE;;AAEA,MAAI,CAACwQ,YAAD,IAAiB,CAACO,eAAtB,EAAuC;AACrC;AACA,QAAIR,UAAJ,EAAgB;AACd7J,MAAAA,yBAAyB,CAAC4D,cAAD,EAAiBM,SAAjB,EAA4B,KAA5B,CAAzB;AACD;;AAED,WAAOU,4BAA4B,CAACjB,OAAD,EAAUC,cAAV,EAA0BE,WAA1B,CAAnC;AACD;;AAED,QAAMqF,QAAQ,GAAGvF,cAAc,CAACgF,SAAhC,CAfA,CAiBA;;AACA9F,EAAAA,iBAAiB,CAACa,OAAlB,GAA4BC,cAA5B;AACA,MAAIC,YAAJ;;AACA,MACEwG,eAAe,IACf,OAAOnG,SAAS,CAACoG,wBAAjB,KAA8C,UAFhD,EAGE;AACA;AACA;AACA;AACA;AACA;AACAzG,IAAAA,YAAY,GAAG,IAAf;;AAEA,QAAIpJ,mBAAJ,EAAyB;AACvB6E,MAAAA,0BAA0B,CAACsE,cAAD,CAA1B;AACD;AACF,GAdD,MAcO;AACL,QAAI5I,wBAAJ,EAA8B;AAC5BnD,MAAAA,0BAA0B,CAAC+L,cAAD,CAA1B;AACD;;AACD,QAAIH,OAAJ,EAAa;AACX/H,MAAAA,cAAc,CAAC,IAAD,CAAd;AACAmI,MAAAA,YAAY,GAAGsF,QAAQ,CAAC3E,MAAT,EAAf;;AACA,UACEnK,wCAAwC,IACxCuJ,cAAc,CAACe,IAAf,GAAsBtH,gBAFxB,EAGE;AACAoF,QAAAA,0BAA0B,CAAC,IAAD,CAA1B;;AACA,YAAI;AACF0G,UAAAA,QAAQ,CAAC3E,MAAT;AACD,SAFD,SAEU;AACR/B,UAAAA,0BAA0B,CAAC,KAAD,CAA1B;AACD;AACF;;AACD/G,MAAAA,cAAc,CAAC,KAAD,CAAd;AACD,KAfD,MAeO;AACLmI,MAAAA,YAAY,GAAGsF,QAAQ,CAAC3E,MAAT,EAAf;AACD;;AACD,QAAIxJ,wBAAJ,EAA8B;AAC5BlD,MAAAA,0BAA0B;AAC3B;AACF,GA3DD,CA6DA;;;AACA8L,EAAAA,cAAc,CAACiB,KAAf,IAAwBtL,aAAxB;;AACA,MAAIoK,OAAO,KAAK,IAAZ,IAAoB0G,eAAxB,EAAyC;AACvC;AACA;AACA;AACA;AACArG,IAAAA,+BAA+B,CAC7BL,OAD6B,EAE7BC,cAF6B,EAG7BC,YAH6B,EAI7BC,WAJ6B,CAA/B;AAMD,GAXD,MAWO;AACLJ,IAAAA,iBAAiB,CAACC,OAAD,EAAUC,cAAV,EAA0BC,YAA1B,EAAwCC,WAAxC,CAAjB;AACD,GA5ED,CA8EA;AACA;;;AACAF,EAAAA,cAAc,CAACgD,aAAf,GAA+BuC,QAAQ,CAACG,KAAxC,CAhFA,CAkFA;;AACA,MAAIO,UAAJ,EAAgB;AACd7J,IAAAA,yBAAyB,CAAC4D,cAAD,EAAiBM,SAAjB,EAA4B,IAA5B,CAAzB;AACD;;AAED,SAAON,cAAc,CAACG,KAAtB;AACD;;AAED,SAASwG,mBAAT,CAA6B3G,cAA7B,EAA6C;AAC3C,QAAM4G,IAAI,GAAI5G,cAAc,CAACgF,SAA7B;;AACA,MAAI4B,IAAI,CAACC,cAAT,EAAyB;AACvB1K,IAAAA,yBAAyB,CACvB6D,cADuB,EAEvB4G,IAAI,CAACC,cAFkB,EAGvBD,IAAI,CAACC,cAAL,KAAwBD,IAAI,CAACxB,OAHN,CAAzB;AAKD,GAND,MAMO,IAAIwB,IAAI,CAACxB,OAAT,EAAkB;AACvB;AACAjJ,IAAAA,yBAAyB,CAAC6D,cAAD,EAAiB4G,IAAI,CAACxB,OAAtB,EAA+B,KAA/B,CAAzB;AACD;;AACD/K,EAAAA,iBAAiB,CAAC2F,cAAD,EAAiB4G,IAAI,CAACE,aAAtB,CAAjB;AACD;;AAED,SAASC,cAAT,CAAwBhH,OAAxB,EAAiCC,cAAjC,EAAiDE,WAAjD,EAA8D;AAC5DyG,EAAAA,mBAAmB,CAAC3G,cAAD,CAAnB;AACA,QAAMwD,WAAW,GAAGxD,cAAc,CAACwD,WAAnC;;AAEA,MAAIzD,OAAO,KAAK,IAAZ,IAAoByD,WAAW,KAAK,IAAxC,EAA8C;AAC5C,UAAM,IAAIsC,KAAJ,CACJ,sEACE,oEADF,GAEE,gBAHE,CAAN;AAKD;;AAED,QAAMvF,SAAS,GAAGP,cAAc,CAAC6C,YAAjC;AACA,QAAME,SAAS,GAAG/C,cAAc,CAACgD,aAAjC;AACA,QAAMgE,YAAY,GAAGjE,SAAS,CAACkE,OAA/B;AACA3O,EAAAA,gBAAgB,CAACyH,OAAD,EAAUC,cAAV,CAAhB;AACA3H,EAAAA,kBAAkB,CAAC2H,cAAD,EAAiBO,SAAjB,EAA4B,IAA5B,EAAkCL,WAAlC,CAAlB;AACA,QAAMgD,SAAS,GAAGlD,cAAc,CAACgD,aAAjC;AAEA,QAAM4D,IAAe,GAAG5G,cAAc,CAACgF,SAAvC;;AAEA,MAAI/N,WAAJ,EAAiB;AACf,UAAM2N,SAAgB,GAAG1B,SAAS,CAACuB,KAAnC;AACArG,IAAAA,iBAAiB,CAACwI,IAAD,CAAjB;AACAzI,IAAAA,iBAAiB,CAAC6B,cAAD,EAAiB4E,SAAjB,CAAjB;;AACA,QAAIA,SAAS,KAAK7B,SAAS,CAAC0B,KAA5B,EAAmC;AACjC;AACAzJ,MAAAA,sBAAsB,CAACgF,cAAD,EAAiB3B,YAAjB,EAA+B6B,WAA/B,CAAtB;AACD;AACF,GA7B2D,CA+B5D;AACA;;;AACA,QAAMD,YAAY,GAAGiD,SAAS,CAAC+D,OAA/B;;AACA,MAAIhH,YAAY,KAAK+G,YAArB,EAAmC;AACjCxK,IAAAA,mBAAmB;AACnB,WAAOwE,4BAA4B,CAACjB,OAAD,EAAUC,cAAV,EAA0BE,WAA1B,CAAnC;AACD;;AACD,MAAI0G,IAAI,CAACM,YAAL,IAAqB5K,mBAAmB,CAAC0D,cAAD,CAA5C,EAA8D;AAC5D;AACA;AACA;AACA;AAEA,QAAIlG,iBAAJ,EAAuB;AACrB,YAAMqN,+BAA+B,GACnCP,IAAI,CAACO,+BADP;;AAEA,UAAIA,+BAA+B,IAAI,IAAvC,EAA6C;AAC3C,aAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,+BAA+B,CAACE,MAApD,EAA4DD,CAAC,IAAI,CAAjE,EAAoE;AAClE,gBAAME,aAAa,GAAKH,+BAA+B,CACrDC,CADqD,CAAvD;AAGA,gBAAMG,OAAO,GAAGJ,+BAA+B,CAACC,CAAC,GAAG,CAAL,CAA/C;AACAnJ,UAAAA,wBAAwB,CAACqJ,aAAD,EAAgBC,OAAhB,CAAxB;AACD;AACF;AACF;;AAED,UAAMpH,KAAK,GAAGjI,gBAAgB,CAC5B8H,cAD4B,EAE5B,IAF4B,EAG5BC,YAH4B,EAI5BC,WAJ4B,CAA9B;AAMAF,IAAAA,cAAc,CAACG,KAAf,GAAuBA,KAAvB;AAEA,QAAIqH,IAAI,GAAGrH,KAAX;;AACA,WAAOqH,IAAP,EAAa;AACX;AACA;AACA;AACA;AACA;AACA;AACAA,MAAAA,IAAI,CAACvG,KAAL,GAAcuG,IAAI,CAACvG,KAAL,GAAa,CAACrL,SAAf,GAA4BC,SAAzC;AACA2R,MAAAA,IAAI,GAAGA,IAAI,CAACC,OAAZ;AACD;AACF,GAvCD,MAuCO;AACL;AACA;AACA3H,IAAAA,iBAAiB,CAACC,OAAD,EAAUC,cAAV,EAA0BC,YAA1B,EAAwCC,WAAxC,CAAjB;AACA1D,IAAAA,mBAAmB;AACpB;;AACD,SAAOwD,cAAc,CAACG,KAAtB;AACD;;AAED,SAASuH,mBAAT,CACE3H,OADF,EAEEC,cAFF,EAGEE,WAHF,EAIE;AACA9F,EAAAA,eAAe,CAAC4F,cAAD,CAAf;;AAEA,MAAID,OAAO,KAAK,IAAhB,EAAsB;AACpBtD,IAAAA,gCAAgC,CAACuD,cAAD,CAAhC;AACD;;AAED,QAAMQ,IAAI,GAAGR,cAAc,CAACQ,IAA5B;AACA,QAAMD,SAAS,GAAGP,cAAc,CAAC6C,YAAjC;AACA,QAAMf,SAAS,GAAG/B,OAAO,KAAK,IAAZ,GAAmBA,OAAO,CAACgC,aAA3B,GAA2C,IAA7D;AAEA,MAAI9B,YAAY,GAAGM,SAAS,CAACuC,QAA7B;AACA,QAAM6E,iBAAiB,GAAGjO,oBAAoB,CAAC8G,IAAD,EAAOD,SAAP,CAA9C;;AAEA,MAAIoH,iBAAJ,EAAuB;AACrB;AACA;AACA;AACA;AACA1H,IAAAA,YAAY,GAAG,IAAf;AACD,GAND,MAMO,IAAI6B,SAAS,KAAK,IAAd,IAAsBpI,oBAAoB,CAAC8G,IAAD,EAAOsB,SAAP,CAA9C,EAAiE;AACtE;AACA;AACA9B,IAAAA,cAAc,CAACiB,KAAf,IAAwBnL,YAAxB;AACD;;AAEDqP,EAAAA,OAAO,CAACpF,OAAD,EAAUC,cAAV,CAAP;AACAF,EAAAA,iBAAiB,CAACC,OAAD,EAAUC,cAAV,EAA0BC,YAA1B,EAAwCC,WAAxC,CAAjB;AACA,SAAOF,cAAc,CAACG,KAAtB;AACD;;AAED,SAASyH,cAAT,CAAwB7H,OAAxB,EAAiCC,cAAjC,EAAiD;AAC/C,MAAID,OAAO,KAAK,IAAhB,EAAsB;AACpBtD,IAAAA,gCAAgC,CAACuD,cAAD,CAAhC;AACD,GAH8C,CAI/C;AACA;;;AACA,SAAO,IAAP;AACD;;AAED,SAAS6H,kBAAT,CACEC,QADF,EAEE9H,cAFF,EAGES,WAHF,EAIEP,WAJF,EAKE;AACA,MAAI4H,QAAQ,KAAK,IAAjB,EAAuB;AACrB;AACA;AACA;AACA;AACAA,IAAAA,QAAQ,CAAC3B,SAAT,GAAqB,IAArB;AACAnG,IAAAA,cAAc,CAACmG,SAAf,GAA2B,IAA3B,CANqB,CAOrB;;AACAnG,IAAAA,cAAc,CAACiB,KAAf,IAAwBrL,SAAxB;AACD;;AAED,QAAM2Q,KAAK,GAAGvG,cAAc,CAAC6C,YAA7B;AACA,QAAMV,aAA0C,GAAG1B,WAAnD;AACA,QAAM2B,OAAO,GAAGD,aAAa,CAACE,QAA9B;AACA,QAAMC,IAAI,GAAGH,aAAa,CAACI,KAA3B;AACA,MAAIjC,SAAS,GAAGgC,IAAI,CAACF,OAAD,CAApB,CAhBA,CAiBA;;AACApC,EAAAA,cAAc,CAACQ,IAAf,GAAsBF,SAAtB;AACA,QAAMyH,WAAW,GAAI/H,cAAc,CAACuB,GAAf,GAAqBtE,uBAAuB,CAACqD,SAAD,CAAjE;AACA,QAAM0H,aAAa,GAAGhL,mBAAmB,CAACsD,SAAD,EAAYiG,KAAZ,CAAzC;AACA,MAAIpG,KAAJ;;AACA,UAAQ4H,WAAR;AACE,SAAK3T,iBAAL;AAAwB;AACtB,YAAIyL,OAAJ,EAAa;AACX2B,UAAAA,8BAA8B,CAACxB,cAAD,EAAiBM,SAAjB,CAA9B;AACAN,UAAAA,cAAc,CAACQ,IAAf,GAAsBF,SAAS,GAAGvI,8BAA8B,CAC9DuI,SAD8D,CAAhE;AAGD;;AACDH,QAAAA,KAAK,GAAGwC,uBAAuB,CAC7B,IAD6B,EAE7B3C,cAF6B,EAG7BM,SAH6B,EAI7B0H,aAJ6B,EAK7B9H,WAL6B,CAA/B;AAOA,eAAOC,KAAP;AACD;;AACD,SAAK9L,cAAL;AAAqB;AACnB,YAAIwL,OAAJ,EAAa;AACXG,UAAAA,cAAc,CAACQ,IAAf,GAAsBF,SAAS,GAAGrI,2BAA2B,CAC3DqI,SAD2D,CAA7D;AAGD;;AACDH,QAAAA,KAAK,GAAGmF,oBAAoB,CAC1B,IAD0B,EAE1BtF,cAF0B,EAG1BM,SAH0B,EAI1B0H,aAJ0B,EAK1B9H,WAL0B,CAA5B;AAOA,eAAOC,KAAP;AACD;;AACD,SAAKzL,UAAL;AAAiB;AACf,YAAImL,OAAJ,EAAa;AACXG,UAAAA,cAAc,CAACQ,IAAf,GAAsBF,SAAS,GAAGtI,gCAAgC,CAChEsI,SADgE,CAAlE;AAGD;;AACDH,QAAAA,KAAK,GAAGE,gBAAgB,CACtB,IADsB,EAEtBL,cAFsB,EAGtBM,SAHsB,EAItB0H,aAJsB,EAKtB9H,WALsB,CAAxB;AAOA,eAAOC,KAAP;AACD;;AACD,SAAKjL,aAAL;AAAoB;AAClB,YAAI2K,OAAJ,EAAa;AACX,cAAIG,cAAc,CAACQ,IAAf,KAAwBR,cAAc,CAACS,WAA3C,EAAwD;AACtD,kBAAMgC,cAAc,GAAGnC,SAAS,CAACK,SAAjC;;AACA,gBAAI8B,cAAJ,EAAoB;AAClBzO,cAAAA,cAAc,CACZyO,cADY,EAEZuF,aAFY,EAEG;AACf,oBAHY,EAIZvQ,wBAAwB,CAAC6I,SAAD,CAJZ,CAAd;AAMD;AACF;AACF;;AACDH,QAAAA,KAAK,GAAGe,mBAAmB,CACzB,IADyB,EAEzBlB,cAFyB,EAGzBM,SAHyB,EAIzBtD,mBAAmB,CAACsD,SAAS,CAACE,IAAX,EAAiBwH,aAAjB,CAJM,EAI2B;AACpD9H,QAAAA,WALyB,CAA3B;AAOA,eAAOC,KAAP;AACD;AArEH;;AAuEA,MAAI8H,IAAI,GAAG,EAAX;;AACA,MAAIpI,OAAJ,EAAa;AACX,QACES,SAAS,KAAK,IAAd,IACA,OAAOA,SAAP,KAAqB,QADrB,IAEAA,SAAS,CAAC4B,QAAV,KAAuBvK,eAHzB,EAIE;AACAsQ,MAAAA,IAAI,GAAG,2DAAP;AACD;AACF,GAtGD,CAwGA;AACA;AACA;;;AACA,QAAM,IAAInC,KAAJ,CACH,iEAAgExF,SAAU,IAA3E,GACG,yDAAwD2H,IAAK,EAF5D,CAAN;AAID;;AAED,SAASC,6BAAT,CACEJ,QADF,EAEE9H,cAFF,EAGEM,SAHF,EAIEC,SAJF,EAKEL,WALF,EAME;AACA,MAAI4H,QAAQ,KAAK,IAAjB,EAAuB;AACrB;AACA;AACA;AACA;AACAA,IAAAA,QAAQ,CAAC3B,SAAT,GAAqB,IAArB;AACAnG,IAAAA,cAAc,CAACmG,SAAf,GAA2B,IAA3B,CANqB,CAOrB;;AACAnG,IAAAA,cAAc,CAACiB,KAAf,IAAwBrL,SAAxB;AACD,GAVD,CAYA;;;AACAoK,EAAAA,cAAc,CAACuB,GAAf,GAAqBlN,cAArB,CAbA,CAeA;AAEA;AACA;AACA;;AACA,MAAI4R,UAAJ;;AACA,MAAI/J,uBAAuB,CAACoE,SAAD,CAA3B,EAAwC;AACtC2F,IAAAA,UAAU,GAAG,IAAb;AACAjK,IAAAA,yBAAyB,CAACgE,cAAD,CAAzB;AACD,GAHD,MAGO;AACLiG,IAAAA,UAAU,GAAG,KAAb;AACD;;AACD5K,EAAAA,oBAAoB,CAAC2E,cAAD,EAAiBE,WAAjB,CAApB;AAEAtD,EAAAA,sBAAsB,CAACoD,cAAD,EAAiBM,SAAjB,EAA4BC,SAA5B,CAAtB;AACA1D,EAAAA,kBAAkB,CAACmD,cAAD,EAAiBM,SAAjB,EAA4BC,SAA5B,EAAuCL,WAAvC,CAAlB;AAEA,SAAOmG,oBAAoB,CACzB,IADyB,EAEzBrG,cAFyB,EAGzBM,SAHyB,EAIzB,IAJyB,EAKzB2F,UALyB,EAMzB/F,WANyB,CAA3B;AAQD;;AAED,SAASiI,2BAAT,CACEL,QADF,EAEE9H,cAFF,EAGEM,SAHF,EAIEJ,WAJF,EAKE;AACA,MAAI4H,QAAQ,KAAK,IAAjB,EAAuB;AACrB;AACA;AACA;AACA;AACAA,IAAAA,QAAQ,CAAC3B,SAAT,GAAqB,IAArB;AACAnG,IAAAA,cAAc,CAACmG,SAAf,GAA2B,IAA3B,CANqB,CAOrB;;AACAnG,IAAAA,cAAc,CAACiB,KAAf,IAAwBrL,SAAxB;AACD;;AAED,QAAM2Q,KAAK,GAAGvG,cAAc,CAAC6C,YAA7B;AACA,MAAIuC,OAAJ;;AACA,MAAI,CAAC1O,oBAAL,EAA2B;AACzB,UAAM2O,eAAe,GAAGzJ,kBAAkB,CACxCoE,cADwC,EAExCM,SAFwC,EAGxC,KAHwC,CAA1C;AAKA8E,IAAAA,OAAO,GAAGzJ,gBAAgB,CAACqE,cAAD,EAAiBqF,eAAjB,CAA1B;AACD;;AAEDhK,EAAAA,oBAAoB,CAAC2E,cAAD,EAAiBE,WAAjB,CAApB;AACA,MAAIkI,KAAJ;AACA,MAAItH,KAAJ;;AAEA,MAAI1J,wBAAJ,EAA8B;AAC5BnD,IAAAA,0BAA0B,CAAC+L,cAAD,CAA1B;AACD;;AACD,MAAIH,OAAJ,EAAa;AACX,QACES,SAAS,CAAC+H,SAAV,IACA,OAAO/H,SAAS,CAAC+H,SAAV,CAAoBzH,MAA3B,KAAsC,UAFxC,EAGE;AACA,YAAM0H,aAAa,GAAG7Q,wBAAwB,CAAC6I,SAAD,CAAxB,IAAuC,SAA7D;;AAEA,UAAI,CAAClB,oBAAoB,CAACkJ,aAAD,CAAzB,EAA0C;AACxC9B,QAAAA,OAAO,CAACX,KAAR,CACE,+FACE,8EAFJ,EAGEyC,aAHF,EAIEA,aAJF;AAMAlJ,QAAAA,oBAAoB,CAACkJ,aAAD,CAApB,GAAsC,IAAtC;AACD;AACF;;AAED,QAAItI,cAAc,CAACe,IAAf,GAAsBtH,gBAA1B,EAA4C;AAC1C/B,MAAAA,uBAAuB,CAAC6Q,0BAAxB,CAAmDvI,cAAnD,EAAmE,IAAnE;AACD;;AAEDlI,IAAAA,cAAc,CAAC,IAAD,CAAd;AACAoH,IAAAA,iBAAiB,CAACa,OAAlB,GAA4BC,cAA5B;AACAoI,IAAAA,KAAK,GAAG7M,eAAe,CACrB,IADqB,EAErByE,cAFqB,EAGrBM,SAHqB,EAIrBiG,KAJqB,EAKrBnB,OALqB,EAMrBlF,WANqB,CAAvB;AAQAY,IAAAA,KAAK,GAAGtF,oBAAoB,EAA5B;AACA1D,IAAAA,cAAc,CAAC,KAAD,CAAd;AACD,GAlCD,MAkCO;AACLsQ,IAAAA,KAAK,GAAG7M,eAAe,CACrB,IADqB,EAErByE,cAFqB,EAGrBM,SAHqB,EAIrBiG,KAJqB,EAKrBnB,OALqB,EAMrBlF,WANqB,CAAvB;AAQAY,IAAAA,KAAK,GAAGtF,oBAAoB,EAA5B;AACD;;AACD,MAAIpE,wBAAJ,EAA8B;AAC5BlD,IAAAA,0BAA0B;AAC3B,GA7ED,CA+EA;;;AACA8L,EAAAA,cAAc,CAACiB,KAAf,IAAwBtL,aAAxB;;AAEA,MAAIkK,OAAJ,EAAa;AACX;AACA;AACA,QACE,OAAOuI,KAAP,KAAiB,QAAjB,IACAA,KAAK,KAAK,IADV,IAEA,OAAOA,KAAK,CAACxH,MAAb,KAAwB,UAFxB,IAGAwH,KAAK,CAAClG,QAAN,KAAmBb,SAJrB,EAKE;AACA,YAAMiH,aAAa,GAAG7Q,wBAAwB,CAAC6I,SAAD,CAAxB,IAAuC,SAA7D;;AACA,UAAI,CAACjB,kCAAkC,CAACiJ,aAAD,CAAvC,EAAwD;AACtD9B,QAAAA,OAAO,CAACX,KAAR,CACE,4FACE,6DADF,GAEE,wFAFF,GAGE,mFAHF,GAIE,uCALJ,EAMEyC,aANF,EAOEA,aAPF,EAQEA,aARF;AAUAjJ,QAAAA,kCAAkC,CAACiJ,aAAD,CAAlC,GAAoD,IAApD;AACD;AACF;AACF;;AAED,OACE;AACA;AACA,GAAC3R,8BAAD,IACA,OAAOyR,KAAP,KAAiB,QADjB,IAEAA,KAAK,KAAK,IAFV,IAGA,OAAOA,KAAK,CAACxH,MAAb,KAAwB,UAHxB,IAIAwH,KAAK,CAAClG,QAAN,KAAmBb,SAPrB,EAQE;AACA,QAAIxB,OAAJ,EAAa;AACX,YAAMyI,aAAa,GAAG7Q,wBAAwB,CAAC6I,SAAD,CAAxB,IAAuC,SAA7D;;AACA,UAAI,CAACjB,kCAAkC,CAACiJ,aAAD,CAAvC,EAAwD;AACtD9B,QAAAA,OAAO,CAACX,KAAR,CACE,4FACE,6DADF,GAEE,wFAFF,GAGE,mFAHF,GAIE,uCALJ,EAMEyC,aANF,EAOEA,aAPF,EAQEA,aARF;AAUAjJ,QAAAA,kCAAkC,CAACiJ,aAAD,CAAlC,GAAoD,IAApD;AACD;AACF,KAhBD,CAkBA;;;AACAtI,IAAAA,cAAc,CAACuB,GAAf,GAAqBlN,cAArB,CAnBA,CAqBA;;AACA2L,IAAAA,cAAc,CAACgD,aAAf,GAA+B,IAA/B;AACAhD,IAAAA,cAAc,CAACwD,WAAf,GAA6B,IAA7B,CAvBA,CAyBA;AACA;AACA;;AACA,QAAIyC,UAAU,GAAG,KAAjB;;AACA,QAAI/J,uBAAuB,CAACoE,SAAD,CAA3B,EAAwC;AACtC2F,MAAAA,UAAU,GAAG,IAAb;AACAjK,MAAAA,yBAAyB,CAACgE,cAAD,CAAzB;AACD,KAHD,MAGO;AACLiG,MAAAA,UAAU,GAAG,KAAb;AACD;;AAEDjG,IAAAA,cAAc,CAACgD,aAAf,GACEoF,KAAK,CAAC1C,KAAN,KAAgB,IAAhB,IAAwB0C,KAAK,CAAC1C,KAAN,KAAgBrE,SAAxC,GAAoD+G,KAAK,CAAC1C,KAA1D,GAAkE,IADpE;AAGAnN,IAAAA,qBAAqB,CAACyH,cAAD,CAArB;AAEArD,IAAAA,kBAAkB,CAACqD,cAAD,EAAiBoI,KAAjB,CAAlB;AACAvL,IAAAA,kBAAkB,CAACmD,cAAD,EAAiBM,SAAjB,EAA4BiG,KAA5B,EAAmCrG,WAAnC,CAAlB;AACA,WAAOmG,oBAAoB,CACzB,IADyB,EAEzBrG,cAFyB,EAGzBM,SAHyB,EAIzB,IAJyB,EAKzB2F,UALyB,EAMzB/F,WANyB,CAA3B;AAQD,GA3DD,MA2DO;AACL;AACAF,IAAAA,cAAc,CAACuB,GAAf,GAAqBnN,iBAArB;;AACA,QAAIyL,OAAJ,EAAa;AACX,UAAInJ,oBAAoB,IAAI4J,SAAS,CAACkI,YAAtC,EAAoD;AAClDhC,QAAAA,OAAO,CAACX,KAAR,CACE,uEACE,4DAFJ,EAGEpO,wBAAwB,CAAC6I,SAAD,CAAxB,IAAuC,SAHzC;AAKD;;AAED,UACE7J,wCAAwC,IACxCuJ,cAAc,CAACe,IAAf,GAAsBtH,gBAFxB,EAGE;AACAoF,QAAAA,0BAA0B,CAAC,IAAD,CAA1B;;AACA,YAAI;AACFuJ,UAAAA,KAAK,GAAG7M,eAAe,CACrB,IADqB,EAErByE,cAFqB,EAGrBM,SAHqB,EAIrBiG,KAJqB,EAKrBnB,OALqB,EAMrBlF,WANqB,CAAvB;AAQAY,UAAAA,KAAK,GAAGtF,oBAAoB,EAA5B;AACD,SAVD,SAUU;AACRqD,UAAAA,0BAA0B,CAAC,KAAD,CAA1B;AACD;AACF;AACF;;AAED,QAAIxC,cAAc,MAAMyE,KAAxB,EAA+B;AAC7B7B,MAAAA,sBAAsB,CAACe,cAAD,CAAtB;AACD;;AAEDF,IAAAA,iBAAiB,CAAC,IAAD,EAAOE,cAAP,EAAuBoI,KAAvB,EAA8BlI,WAA9B,CAAjB;;AACA,QAAIL,OAAJ,EAAa;AACX2B,MAAAA,8BAA8B,CAACxB,cAAD,EAAiBM,SAAjB,CAA9B;AACD;;AACD,WAAON,cAAc,CAACG,KAAtB;AACD;AACF;;AAED,SAASqB,8BAAT,CAAwCxB,cAAxC,EAA+DM,SAA/D,EAA+E;AAC7E,MAAIT,OAAJ,EAAa;AACX,QAAIS,SAAJ,EAAe;AACb,UAAIA,SAAS,CAACmI,iBAAd,EAAiC;AAC/BjC,QAAAA,OAAO,CAACX,KAAR,CACE,uEADF,EAEEvF,SAAS,CAACoI,WAAV,IAAyBpI,SAAS,CAACqI,IAAnC,IAA2C,WAF7C;AAID;AACF;;AACD,QAAI3I,cAAc,CAACa,GAAf,KAAuB,IAA3B,EAAiC;AAC/B,UAAI+H,IAAI,GAAG,EAAX;AACA,YAAMC,SAAS,GAAGhR,mCAAmC,EAArD;;AACA,UAAIgR,SAAJ,EAAe;AACbD,QAAAA,IAAI,IAAI,qCAAqCC,SAArC,GAAiD,IAAzD;AACD;;AAED,UAAIC,UAAU,GAAGD,SAAS,IAAI,EAA9B;AACA,YAAME,WAAW,GAAG/I,cAAc,CAACgJ,YAAnC;;AACA,UAAID,WAAJ,EAAiB;AACfD,QAAAA,UAAU,GAAGC,WAAW,CAACE,QAAZ,GAAuB,GAAvB,GAA6BF,WAAW,CAACG,UAAtD;AACD;;AACD,UAAI,CAAC1J,wBAAwB,CAACsJ,UAAD,CAA7B,EAA2C;AACzCtJ,QAAAA,wBAAwB,CAACsJ,UAAD,CAAxB,GAAuC,IAAvC;AACAtC,QAAAA,OAAO,CAACX,KAAR,CACE,+CACE,yCADF,GAEE,2CAHJ,EAIE+C,IAJF;AAMD;AACF;;AAED,QACE7R,yCAAyC,IACzCuJ,SAAS,CAACc,YAAV,KAA2BC,SAF7B,EAGE;AACA,YAAMiH,aAAa,GAAG7Q,wBAAwB,CAAC6I,SAAD,CAAxB,IAAuC,SAA7D;;AAEA,UAAI,CAACV,2CAA2C,CAAC0I,aAAD,CAAhD,EAAiE;AAC/D9B,QAAAA,OAAO,CAACX,KAAR,CACE,2EACE,uEAFJ,EAGEyC,aAHF;AAKA1I,QAAAA,2CAA2C,CAAC0I,aAAD,CAA3C,GAA6D,IAA7D;AACD;AACF;;AAED,QAAI,OAAOhI,SAAS,CAAC6I,wBAAjB,KAA8C,UAAlD,EAA8D;AAC5D,YAAMb,aAAa,GAAG7Q,wBAAwB,CAAC6I,SAAD,CAAxB,IAAuC,SAA7D;;AAEA,UAAI,CAACf,8CAA8C,CAAC+I,aAAD,CAAnD,EAAoE;AAClE9B,QAAAA,OAAO,CAACX,KAAR,CACE,kEADF,EAEEyC,aAFF;AAIA/I,QAAAA,8CAA8C,CAAC+I,aAAD,CAA9C,GAAgE,IAAhE;AACD;AACF;;AAED,QACE,OAAOhI,SAAS,CAAC8I,WAAjB,KAAiC,QAAjC,IACA9I,SAAS,CAAC8I,WAAV,KAA0B,IAF5B,EAGE;AACA,YAAMd,aAAa,GAAG7Q,wBAAwB,CAAC6I,SAAD,CAAxB,IAAuC,SAA7D;;AAEA,UAAI,CAAChB,0CAA0C,CAACgJ,aAAD,CAA/C,EAAgE;AAC9D9B,QAAAA,OAAO,CAACX,KAAR,CACE,qDADF,EAEEyC,aAFF;AAIAhJ,QAAAA,0CAA0C,CAACgJ,aAAD,CAA1C,GAA4D,IAA5D;AACD;AACF;AACF;AACF;;AAED,MAAMe,gBAA+B,GAAG;AACtCC,EAAAA,UAAU,EAAE,IAD0B;AAEtCC,EAAAA,WAAW,EAAE,IAFyB;AAGtCC,EAAAA,SAAS,EAAE/Q;AAH2B,CAAxC;;AAMA,SAASgR,2BAAT,CAAqCvJ,WAArC,EAAyE;AACvE,SAAO;AACLiD,IAAAA,SAAS,EAAEjD,WADN;AAELkD,IAAAA,SAAS,EAAE9E,qBAAqB;AAF3B,GAAP;AAID;;AAED,SAASoL,4BAAT,CACEC,kBADF,EAEEzJ,WAFF,EAGkB;AAChB,MAAIkD,SAAkC,GAAG,IAAzC;;AACA,MAAInM,WAAJ,EAAiB;AACf,UAAMwM,aAAsC,GAAGkG,kBAAkB,CAACvG,SAAlE;;AACA,QAAIK,aAAa,KAAK,IAAtB,EAA4B;AAC1B,YAAMY,WAAW,GAAGtK,iBAAiB,GACjCsE,YAAY,CAACuL,aADoB,GAEjCvL,YAAY,CAACwL,cAFjB;;AAGA,UAAIpG,aAAa,CAACe,MAAd,KAAyBH,WAA7B,EAA0C;AACxC;AACA;AACAjB,QAAAA,SAAS,GAAG;AACVoB,UAAAA,MAAM,EAAEH,WADE;AAEVyF,UAAAA,IAAI,EAAEzF;AAFI,SAAZ;AAID,OAPD,MAOO;AACL;AACA;AACAjB,QAAAA,SAAS,GAAGK,aAAZ;AACD;AACF,KAhBD,MAgBO;AACL;AACAL,MAAAA,SAAS,GAAG9E,qBAAqB,EAAjC;AACD;AACF;;AACD,SAAO;AACL6E,IAAAA,SAAS,EAAEhK,UAAU,CAACwQ,kBAAkB,CAACxG,SAApB,EAA+BjD,WAA/B,CADhB;AAELkD,IAAAA;AAFK,GAAP;AAID,C,CAED;;;AACA,SAAS2G,sBAAT,CACEC,eADF,EAEEjK,OAFF,EAGEC,cAHF,EAIEE,WAJF,EAKE;AACA;AACA;AACA;AACA,MAAIH,OAAO,KAAK,IAAhB,EAAsB;AACpB,UAAMkK,aAA4B,GAAGlK,OAAO,CAACiD,aAA7C;;AACA,QAAIiH,aAAa,KAAK,IAAtB,EAA4B;AAC1B;AACA;AACA;AACA;AACA,aAAO,KAAP;AACD;AACF,GAbD,CAeA;;;AACA,SAAOvP,kBAAkB,CACvBsP,eADuB,EAEtBvP,qBAFsB,CAAzB;AAID;;AAED,SAASyP,6BAAT,CAAuCnK,OAAvC,EAAuDG,WAAvD,EAAoE;AAClE;AACA,SAAOhH,WAAW,CAAC6G,OAAO,CAACwD,UAAT,EAAqBrD,WAArB,CAAlB;AACD;;AAED,SAASiK,uBAAT,CAAiCpK,OAAjC,EAA0CC,cAA1C,EAA0DE,WAA1D,EAAuE;AACrE,QAAMK,SAAS,GAAGP,cAAc,CAAC6C,YAAjC,CADqE,CAGrE;;AACA,MAAIhD,OAAJ,EAAa;AACX,QAAI1F,aAAa,CAAC6F,cAAD,CAAjB,EAAmC;AACjCA,MAAAA,cAAc,CAACiB,KAAf,IAAwBlL,UAAxB;AACD;AACF;;AAED,MAAIiU,eAAgC,GAAG1P,mBAAmB,CAACyF,OAA3D;AAEA,MAAIqK,YAAY,GAAG,KAAnB;AACA,QAAMC,UAAU,GAAG,CAACrK,cAAc,CAACiB,KAAf,GAAuBlL,UAAxB,MAAwCL,OAA3D;;AAEA,MACE2U,UAAU,IACVN,sBAAsB,CACpBC,eADoB,EAEpBjK,OAFoB,EAGpBC,cAHoB,EAIpBE,WAJoB,CAFxB,EAQE;AACA;AACA;AACAkK,IAAAA,YAAY,GAAG,IAAf;AACApK,IAAAA,cAAc,CAACiB,KAAf,IAAwB,CAAClL,UAAzB;AACD,GAbD,MAaO;AACL;AACA,QACEgK,OAAO,KAAK,IAAZ,IACCA,OAAO,CAACiD,aAAT,KAAkD,IAFpD,EAGE;AACA;AACA;AACA;AACA;AACA,UAAIzC,SAAS,CAAC+J,0BAAV,KAAyC,IAA7C,EAAmD;AACjDN,QAAAA,eAAe,GAAGpP,yBAAyB,CACzCoP,eADyC,EAEzCxP,8BAFyC,CAA3C;AAID;AACF;AACF;;AAEDwP,EAAAA,eAAe,GAAGrP,gCAAgC,CAACqP,eAAD,CAAlD;AAEAzP,EAAAA,mBAAmB,CAACyF,cAAD,EAAiBgK,eAAjB,CAAnB,CAjDqE,CAmDrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAIjK,OAAO,KAAK,IAAhB,EAAsB;AACpB;AACA;AACAtD,IAAAA,gCAAgC,CAACuD,cAAD,CAAhC,CAHoB,CAIpB;;AACA,QAAIlJ,4BAAJ,EAAkC;AAChC,YAAMmT,aAAmC,GAAGjK,cAAc,CAACgD,aAA3D;;AACA,UAAIiH,aAAa,KAAK,IAAtB,EAA4B;AAC1B,cAAMX,UAAU,GAAGW,aAAa,CAACX,UAAjC;;AACA,YAAIA,UAAU,KAAK,IAAnB,EAAyB;AACvB,iBAAOiB,gCAAgC,CACrCvK,cADqC,EAErCsJ,UAFqC,EAGrCpJ,WAHqC,CAAvC;AAKD;AACF;AACF;;AAED,UAAMsK,mBAAmB,GAAGjK,SAAS,CAACuC,QAAtC;AACA,UAAM2H,oBAAoB,GAAGlK,SAAS,CAACmK,QAAvC;;AACA,QAAIN,YAAJ,EAAkB;AAChB,YAAMO,gBAAgB,GAAGC,6BAA6B,CACpD5K,cADoD,EAEpDwK,mBAFoD,EAGpDC,oBAHoD,EAIpDvK,WAJoD,CAAtD;AAMA,YAAM2K,oBAA2B,GAAI7K,cAAc,CAACG,KAApD;AACA0K,MAAAA,oBAAoB,CAAC7H,aAArB,GAAqCyG,2BAA2B,CAC9DvJ,WAD8D,CAAhE;AAGAF,MAAAA,cAAc,CAACgD,aAAf,GAA+BqG,gBAA/B;AACA,aAAOsB,gBAAP;AACD,KAbD,MAaO,IAAI,OAAOpK,SAAS,CAACuK,yBAAjB,KAA+C,QAAnD,EAA6D;AAClE;AACA;AACA;AACA,YAAMH,gBAAgB,GAAGC,6BAA6B,CACpD5K,cADoD,EAEpDwK,mBAFoD,EAGpDC,oBAHoD,EAIpDvK,WAJoD,CAAtD;AAMA,YAAM2K,oBAA2B,GAAI7K,cAAc,CAACG,KAApD;AACA0K,MAAAA,oBAAoB,CAAC7H,aAArB,GAAqCyG,2BAA2B,CAC9DvJ,WAD8D,CAAhE;AAGAF,MAAAA,cAAc,CAACgD,aAAf,GAA+BqG,gBAA/B,CAdkE,CAgBlE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACArJ,MAAAA,cAAc,CAAC0C,KAAf,GAAuB5J,aAAvB;AACA,aAAO6R,gBAAP;AACD,KA1BM,MA0BA;AACL,aAAOI,4BAA4B,CACjC/K,cADiC,EAEjCwK,mBAFiC,EAGjCtK,WAHiC,CAAnC;AAKD;AACF,GAnED,MAmEO;AACL;AAEA;AACA;AACA,UAAM6C,SAA+B,GAAGhD,OAAO,CAACiD,aAAhD;;AACA,QAAID,SAAS,KAAK,IAAlB,EAAwB;AACtB;AAEA;AACA,UAAIjM,4BAAJ,EAAkC;AAChC,cAAMwS,UAAU,GAAGvG,SAAS,CAACuG,UAA7B;;AACA,YAAIA,UAAU,KAAK,IAAnB,EAAyB;AACvB,cAAI,CAACe,UAAL,EAAiB;AACf,mBAAOW,iCAAiC,CACtCjL,OADsC,EAEtCC,cAFsC,EAGtCsJ,UAHsC,EAItCvG,SAJsC,EAKtC7C,WALsC,CAAxC;AAOD,WARD,MAQO,IAAIF,cAAc,CAACiB,KAAf,GAAuB1K,iBAA3B,EAA8C;AACnD;AACAyJ,YAAAA,cAAc,CAACiB,KAAf,IAAwB,CAAC1K,iBAAzB;AACA,mBAAO0U,sCAAsC,CAC3ClL,OAD2C,EAE3CC,cAF2C,EAG3CE,WAH2C,CAA7C;AAKD,WARM,MAQA,IACJF,cAAc,CAACgD,aAAhB,KAAyD,IADpD,EAEL;AACA;AACA;AACAhD,YAAAA,cAAc,CAACG,KAAf,GAAuBJ,OAAO,CAACI,KAA/B,CAHA,CAIA;AACA;;AACAH,YAAAA,cAAc,CAACiB,KAAf,IAAwBlL,UAAxB;AACA,mBAAO,IAAP;AACD,WAVM,MAUA;AACL;AACA;AACA,kBAAMyU,mBAAmB,GAAGjK,SAAS,CAACuC,QAAtC;AACA,kBAAM2H,oBAAoB,GAAGlK,SAAS,CAACmK,QAAvC;AACA,kBAAMQ,qBAAqB,GAAGC,+CAA+C,CAC3EpL,OAD2E,EAE3EC,cAF2E,EAG3EwK,mBAH2E,EAI3EC,oBAJ2E,EAK3EvK,WAL2E,CAA7E;AAOA,kBAAM2K,oBAA2B,GAAI7K,cAAc,CAACG,KAApD;AACA0K,YAAAA,oBAAoB,CAAC7H,aAArB,GAAqCyG,2BAA2B,CAC9DvJ,WAD8D,CAAhE;AAGAF,YAAAA,cAAc,CAACgD,aAAf,GAA+BqG,gBAA/B;AACA,mBAAO6B,qBAAP;AACD;AACF;AACF;;AAED,UAAId,YAAJ,EAAkB;AAChB,cAAMK,oBAAoB,GAAGlK,SAAS,CAACmK,QAAvC;AACA,cAAMF,mBAAmB,GAAGjK,SAAS,CAACuC,QAAtC;AACA,cAAMoI,qBAAqB,GAAGE,8BAA8B,CAC1DrL,OAD0D,EAE1DC,cAF0D,EAG1DwK,mBAH0D,EAI1DC,oBAJ0D,EAK1DvK,WAL0D,CAA5D;AAOA,cAAM2K,oBAA2B,GAAI7K,cAAc,CAACG,KAApD;AACA,cAAMwJ,kBAAyC,GAAI5J,OAAO,CAACI,KAAT,CAC/C6C,aADH;AAEA6H,QAAAA,oBAAoB,CAAC7H,aAArB,GACE2G,kBAAkB,KAAK,IAAvB,GACIF,2BAA2B,CAACvJ,WAAD,CAD/B,GAEIwJ,4BAA4B,CAACC,kBAAD,EAAqBzJ,WAArB,CAHlC;AAIA2K,QAAAA,oBAAoB,CAACtH,UAArB,GAAkC2G,6BAA6B,CAC7DnK,OAD6D,EAE7DG,WAF6D,CAA/D;AAIAF,QAAAA,cAAc,CAACgD,aAAf,GAA+BqG,gBAA/B;AACA,eAAO6B,qBAAP;AACD,OAvBD,MAuBO;AACL,cAAMV,mBAAmB,GAAGjK,SAAS,CAACuC,QAAtC;AACA,cAAM+H,oBAAoB,GAAGQ,6BAA6B,CACxDtL,OADwD,EAExDC,cAFwD,EAGxDwK,mBAHwD,EAIxDtK,WAJwD,CAA1D;AAMAF,QAAAA,cAAc,CAACgD,aAAf,GAA+B,IAA/B;AACA,eAAO6H,oBAAP;AACD;AACF,KAzFD,MAyFO;AACL;AACA,UAAIT,YAAJ,EAAkB;AAChB;AACA,cAAMK,oBAAoB,GAAGlK,SAAS,CAACmK,QAAvC;AACA,cAAMF,mBAAmB,GAAGjK,SAAS,CAACuC,QAAtC;AACA,cAAMoI,qBAAqB,GAAGE,8BAA8B,CAC1DrL,OAD0D,EAE1DC,cAF0D,EAG1DwK,mBAH0D,EAI1DC,oBAJ0D,EAK1DvK,WAL0D,CAA5D;AAOA,cAAM2K,oBAA2B,GAAI7K,cAAc,CAACG,KAApD;AACA,cAAMwJ,kBAAyC,GAAI5J,OAAO,CAACI,KAAT,CAC/C6C,aADH;AAEA6H,QAAAA,oBAAoB,CAAC7H,aAArB,GACE2G,kBAAkB,KAAK,IAAvB,GACIF,2BAA2B,CAACvJ,WAAD,CAD/B,GAEIwJ,4BAA4B,CAACC,kBAAD,EAAqBzJ,WAArB,CAHlC;AAIA2K,QAAAA,oBAAoB,CAACtH,UAArB,GAAkC2G,6BAA6B,CAC7DnK,OAD6D,EAE7DG,WAF6D,CAA/D,CAlBgB,CAsBhB;AACA;;AACAF,QAAAA,cAAc,CAACgD,aAAf,GAA+BqG,gBAA/B;AACA,eAAO6B,qBAAP;AACD,OA1BD,MA0BO;AACL;AACA;AACA,cAAMV,mBAAmB,GAAGjK,SAAS,CAACuC,QAAtC;AACA,cAAM+H,oBAAoB,GAAGQ,6BAA6B,CACxDtL,OADwD,EAExDC,cAFwD,EAGxDwK,mBAHwD,EAIxDtK,WAJwD,CAA1D;AAMAF,QAAAA,cAAc,CAACgD,aAAf,GAA+B,IAA/B;AACA,eAAO6H,oBAAP;AACD;AACF;AACF;AACF;;AAED,SAASE,4BAAT,CACE/K,cADF,EAEEsL,eAFF,EAGEpL,WAHF,EAIE;AACA,QAAMa,IAAI,GAAGf,cAAc,CAACe,IAA5B;AACA,QAAMwK,iBAAiC,GAAG;AACxCxK,IAAAA,IAAI,EAAE,SADkC;AAExC+B,IAAAA,QAAQ,EAAEwI;AAF8B,GAA1C;AAIA,QAAMT,oBAAoB,GAAGW,iCAAiC,CAC5DD,iBAD4D,EAE5DxK,IAF4D,EAG5Db,WAH4D,CAA9D;AAKA2K,EAAAA,oBAAoB,CAACnJ,MAArB,GAA8B1B,cAA9B;AACAA,EAAAA,cAAc,CAACG,KAAf,GAAuB0K,oBAAvB;AACA,SAAOA,oBAAP;AACD;;AAED,SAASD,6BAAT,CACE5K,cADF,EAEEsL,eAFF,EAGEG,gBAHF,EAIEvL,WAJF,EAKE;AACA,QAAMa,IAAI,GAAGf,cAAc,CAACe,IAA5B;AACA,QAAM2K,yBAAuC,GAAG1L,cAAc,CAACG,KAA/D;AAEA,QAAMoL,iBAAiC,GAAG;AACxCxK,IAAAA,IAAI,EAAE,QADkC;AAExC+B,IAAAA,QAAQ,EAAEwI;AAF8B,GAA1C;AAKA,MAAIT,oBAAJ;AACA,MAAIK,qBAAJ;;AACA,MACE,CAACnK,IAAI,GAAGzH,cAAR,MAA4BC,MAA5B,IACAmS,yBAAyB,KAAK,IAFhC,EAGE;AACA;AACA;AACAb,IAAAA,oBAAoB,GAAGa,yBAAvB;AACAb,IAAAA,oBAAoB,CAACtH,UAArB,GAAkC7K,OAAlC;AACAmS,IAAAA,oBAAoB,CAAChI,YAArB,GAAoC0I,iBAApC;;AAEA,QAAI1U,mBAAmB,IAAImJ,cAAc,CAACe,IAAf,GAAsBvH,WAAjD,EAA8D;AAC5D;AACA;AACA;AACA;AACAqR,MAAAA,oBAAoB,CAACc,cAArB,GAAsC,CAAtC;AACAd,MAAAA,oBAAoB,CAACe,eAArB,GAAuC,CAAC,CAAxC;AACAf,MAAAA,oBAAoB,CAACgB,gBAArB,GAAwC,CAAxC;AACAhB,MAAAA,oBAAoB,CAACiB,gBAArB,GAAwC,CAAxC;AACD;;AAEDZ,IAAAA,qBAAqB,GAAG/N,uBAAuB,CAC7CsO,gBAD6C,EAE7C1K,IAF6C,EAG7Cb,WAH6C,EAI7C,IAJ6C,CAA/C;AAMD,GA3BD,MA2BO;AACL2K,IAAAA,oBAAoB,GAAGW,iCAAiC,CACtDD,iBADsD,EAEtDxK,IAFsD,EAGtDrI,OAHsD,CAAxD;AAKAwS,IAAAA,qBAAqB,GAAG/N,uBAAuB,CAC7CsO,gBAD6C,EAE7C1K,IAF6C,EAG7Cb,WAH6C,EAI7C,IAJ6C,CAA/C;AAMD;;AAED2K,EAAAA,oBAAoB,CAACnJ,MAArB,GAA8B1B,cAA9B;AACAkL,EAAAA,qBAAqB,CAACxJ,MAAtB,GAA+B1B,cAA/B;AACA6K,EAAAA,oBAAoB,CAACpD,OAArB,GAA+ByD,qBAA/B;AACAlL,EAAAA,cAAc,CAACG,KAAf,GAAuB0K,oBAAvB;AACA,SAAOK,qBAAP;AACD;;AAED,SAASM,iCAAT,CACEO,cADF,EAEEhL,IAFF,EAGEb,WAHF,EAIE;AACA;AACA;AACA,SAAO9C,wBAAwB,CAAC2O,cAAD,EAAiBhL,IAAjB,EAAuBrI,OAAvB,EAAgC,IAAhC,CAA/B;AACD;;AAED,SAASsT,kCAAT,CACEjM,OADF,EAEEgM,cAFF,EAGE;AACA;AACA;AACA,SAAO1O,oBAAoB,CAAC0C,OAAD,EAAUgM,cAAV,CAA3B;AACD;;AAED,SAASV,6BAAT,CACEtL,OADF,EAEEC,cAFF,EAGEsL,eAHF,EAIEpL,WAJF,EAKE;AACA,QAAM+L,2BAAkC,GAAIlM,OAAO,CAACI,KAApD;AACA,QAAM+L,4BAA0C,GAC9CD,2BAA2B,CAACxE,OAD9B;AAGA,QAAMoD,oBAAoB,GAAGmB,kCAAkC,CAC7DC,2BAD6D,EAE7D;AACElL,IAAAA,IAAI,EAAE,SADR;AAEE+B,IAAAA,QAAQ,EAAEwI;AAFZ,GAF6D,CAA/D;;AAOA,MAAI,CAACtL,cAAc,CAACe,IAAf,GAAsBzH,cAAvB,MAA2CC,MAA/C,EAAuD;AACrDsR,IAAAA,oBAAoB,CAACnI,KAArB,GAA6BxC,WAA7B;AACD;;AACD2K,EAAAA,oBAAoB,CAACnJ,MAArB,GAA8B1B,cAA9B;AACA6K,EAAAA,oBAAoB,CAACpD,OAArB,GAA+B,IAA/B;;AACA,MAAIyE,4BAA4B,KAAK,IAArC,EAA2C;AACzC;AACA,UAAMC,SAAS,GAAGnM,cAAc,CAACmM,SAAjC;;AACA,QAAIA,SAAS,KAAK,IAAlB,EAAwB;AACtBnM,MAAAA,cAAc,CAACmM,SAAf,GAA2B,CAACD,4BAAD,CAA3B;AACAlM,MAAAA,cAAc,CAACiB,KAAf,IAAwB9K,aAAxB;AACD,KAHD,MAGO;AACLgW,MAAAA,SAAS,CAACC,IAAV,CAAeF,4BAAf;AACD;AACF;;AAEDlM,EAAAA,cAAc,CAACG,KAAf,GAAuB0K,oBAAvB;AACA,SAAOA,oBAAP;AACD;;AAED,SAASO,8BAAT,CACErL,OADF,EAEEC,cAFF,EAGEsL,eAHF,EAIEG,gBAJF,EAKEvL,WALF,EAME;AACA,QAAMa,IAAI,GAAGf,cAAc,CAACe,IAA5B;AACA,QAAMkL,2BAAkC,GAAIlM,OAAO,CAACI,KAApD;AACA,QAAM+L,4BAA0C,GAC9CD,2BAA2B,CAACxE,OAD9B;AAGA,QAAM8D,iBAAiC,GAAG;AACxCxK,IAAAA,IAAI,EAAE,QADkC;AAExC+B,IAAAA,QAAQ,EAAEwI;AAF8B,GAA1C;AAKA,MAAIT,oBAAJ;;AACA,OACE;AACA;AACA,GAAC9J,IAAI,GAAGzH,cAAR,MAA4BC,MAA5B,IACA;AACA;AACA;AACA;AACA;AACA;AACAyG,EAAAA,cAAc,CAACG,KAAf,KAAyB8L,2BAV3B,EAWE;AACA,UAAMP,yBAAgC,GAAI1L,cAAc,CAACG,KAAzD;AACA0K,IAAAA,oBAAoB,GAAGa,yBAAvB;AACAb,IAAAA,oBAAoB,CAACtH,UAArB,GAAkC7K,OAAlC;AACAmS,IAAAA,oBAAoB,CAAChI,YAArB,GAAoC0I,iBAApC;;AAEA,QAAI1U,mBAAmB,IAAImJ,cAAc,CAACe,IAAf,GAAsBvH,WAAjD,EAA8D;AAC5D;AACA;AACA;AACA;AACAqR,MAAAA,oBAAoB,CAACc,cAArB,GAAsC,CAAtC;AACAd,MAAAA,oBAAoB,CAACe,eAArB,GAAuC,CAAC,CAAxC;AACAf,MAAAA,oBAAoB,CAACgB,gBAArB,GACEI,2BAA2B,CAACJ,gBAD9B;AAEAhB,MAAAA,oBAAoB,CAACiB,gBAArB,GACEG,2BAA2B,CAACH,gBAD9B;AAED;;AAED,QAAIzU,sCAAsC,IAAI2C,mBAA9C,EAAmE;AACjE;AACA;AACA;AACA,YAAMqS,yBAAyB,GAAGJ,2BAA2B,CAAC9L,KAA9D;AACA,YAAMyD,kBAAyB,GAAIiH,oBAAoB,CAAC1K,KAAxD;AACA,YAAM6D,cAAc,GAAG/J,0BAA0B,CAC/C,QAD+C,EAE/CqR,eAF+C,CAAjD;AAIA1H,MAAAA,kBAAkB,CAACf,YAAnB,GAAkCmB,cAAlC;AACAJ,MAAAA,kBAAkB,CAAC7B,aAAnB,GAAmCiC,cAAnC;AACArF,MAAAA,uCAAuC,CACrC0N,yBADqC,EAErCzI,kBAFqC,CAAvC;AAID,KAnCD,CAqCA;AACA;AACA;;;AACA5D,IAAAA,cAAc,CAACmM,SAAf,GAA2B,IAA3B;AACD,GApDD,MAoDO;AACLtB,IAAAA,oBAAoB,GAAGmB,kCAAkC,CACvDC,2BADuD,EAEvDV,iBAFuD,CAAzD;;AAKA,QAAIlU,sCAAsC,IAAI2C,mBAA9C,EAAmE;AACjE;AACA;AACA;AACA,YAAMqS,yBAAyB,GAAGJ,2BAA2B,CAAC9L,KAA9D;;AACA,UAAIkM,yBAAyB,KAAK,IAAlC,EAAwC;AACtC,cAAM1I,QAAQ,GAAG,IAAjB;AACA,cAAMC,kBAAkB,GAAGC,+BAA+B,CACxDoI,2BADwD,EAExDpB,oBAFwD,EAGxDlH,QAHwD,EAIxD2H,eAJwD,EAKxDpL,WALwD,CAA1D;AAOA0D,QAAAA,kBAAkB,CAAC7B,aAAnB,GAAmC6B,kBAAkB,CAACf,YAAtD;AACAlE,QAAAA,uCAAuC,CACrC0N,yBADqC,EAErCzI,kBAFqC,CAAvC;AAID;AACF,KA1BI,CA4BL;AACA;AACA;;;AACAiH,IAAAA,oBAAoB,CAACyB,YAArB,GACEL,2BAA2B,CAACK,YAA5B,GAA2CjW,UAD7C;AAED;;AACD,MAAI6U,qBAAJ;;AACA,MAAIgB,4BAA4B,KAAK,IAArC,EAA2C;AACzChB,IAAAA,qBAAqB,GAAG7N,oBAAoB,CAC1C6O,4BAD0C,EAE1CT,gBAF0C,CAA5C;AAID,GALD,MAKO;AACLP,IAAAA,qBAAqB,GAAG/N,uBAAuB,CAC7CsO,gBAD6C,EAE7C1K,IAF6C,EAG7Cb,WAH6C,EAI7C,IAJ6C,CAA/C,CADK,CAOL;AACA;;AACAgL,IAAAA,qBAAqB,CAACjK,KAAtB,IAA+BrL,SAA/B;AACD;;AAEDsV,EAAAA,qBAAqB,CAACxJ,MAAtB,GAA+B1B,cAA/B;AACA6K,EAAAA,oBAAoB,CAACnJ,MAArB,GAA8B1B,cAA9B;AACA6K,EAAAA,oBAAoB,CAACpD,OAArB,GAA+ByD,qBAA/B;AACAlL,EAAAA,cAAc,CAACG,KAAf,GAAuB0K,oBAAvB;AAEA,SAAOK,qBAAP;AACD;;AAED,SAASD,sCAAT,CACElL,OADF,EAEEC,cAFF,EAGEE,WAHF,EAIE;AACA;AACA/H,EAAAA,oBAAoB,CAAC6H,cAAD,EAAiBD,OAAO,CAACI,KAAzB,EAAgC,IAAhC,EAAsCD,WAAtC,CAApB,CAFA,CAIA;;AACA,QAAMK,SAAS,GAAGP,cAAc,CAAC6C,YAAjC;AACA,QAAMyI,eAAe,GAAG/K,SAAS,CAACuC,QAAlC;AACA,QAAM+H,oBAAoB,GAAGE,4BAA4B,CACvD/K,cADuD,EAEvDsL,eAFuD,EAGvDpL,WAHuD,CAAzD,CAPA,CAYA;AACA;;AACA2K,EAAAA,oBAAoB,CAAC5J,KAArB,IAA8BrL,SAA9B;AACAoK,EAAAA,cAAc,CAACgD,aAAf,GAA+B,IAA/B;AAEA,SAAO6H,oBAAP;AACD;;AAED,SAASM,+CAAT,CACEpL,OADF,EAEEC,cAFF,EAGEsL,eAHF,EAIEG,gBAJF,EAKEvL,WALF,EAME;AACA,QAAMqM,SAAS,GAAGvM,cAAc,CAACe,IAAjC;AACA,QAAMwK,iBAAiC,GAAG;AACxCxK,IAAAA,IAAI,EAAE,SADkC;AAExC+B,IAAAA,QAAQ,EAAEwI;AAF8B,GAA1C;AAIA,QAAMT,oBAAoB,GAAGW,iCAAiC,CAC5DD,iBAD4D,EAE5DgB,SAF4D,EAG5D7T,OAH4D,CAA9D;AAKA,QAAMwS,qBAAqB,GAAG/N,uBAAuB,CACnDsO,gBADmD,EAEnDc,SAFmD,EAGnDrM,WAHmD,EAInD,IAJmD,CAArD,CAXA,CAiBA;AACA;;AACAgL,EAAAA,qBAAqB,CAACjK,KAAtB,IAA+BrL,SAA/B;AAEAiV,EAAAA,oBAAoB,CAACnJ,MAArB,GAA8B1B,cAA9B;AACAkL,EAAAA,qBAAqB,CAACxJ,MAAtB,GAA+B1B,cAA/B;AACA6K,EAAAA,oBAAoB,CAACpD,OAArB,GAA+ByD,qBAA/B;AACAlL,EAAAA,cAAc,CAACG,KAAf,GAAuB0K,oBAAvB;;AAEA,MAAI,CAAC7K,cAAc,CAACe,IAAf,GAAsBzH,cAAvB,MAA2CC,MAA/C,EAAuD;AACrD;AACA;AACApB,IAAAA,oBAAoB,CAAC6H,cAAD,EAAiBD,OAAO,CAACI,KAAzB,EAAgC,IAAhC,EAAsCD,WAAtC,CAApB;AACD;;AAED,SAAOgL,qBAAP;AACD;;AAED,SAASX,gCAAT,CACEvK,cADF,EAEEwM,gBAFF,EAGEtM,WAHF,EAIgB;AACd;AACA;AACA,MAAI,CAACF,cAAc,CAACe,IAAf,GAAsBzH,cAAvB,MAA2CC,MAA/C,EAAuD;AACrD,QAAIsG,OAAJ,EAAa;AACX2G,MAAAA,OAAO,CAACX,KAAR,CACE,yDACE,0CADF,GAEE,mDAFF,GAGE,0DAHF,GAIE,iCALJ;AAOD;;AACD7F,IAAAA,cAAc,CAAC0C,KAAf,GAAuBzJ,WAAW,CAACN,QAAD,CAAlC;AACD,GAXD,MAWO,IAAIiB,0BAA0B,CAAC4S,gBAAD,CAA9B,EAAkD;AACvD;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACAxM,IAAAA,cAAc,CAAC0C,KAAf,GAAuBzJ,WAAW,CAACJ,oBAAD,CAAlC;AACD,GAdM,MAcA;AACL;AACA;AACAmH,IAAAA,cAAc,CAAC0C,KAAf,GAAuBzJ,WAAW,CAACL,aAAD,CAAlC;AACD;;AACD,SAAO,IAAP;AACD;;AAED,SAASoS,iCAAT,CACEjL,OADF,EAEEC,cAFF,EAGEwM,gBAHF,EAIEvC,aAJF,EAKE/J,WALF,EAMgB;AACd;AACA;AACAxD,EAAAA,eAAe;;AAEf,MAAI,CAACoB,mBAAmB,KAAKC,eAAzB,MAA8CC,SAAlD,EAA6D;AAC3D,WAAOiN,sCAAsC,CAC3ClL,OAD2C,EAE3CC,cAF2C,EAG3CE,WAH2C,CAA7C;AAKD;;AAED,MAAI,CAACF,cAAc,CAACe,IAAf,GAAsBzH,cAAvB,MAA2CC,MAA/C,EAAuD;AACrD,WAAO0R,sCAAsC,CAC3ClL,OAD2C,EAE3CC,cAF2C,EAG3CE,WAH2C,CAA7C;AAKD;;AAED,MAAItG,0BAA0B,CAAC4S,gBAAD,CAA9B,EAAkD;AAChD;AACA;AACA;AACA,WAAOvB,sCAAsC,CAC3ClL,OAD2C,EAE3CC,cAF2C,EAG3CE,WAH2C,CAA7C;AAKD;;AAED,MACEhJ,4BAA4B,IAC5B;AACA;AACA;AACA,GAACiI,gBALH,EAME;AACA;AACA;AACAlE,IAAAA,mCAAmC,CAAC8E,OAAD,EAAUC,cAAV,EAA0BE,WAA1B,CAAnC;AACD,GA1Ca,CA4Cd;AACA;;;AACA,QAAMrE,iBAAiB,GAAG7C,gBAAgB,CAACkH,WAAD,EAAcH,OAAO,CAACwD,UAAtB,CAA1C;;AACA,MAAIpE,gBAAgB,IAAItD,iBAAxB,EAA2C;AACzC;AACA;AACA,UAAM+K,IAAI,GAAGhJ,qBAAqB,EAAlC;;AACA,QAAIgJ,IAAI,KAAK,IAAb,EAAmB;AACjB,YAAM6F,sBAAsB,GAAGrT,yBAAyB,CACtDwN,IADsD,EAEtD1G,WAFsD,CAAxD;;AAIA,UACEuM,sBAAsB,KAAKhU,MAA3B,IACAgU,sBAAsB,KAAKxC,aAAa,CAACT,SAF3C,EAGE;AACA;AACA;AACA;AACAS,QAAAA,aAAa,CAACT,SAAd,GAA0BiD,sBAA1B,CAJA,CAKA;;AACA,cAAMC,SAAS,GAAG3T,WAAlB;AACA0E,QAAAA,qBAAqB,CAACsC,OAAD,EAAU0M,sBAAV,EAAkCC,SAAlC,CAArB;AACD,OAXD,MAWO,CACL;AACA;AACA;AACA;AACA;AACA;AACD;AACF,KA5BwC,CA8BzC;AACA;AACA;AACA;AACA;;;AACAhP,IAAAA,+BAA+B;AAC/B,WAAOuN,sCAAsC,CAC3ClL,OAD2C,EAE3CC,cAF2C,EAG3CE,WAH2C,CAA7C;AAKD,GAzCD,MAyCO,IAAIvG,yBAAyB,CAAC6S,gBAAD,CAA7B,EAAiD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAxM,IAAAA,cAAc,CAACiB,KAAf,IAAwBlL,UAAxB,CAVsD,CAWtD;;AACAiK,IAAAA,cAAc,CAACG,KAAf,GAAuBJ,OAAO,CAACI,KAA/B,CAZsD,CAatD;;AACA,UAAMwM,KAAK,GAAGnP,+BAA+B,CAACoP,IAAhC,CAAqC,IAArC,EAA2C7M,OAA3C,CAAd;AACAlG,IAAAA,6BAA6B,CAAC2S,gBAAD,EAAmBG,KAAnB,CAA7B;AACA,WAAO,IAAP;AACD,GAjBM,MAiBA;AACL;AACApQ,IAAAA,mDAAmD,CACjDyD,cADiD,EAEjDwM,gBAFiD,EAGjDvC,aAAa,CAACV,WAHmC,CAAnD;AAKA,UAAMhJ,SAAS,GAAGP,cAAc,CAAC6C,YAAjC;AACA,UAAMyI,eAAe,GAAG/K,SAAS,CAACuC,QAAlC;AACA,UAAM+H,oBAAoB,GAAGE,4BAA4B,CACvD/K,cADuD,EAEvDsL,eAFuD,EAGvDpL,WAHuD,CAAzD,CATK,CAcL;AACA;AACA;AACA;AACA;AACA;;AACA2K,IAAAA,oBAAoB,CAAC5J,KAArB,IAA8BpL,SAA9B;AACA,WAAOgV,oBAAP;AACD;AACF;;AAED,SAASgC,mBAAT,CAA6BC,KAA7B,EAA2C5M,WAA3C,EAA+D;AAC7D4M,EAAAA,KAAK,CAACpK,KAAN,GAAcvJ,UAAU,CAAC2T,KAAK,CAACpK,KAAP,EAAcxC,WAAd,CAAxB;AACA,QAAMiG,SAAS,GAAG2G,KAAK,CAAC3G,SAAxB;;AACA,MAAIA,SAAS,KAAK,IAAlB,EAAwB;AACtBA,IAAAA,SAAS,CAACzD,KAAV,GAAkBvJ,UAAU,CAACgN,SAAS,CAACzD,KAAX,EAAkBxC,WAAlB,CAA5B;AACD;;AACD5E,EAAAA,wBAAwB,CAACwR,KAAK,CAACpL,MAAP,EAAexB,WAAf,CAAxB;AACD;;AAED,SAAS6M,8BAAT,CACE/M,cADF,EAEEgN,UAFF,EAGE9M,WAHF,EAIQ;AACN;AACA;AACA;AACA,MAAIsH,IAAI,GAAGwF,UAAX;;AACA,SAAOxF,IAAI,KAAK,IAAhB,EAAsB;AACpB,QAAIA,IAAI,CAACjG,GAAL,KAAavM,iBAAjB,EAAoC;AAClC,YAAM0Q,KAA2B,GAAG8B,IAAI,CAACxE,aAAzC;;AACA,UAAI0C,KAAK,KAAK,IAAd,EAAoB;AAClBmH,QAAAA,mBAAmB,CAACrF,IAAD,EAAOtH,WAAP,CAAnB;AACD;AACF,KALD,MAKO,IAAIsH,IAAI,CAACjG,GAAL,KAAatM,qBAAjB,EAAwC;AAC7C;AACA;AACA;AACA;AACA;AACA4X,MAAAA,mBAAmB,CAACrF,IAAD,EAAOtH,WAAP,CAAnB;AACD,KAPM,MAOA,IAAIsH,IAAI,CAACrH,KAAL,KAAe,IAAnB,EAAyB;AAC9BqH,MAAAA,IAAI,CAACrH,KAAL,CAAWuB,MAAX,GAAoB8F,IAApB;AACAA,MAAAA,IAAI,GAAGA,IAAI,CAACrH,KAAZ;AACA;AACD;;AACD,QAAIqH,IAAI,KAAKxH,cAAb,EAA6B;AAC3B;AACD;;AACD,WAAOwH,IAAI,CAACC,OAAL,KAAiB,IAAxB,EAA8B;AAC5B,UAAID,IAAI,CAAC9F,MAAL,KAAgB,IAAhB,IAAwB8F,IAAI,CAAC9F,MAAL,KAAgB1B,cAA5C,EAA4D;AAC1D;AACD;;AACDwH,MAAAA,IAAI,GAAGA,IAAI,CAAC9F,MAAZ;AACD;;AACD8F,IAAAA,IAAI,CAACC,OAAL,CAAa/F,MAAb,GAAsB8F,IAAI,CAAC9F,MAA3B;AACA8F,IAAAA,IAAI,GAAGA,IAAI,CAACC,OAAZ;AACD;AACF;;AAED,SAASwF,kBAAT,CAA4BD,UAA5B,EAAoE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAIE,GAAG,GAAGF,UAAV;AACA,MAAIG,cAA4B,GAAG,IAAnC;;AACA,SAAOD,GAAG,KAAK,IAAf,EAAqB;AACnB,UAAME,UAAU,GAAGF,GAAG,CAAC/G,SAAvB,CADmB,CAEnB;;AACA,QAAIiH,UAAU,KAAK,IAAf,IAAuBtS,kBAAkB,CAACsS,UAAD,CAAlB,KAAmC,IAA9D,EAAoE;AAClED,MAAAA,cAAc,GAAGD,GAAjB;AACD;;AACDA,IAAAA,GAAG,GAAGA,GAAG,CAACzF,OAAV;AACD;;AACD,SAAO0F,cAAP;AACD;;AAID,SAASE,mBAAT,CAA6BC,WAA7B,EAAmE;AACjE,MAAIzN,OAAJ,EAAa;AACX,QACEyN,WAAW,KAAKjM,SAAhB,IACAiM,WAAW,KAAK,UADhB,IAEAA,WAAW,KAAK,WAFhB,IAGAA,WAAW,KAAK,UAHhB,IAIA,CAAC5N,uBAAuB,CAAC4N,WAAD,CAL1B,EAME;AACA5N,MAAAA,uBAAuB,CAAC4N,WAAD,CAAvB,GAAuC,IAAvC;;AACA,UAAI,OAAOA,WAAP,KAAuB,QAA3B,EAAqC;AACnC,gBAAQA,WAAW,CAACC,WAAZ,EAAR;AACE,eAAK,UAAL;AACA,eAAK,UAAL;AACA,eAAK,WAAL;AAAkB;AAChB/G,cAAAA,OAAO,CAACX,KAAR,CACE,oEACE,6BAFJ,EAGEyH,WAHF,EAIEA,WAAW,CAACC,WAAZ,EAJF;AAMA;AACD;;AACD,eAAK,SAAL;AACA,eAAK,UAAL;AAAiB;AACf/G,cAAAA,OAAO,CAACX,KAAR,CACE,oEACE,8DAFJ,EAGEyH,WAHF,EAIEA,WAAW,CAACC,WAAZ,EAJF;AAMA;AACD;;AACD;AACE/G,YAAAA,OAAO,CAACX,KAAR,CACE,8DACE,qDAFJ,EAGEyH,WAHF;AAKA;AA5BJ;AA8BD,OA/BD,MA+BO;AACL9G,QAAAA,OAAO,CAACX,KAAR,CACE,sEACE,qDAFJ,EAGEyH,WAHF;AAKD;AACF;AACF;AACF;;AAED,SAASE,mBAAT,CACEC,QADF,EAEEH,WAFF,EAGE;AACA,MAAIzN,OAAJ,EAAa;AACX,QAAI4N,QAAQ,KAAKpM,SAAb,IAA0B,CAAC1B,uBAAuB,CAAC8N,QAAD,CAAtD,EAAkE;AAChE,UAAIA,QAAQ,KAAK,WAAb,IAA4BA,QAAQ,KAAK,QAA7C,EAAuD;AACrD9N,QAAAA,uBAAuB,CAAC8N,QAAD,CAAvB,GAAoC,IAApC;AACAjH,QAAAA,OAAO,CAACX,KAAR,CACE,iEACE,uCAFJ,EAGE4H,QAHF;AAKD,OAPD,MAOO,IAAIH,WAAW,KAAK,UAAhB,IAA8BA,WAAW,KAAK,WAAlD,EAA+D;AACpE3N,QAAAA,uBAAuB,CAAC8N,QAAD,CAAvB,GAAoC,IAApC;AACAjH,QAAAA,OAAO,CAACX,KAAR,CACE,gEACE,6BADF,GAEE,iDAHJ,EAIE4H,QAJF;AAMD;AACF;AACF;AACF;;AAED,SAASC,+BAAT,CAAyCC,SAAzC,EAA2DC,KAA3D,EAA0E;AACxE,MAAI/N,OAAJ,EAAa;AACX,UAAMgO,SAAS,GAAGvW,OAAO,CAACqW,SAAD,CAAzB;AACA,UAAMG,UAAU,GACd,CAACD,SAAD,IAAc,OAAOjW,aAAa,CAAC+V,SAAD,CAApB,KAAoC,UADpD;;AAEA,QAAIE,SAAS,IAAIC,UAAjB,EAA6B;AAC3B,YAAMtN,IAAI,GAAGqN,SAAS,GAAG,OAAH,GAAa,UAAnC;AACArH,MAAAA,OAAO,CAACX,KAAR,CACE,uEACE,2DADF,GAEE,qCAFF,GAGE,wDAHF,GAIE,iBALJ,EAMErF,IANF,EAOEoN,KAPF,EAQEpN,IARF;AAUA,aAAO,KAAP;AACD;AACF;;AACD,SAAO,IAAP;AACD;;AAED,SAASuN,4BAAT,CACEjL,QADF,EAEEwK,WAFF,EAGE;AACA,MAAIzN,OAAJ,EAAa;AACX,QACE,CAACyN,WAAW,KAAK,UAAhB,IAA8BA,WAAW,KAAK,WAA/C,KACAxK,QAAQ,KAAKzB,SADb,IAEAyB,QAAQ,KAAK,IAFb,IAGAA,QAAQ,KAAK,KAJf,EAKE;AACA,UAAIxL,OAAO,CAACwL,QAAD,CAAX,EAAuB;AACrB,aAAK,IAAIsE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGtE,QAAQ,CAACuE,MAA7B,EAAqCD,CAAC,EAAtC,EAA0C;AACxC,cAAI,CAACsG,+BAA+B,CAAC5K,QAAQ,CAACsE,CAAD,CAAT,EAAcA,CAAd,CAApC,EAAsD;AACpD;AACD;AACF;AACF,OAND,MAMO;AACL,cAAM4G,UAAU,GAAGpW,aAAa,CAACkL,QAAD,CAAhC;;AACA,YAAI,OAAOkL,UAAP,KAAsB,UAA1B,EAAsC;AACpC,gBAAMC,gBAAgB,GAAGD,UAAU,CAACE,IAAX,CAAgBpL,QAAhB,CAAzB;;AACA,cAAImL,gBAAJ,EAAsB;AACpB,gBAAIE,IAAI,GAAGF,gBAAgB,CAACG,IAAjB,EAAX;AACA,gBAAIhH,CAAC,GAAG,CAAR;;AACA,mBAAO,CAAC+G,IAAI,CAACE,IAAb,EAAmBF,IAAI,GAAGF,gBAAgB,CAACG,IAAjB,EAA1B,EAAmD;AACjD,kBAAI,CAACV,+BAA+B,CAACS,IAAI,CAAC/F,KAAN,EAAahB,CAAb,CAApC,EAAqD;AACnD;AACD;;AACDA,cAAAA,CAAC;AACF;AACF;AACF,SAZD,MAYO;AACLZ,UAAAA,OAAO,CAACX,KAAR,CACE,qEACE,mDADF,GAEE,qDAHJ,EAIEyH,WAJF;AAMD;AACF;AACF;AACF;AACF;;AAED,SAASgB,2BAAT,CACEtO,cADF,EAEEuO,WAFF,EAGEC,IAHF,EAIErB,cAJF,EAKEM,QALF,EAMQ;AACN,QAAMgB,WAA2C,GAC/CzO,cAAc,CAACgD,aADjB;;AAEA,MAAIyL,WAAW,KAAK,IAApB,EAA0B;AACxBzO,IAAAA,cAAc,CAACgD,aAAf,GAAgC;AAC9BuL,MAAAA,WAAW,EAAEA,WADiB;AAE9BG,MAAAA,SAAS,EAAE,IAFmB;AAG9BC,MAAAA,kBAAkB,EAAE,CAHU;AAI9BC,MAAAA,IAAI,EAAEzB,cAJwB;AAK9BqB,MAAAA,IAAI,EAAEA,IALwB;AAM9Bf,MAAAA,QAAQ,EAAEA;AANoB,KAAhC;AAQD,GATD,MASO;AACL;AACAgB,IAAAA,WAAW,CAACF,WAAZ,GAA0BA,WAA1B;AACAE,IAAAA,WAAW,CAACC,SAAZ,GAAwB,IAAxB;AACAD,IAAAA,WAAW,CAACE,kBAAZ,GAAiC,CAAjC;AACAF,IAAAA,WAAW,CAACG,IAAZ,GAAmBzB,cAAnB;AACAsB,IAAAA,WAAW,CAACD,IAAZ,GAAmBA,IAAnB;AACAC,IAAAA,WAAW,CAAChB,QAAZ,GAAuBA,QAAvB;AACD;AACF,C,CAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASoB,2BAAT,CACE9O,OADF,EAEEC,cAFF,EAGEE,WAHF,EAIE;AACA,QAAMK,SAAS,GAAGP,cAAc,CAAC6C,YAAjC;AACA,QAAMyK,WAAoC,GAAG/M,SAAS,CAAC+M,WAAvD;AACA,QAAMG,QAA8B,GAAGlN,SAAS,CAACiO,IAAjD;AACA,QAAMM,WAAW,GAAGvO,SAAS,CAACuC,QAA9B;AAEAuK,EAAAA,mBAAmB,CAACC,WAAD,CAAnB;AACAE,EAAAA,mBAAmB,CAACC,QAAD,EAAWH,WAAX,CAAnB;AACAS,EAAAA,4BAA4B,CAACe,WAAD,EAAcxB,WAAd,CAA5B;AAEAxN,EAAAA,iBAAiB,CAACC,OAAD,EAAUC,cAAV,EAA0B8O,WAA1B,EAAuC5O,WAAvC,CAAjB;AAEA,MAAI8J,eAAgC,GAAG1P,mBAAmB,CAACyF,OAA3D;AAEA,QAAMgP,mBAAmB,GAAGrU,kBAAkB,CAC5CsP,eAD4C,EAE3CvP,qBAF2C,CAA9C;;AAIA,MAAIsU,mBAAJ,EAAyB;AACvB/E,IAAAA,eAAe,GAAGnP,yBAAyB,CACzCmP,eADyC,EAEzCvP,qBAFyC,CAA3C;AAIAuF,IAAAA,cAAc,CAACiB,KAAf,IAAwBlL,UAAxB;AACD,GAND,MAMO;AACL,UAAMiZ,gBAAgB,GACpBjP,OAAO,KAAK,IAAZ,IAAoB,CAACA,OAAO,CAACkB,KAAR,GAAgBlL,UAAjB,MAAiCL,OADvD;;AAEA,QAAIsZ,gBAAJ,EAAsB;AACpB;AACA;AACA;AACAjC,MAAAA,8BAA8B,CAC5B/M,cAD4B,EAE5BA,cAAc,CAACG,KAFa,EAG5BD,WAH4B,CAA9B;AAKD;;AACD8J,IAAAA,eAAe,GAAGrP,gCAAgC,CAACqP,eAAD,CAAlD;AACD;;AACDzP,EAAAA,mBAAmB,CAACyF,cAAD,EAAiBgK,eAAjB,CAAnB;;AAEA,MAAI,CAAChK,cAAc,CAACe,IAAf,GAAsBzH,cAAvB,MAA2CC,MAA/C,EAAuD;AACrD;AACA;AACAyG,IAAAA,cAAc,CAACgD,aAAf,GAA+B,IAA/B;AACD,GAJD,MAIO;AACL,YAAQsK,WAAR;AACE,WAAK,UAAL;AAAiB;AACf,gBAAMH,cAAc,GAAGF,kBAAkB,CAACjN,cAAc,CAACG,KAAhB,CAAzC;AACA,cAAIqO,IAAJ;;AACA,cAAIrB,cAAc,KAAK,IAAvB,EAA6B;AAC3B;AACA;AACAqB,YAAAA,IAAI,GAAGxO,cAAc,CAACG,KAAtB;AACAH,YAAAA,cAAc,CAACG,KAAf,GAAuB,IAAvB;AACD,WALD,MAKO;AACL;AACA;AACAqO,YAAAA,IAAI,GAAGrB,cAAc,CAAC1F,OAAtB;AACA0F,YAAAA,cAAc,CAAC1F,OAAf,GAAyB,IAAzB;AACD;;AACD6G,UAAAA,2BAA2B,CACzBtO,cADyB,EAEzB,KAFyB,EAElB;AACPwO,UAAAA,IAHyB,EAIzBrB,cAJyB,EAKzBM,QALyB,CAA3B;AAOA;AACD;;AACD,WAAK,WAAL;AAAkB;AAChB;AACA;AACA;AACA;AACA,cAAIe,IAAI,GAAG,IAAX;AACA,cAAItB,GAAG,GAAGlN,cAAc,CAACG,KAAzB;AACAH,UAAAA,cAAc,CAACG,KAAf,GAAuB,IAAvB;;AACA,iBAAO+M,GAAG,KAAK,IAAf,EAAqB;AACnB,kBAAME,UAAU,GAAGF,GAAG,CAAC/G,SAAvB,CADmB,CAEnB;;AACA,gBAAIiH,UAAU,KAAK,IAAf,IAAuBtS,kBAAkB,CAACsS,UAAD,CAAlB,KAAmC,IAA9D,EAAoE;AAClE;AACApN,cAAAA,cAAc,CAACG,KAAf,GAAuB+M,GAAvB;AACA;AACD;;AACD,kBAAM+B,OAAO,GAAG/B,GAAG,CAACzF,OAApB;AACAyF,YAAAA,GAAG,CAACzF,OAAJ,GAAc+G,IAAd;AACAA,YAAAA,IAAI,GAAGtB,GAAP;AACAA,YAAAA,GAAG,GAAG+B,OAAN;AACD,WApBe,CAqBhB;;;AACAX,UAAAA,2BAA2B,CACzBtO,cADyB,EAEzB,IAFyB,EAEnB;AACNwO,UAAAA,IAHyB,EAIzB,IAJyB,EAInB;AACNf,UAAAA,QALyB,CAA3B;AAOA;AACD;;AACD,WAAK,UAAL;AAAiB;AACfa,UAAAA,2BAA2B,CACzBtO,cADyB,EAEzB,KAFyB,EAElB;AACP,cAHyB,EAGnB;AACN,cAJyB,EAInB;AACNqB,UAAAA,SALyB,CAA3B;AAOA;AACD;;AACD;AAAS;AACP;AACA;AACArB,UAAAA,cAAc,CAACgD,aAAf,GAA+B,IAA/B;AACD;AArEH;AAuED;;AACD,SAAOhD,cAAc,CAACG,KAAtB;AACD;;AAED,SAAS+O,qBAAT,CACEnP,OADF,EAEEC,cAFF,EAGEE,WAHF,EAIE;AACA7F,EAAAA,iBAAiB,CAAC2F,cAAD,EAAiBA,cAAc,CAACgF,SAAf,CAAyB8B,aAA1C,CAAjB;AACA,QAAM7G,YAAY,GAAGD,cAAc,CAAC6C,YAApC;;AACA,MAAI9C,OAAO,KAAK,IAAhB,EAAsB;AACpB;AACA;AACA;AACA;AACA;AACAC,IAAAA,cAAc,CAACG,KAAf,GAAuBhI,oBAAoB,CACzC6H,cADyC,EAEzC,IAFyC,EAGzCC,YAHyC,EAIzCC,WAJyC,CAA3C;AAMD,GAZD,MAYO;AACLJ,IAAAA,iBAAiB,CAACC,OAAD,EAAUC,cAAV,EAA0BC,YAA1B,EAAwCC,WAAxC,CAAjB;AACD;;AACD,SAAOF,cAAc,CAACG,KAAtB;AACD;;AAED,IAAIgP,+CAA+C,GAAG,KAAtD;;AAEA,SAASC,qBAAT,CACErP,OADF,EAEEC,cAFF,EAGEE,WAHF,EAIE;AACA,QAAMmP,YAAoC,GAAGrP,cAAc,CAACQ,IAA5D;AACA,QAAM4E,OAA0B,GAAGiK,YAAY,CAACC,QAAhD;AAEA,QAAMC,QAAQ,GAAGvP,cAAc,CAAC6C,YAAhC;AACA,QAAM2M,QAAQ,GAAGxP,cAAc,CAAC+B,aAAhC;AAEA,QAAM0N,QAAQ,GAAGF,QAAQ,CAACnH,KAA1B;;AAEA,MAAIvI,OAAJ,EAAa;AACX,QAAI,EAAE,WAAW0P,QAAb,CAAJ,EAA4B;AAC1B,UAAI,CAACJ,+CAAL,EAAsD;AACpDA,QAAAA,+CAA+C,GAAG,IAAlD;AACA3I,QAAAA,OAAO,CAACX,KAAR,CACE,sGADF;AAGD;AACF;;AACD,UAAM6J,iBAAiB,GAAG1P,cAAc,CAACQ,IAAf,CAAoBG,SAA9C;;AAEA,QAAI+O,iBAAJ,EAAuB;AACrB1b,MAAAA,cAAc,CAAC0b,iBAAD,EAAoBH,QAApB,EAA8B,MAA9B,EAAsC,kBAAtC,CAAd;AACD;AACF;;AAEDxU,EAAAA,YAAY,CAACiF,cAAD,EAAiBoF,OAAjB,EAA0BqK,QAA1B,CAAZ;;AAEA,MAAIvY,4BAAJ,EAAkC,CAChC;AACA;AACA;AACA;AACD,GALD,MAKO;AACL,QAAIsY,QAAQ,KAAK,IAAjB,EAAuB;AACrB,YAAMG,QAAQ,GAAGH,QAAQ,CAACpH,KAA1B;;AACA,UAAIxJ,EAAE,CAAC+Q,QAAD,EAAWF,QAAX,CAAN,EAA4B;AAC1B;AACA,YACED,QAAQ,CAAC1M,QAAT,KAAsByM,QAAQ,CAACzM,QAA/B,IACA,CAAChH,uBAAuB,EAF1B,EAGE;AACA,iBAAOkF,4BAA4B,CACjCjB,OADiC,EAEjCC,cAFiC,EAGjCE,WAHiC,CAAnC;AAKD;AACF,OAZD,MAYO;AACL;AACA;AACAlF,QAAAA,sBAAsB,CAACgF,cAAD,EAAiBoF,OAAjB,EAA0BlF,WAA1B,CAAtB;AACD;AACF;AACF;;AAED,QAAM4O,WAAW,GAAGS,QAAQ,CAACzM,QAA7B;AACAhD,EAAAA,iBAAiB,CAACC,OAAD,EAAUC,cAAV,EAA0B8O,WAA1B,EAAuC5O,WAAvC,CAAjB;AACA,SAAOF,cAAc,CAACG,KAAtB;AACD;;AAED,IAAIyP,oCAAoC,GAAG,KAA3C;;AAEA,SAASC,qBAAT,CACE9P,OADF,EAEEC,cAFF,EAGEE,WAHF,EAIE;AACA,MAAIkF,OAA0B,GAAGpF,cAAc,CAACQ,IAAhD,CADA,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAIX,OAAJ,EAAa;AACX,QAAKuF,OAAD,CAAekK,QAAf,KAA4BjO,SAAhC,EAA2C;AACzC;AACA;AACA;AACA,UAAI+D,OAAO,KAAKA,OAAO,CAAC0K,QAAxB,EAAkC;AAChC,YAAI,CAACF,oCAAL,EAA2C;AACzCA,UAAAA,oCAAoC,GAAG,IAAvC;AACApJ,UAAAA,OAAO,CAACX,KAAR,CACE,0EACE,4EAFJ;AAID;AACF;AACF,KAbD,MAaO;AACLT,MAAAA,OAAO,GAAIA,OAAD,CAAekK,QAAzB;AACD;AACF;;AACD,QAAMC,QAAQ,GAAGvP,cAAc,CAAC6C,YAAhC;AACA,QAAMjC,MAAM,GAAG2O,QAAQ,CAACzM,QAAxB;;AAEA,MAAIjD,OAAJ,EAAa;AACX,QAAI,OAAOe,MAAP,KAAkB,UAAtB,EAAkC;AAChC4F,MAAAA,OAAO,CAACX,KAAR,CACE,wEACE,mEADF,GAEE,kEAFF,GAGE,iDAJJ;AAMD;AACF;;AAEDxK,EAAAA,oBAAoB,CAAC2E,cAAD,EAAiBE,WAAjB,CAApB;AACA,QAAMuP,QAAQ,GAAGrU,WAAW,CAACgK,OAAD,CAA5B;;AACA,MAAIhO,wBAAJ,EAA8B;AAC5BnD,IAAAA,0BAA0B,CAAC+L,cAAD,CAA1B;AACD;;AACD,MAAI8O,WAAJ;;AACA,MAAIjP,OAAJ,EAAa;AACXX,IAAAA,iBAAiB,CAACa,OAAlB,GAA4BC,cAA5B;AACAlI,IAAAA,cAAc,CAAC,IAAD,CAAd;AACAgX,IAAAA,WAAW,GAAGlO,MAAM,CAAC6O,QAAD,CAApB;AACA3X,IAAAA,cAAc,CAAC,KAAD,CAAd;AACD,GALD,MAKO;AACLgX,IAAAA,WAAW,GAAGlO,MAAM,CAAC6O,QAAD,CAApB;AACD;;AACD,MAAIrY,wBAAJ,EAA8B;AAC5BlD,IAAAA,0BAA0B;AAC3B,GAzDD,CA2DA;;;AACA8L,EAAAA,cAAc,CAACiB,KAAf,IAAwBtL,aAAxB;AACAmK,EAAAA,iBAAiB,CAACC,OAAD,EAAUC,cAAV,EAA0B8O,WAA1B,EAAuC5O,WAAvC,CAAjB;AACA,SAAOF,cAAc,CAACG,KAAtB;AACD;;AAED,SAAS4P,oBAAT,CAA8BhQ,OAA9B,EAAuCC,cAAvC,EAAuDE,WAAvD,EAAoE;AAClE,QAAMK,SAAS,GAAGP,cAAc,CAAC6C,YAAjC;AACA,QAAM5C,YAAY,GAAGM,SAAS,CAACuC,QAA/B;AAEAhD,EAAAA,iBAAiB,CAACC,OAAD,EAAUC,cAAV,EAA0BC,YAA1B,EAAwCC,WAAxC,CAAjB;AACA,SAAOF,cAAc,CAACG,KAAtB;AACD;;AAED,OAAO,SAAS6P,gCAAT,GAA4C;AACjD7Q,EAAAA,gBAAgB,GAAG,IAAnB;AACD;AAED,OAAO,SAAS8Q,mCAAT,GAA+C;AACpD,SAAO9Q,gBAAP;AACD;;AAED,SAAS6B,4BAAT,CACEjB,OADF,EAEEC,cAFF,EAGEE,WAHF,EAIgB;AACd,MAAIH,OAAO,KAAK,IAAhB,EAAsB;AACpB;AACAC,IAAAA,cAAc,CAACkQ,YAAf,GAA8BnQ,OAAO,CAACmQ,YAAtC;AACD;;AAED,MAAIrZ,mBAAJ,EAAyB;AACvB;AACA6E,IAAAA,0BAA0B,CAACsE,cAAD,CAA1B;AACD;;AAEDrC,EAAAA,sBAAsB,CAACqC,cAAc,CAAC0C,KAAhB,CAAtB,CAXc,CAad;;AACA,MAAI,CAAC1J,gBAAgB,CAACkH,WAAD,EAAcF,cAAc,CAACuD,UAA7B,CAArB,EAA+D;AAC7D;AACA;AACA;AAEA,QAAIrM,4BAA4B,IAAI6I,OAAO,KAAK,IAAhD,EAAsD;AACpD;AACA;AACA9E,MAAAA,mCAAmC,CAAC8E,OAAD,EAAUC,cAAV,EAA0BE,WAA1B,CAAnC;;AACA,UAAI,CAAClH,gBAAgB,CAACkH,WAAD,EAAcF,cAAc,CAACuD,UAA7B,CAArB,EAA+D;AAC7D,eAAO,IAAP;AACD;AACF,KAPD,MAOO;AACL,aAAO,IAAP;AACD;AACF,GA7Ba,CA+Bd;AACA;;;AACAnL,EAAAA,gBAAgB,CAAC2H,OAAD,EAAUC,cAAV,CAAhB;AACA,SAAOA,cAAc,CAACG,KAAtB;AACD;;AAED,SAASgQ,YAAT,CACEpQ,OADF,EAEEqQ,iBAFF,EAGEC,iBAHF,EAIgB;AACd,MAAIxQ,OAAJ,EAAa;AACX,UAAMyQ,WAAW,GAAGF,iBAAiB,CAAC1O,MAAtC;;AACA,QAAI4O,WAAW,KAAK,IAApB,EAA0B;AACxB;AACA,YAAM,IAAIxK,KAAJ,CAAU,6BAAV,CAAN;AACD,KALU,CAOX;AACA;;;AACA/F,IAAAA,OAAO,CAACoG,SAAR,GAAoB,IAApB;AACAiK,IAAAA,iBAAiB,CAACjK,SAAlB,GAA8B,IAA9B,CAVW,CAYX;;AACAkK,IAAAA,iBAAiB,CAACzC,KAAlB,GAA0BwC,iBAAiB,CAACxC,KAA5C;AACAyC,IAAAA,iBAAiB,CAAC5I,OAAlB,GAA4B2I,iBAAiB,CAAC3I,OAA9C;AACA4I,IAAAA,iBAAiB,CAAC3O,MAAlB,GAA2B0O,iBAAiB,CAAC1O,MAA7C;AACA2O,IAAAA,iBAAiB,CAACxP,GAAlB,GAAwBuP,iBAAiB,CAACvP,GAA1C,CAhBW,CAkBX;;AACA,QAAIuP,iBAAiB,KAAKE,WAAW,CAACnQ,KAAtC,EAA6C;AAC3CmQ,MAAAA,WAAW,CAACnQ,KAAZ,GAAoBkQ,iBAApB;AACD,KAFD,MAEO;AACL,UAAIE,WAAW,GAAGD,WAAW,CAACnQ,KAA9B;;AACA,UAAIoQ,WAAW,KAAK,IAApB,EAA0B;AACxB;AACA,cAAM,IAAIzK,KAAJ,CAAU,kCAAV,CAAN;AACD;;AACD,aAAOyK,WAAW,CAAC9I,OAAZ,KAAwB2I,iBAA/B,EAAkD;AAChDG,QAAAA,WAAW,GAAGA,WAAW,CAAC9I,OAA1B;;AACA,YAAI8I,WAAW,KAAK,IAApB,EAA0B;AACxB;AACA,gBAAM,IAAIzK,KAAJ,CAAU,wCAAV,CAAN;AACD;AACF;;AACDyK,MAAAA,WAAW,CAAC9I,OAAZ,GAAsB4I,iBAAtB;AACD,KAnCU,CAqCX;AACA;;;AACA,UAAMlE,SAAS,GAAGmE,WAAW,CAACnE,SAA9B;;AACA,QAAIA,SAAS,KAAK,IAAlB,EAAwB;AACtBmE,MAAAA,WAAW,CAACnE,SAAZ,GAAwB,CAACpM,OAAD,CAAxB;AACAuQ,MAAAA,WAAW,CAACrP,KAAZ,IAAqB9K,aAArB;AACD,KAHD,MAGO;AACLgW,MAAAA,SAAS,CAACC,IAAV,CAAerM,OAAf;AACD;;AAEDsQ,IAAAA,iBAAiB,CAACpP,KAAlB,IAA2BrL,SAA3B,CA/CW,CAiDX;;AACA,WAAOya,iBAAP;AACD,GAnDD,MAmDO;AACL,UAAM,IAAIvK,KAAJ,CACJ,6CACE,+CAFE,CAAN;AAID;AACF;;AAED,SAASjE,6BAAT,CACE9B,OADF,EAEEG,WAFF,EAGW;AACT;AACA;AACA,QAAMsQ,WAAW,GAAGzQ,OAAO,CAAC2C,KAA5B;;AACA,MAAI1J,gBAAgB,CAACwX,WAAD,EAActQ,WAAd,CAApB,EAAgD;AAC9C,WAAO,IAAP;AACD,GANQ,CAOT;AACA;;;AACA,MAAIhJ,4BAAJ,EAAkC;AAChC,UAAMgZ,YAAY,GAAGnQ,OAAO,CAACmQ,YAA7B;;AACA,QAAIA,YAAY,KAAK,IAAjB,IAAyB/U,qBAAqB,CAAC+U,YAAD,CAAlD,EAAkE;AAChE,aAAO,IAAP;AACD;AACF;;AACD,SAAO,KAAP;AACD;;AAED,SAASO,sCAAT,CACE1Q,OADF,EAEEC,cAFF,EAGEE,WAHF,EAIE;AACA;AACA;AACA;AACA,UAAQF,cAAc,CAACuB,GAAvB;AACE,SAAKjN,QAAL;AACEqS,MAAAA,mBAAmB,CAAC3G,cAAD,CAAnB;;AACA,UAAI/I,WAAJ,EAAiB;AACf,cAAM2P,IAAe,GAAG5G,cAAc,CAACgF,SAAvC;AACA,cAAMP,KAAY,GAAG1E,OAAO,CAACiD,aAAR,CAAsByB,KAA3C;AACAtG,QAAAA,iBAAiB,CAAC6B,cAAD,EAAiByE,KAAjB,CAAjB;AACArG,QAAAA,iBAAiB,CAACwI,IAAD,CAAjB;AACD;;AACDpK,MAAAA,mBAAmB;AACnB;;AACF,SAAKjI,aAAL;AACE6F,MAAAA,eAAe,CAAC4F,cAAD,CAAf;AACA;;AACF,SAAK3L,cAAL;AAAqB;AACnB,cAAMiM,SAAS,GAAGN,cAAc,CAACQ,IAAjC;;AACA,YAAItE,uBAAuB,CAACoE,SAAD,CAA3B,EAAwC;AACtCtE,UAAAA,yBAAyB,CAACgE,cAAD,CAAzB;AACD;;AACD;AACD;;AACD,SAAKvL,UAAL;AACE4F,MAAAA,iBAAiB,CAAC2F,cAAD,EAAiBA,cAAc,CAACgF,SAAf,CAAyB8B,aAA1C,CAAjB;AACA;;AACF,SAAKjS,eAAL;AAAsB;AACpB,cAAM4a,QAAQ,GAAGzP,cAAc,CAAC+B,aAAf,CAA6BqG,KAA9C;AACA,cAAMhD,OAA0B,GAAGpF,cAAc,CAACQ,IAAf,CAAoB8O,QAAvD;AACAvU,QAAAA,YAAY,CAACiF,cAAD,EAAiBoF,OAAjB,EAA0BqK,QAA1B,CAAZ;AACA;AACD;;AACD,SAAK1a,QAAL;AACE,UAAI8B,mBAAJ,EAAyB;AACvB;AACA,cAAM6Z,YAAY,GAAG1X,gBAAgB,CACnCkH,WADmC,EAEnCF,cAAc,CAACuD,UAFoB,CAArC;;AAIA,YAAImN,YAAJ,EAAkB;AAChB1Q,UAAAA,cAAc,CAACiB,KAAf,IAAwBjL,MAAxB;AACD;;AAED,YAAIY,yBAAJ,EAA+B;AAC7B;AACA;AACA,gBAAMoO,SAAS,GAAGhF,cAAc,CAACgF,SAAjC;AACAA,UAAAA,SAAS,CAACC,cAAV,GAA2B,CAA3B;AACAD,UAAAA,SAAS,CAACE,qBAAV,GAAkC,CAAlC;AACD;AACF;;AACD;;AACF,SAAKlQ,iBAAL;AAAwB;AACtB,cAAM0Q,KAA2B,GAAG1F,cAAc,CAACgD,aAAnD;;AACA,YAAI0C,KAAK,KAAK,IAAd,EAAoB;AAClB,cAAI5O,4BAAJ,EAAkC;AAChC,gBAAI4O,KAAK,CAAC4D,UAAN,KAAqB,IAAzB,EAA+B;AAC7B/O,cAAAA,mBAAmB,CACjByF,cADiB,EAEjBrF,gCAAgC,CAACL,mBAAmB,CAACyF,OAArB,CAFf,CAAnB,CAD6B,CAK7B;AACA;AACA;;AACAC,cAAAA,cAAc,CAACiB,KAAf,IAAwBlL,UAAxB,CAR6B,CAS7B;AACA;;AACA,qBAAO,IAAP;AACD;AACF,WAfiB,CAiBlB;AACA;AACA;AACA;;;AACA,gBAAM8U,oBAA2B,GAAI7K,cAAc,CAACG,KAApD;AACA,gBAAMwQ,iBAAiB,GAAG9F,oBAAoB,CAACtH,UAA/C;;AACA,cAAIvK,gBAAgB,CAACkH,WAAD,EAAcyQ,iBAAd,CAApB,EAAsD;AACpD;AACA;AACA,mBAAOxG,uBAAuB,CAACpK,OAAD,EAAUC,cAAV,EAA0BE,WAA1B,CAA9B;AACD,WAJD,MAIO;AACL;AACA;AACA3F,YAAAA,mBAAmB,CACjByF,cADiB,EAEjBrF,gCAAgC,CAACL,mBAAmB,CAACyF,OAArB,CAFf,CAAnB,CAHK,CAOL;AACA;;AACA,kBAAMI,KAAK,GAAGa,4BAA4B,CACxCjB,OADwC,EAExCC,cAFwC,EAGxCE,WAHwC,CAA1C;;AAKA,gBAAIC,KAAK,KAAK,IAAd,EAAoB;AAClB;AACA;AACA,qBAAOA,KAAK,CAACsH,OAAb;AACD,aAJD,MAIO;AACL;AACA;AACA;AACA,qBAAO,IAAP;AACD;AACF;AACF,SApDD,MAoDO;AACLlN,UAAAA,mBAAmB,CACjByF,cADiB,EAEjBrF,gCAAgC,CAACL,mBAAmB,CAACyF,OAArB,CAFf,CAAnB;AAID;;AACD;AACD;;AACD,SAAK9K,qBAAL;AAA4B;AAC1B,cAAM+Z,gBAAgB,GAAG,CAACjP,OAAO,CAACkB,KAAR,GAAgBlL,UAAjB,MAAiCL,OAA1D;AAEA,YAAIgb,YAAY,GAAG1X,gBAAgB,CACjCkH,WADiC,EAEjCF,cAAc,CAACuD,UAFkB,CAAnC;;AAKA,YAAIrM,4BAA4B,IAAI,CAACwZ,YAArC,EAAmD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACAzV,UAAAA,mCAAmC,CACjC8E,OADiC,EAEjCC,cAFiC,EAGjCE,WAHiC,CAAnC;AAKAwQ,UAAAA,YAAY,GAAG1X,gBAAgB,CAACkH,WAAD,EAAcF,cAAc,CAACuD,UAA7B,CAA/B;AACD;;AAED,YAAIyL,gBAAJ,EAAsB;AACpB,cAAI0B,YAAJ,EAAkB;AAChB;AACA;AACA;AACA;AACA;AACA,mBAAO7B,2BAA2B,CAChC9O,OADgC,EAEhCC,cAFgC,EAGhCE,WAHgC,CAAlC;AAKD,WAZmB,CAapB;AACA;AACA;;;AACAF,UAAAA,cAAc,CAACiB,KAAf,IAAwBlL,UAAxB;AACD,SAzCyB,CA2C1B;AACA;AACA;;;AACA,cAAM0Y,WAAW,GAAGzO,cAAc,CAACgD,aAAnC;;AACA,YAAIyL,WAAW,KAAK,IAApB,EAA0B;AACxB;AACA;AACAA,UAAAA,WAAW,CAACC,SAAZ,GAAwB,IAAxB;AACAD,UAAAA,WAAW,CAACD,IAAZ,GAAmB,IAAnB;AACAC,UAAAA,WAAW,CAACmC,UAAZ,GAAyB,IAAzB;AACD;;AACDrW,QAAAA,mBAAmB,CAACyF,cAAD,EAAiB1F,mBAAmB,CAACyF,OAArC,CAAnB;;AAEA,YAAI2Q,YAAJ,EAAkB;AAChB;AACD,SAFD,MAEO;AACL;AACA;AACA;AACA,iBAAO,IAAP;AACD;AACF;;AACD,SAAKnb,kBAAL;AACA,SAAKC,qBAAL;AAA4B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAwK,QAAAA,cAAc,CAAC0C,KAAf,GAAuBhK,OAAvB;AACA,eAAOkK,wBAAwB,CAAC7C,OAAD,EAAUC,cAAV,EAA0BE,WAA1B,CAA/B;AACD;;AACD,SAAKzK,cAAL;AAAqB;AACnB,YAAIwB,WAAJ,EAAiB;AACf,gBAAMwN,KAAY,GAAG1E,OAAO,CAACiD,aAAR,CAAsByB,KAA3C;AACAtG,UAAAA,iBAAiB,CAAC6B,cAAD,EAAiByE,KAAjB,CAAjB;AACD;;AACD;AACD;AApMH;;AAsMA,SAAOzD,4BAA4B,CAACjB,OAAD,EAAUC,cAAV,EAA0BE,WAA1B,CAAnC;AACD;;AAED,SAAS2Q,SAAT,CACE9Q,OADF,EAEEC,cAFF,EAGEE,WAHF,EAIgB;AACd,MAAIL,OAAJ,EAAa;AACX,QAAIG,cAAc,CAAC8Q,kBAAf,IAAqC/Q,OAAO,KAAK,IAArD,EAA2D;AACzD;AACA,aAAOoQ,YAAY,CACjBpQ,OADiB,EAEjBC,cAFiB,EAGjB9C,2BAA2B,CACzB8C,cAAc,CAACQ,IADU,EAEzBR,cAAc,CAAC+Q,GAFU,EAGzB/Q,cAAc,CAAC6C,YAHU,EAIzB7C,cAAc,CAACgR,WAAf,IAA8B,IAJL,EAKzBhR,cAAc,CAACe,IALU,EAMzBf,cAAc,CAAC0C,KANU,CAHV,CAAnB;AAYD;AACF;;AAED,MAAI3C,OAAO,KAAK,IAAhB,EAAsB;AACpB,UAAMyP,QAAQ,GAAGzP,OAAO,CAACgC,aAAzB;AACA,UAAMwN,QAAQ,GAAGvP,cAAc,CAAC6C,YAAhC;;AAEA,QACE2M,QAAQ,KAAKD,QAAb,IACAzT,uBAAuB,EADvB,MAEA;AACC+D,IAAAA,OAAO,GAAGG,cAAc,CAACQ,IAAf,KAAwBT,OAAO,CAACS,IAAnC,GAA0C,KAHlD,CADF,EAKE;AACA;AACA;AACArB,MAAAA,gBAAgB,GAAG,IAAnB;AACD,KATD,MASO;AACL;AACA;AACA,YAAMyC,2BAA2B,GAAGC,6BAA6B,CAC/D9B,OAD+D,EAE/DG,WAF+D,CAAjE;;AAIA,UACE,CAAC0B,2BAAD,IACA;AACA;AACA,OAAC5B,cAAc,CAACiB,KAAf,GAAuBlL,UAAxB,MAAwCL,OAJ1C,EAKE;AACA;AACAyJ,QAAAA,gBAAgB,GAAG,KAAnB;AACA,eAAOsR,sCAAsC,CAC3C1Q,OAD2C,EAE3CC,cAF2C,EAG3CE,WAH2C,CAA7C;AAKD;;AACD,UAAI,CAACH,OAAO,CAACkB,KAAR,GAAgB7K,4BAAjB,MAAmDV,OAAvD,EAAgE;AAC9D;AACA;AACAyJ,QAAAA,gBAAgB,GAAG,IAAnB;AACD,OAJD,MAIO;AACL;AACA;AACA;AACA;AACAA,QAAAA,gBAAgB,GAAG,KAAnB;AACD;AACF;AACF,GA9CD,MA8CO;AACLA,IAAAA,gBAAgB,GAAG,KAAnB;;AAEA,QAAI9C,cAAc,MAAM0C,aAAa,CAACiB,cAAD,CAArC,EAAuD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAMiR,SAAS,GAAGjR,cAAc,CAAC4N,KAAjC;AACA,YAAMsD,aAAa,GAAGpS,eAAe,CAACkB,cAAD,CAArC;AACAhB,MAAAA,UAAU,CAACgB,cAAD,EAAiBkR,aAAjB,EAAgCD,SAAhC,CAAV;AACD;AACF,GAlFa,CAoFd;AACA;AACA;AACA;AACA;;;AACAjR,EAAAA,cAAc,CAAC0C,KAAf,GAAuBhK,OAAvB;;AAEA,UAAQsH,cAAc,CAACuB,GAAvB;AACE,SAAKpN,sBAAL;AAA6B;AAC3B,eAAOgU,2BAA2B,CAChCpI,OADgC,EAEhCC,cAFgC,EAGhCA,cAAc,CAACQ,IAHiB,EAIhCN,WAJgC,CAAlC;AAMD;;AACD,SAAK9K,aAAL;AAAoB;AAClB,cAAMqL,WAAW,GAAGT,cAAc,CAACS,WAAnC;AACA,eAAOoH,kBAAkB,CACvB9H,OADuB,EAEvBC,cAFuB,EAGvBS,WAHuB,EAIvBP,WAJuB,CAAzB;AAMD;;AACD,SAAK9L,iBAAL;AAAwB;AACtB,cAAMkM,SAAS,GAAGN,cAAc,CAACQ,IAAjC;AACA,cAAM2Q,eAAe,GAAGnR,cAAc,CAAC6C,YAAvC;AACA,cAAMmF,aAAa,GACjBhI,cAAc,CAACS,WAAf,KAA+BH,SAA/B,GACI6Q,eADJ,GAEInU,mBAAmB,CAACsD,SAAD,EAAY6Q,eAAZ,CAHzB;AAIA,eAAOxO,uBAAuB,CAC5B5C,OAD4B,EAE5BC,cAF4B,EAG5BM,SAH4B,EAI5B0H,aAJ4B,EAK5B9H,WAL4B,CAA9B;AAOD;;AACD,SAAK7L,cAAL;AAAqB;AACnB,cAAMiM,SAAS,GAAGN,cAAc,CAACQ,IAAjC;AACA,cAAM2Q,eAAe,GAAGnR,cAAc,CAAC6C,YAAvC;AACA,cAAMmF,aAAa,GACjBhI,cAAc,CAACS,WAAf,KAA+BH,SAA/B,GACI6Q,eADJ,GAEInU,mBAAmB,CAACsD,SAAD,EAAY6Q,eAAZ,CAHzB;AAIA,eAAO7L,oBAAoB,CACzBvF,OADyB,EAEzBC,cAFyB,EAGzBM,SAHyB,EAIzB0H,aAJyB,EAKzB9H,WALyB,CAA3B;AAOD;;AACD,SAAK5L,QAAL;AACE,aAAOyS,cAAc,CAAChH,OAAD,EAAUC,cAAV,EAA0BE,WAA1B,CAArB;;AACF,SAAK3L,aAAL;AACE,aAAOmT,mBAAmB,CAAC3H,OAAD,EAAUC,cAAV,EAA0BE,WAA1B,CAA1B;;AACF,SAAK1L,QAAL;AACE,aAAOoT,cAAc,CAAC7H,OAAD,EAAUC,cAAV,CAArB;;AACF,SAAKhL,iBAAL;AACE,aAAOmV,uBAAuB,CAACpK,OAAD,EAAUC,cAAV,EAA0BE,WAA1B,CAA9B;;AACF,SAAKzL,UAAL;AACE,aAAOya,qBAAqB,CAACnP,OAAD,EAAUC,cAAV,EAA0BE,WAA1B,CAA5B;;AACF,SAAKxL,UAAL;AAAiB;AACf,cAAM8L,IAAI,GAAGR,cAAc,CAACQ,IAA5B;AACA,cAAM2Q,eAAe,GAAGnR,cAAc,CAAC6C,YAAvC;AACA,cAAMmF,aAAa,GACjBhI,cAAc,CAACS,WAAf,KAA+BD,IAA/B,GACI2Q,eADJ,GAEInU,mBAAmB,CAACwD,IAAD,EAAO2Q,eAAP,CAHzB;AAIA,eAAO9Q,gBAAgB,CACrBN,OADqB,EAErBC,cAFqB,EAGrBQ,IAHqB,EAIrBwH,aAJqB,EAKrB9H,WALqB,CAAvB;AAOD;;AACD,SAAKvL,QAAL;AACE,aAAOkQ,cAAc,CAAC9E,OAAD,EAAUC,cAAV,EAA0BE,WAA1B,CAArB;;AACF,SAAKtL,IAAL;AACE,aAAOkQ,UAAU,CAAC/E,OAAD,EAAUC,cAAV,EAA0BE,WAA1B,CAAjB;;AACF,SAAKnL,QAAL;AACE,aAAOgQ,cAAc,CAAChF,OAAD,EAAUC,cAAV,EAA0BE,WAA1B,CAArB;;AACF,SAAKrL,eAAL;AACE,aAAOua,qBAAqB,CAACrP,OAAD,EAAUC,cAAV,EAA0BE,WAA1B,CAA5B;;AACF,SAAKpL,eAAL;AACE,aAAO+a,qBAAqB,CAAC9P,OAAD,EAAUC,cAAV,EAA0BE,WAA1B,CAA5B;;AACF,SAAKhL,aAAL;AAAoB;AAClB,cAAMsL,IAAI,GAAGR,cAAc,CAACQ,IAA5B;AACA,cAAM2Q,eAAe,GAAGnR,cAAc,CAAC6C,YAAvC,CAFkB,CAGlB;;AACA,YAAImF,aAAa,GAAGhL,mBAAmB,CAACwD,IAAD,EAAO2Q,eAAP,CAAvC;;AACA,YAAItR,OAAJ,EAAa;AACX,cAAIG,cAAc,CAACQ,IAAf,KAAwBR,cAAc,CAACS,WAA3C,EAAwD;AACtD,kBAAMgC,cAAc,GAAGjC,IAAI,CAACG,SAA5B;;AACA,gBAAI8B,cAAJ,EAAoB;AAClBzO,cAAAA,cAAc,CACZyO,cADY,EAEZuF,aAFY,EAEG;AACf,oBAHY,EAIZvQ,wBAAwB,CAAC+I,IAAD,CAJZ,CAAd;AAMD;AACF;AACF;;AACDwH,QAAAA,aAAa,GAAGhL,mBAAmB,CAACwD,IAAI,CAACA,IAAN,EAAYwH,aAAZ,CAAnC;AACA,eAAO9G,mBAAmB,CACxBnB,OADwB,EAExBC,cAFwB,EAGxBQ,IAHwB,EAIxBwH,aAJwB,EAKxB9H,WALwB,CAA1B;AAOD;;AACD,SAAK/K,mBAAL;AAA0B;AACxB,eAAOsM,yBAAyB,CAC9B1B,OAD8B,EAE9BC,cAF8B,EAG9BA,cAAc,CAACQ,IAHe,EAI9BR,cAAc,CAAC6C,YAJe,EAK9B3C,WAL8B,CAAhC;AAOD;;AACD,SAAK7K,wBAAL;AAA+B;AAC7B,cAAMiL,SAAS,GAAGN,cAAc,CAACQ,IAAjC;AACA,cAAM2Q,eAAe,GAAGnR,cAAc,CAAC6C,YAAvC;AACA,cAAMmF,aAAa,GACjBhI,cAAc,CAACS,WAAf,KAA+BH,SAA/B,GACI6Q,eADJ,GAEInU,mBAAmB,CAACsD,SAAD,EAAY6Q,eAAZ,CAHzB;AAIA,eAAOjJ,6BAA6B,CAClCnI,OADkC,EAElCC,cAFkC,EAGlCM,SAHkC,EAIlC0H,aAJkC,EAKlC9H,WALkC,CAApC;AAOD;;AACD,SAAKjL,qBAAL;AAA4B;AAC1B,eAAO4Z,2BAA2B,CAAC9O,OAAD,EAAUC,cAAV,EAA0BE,WAA1B,CAAlC;AACD;;AACD,SAAK5K,cAAL;AAAqB;AACnB,YAAI0B,cAAJ,EAAoB;AAClB,iBAAO+Y,oBAAoB,CAAChQ,OAAD,EAAUC,cAAV,EAA0BE,WAA1B,CAA3B;AACD;;AACD;AACD;;AACD,SAAK3K,kBAAL;AAAyB;AACvB,eAAOqN,wBAAwB,CAAC7C,OAAD,EAAUC,cAAV,EAA0BE,WAA1B,CAA/B;AACD;;AACD,SAAK1K,qBAAL;AAA4B;AAC1B,eAAO2O,2BAA2B,CAACpE,OAAD,EAAUC,cAAV,EAA0BE,WAA1B,CAAlC;AACD;;AACD,SAAKzK,cAAL;AAAqB;AACnB,YAAIwB,WAAJ,EAAiB;AACf,iBAAOmN,oBAAoB,CAACrE,OAAD,EAAUC,cAAV,EAA0BE,WAA1B,CAA3B;AACD;;AACD;AACD;AA1JH;;AA6JA,QAAM,IAAI4F,KAAJ,CACH,6BAA4B9F,cAAc,CAACuB,GAAI,6CAAhD,GACE,8BAFE,CAAN;AAID;;AAED,SAAQsP,SAAR","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {ReactProviderType, ReactContext} from 'shared/ReactTypes';\nimport type {LazyComponent as LazyComponentType} from 'react/src/ReactLazy';\nimport type {Fiber, FiberRoot} from './ReactInternalTypes';\nimport type {TypeOfMode} from './ReactTypeOfMode';\nimport type {Lanes, Lane} from './ReactFiberLane.new';\nimport type {MutableSource} from 'shared/ReactTypes';\nimport type {\n  SuspenseState,\n  SuspenseListRenderState,\n  SuspenseListTailMode,\n} from './ReactFiberSuspenseComponent.new';\nimport type {SuspenseContext} from './ReactFiberSuspenseContext.new';\nimport type {\n  OffscreenProps,\n  OffscreenState,\n} from './ReactFiberOffscreenComponent';\nimport type {\n  Cache,\n  CacheComponentState,\n  SpawnedCachePool,\n} from './ReactFiberCacheComponent.new';\nimport type {UpdateQueue} from './ReactUpdateQueue.new';\n\nimport checkPropTypes from 'shared/checkPropTypes';\nimport {\n  markComponentRenderStarted,\n  markComponentRenderStopped,\n} from './SchedulingProfiler';\nimport {\n  IndeterminateComponent,\n  FunctionComponent,\n  ClassComponent,\n  HostRoot,\n  HostComponent,\n  HostText,\n  HostPortal,\n  ForwardRef,\n  Fragment,\n  Mode,\n  ContextProvider,\n  ContextConsumer,\n  Profiler,\n  SuspenseComponent,\n  SuspenseListComponent,\n  MemoComponent,\n  SimpleMemoComponent,\n  LazyComponent,\n  IncompleteClassComponent,\n  ScopeComponent,\n  OffscreenComponent,\n  LegacyHiddenComponent,\n  CacheComponent,\n} from './ReactWorkTags';\nimport {\n  NoFlags,\n  PerformedWork,\n  Placement,\n  Hydrating,\n  ContentReset,\n  DidCapture,\n  Update,\n  Ref,\n  RefStatic,\n  ChildDeletion,\n  ForceUpdateForLegacySuspense,\n  StaticMask,\n  ShouldCapture,\n  ForceClientRender,\n} from './ReactFiberFlags';\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nimport {\n  debugRenderPhaseSideEffectsForStrictMode,\n  disableLegacyContext,\n  disableModulePatternComponents,\n  enableProfilerCommitHooks,\n  enableProfilerTimer,\n  enableSuspenseServerRenderer,\n  warnAboutDefaultPropsOnFunctionComponents,\n  enableScopeAPI,\n  enableCache,\n  enableLazyContextPropagation,\n  enableSuspenseLayoutEffectSemantics,\n  enableSchedulingProfiler,\n  enablePersistentOffscreenHostContainer,\n} from 'shared/ReactFeatureFlags';\nimport isArray from 'shared/isArray';\nimport shallowEqual from 'shared/shallowEqual';\nimport getComponentNameFromFiber from 'react-reconciler/src/getComponentNameFromFiber';\nimport getComponentNameFromType from 'shared/getComponentNameFromType';\nimport ReactStrictModeWarnings from './ReactStrictModeWarnings.new';\nimport {REACT_LAZY_TYPE, getIteratorFn} from 'shared/ReactSymbols';\nimport {\n  getCurrentFiberOwnerNameInDevOrNull,\n  setIsRendering,\n} from './ReactCurrentFiber';\nimport {\n  resolveFunctionForHotReloading,\n  resolveForwardRefForHotReloading,\n  resolveClassForHotReloading,\n} from './ReactFiberHotReloading.new';\n\nimport {\n  mountChildFibers,\n  reconcileChildFibers,\n  cloneChildFibers,\n} from './ReactChildFiber.new';\nimport {\n  processUpdateQueue,\n  cloneUpdateQueue,\n  initializeUpdateQueue,\n  enqueueCapturedUpdate,\n} from './ReactUpdateQueue.new';\nimport {\n  NoLane,\n  NoLanes,\n  SyncLane,\n  OffscreenLane,\n  DefaultHydrationLane,\n  SomeRetryLane,\n  NoTimestamp,\n  includesSomeLane,\n  laneToLanes,\n  removeLanes,\n  mergeLanes,\n  getBumpedLaneForHydration,\n  pickArbitraryLane,\n} from './ReactFiberLane.new';\nimport {\n  ConcurrentMode,\n  NoMode,\n  ProfileMode,\n  StrictLegacyMode,\n} from './ReactTypeOfMode';\nimport {\n  shouldSetTextContent,\n  isSuspenseInstancePending,\n  isSuspenseInstanceFallback,\n  registerSuspenseInstanceRetry,\n  supportsHydration,\n  isPrimaryRenderer,\n  supportsPersistence,\n  getOffscreenContainerProps,\n} from './ReactFiberHostConfig';\nimport type {SuspenseInstance} from './ReactFiberHostConfig';\nimport {shouldError, shouldSuspend} from './ReactFiberReconciler';\nimport {pushHostContext, pushHostContainer} from './ReactFiberHostContext.new';\nimport {\n  suspenseStackCursor,\n  pushSuspenseContext,\n  InvisibleParentSuspenseContext,\n  ForceSuspenseFallback,\n  hasSuspenseContext,\n  setDefaultShallowSuspenseContext,\n  addSubtreeSuspenseContext,\n  setShallowSuspenseContext,\n} from './ReactFiberSuspenseContext.new';\nimport {findFirstSuspended} from './ReactFiberSuspenseComponent.new';\nimport {\n  pushProvider,\n  propagateContextChange,\n  lazilyPropagateParentContextChanges,\n  propagateParentContextChangesToDeferredTree,\n  checkIfContextChanged,\n  readContext,\n  prepareToReadContext,\n  scheduleWorkOnParentPath,\n} from './ReactFiberNewContext.new';\nimport {\n  renderWithHooks,\n  checkDidRenderIdHook,\n  bailoutHooks,\n} from './ReactFiberHooks.new';\nimport {stopProfilerTimerIfRunning} from './ReactProfilerTimer.new';\nimport {\n  getMaskedContext,\n  getUnmaskedContext,\n  hasContextChanged as hasLegacyContextChanged,\n  pushContextProvider as pushLegacyContextProvider,\n  isContextProvider as isLegacyContextProvider,\n  pushTopLevelContextObject,\n  invalidateContextProvider,\n} from './ReactFiberContext.new';\nimport {\n  getIsHydrating,\n  enterHydrationState,\n  reenterHydrationStateFromDehydratedSuspenseInstance,\n  resetHydrationState,\n  tryToClaimNextHydratableInstance,\n  warnIfHydrating,\n} from './ReactFiberHydrationContext.new';\nimport {\n  adoptClassInstance,\n  constructClassInstance,\n  mountClassInstance,\n  resumeMountClassInstance,\n  updateClassInstance,\n} from './ReactFiberClassComponent.new';\nimport {resolveDefaultProps} from './ReactFiberLazyComponent.new';\nimport {\n  resolveLazyComponentTag,\n  createFiberFromTypeAndProps,\n  createFiberFromFragment,\n  createFiberFromOffscreen,\n  createWorkInProgress,\n  createOffscreenHostContainerFiber,\n  isSimpleFunctionComponent,\n} from './ReactFiber.new';\nimport {\n  retryDehydratedSuspenseBoundary,\n  scheduleUpdateOnFiber,\n  renderDidSuspendDelayIfPossible,\n  markSkippedUpdateLanes,\n  getWorkInProgressRoot,\n  pushRenderLanes,\n  getExecutionContext,\n  RetryAfterError,\n  NoContext,\n} from './ReactFiberWorkLoop.new';\nimport {setWorkInProgressVersion} from './ReactMutableSource.new';\nimport {\n  requestCacheFromPool,\n  pushCacheProvider,\n  pushRootCachePool,\n  CacheContext,\n  getSuspendedCachePool,\n  restoreSpawnedCachePool,\n  getOffscreenDeferredCachePool,\n} from './ReactFiberCacheComponent.new';\nimport {createCapturedValue} from './ReactCapturedValue';\nimport {createClassErrorUpdate} from './ReactFiberThrow.new';\nimport {completeSuspendedOffscreenHostContainer} from './ReactFiberCompleteWork.new';\nimport is from 'shared/objectIs';\nimport {setIsStrictModeForDevtools} from './ReactFiberDevToolsHook.new';\nimport {\n  getForksAtLevel,\n  isForkedChild,\n  pushTreeId,\n  pushMaterializedTreeId,\n} from './ReactFiberTreeContext.new';\n\nconst ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\n\nlet didReceiveUpdate: boolean = false;\n\nlet didWarnAboutBadClass;\nlet didWarnAboutModulePatternComponent;\nlet didWarnAboutContextTypeOnFunctionComponent;\nlet didWarnAboutGetDerivedStateOnFunctionComponent;\nlet didWarnAboutFunctionRefs;\nexport let didWarnAboutReassigningProps;\nlet didWarnAboutRevealOrder;\nlet didWarnAboutTailOptions;\nlet didWarnAboutDefaultPropsOnFunctionComponent;\n\nif (__DEV__) {\n  didWarnAboutBadClass = {};\n  didWarnAboutModulePatternComponent = {};\n  didWarnAboutContextTypeOnFunctionComponent = {};\n  didWarnAboutGetDerivedStateOnFunctionComponent = {};\n  didWarnAboutFunctionRefs = {};\n  didWarnAboutReassigningProps = false;\n  didWarnAboutRevealOrder = {};\n  didWarnAboutTailOptions = {};\n  didWarnAboutDefaultPropsOnFunctionComponent = {};\n}\n\nexport function reconcileChildren(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  nextChildren: any,\n  renderLanes: Lanes,\n) {\n  if (current === null) {\n    // If this is a fresh new component that hasn't been rendered yet, we\n    // won't update its child set by applying minimal side-effects. Instead,\n    // we will add them all to the child before it gets rendered. That means\n    // we can optimize this reconciliation pass by not tracking side-effects.\n    workInProgress.child = mountChildFibers(\n      workInProgress,\n      null,\n      nextChildren,\n      renderLanes,\n    );\n  } else {\n    // If the current child is the same as the work in progress, it means that\n    // we haven't yet started any work on these children. Therefore, we use\n    // the clone algorithm to create a copy of all the current children.\n\n    // If we had any progressed work already, that is invalid at this point so\n    // let's throw it out.\n    workInProgress.child = reconcileChildFibers(\n      workInProgress,\n      current.child,\n      nextChildren,\n      renderLanes,\n    );\n  }\n}\n\nfunction forceUnmountCurrentAndReconcile(\n  current: Fiber,\n  workInProgress: Fiber,\n  nextChildren: any,\n  renderLanes: Lanes,\n) {\n  // This function is fork of reconcileChildren. It's used in cases where we\n  // want to reconcile without matching against the existing set. This has the\n  // effect of all current children being unmounted; even if the type and key\n  // are the same, the old child is unmounted and a new child is created.\n  //\n  // To do this, we're going to go through the reconcile algorithm twice. In\n  // the first pass, we schedule a deletion for all the current children by\n  // passing null.\n  workInProgress.child = reconcileChildFibers(\n    workInProgress,\n    current.child,\n    null,\n    renderLanes,\n  );\n  // In the second pass, we mount the new children. The trick here is that we\n  // pass null in place of where we usually pass the current child set. This has\n  // the effect of remounting all children regardless of whether their\n  // identities match.\n  workInProgress.child = reconcileChildFibers(\n    workInProgress,\n    null,\n    nextChildren,\n    renderLanes,\n  );\n}\n\nfunction updateForwardRef(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  Component: any,\n  nextProps: any,\n  renderLanes: Lanes,\n) {\n  // TODO: current can be non-null here even if the component\n  // hasn't yet mounted. This happens after the first render suspends.\n  // We'll need to figure out if this is fine or can cause issues.\n\n  if (__DEV__) {\n    if (workInProgress.type !== workInProgress.elementType) {\n      // Lazy component props can't be validated in createElement\n      // because they're only guaranteed to be resolved here.\n      const innerPropTypes = Component.propTypes;\n      if (innerPropTypes) {\n        checkPropTypes(\n          innerPropTypes,\n          nextProps, // Resolved props\n          'prop',\n          getComponentNameFromType(Component),\n        );\n      }\n    }\n  }\n\n  const render = Component.render;\n  const ref = workInProgress.ref;\n\n  // The rest is a fork of updateFunctionComponent\n  let nextChildren;\n  let hasId;\n  prepareToReadContext(workInProgress, renderLanes);\n  if (enableSchedulingProfiler) {\n    markComponentRenderStarted(workInProgress);\n  }\n  if (__DEV__) {\n    ReactCurrentOwner.current = workInProgress;\n    setIsRendering(true);\n    nextChildren = renderWithHooks(\n      current,\n      workInProgress,\n      render,\n      nextProps,\n      ref,\n      renderLanes,\n    );\n    hasId = checkDidRenderIdHook();\n    if (\n      debugRenderPhaseSideEffectsForStrictMode &&\n      workInProgress.mode & StrictLegacyMode\n    ) {\n      setIsStrictModeForDevtools(true);\n      try {\n        nextChildren = renderWithHooks(\n          current,\n          workInProgress,\n          render,\n          nextProps,\n          ref,\n          renderLanes,\n        );\n        hasId = checkDidRenderIdHook();\n      } finally {\n        setIsStrictModeForDevtools(false);\n      }\n    }\n    setIsRendering(false);\n  } else {\n    nextChildren = renderWithHooks(\n      current,\n      workInProgress,\n      render,\n      nextProps,\n      ref,\n      renderLanes,\n    );\n    hasId = checkDidRenderIdHook();\n  }\n  if (enableSchedulingProfiler) {\n    markComponentRenderStopped();\n  }\n\n  if (current !== null && !didReceiveUpdate) {\n    bailoutHooks(current, workInProgress, renderLanes);\n    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n  }\n\n  if (getIsHydrating() && hasId) {\n    pushMaterializedTreeId(workInProgress);\n  }\n\n  // React DevTools reads this flag.\n  workInProgress.flags |= PerformedWork;\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\nfunction updateMemoComponent(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  Component: any,\n  nextProps: any,\n  renderLanes: Lanes,\n): null | Fiber {\n  if (current === null) {\n    const type = Component.type;\n    if (\n      isSimpleFunctionComponent(type) &&\n      Component.compare === null &&\n      // SimpleMemoComponent codepath doesn't resolve outer props either.\n      Component.defaultProps === undefined\n    ) {\n      let resolvedType = type;\n      if (__DEV__) {\n        resolvedType = resolveFunctionForHotReloading(type);\n      }\n      // If this is a plain function component without default props,\n      // and with only the default shallow comparison, we upgrade it\n      // to a SimpleMemoComponent to allow fast path updates.\n      workInProgress.tag = SimpleMemoComponent;\n      workInProgress.type = resolvedType;\n      if (__DEV__) {\n        validateFunctionComponentInDev(workInProgress, type);\n      }\n      return updateSimpleMemoComponent(\n        current,\n        workInProgress,\n        resolvedType,\n        nextProps,\n        renderLanes,\n      );\n    }\n    if (__DEV__) {\n      const innerPropTypes = type.propTypes;\n      if (innerPropTypes) {\n        // Inner memo component props aren't currently validated in createElement.\n        // We could move it there, but we'd still need this for lazy code path.\n        checkPropTypes(\n          innerPropTypes,\n          nextProps, // Resolved props\n          'prop',\n          getComponentNameFromType(type),\n        );\n      }\n    }\n    const child = createFiberFromTypeAndProps(\n      Component.type,\n      null,\n      nextProps,\n      workInProgress,\n      workInProgress.mode,\n      renderLanes,\n    );\n    child.ref = workInProgress.ref;\n    child.return = workInProgress;\n    workInProgress.child = child;\n    return child;\n  }\n  if (__DEV__) {\n    const type = Component.type;\n    const innerPropTypes = type.propTypes;\n    if (innerPropTypes) {\n      // Inner memo component props aren't currently validated in createElement.\n      // We could move it there, but we'd still need this for lazy code path.\n      checkPropTypes(\n        innerPropTypes,\n        nextProps, // Resolved props\n        'prop',\n        getComponentNameFromType(type),\n      );\n    }\n  }\n  const currentChild = ((current.child: any): Fiber); // This is always exactly one child\n  const hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(\n    current,\n    renderLanes,\n  );\n  if (!hasScheduledUpdateOrContext) {\n    // This will be the props with resolved defaultProps,\n    // unlike current.memoizedProps which will be the unresolved ones.\n    const prevProps = currentChild.memoizedProps;\n    // Default to shallow comparison\n    let compare = Component.compare;\n    compare = compare !== null ? compare : shallowEqual;\n    if (compare(prevProps, nextProps) && current.ref === workInProgress.ref) {\n      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n    }\n  }\n  // React DevTools reads this flag.\n  workInProgress.flags |= PerformedWork;\n  const newChild = createWorkInProgress(currentChild, nextProps);\n  newChild.ref = workInProgress.ref;\n  newChild.return = workInProgress;\n  workInProgress.child = newChild;\n  return newChild;\n}\n\nfunction updateSimpleMemoComponent(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  Component: any,\n  nextProps: any,\n  renderLanes: Lanes,\n): null | Fiber {\n  // TODO: current can be non-null here even if the component\n  // hasn't yet mounted. This happens when the inner render suspends.\n  // We'll need to figure out if this is fine or can cause issues.\n\n  if (__DEV__) {\n    if (workInProgress.type !== workInProgress.elementType) {\n      // Lazy component props can't be validated in createElement\n      // because they're only guaranteed to be resolved here.\n      let outerMemoType = workInProgress.elementType;\n      if (outerMemoType.$$typeof === REACT_LAZY_TYPE) {\n        // We warn when you define propTypes on lazy()\n        // so let's just skip over it to find memo() outer wrapper.\n        // Inner props for memo are validated later.\n        const lazyComponent: LazyComponentType<any, any> = outerMemoType;\n        const payload = lazyComponent._payload;\n        const init = lazyComponent._init;\n        try {\n          outerMemoType = init(payload);\n        } catch (x) {\n          outerMemoType = null;\n        }\n        // Inner propTypes will be validated in the function component path.\n        const outerPropTypes = outerMemoType && (outerMemoType: any).propTypes;\n        if (outerPropTypes) {\n          checkPropTypes(\n            outerPropTypes,\n            nextProps, // Resolved (SimpleMemoComponent has no defaultProps)\n            'prop',\n            getComponentNameFromType(outerMemoType),\n          );\n        }\n      }\n    }\n  }\n  if (current !== null) {\n    const prevProps = current.memoizedProps;\n    if (\n      shallowEqual(prevProps, nextProps) &&\n      current.ref === workInProgress.ref &&\n      // Prevent bailout if the implementation changed due to hot reload.\n      (__DEV__ ? workInProgress.type === current.type : true)\n    ) {\n      didReceiveUpdate = false;\n      if (!checkScheduledUpdateOrContext(current, renderLanes)) {\n        // The pending lanes were cleared at the beginning of beginWork. We're\n        // about to bail out, but there might be other lanes that weren't\n        // included in the current render. Usually, the priority level of the\n        // remaining updates is accumulated during the evaluation of the\n        // component (i.e. when processing the update queue). But since since\n        // we're bailing out early *without* evaluating the component, we need\n        // to account for it here, too. Reset to the value of the current fiber.\n        // NOTE: This only applies to SimpleMemoComponent, not MemoComponent,\n        // because a MemoComponent fiber does not have hooks or an update queue;\n        // rather, it wraps around an inner component, which may or may not\n        // contains hooks.\n        // TODO: Move the reset at in beginWork out of the common path so that\n        // this is no longer necessary.\n        workInProgress.lanes = current.lanes;\n        return bailoutOnAlreadyFinishedWork(\n          current,\n          workInProgress,\n          renderLanes,\n        );\n      } else if ((current.flags & ForceUpdateForLegacySuspense) !== NoFlags) {\n        // This is a special case that only exists for legacy mode.\n        // See https://github.com/facebook/react/pull/19216.\n        didReceiveUpdate = true;\n      }\n    }\n  }\n  return updateFunctionComponent(\n    current,\n    workInProgress,\n    Component,\n    nextProps,\n    renderLanes,\n  );\n}\n\nfunction updateOffscreenComponent(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderLanes: Lanes,\n) {\n  const nextProps: OffscreenProps = workInProgress.pendingProps;\n  const nextChildren = nextProps.children;\n\n  const prevState: OffscreenState | null =\n    current !== null ? current.memoizedState : null;\n\n  // If this is not null, this is a cache pool that was carried over from the\n  // previous render. We will push this to the cache pool context so that we can\n  // resume in-flight requests.\n  let spawnedCachePool: SpawnedCachePool | null = null;\n\n  if (\n    nextProps.mode === 'hidden' ||\n    nextProps.mode === 'unstable-defer-without-hiding'\n  ) {\n    // Rendering a hidden tree.\n    if ((workInProgress.mode & ConcurrentMode) === NoMode) {\n      // In legacy sync mode, don't defer the subtree. Render it now.\n      const nextState: OffscreenState = {\n        baseLanes: NoLanes,\n        cachePool: null,\n      };\n      workInProgress.memoizedState = nextState;\n      pushRenderLanes(workInProgress, renderLanes);\n    } else if (!includesSomeLane(renderLanes, (OffscreenLane: Lane))) {\n      // We're hidden, and we're not rendering at Offscreen. We will bail out\n      // and resume this tree later.\n      let nextBaseLanes;\n      if (prevState !== null) {\n        const prevBaseLanes = prevState.baseLanes;\n        nextBaseLanes = mergeLanes(prevBaseLanes, renderLanes);\n        if (enableCache) {\n          // Save the cache pool so we can resume later.\n          spawnedCachePool = getOffscreenDeferredCachePool();\n          // We don't need to push to the cache pool because we're about to\n          // bail out. There won't be a context mismatch because we only pop\n          // the cache pool if `updateQueue` is non-null.\n        }\n      } else {\n        nextBaseLanes = renderLanes;\n      }\n\n      // Schedule this fiber to re-render at offscreen priority. Then bailout.\n      workInProgress.lanes = workInProgress.childLanes = laneToLanes(\n        OffscreenLane,\n      );\n      const nextState: OffscreenState = {\n        baseLanes: nextBaseLanes,\n        cachePool: spawnedCachePool,\n      };\n      workInProgress.memoizedState = nextState;\n      workInProgress.updateQueue = null;\n      // We're about to bail out, but we need to push this to the stack anyway\n      // to avoid a push/pop misalignment.\n      pushRenderLanes(workInProgress, nextBaseLanes);\n\n      if (enableLazyContextPropagation && current !== null) {\n        // Since this tree will resume rendering in a separate render, we need\n        // to propagate parent contexts now so we don't lose track of which\n        // ones changed.\n        propagateParentContextChangesToDeferredTree(\n          current,\n          workInProgress,\n          renderLanes,\n        );\n      }\n\n      return null;\n    } else {\n      // This is the second render. The surrounding visible content has already\n      // committed. Now we resume rendering the hidden tree.\n\n      if (enableCache && prevState !== null) {\n        // If the render that spawned this one accessed the cache pool, resume\n        // using the same cache. Unless the parent changed, since that means\n        // there was a refresh.\n        const prevCachePool = prevState.cachePool;\n        if (prevCachePool !== null) {\n          spawnedCachePool = restoreSpawnedCachePool(\n            workInProgress,\n            prevCachePool,\n          );\n        }\n      }\n\n      // Rendering at offscreen, so we can clear the base lanes.\n      const nextState: OffscreenState = {\n        baseLanes: NoLanes,\n        cachePool: null,\n      };\n      workInProgress.memoizedState = nextState;\n      // Push the lanes that were skipped when we bailed out.\n      const subtreeRenderLanes =\n        prevState !== null ? prevState.baseLanes : renderLanes;\n      pushRenderLanes(workInProgress, subtreeRenderLanes);\n    }\n  } else {\n    // Rendering a visible tree.\n    let subtreeRenderLanes;\n    if (prevState !== null) {\n      // We're going from hidden -> visible.\n\n      subtreeRenderLanes = mergeLanes(prevState.baseLanes, renderLanes);\n\n      if (enableCache) {\n        // If the render that spawned this one accessed the cache pool, resume\n        // using the same cache. Unless the parent changed, since that means\n        // there was a refresh.\n        const prevCachePool = prevState.cachePool;\n        if (prevCachePool !== null) {\n          spawnedCachePool = restoreSpawnedCachePool(\n            workInProgress,\n            prevCachePool,\n          );\n        }\n      }\n\n      // Since we're not hidden anymore, reset the state\n      workInProgress.memoizedState = null;\n    } else {\n      // We weren't previously hidden, and we still aren't, so there's nothing\n      // special to do. Need to push to the stack regardless, though, to avoid\n      // a push/pop misalignment.\n      subtreeRenderLanes = renderLanes;\n    }\n    pushRenderLanes(workInProgress, subtreeRenderLanes);\n  }\n\n  if (enableCache) {\n    // If we have a cache pool from a previous render attempt, then this will be\n    // non-null. We use this to infer whether to push/pop the cache context.\n    workInProgress.updateQueue = spawnedCachePool;\n  }\n\n  if (enablePersistentOffscreenHostContainer && supportsPersistence) {\n    // In persistent mode, the offscreen children are wrapped in a host node.\n    // TODO: Optimize this to use the OffscreenComponent fiber instead of\n    // an extra HostComponent fiber. Need to make sure this doesn't break Fabric\n    // or some other infra that expects a HostComponent.\n    const isHidden =\n      nextProps.mode === 'hidden' &&\n      workInProgress.tag !== LegacyHiddenComponent;\n    const offscreenContainer = reconcileOffscreenHostContainer(\n      current,\n      workInProgress,\n      isHidden,\n      nextChildren,\n      renderLanes,\n    );\n    return offscreenContainer;\n  } else {\n    reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n    return workInProgress.child;\n  }\n}\n\nfunction reconcileOffscreenHostContainer(\n  currentOffscreen: Fiber | null,\n  offscreen: Fiber,\n  isHidden: boolean,\n  children: any,\n  renderLanes: Lanes,\n) {\n  const containerProps = getOffscreenContainerProps(\n    isHidden ? 'hidden' : 'visible',\n    children,\n  );\n  let hostContainer;\n  if (currentOffscreen === null) {\n    hostContainer = createOffscreenHostContainerFiber(\n      containerProps,\n      offscreen.mode,\n      renderLanes,\n      null,\n    );\n  } else {\n    const currentHostContainer = currentOffscreen.child;\n    if (currentHostContainer === null) {\n      hostContainer = createOffscreenHostContainerFiber(\n        containerProps,\n        offscreen.mode,\n        renderLanes,\n        null,\n      );\n      hostContainer.flags |= Placement;\n    } else {\n      hostContainer = createWorkInProgress(\n        currentHostContainer,\n        containerProps,\n      );\n    }\n  }\n  hostContainer.return = offscreen;\n  offscreen.child = hostContainer;\n  return hostContainer;\n}\n\n// Note: These happen to have identical begin phases, for now. We shouldn't hold\n// ourselves to this constraint, though. If the behavior diverges, we should\n// fork the function.\nconst updateLegacyHiddenComponent = updateOffscreenComponent;\n\nfunction updateCacheComponent(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderLanes: Lanes,\n) {\n  if (!enableCache) {\n    return null;\n  }\n\n  prepareToReadContext(workInProgress, renderLanes);\n  const parentCache = readContext(CacheContext);\n\n  if (current === null) {\n    // Initial mount. Request a fresh cache from the pool.\n    const freshCache = requestCacheFromPool(renderLanes);\n    const initialState: CacheComponentState = {\n      parent: parentCache,\n      cache: freshCache,\n    };\n    workInProgress.memoizedState = initialState;\n    initializeUpdateQueue(workInProgress);\n    pushCacheProvider(workInProgress, freshCache);\n  } else {\n    // Check for updates\n    if (includesSomeLane(current.lanes, renderLanes)) {\n      cloneUpdateQueue(current, workInProgress);\n      processUpdateQueue(workInProgress, null, null, renderLanes);\n    }\n    const prevState: CacheComponentState = current.memoizedState;\n    const nextState: CacheComponentState = workInProgress.memoizedState;\n\n    // Compare the new parent cache to the previous to see detect there was\n    // a refresh.\n    if (prevState.parent !== parentCache) {\n      // Refresh in parent. Update the parent.\n      const derivedState: CacheComponentState = {\n        parent: parentCache,\n        cache: parentCache,\n      };\n\n      // Copied from getDerivedStateFromProps implementation. Once the update\n      // queue is empty, persist the derived state onto the base state.\n      workInProgress.memoizedState = derivedState;\n      if (workInProgress.lanes === NoLanes) {\n        const updateQueue: UpdateQueue<any> = (workInProgress.updateQueue: any);\n        workInProgress.memoizedState = updateQueue.baseState = derivedState;\n      }\n\n      pushCacheProvider(workInProgress, parentCache);\n      // No need to propagate a context change because the refreshed parent\n      // already did.\n    } else {\n      // The parent didn't refresh. Now check if this cache did.\n      const nextCache = nextState.cache;\n      pushCacheProvider(workInProgress, nextCache);\n      if (nextCache !== prevState.cache) {\n        // This cache refreshed. Propagate a context change.\n        propagateContextChange(workInProgress, CacheContext, renderLanes);\n      }\n    }\n  }\n\n  const nextChildren = workInProgress.pendingProps.children;\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\nfunction updateFragment(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderLanes: Lanes,\n) {\n  const nextChildren = workInProgress.pendingProps;\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\nfunction updateMode(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderLanes: Lanes,\n) {\n  const nextChildren = workInProgress.pendingProps.children;\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\nfunction updateProfiler(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderLanes: Lanes,\n) {\n  if (enableProfilerTimer) {\n    workInProgress.flags |= Update;\n\n    if (enableProfilerCommitHooks) {\n      // Reset effect durations for the next eventual effect phase.\n      // These are reset during render to allow the DevTools commit hook a chance to read them,\n      const stateNode = workInProgress.stateNode;\n      stateNode.effectDuration = 0;\n      stateNode.passiveEffectDuration = 0;\n    }\n  }\n  const nextProps = workInProgress.pendingProps;\n  const nextChildren = nextProps.children;\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\nfunction markRef(current: Fiber | null, workInProgress: Fiber) {\n  const ref = workInProgress.ref;\n  if (\n    (current === null && ref !== null) ||\n    (current !== null && current.ref !== ref)\n  ) {\n    // Schedule a Ref effect\n    workInProgress.flags |= Ref;\n    if (enableSuspenseLayoutEffectSemantics) {\n      workInProgress.flags |= RefStatic;\n    }\n  }\n}\n\nfunction updateFunctionComponent(\n  current,\n  workInProgress,\n  Component,\n  nextProps: any,\n  renderLanes,\n) {\n  if (__DEV__) {\n    if (workInProgress.type !== workInProgress.elementType) {\n      // Lazy component props can't be validated in createElement\n      // because they're only guaranteed to be resolved here.\n      const innerPropTypes = Component.propTypes;\n      if (innerPropTypes) {\n        checkPropTypes(\n          innerPropTypes,\n          nextProps, // Resolved props\n          'prop',\n          getComponentNameFromType(Component),\n        );\n      }\n    }\n  }\n\n  let context;\n  if (!disableLegacyContext) {\n    const unmaskedContext = getUnmaskedContext(workInProgress, Component, true);\n    context = getMaskedContext(workInProgress, unmaskedContext);\n  }\n\n  let nextChildren;\n  let hasId;\n  prepareToReadContext(workInProgress, renderLanes);\n  if (enableSchedulingProfiler) {\n    markComponentRenderStarted(workInProgress);\n  }\n  if (__DEV__) {\n    ReactCurrentOwner.current = workInProgress;\n    setIsRendering(true);\n    nextChildren = renderWithHooks(\n      current,\n      workInProgress,\n      Component,\n      nextProps,\n      context,\n      renderLanes,\n    );\n    hasId = checkDidRenderIdHook();\n    if (\n      debugRenderPhaseSideEffectsForStrictMode &&\n      workInProgress.mode & StrictLegacyMode\n    ) {\n      setIsStrictModeForDevtools(true);\n      try {\n        nextChildren = renderWithHooks(\n          current,\n          workInProgress,\n          Component,\n          nextProps,\n          context,\n          renderLanes,\n        );\n        hasId = checkDidRenderIdHook();\n      } finally {\n        setIsStrictModeForDevtools(false);\n      }\n    }\n    setIsRendering(false);\n  } else {\n    nextChildren = renderWithHooks(\n      current,\n      workInProgress,\n      Component,\n      nextProps,\n      context,\n      renderLanes,\n    );\n    hasId = checkDidRenderIdHook();\n  }\n  if (enableSchedulingProfiler) {\n    markComponentRenderStopped();\n  }\n\n  if (current !== null && !didReceiveUpdate) {\n    bailoutHooks(current, workInProgress, renderLanes);\n    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n  }\n\n  if (getIsHydrating() && hasId) {\n    pushMaterializedTreeId(workInProgress);\n  }\n\n  // React DevTools reads this flag.\n  workInProgress.flags |= PerformedWork;\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\nfunction updateClassComponent(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  Component: any,\n  nextProps: any,\n  renderLanes: Lanes,\n) {\n  if (__DEV__) {\n    // This is used by DevTools to force a boundary to error.\n    switch (shouldError(workInProgress)) {\n      case false: {\n        const instance = workInProgress.stateNode;\n        const ctor = workInProgress.type;\n        // TODO This way of resetting the error boundary state is a hack.\n        // Is there a better way to do this?\n        const tempInstance = new ctor(\n          workInProgress.memoizedProps,\n          instance.context,\n        );\n        const state = tempInstance.state;\n        instance.updater.enqueueSetState(instance, state, null);\n        break;\n      }\n      case true: {\n        workInProgress.flags |= DidCapture;\n        workInProgress.flags |= ShouldCapture;\n        // eslint-disable-next-line react-internal/prod-error-codes\n        const error = new Error('Simulated error coming from DevTools');\n        const lane = pickArbitraryLane(renderLanes);\n        workInProgress.lanes = mergeLanes(workInProgress.lanes, lane);\n        // Schedule the error boundary to re-render using updated state\n        const update = createClassErrorUpdate(\n          workInProgress,\n          createCapturedValue(error, workInProgress),\n          lane,\n        );\n        enqueueCapturedUpdate(workInProgress, update);\n        break;\n      }\n    }\n\n    if (workInProgress.type !== workInProgress.elementType) {\n      // Lazy component props can't be validated in createElement\n      // because they're only guaranteed to be resolved here.\n      const innerPropTypes = Component.propTypes;\n      if (innerPropTypes) {\n        checkPropTypes(\n          innerPropTypes,\n          nextProps, // Resolved props\n          'prop',\n          getComponentNameFromType(Component),\n        );\n      }\n    }\n  }\n\n  // Push context providers early to prevent context stack mismatches.\n  // During mounting we don't know the child context yet as the instance doesn't exist.\n  // We will invalidate the child context in finishClassComponent() right after rendering.\n  let hasContext;\n  if (isLegacyContextProvider(Component)) {\n    hasContext = true;\n    pushLegacyContextProvider(workInProgress);\n  } else {\n    hasContext = false;\n  }\n  prepareToReadContext(workInProgress, renderLanes);\n\n  const instance = workInProgress.stateNode;\n  let shouldUpdate;\n  if (instance === null) {\n    if (current !== null) {\n      // A class component without an instance only mounts if it suspended\n      // inside a non-concurrent tree, in an inconsistent state. We want to\n      // treat it like a new mount, even though an empty version of it already\n      // committed. Disconnect the alternate pointers.\n      current.alternate = null;\n      workInProgress.alternate = null;\n      // Since this is conceptually a new fiber, schedule a Placement effect\n      workInProgress.flags |= Placement;\n    }\n    // In the initial pass we might need to construct the instance.\n    constructClassInstance(workInProgress, Component, nextProps);\n    mountClassInstance(workInProgress, Component, nextProps, renderLanes);\n    shouldUpdate = true;\n  } else if (current === null) {\n    // In a resume, we'll already have an instance we can reuse.\n    shouldUpdate = resumeMountClassInstance(\n      workInProgress,\n      Component,\n      nextProps,\n      renderLanes,\n    );\n  } else {\n    shouldUpdate = updateClassInstance(\n      current,\n      workInProgress,\n      Component,\n      nextProps,\n      renderLanes,\n    );\n  }\n  const nextUnitOfWork = finishClassComponent(\n    current,\n    workInProgress,\n    Component,\n    shouldUpdate,\n    hasContext,\n    renderLanes,\n  );\n  if (__DEV__) {\n    const inst = workInProgress.stateNode;\n    if (shouldUpdate && inst.props !== nextProps) {\n      if (!didWarnAboutReassigningProps) {\n        console.error(\n          'It looks like %s is reassigning its own `this.props` while rendering. ' +\n            'This is not supported and can lead to confusing bugs.',\n          getComponentNameFromFiber(workInProgress) || 'a component',\n        );\n      }\n      didWarnAboutReassigningProps = true;\n    }\n  }\n  return nextUnitOfWork;\n}\n\nfunction finishClassComponent(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  Component: any,\n  shouldUpdate: boolean,\n  hasContext: boolean,\n  renderLanes: Lanes,\n) {\n  // Refs should update even if shouldComponentUpdate returns false\n  markRef(current, workInProgress);\n\n  const didCaptureError = (workInProgress.flags & DidCapture) !== NoFlags;\n\n  if (!shouldUpdate && !didCaptureError) {\n    // Context providers should defer to sCU for rendering\n    if (hasContext) {\n      invalidateContextProvider(workInProgress, Component, false);\n    }\n\n    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n  }\n\n  const instance = workInProgress.stateNode;\n\n  // Rerender\n  ReactCurrentOwner.current = workInProgress;\n  let nextChildren;\n  if (\n    didCaptureError &&\n    typeof Component.getDerivedStateFromError !== 'function'\n  ) {\n    // If we captured an error, but getDerivedStateFromError is not defined,\n    // unmount all the children. componentDidCatch will schedule an update to\n    // re-render a fallback. This is temporary until we migrate everyone to\n    // the new API.\n    // TODO: Warn in a future release.\n    nextChildren = null;\n\n    if (enableProfilerTimer) {\n      stopProfilerTimerIfRunning(workInProgress);\n    }\n  } else {\n    if (enableSchedulingProfiler) {\n      markComponentRenderStarted(workInProgress);\n    }\n    if (__DEV__) {\n      setIsRendering(true);\n      nextChildren = instance.render();\n      if (\n        debugRenderPhaseSideEffectsForStrictMode &&\n        workInProgress.mode & StrictLegacyMode\n      ) {\n        setIsStrictModeForDevtools(true);\n        try {\n          instance.render();\n        } finally {\n          setIsStrictModeForDevtools(false);\n        }\n      }\n      setIsRendering(false);\n    } else {\n      nextChildren = instance.render();\n    }\n    if (enableSchedulingProfiler) {\n      markComponentRenderStopped();\n    }\n  }\n\n  // React DevTools reads this flag.\n  workInProgress.flags |= PerformedWork;\n  if (current !== null && didCaptureError) {\n    // If we're recovering from an error, reconcile without reusing any of\n    // the existing children. Conceptually, the normal children and the children\n    // that are shown on error are two different sets, so we shouldn't reuse\n    // normal children even if their identities match.\n    forceUnmountCurrentAndReconcile(\n      current,\n      workInProgress,\n      nextChildren,\n      renderLanes,\n    );\n  } else {\n    reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  }\n\n  // Memoize state using the values we just used to render.\n  // TODO: Restructure so we never read values from the instance.\n  workInProgress.memoizedState = instance.state;\n\n  // The context might have changed so we need to recalculate it.\n  if (hasContext) {\n    invalidateContextProvider(workInProgress, Component, true);\n  }\n\n  return workInProgress.child;\n}\n\nfunction pushHostRootContext(workInProgress) {\n  const root = (workInProgress.stateNode: FiberRoot);\n  if (root.pendingContext) {\n    pushTopLevelContextObject(\n      workInProgress,\n      root.pendingContext,\n      root.pendingContext !== root.context,\n    );\n  } else if (root.context) {\n    // Should always be set\n    pushTopLevelContextObject(workInProgress, root.context, false);\n  }\n  pushHostContainer(workInProgress, root.containerInfo);\n}\n\nfunction updateHostRoot(current, workInProgress, renderLanes) {\n  pushHostRootContext(workInProgress);\n  const updateQueue = workInProgress.updateQueue;\n\n  if (current === null || updateQueue === null) {\n    throw new Error(\n      'If the root does not have an updateQueue, we should have already ' +\n        'bailed out. This error is likely caused by a bug in React. Please ' +\n        'file an issue.',\n    );\n  }\n\n  const nextProps = workInProgress.pendingProps;\n  const prevState = workInProgress.memoizedState;\n  const prevChildren = prevState.element;\n  cloneUpdateQueue(current, workInProgress);\n  processUpdateQueue(workInProgress, nextProps, null, renderLanes);\n  const nextState = workInProgress.memoizedState;\n\n  const root: FiberRoot = workInProgress.stateNode;\n\n  if (enableCache) {\n    const nextCache: Cache = nextState.cache;\n    pushRootCachePool(root);\n    pushCacheProvider(workInProgress, nextCache);\n    if (nextCache !== prevState.cache) {\n      // The root cache refreshed.\n      propagateContextChange(workInProgress, CacheContext, renderLanes);\n    }\n  }\n\n  // Caution: React DevTools currently depends on this property\n  // being called \"element\".\n  const nextChildren = nextState.element;\n  if (nextChildren === prevChildren) {\n    resetHydrationState();\n    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n  }\n  if (root.isDehydrated && enterHydrationState(workInProgress)) {\n    // If we don't have any current children this might be the first pass.\n    // We always try to hydrate. If this isn't a hydration pass there won't\n    // be any children to hydrate which is effectively the same thing as\n    // not hydrating.\n\n    if (supportsHydration) {\n      const mutableSourceEagerHydrationData =\n        root.mutableSourceEagerHydrationData;\n      if (mutableSourceEagerHydrationData != null) {\n        for (let i = 0; i < mutableSourceEagerHydrationData.length; i += 2) {\n          const mutableSource = ((mutableSourceEagerHydrationData[\n            i\n          ]: any): MutableSource<any>);\n          const version = mutableSourceEagerHydrationData[i + 1];\n          setWorkInProgressVersion(mutableSource, version);\n        }\n      }\n    }\n\n    const child = mountChildFibers(\n      workInProgress,\n      null,\n      nextChildren,\n      renderLanes,\n    );\n    workInProgress.child = child;\n\n    let node = child;\n    while (node) {\n      // Mark each child as hydrating. This is a fast path to know whether this\n      // tree is part of a hydrating tree. This is used to determine if a child\n      // node has fully mounted yet, and for scheduling event replaying.\n      // Conceptually this is similar to Placement in that a new subtree is\n      // inserted into the React tree here. It just happens to not need DOM\n      // mutations because it already exists.\n      node.flags = (node.flags & ~Placement) | Hydrating;\n      node = node.sibling;\n    }\n  } else {\n    // Otherwise reset hydration state in case we aborted and resumed another\n    // root.\n    reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n    resetHydrationState();\n  }\n  return workInProgress.child;\n}\n\nfunction updateHostComponent(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderLanes: Lanes,\n) {\n  pushHostContext(workInProgress);\n\n  if (current === null) {\n    tryToClaimNextHydratableInstance(workInProgress);\n  }\n\n  const type = workInProgress.type;\n  const nextProps = workInProgress.pendingProps;\n  const prevProps = current !== null ? current.memoizedProps : null;\n\n  let nextChildren = nextProps.children;\n  const isDirectTextChild = shouldSetTextContent(type, nextProps);\n\n  if (isDirectTextChild) {\n    // We special case a direct text child of a host node. This is a common\n    // case. We won't handle it as a reified child. We will instead handle\n    // this in the host environment that also has access to this prop. That\n    // avoids allocating another HostText fiber and traversing it.\n    nextChildren = null;\n  } else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {\n    // If we're switching from a direct text child to a normal child, or to\n    // empty, we need to schedule the text content to be reset.\n    workInProgress.flags |= ContentReset;\n  }\n\n  markRef(current, workInProgress);\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\nfunction updateHostText(current, workInProgress) {\n  if (current === null) {\n    tryToClaimNextHydratableInstance(workInProgress);\n  }\n  // Nothing to do here. This is terminal. We'll do the completion step\n  // immediately after.\n  return null;\n}\n\nfunction mountLazyComponent(\n  _current,\n  workInProgress,\n  elementType,\n  renderLanes,\n) {\n  if (_current !== null) {\n    // A lazy component only mounts if it suspended inside a non-\n    // concurrent tree, in an inconsistent state. We want to treat it like\n    // a new mount, even though an empty version of it already committed.\n    // Disconnect the alternate pointers.\n    _current.alternate = null;\n    workInProgress.alternate = null;\n    // Since this is conceptually a new fiber, schedule a Placement effect\n    workInProgress.flags |= Placement;\n  }\n\n  const props = workInProgress.pendingProps;\n  const lazyComponent: LazyComponentType<any, any> = elementType;\n  const payload = lazyComponent._payload;\n  const init = lazyComponent._init;\n  let Component = init(payload);\n  // Store the unwrapped component in the type.\n  workInProgress.type = Component;\n  const resolvedTag = (workInProgress.tag = resolveLazyComponentTag(Component));\n  const resolvedProps = resolveDefaultProps(Component, props);\n  let child;\n  switch (resolvedTag) {\n    case FunctionComponent: {\n      if (__DEV__) {\n        validateFunctionComponentInDev(workInProgress, Component);\n        workInProgress.type = Component = resolveFunctionForHotReloading(\n          Component,\n        );\n      }\n      child = updateFunctionComponent(\n        null,\n        workInProgress,\n        Component,\n        resolvedProps,\n        renderLanes,\n      );\n      return child;\n    }\n    case ClassComponent: {\n      if (__DEV__) {\n        workInProgress.type = Component = resolveClassForHotReloading(\n          Component,\n        );\n      }\n      child = updateClassComponent(\n        null,\n        workInProgress,\n        Component,\n        resolvedProps,\n        renderLanes,\n      );\n      return child;\n    }\n    case ForwardRef: {\n      if (__DEV__) {\n        workInProgress.type = Component = resolveForwardRefForHotReloading(\n          Component,\n        );\n      }\n      child = updateForwardRef(\n        null,\n        workInProgress,\n        Component,\n        resolvedProps,\n        renderLanes,\n      );\n      return child;\n    }\n    case MemoComponent: {\n      if (__DEV__) {\n        if (workInProgress.type !== workInProgress.elementType) {\n          const outerPropTypes = Component.propTypes;\n          if (outerPropTypes) {\n            checkPropTypes(\n              outerPropTypes,\n              resolvedProps, // Resolved for outer only\n              'prop',\n              getComponentNameFromType(Component),\n            );\n          }\n        }\n      }\n      child = updateMemoComponent(\n        null,\n        workInProgress,\n        Component,\n        resolveDefaultProps(Component.type, resolvedProps), // The inner type can have defaults too\n        renderLanes,\n      );\n      return child;\n    }\n  }\n  let hint = '';\n  if (__DEV__) {\n    if (\n      Component !== null &&\n      typeof Component === 'object' &&\n      Component.$$typeof === REACT_LAZY_TYPE\n    ) {\n      hint = ' Did you wrap a component in React.lazy() more than once?';\n    }\n  }\n\n  // This message intentionally doesn't mention ForwardRef or MemoComponent\n  // because the fact that it's a separate type of work is an\n  // implementation detail.\n  throw new Error(\n    `Element type is invalid. Received a promise that resolves to: ${Component}. ` +\n      `Lazy element type must resolve to a class or function.${hint}`,\n  );\n}\n\nfunction mountIncompleteClassComponent(\n  _current,\n  workInProgress,\n  Component,\n  nextProps,\n  renderLanes,\n) {\n  if (_current !== null) {\n    // An incomplete component only mounts if it suspended inside a non-\n    // concurrent tree, in an inconsistent state. We want to treat it like\n    // a new mount, even though an empty version of it already committed.\n    // Disconnect the alternate pointers.\n    _current.alternate = null;\n    workInProgress.alternate = null;\n    // Since this is conceptually a new fiber, schedule a Placement effect\n    workInProgress.flags |= Placement;\n  }\n\n  // Promote the fiber to a class and try rendering again.\n  workInProgress.tag = ClassComponent;\n\n  // The rest of this function is a fork of `updateClassComponent`\n\n  // Push context providers early to prevent context stack mismatches.\n  // During mounting we don't know the child context yet as the instance doesn't exist.\n  // We will invalidate the child context in finishClassComponent() right after rendering.\n  let hasContext;\n  if (isLegacyContextProvider(Component)) {\n    hasContext = true;\n    pushLegacyContextProvider(workInProgress);\n  } else {\n    hasContext = false;\n  }\n  prepareToReadContext(workInProgress, renderLanes);\n\n  constructClassInstance(workInProgress, Component, nextProps);\n  mountClassInstance(workInProgress, Component, nextProps, renderLanes);\n\n  return finishClassComponent(\n    null,\n    workInProgress,\n    Component,\n    true,\n    hasContext,\n    renderLanes,\n  );\n}\n\nfunction mountIndeterminateComponent(\n  _current,\n  workInProgress,\n  Component,\n  renderLanes,\n) {\n  if (_current !== null) {\n    // An indeterminate component only mounts if it suspended inside a non-\n    // concurrent tree, in an inconsistent state. We want to treat it like\n    // a new mount, even though an empty version of it already committed.\n    // Disconnect the alternate pointers.\n    _current.alternate = null;\n    workInProgress.alternate = null;\n    // Since this is conceptually a new fiber, schedule a Placement effect\n    workInProgress.flags |= Placement;\n  }\n\n  const props = workInProgress.pendingProps;\n  let context;\n  if (!disableLegacyContext) {\n    const unmaskedContext = getUnmaskedContext(\n      workInProgress,\n      Component,\n      false,\n    );\n    context = getMaskedContext(workInProgress, unmaskedContext);\n  }\n\n  prepareToReadContext(workInProgress, renderLanes);\n  let value;\n  let hasId;\n\n  if (enableSchedulingProfiler) {\n    markComponentRenderStarted(workInProgress);\n  }\n  if (__DEV__) {\n    if (\n      Component.prototype &&\n      typeof Component.prototype.render === 'function'\n    ) {\n      const componentName = getComponentNameFromType(Component) || 'Unknown';\n\n      if (!didWarnAboutBadClass[componentName]) {\n        console.error(\n          \"The <%s /> component appears to have a render method, but doesn't extend React.Component. \" +\n            'This is likely to cause errors. Change %s to extend React.Component instead.',\n          componentName,\n          componentName,\n        );\n        didWarnAboutBadClass[componentName] = true;\n      }\n    }\n\n    if (workInProgress.mode & StrictLegacyMode) {\n      ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, null);\n    }\n\n    setIsRendering(true);\n    ReactCurrentOwner.current = workInProgress;\n    value = renderWithHooks(\n      null,\n      workInProgress,\n      Component,\n      props,\n      context,\n      renderLanes,\n    );\n    hasId = checkDidRenderIdHook();\n    setIsRendering(false);\n  } else {\n    value = renderWithHooks(\n      null,\n      workInProgress,\n      Component,\n      props,\n      context,\n      renderLanes,\n    );\n    hasId = checkDidRenderIdHook();\n  }\n  if (enableSchedulingProfiler) {\n    markComponentRenderStopped();\n  }\n\n  // React DevTools reads this flag.\n  workInProgress.flags |= PerformedWork;\n\n  if (__DEV__) {\n    // Support for module components is deprecated and is removed behind a flag.\n    // Whether or not it would crash later, we want to show a good message in DEV first.\n    if (\n      typeof value === 'object' &&\n      value !== null &&\n      typeof value.render === 'function' &&\n      value.$$typeof === undefined\n    ) {\n      const componentName = getComponentNameFromType(Component) || 'Unknown';\n      if (!didWarnAboutModulePatternComponent[componentName]) {\n        console.error(\n          'The <%s /> component appears to be a function component that returns a class instance. ' +\n            'Change %s to a class that extends React.Component instead. ' +\n            \"If you can't use a class try assigning the prototype on the function as a workaround. \" +\n            \"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it \" +\n            'cannot be called with `new` by React.',\n          componentName,\n          componentName,\n          componentName,\n        );\n        didWarnAboutModulePatternComponent[componentName] = true;\n      }\n    }\n  }\n\n  if (\n    // Run these checks in production only if the flag is off.\n    // Eventually we'll delete this branch altogether.\n    !disableModulePatternComponents &&\n    typeof value === 'object' &&\n    value !== null &&\n    typeof value.render === 'function' &&\n    value.$$typeof === undefined\n  ) {\n    if (__DEV__) {\n      const componentName = getComponentNameFromType(Component) || 'Unknown';\n      if (!didWarnAboutModulePatternComponent[componentName]) {\n        console.error(\n          'The <%s /> component appears to be a function component that returns a class instance. ' +\n            'Change %s to a class that extends React.Component instead. ' +\n            \"If you can't use a class try assigning the prototype on the function as a workaround. \" +\n            \"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it \" +\n            'cannot be called with `new` by React.',\n          componentName,\n          componentName,\n          componentName,\n        );\n        didWarnAboutModulePatternComponent[componentName] = true;\n      }\n    }\n\n    // Proceed under the assumption that this is a class instance\n    workInProgress.tag = ClassComponent;\n\n    // Throw out any hooks that were used.\n    workInProgress.memoizedState = null;\n    workInProgress.updateQueue = null;\n\n    // Push context providers early to prevent context stack mismatches.\n    // During mounting we don't know the child context yet as the instance doesn't exist.\n    // We will invalidate the child context in finishClassComponent() right after rendering.\n    let hasContext = false;\n    if (isLegacyContextProvider(Component)) {\n      hasContext = true;\n      pushLegacyContextProvider(workInProgress);\n    } else {\n      hasContext = false;\n    }\n\n    workInProgress.memoizedState =\n      value.state !== null && value.state !== undefined ? value.state : null;\n\n    initializeUpdateQueue(workInProgress);\n\n    adoptClassInstance(workInProgress, value);\n    mountClassInstance(workInProgress, Component, props, renderLanes);\n    return finishClassComponent(\n      null,\n      workInProgress,\n      Component,\n      true,\n      hasContext,\n      renderLanes,\n    );\n  } else {\n    // Proceed under the assumption that this is a function component\n    workInProgress.tag = FunctionComponent;\n    if (__DEV__) {\n      if (disableLegacyContext && Component.contextTypes) {\n        console.error(\n          '%s uses the legacy contextTypes API which is no longer supported. ' +\n            'Use React.createContext() with React.useContext() instead.',\n          getComponentNameFromType(Component) || 'Unknown',\n        );\n      }\n\n      if (\n        debugRenderPhaseSideEffectsForStrictMode &&\n        workInProgress.mode & StrictLegacyMode\n      ) {\n        setIsStrictModeForDevtools(true);\n        try {\n          value = renderWithHooks(\n            null,\n            workInProgress,\n            Component,\n            props,\n            context,\n            renderLanes,\n          );\n          hasId = checkDidRenderIdHook();\n        } finally {\n          setIsStrictModeForDevtools(false);\n        }\n      }\n    }\n\n    if (getIsHydrating() && hasId) {\n      pushMaterializedTreeId(workInProgress);\n    }\n\n    reconcileChildren(null, workInProgress, value, renderLanes);\n    if (__DEV__) {\n      validateFunctionComponentInDev(workInProgress, Component);\n    }\n    return workInProgress.child;\n  }\n}\n\nfunction validateFunctionComponentInDev(workInProgress: Fiber, Component: any) {\n  if (__DEV__) {\n    if (Component) {\n      if (Component.childContextTypes) {\n        console.error(\n          '%s(...): childContextTypes cannot be defined on a function component.',\n          Component.displayName || Component.name || 'Component',\n        );\n      }\n    }\n    if (workInProgress.ref !== null) {\n      let info = '';\n      const ownerName = getCurrentFiberOwnerNameInDevOrNull();\n      if (ownerName) {\n        info += '\\n\\nCheck the render method of `' + ownerName + '`.';\n      }\n\n      let warningKey = ownerName || '';\n      const debugSource = workInProgress._debugSource;\n      if (debugSource) {\n        warningKey = debugSource.fileName + ':' + debugSource.lineNumber;\n      }\n      if (!didWarnAboutFunctionRefs[warningKey]) {\n        didWarnAboutFunctionRefs[warningKey] = true;\n        console.error(\n          'Function components cannot be given refs. ' +\n            'Attempts to access this ref will fail. ' +\n            'Did you mean to use React.forwardRef()?%s',\n          info,\n        );\n      }\n    }\n\n    if (\n      warnAboutDefaultPropsOnFunctionComponents &&\n      Component.defaultProps !== undefined\n    ) {\n      const componentName = getComponentNameFromType(Component) || 'Unknown';\n\n      if (!didWarnAboutDefaultPropsOnFunctionComponent[componentName]) {\n        console.error(\n          '%s: Support for defaultProps will be removed from function components ' +\n            'in a future major release. Use JavaScript default parameters instead.',\n          componentName,\n        );\n        didWarnAboutDefaultPropsOnFunctionComponent[componentName] = true;\n      }\n    }\n\n    if (typeof Component.getDerivedStateFromProps === 'function') {\n      const componentName = getComponentNameFromType(Component) || 'Unknown';\n\n      if (!didWarnAboutGetDerivedStateOnFunctionComponent[componentName]) {\n        console.error(\n          '%s: Function components do not support getDerivedStateFromProps.',\n          componentName,\n        );\n        didWarnAboutGetDerivedStateOnFunctionComponent[componentName] = true;\n      }\n    }\n\n    if (\n      typeof Component.contextType === 'object' &&\n      Component.contextType !== null\n    ) {\n      const componentName = getComponentNameFromType(Component) || 'Unknown';\n\n      if (!didWarnAboutContextTypeOnFunctionComponent[componentName]) {\n        console.error(\n          '%s: Function components do not support contextType.',\n          componentName,\n        );\n        didWarnAboutContextTypeOnFunctionComponent[componentName] = true;\n      }\n    }\n  }\n}\n\nconst SUSPENDED_MARKER: SuspenseState = {\n  dehydrated: null,\n  treeContext: null,\n  retryLane: NoLane,\n};\n\nfunction mountSuspenseOffscreenState(renderLanes: Lanes): OffscreenState {\n  return {\n    baseLanes: renderLanes,\n    cachePool: getSuspendedCachePool(),\n  };\n}\n\nfunction updateSuspenseOffscreenState(\n  prevOffscreenState: OffscreenState,\n  renderLanes: Lanes,\n): OffscreenState {\n  let cachePool: SpawnedCachePool | null = null;\n  if (enableCache) {\n    const prevCachePool: SpawnedCachePool | null = prevOffscreenState.cachePool;\n    if (prevCachePool !== null) {\n      const parentCache = isPrimaryRenderer\n        ? CacheContext._currentValue\n        : CacheContext._currentValue2;\n      if (prevCachePool.parent !== parentCache) {\n        // Detected a refresh in the parent. This overrides any previously\n        // suspended cache.\n        cachePool = {\n          parent: parentCache,\n          pool: parentCache,\n        };\n      } else {\n        // We can reuse the cache from last time. The only thing that would have\n        // overridden it is a parent refresh, which we checked for above.\n        cachePool = prevCachePool;\n      }\n    } else {\n      // If there's no previous cache pool, grab the current one.\n      cachePool = getSuspendedCachePool();\n    }\n  }\n  return {\n    baseLanes: mergeLanes(prevOffscreenState.baseLanes, renderLanes),\n    cachePool,\n  };\n}\n\n// TODO: Probably should inline this back\nfunction shouldRemainOnFallback(\n  suspenseContext: SuspenseContext,\n  current: null | Fiber,\n  workInProgress: Fiber,\n  renderLanes: Lanes,\n) {\n  // If we're already showing a fallback, there are cases where we need to\n  // remain on that fallback regardless of whether the content has resolved.\n  // For example, SuspenseList coordinates when nested content appears.\n  if (current !== null) {\n    const suspenseState: SuspenseState = current.memoizedState;\n    if (suspenseState === null) {\n      // Currently showing content. Don't hide it, even if ForceSuspenseFallback\n      // is true. More precise name might be \"ForceRemainSuspenseFallback\".\n      // Note: This is a factoring smell. Can't remain on a fallback if there's\n      // no fallback to remain on.\n      return false;\n    }\n  }\n\n  // Not currently showing content. Consult the Suspense context.\n  return hasSuspenseContext(\n    suspenseContext,\n    (ForceSuspenseFallback: SuspenseContext),\n  );\n}\n\nfunction getRemainingWorkInPrimaryTree(current: Fiber, renderLanes) {\n  // TODO: Should not remove render lanes that were pinged during this render\n  return removeLanes(current.childLanes, renderLanes);\n}\n\nfunction updateSuspenseComponent(current, workInProgress, renderLanes) {\n  const nextProps = workInProgress.pendingProps;\n\n  // This is used by DevTools to force a boundary to suspend.\n  if (__DEV__) {\n    if (shouldSuspend(workInProgress)) {\n      workInProgress.flags |= DidCapture;\n    }\n  }\n\n  let suspenseContext: SuspenseContext = suspenseStackCursor.current;\n\n  let showFallback = false;\n  const didSuspend = (workInProgress.flags & DidCapture) !== NoFlags;\n\n  if (\n    didSuspend ||\n    shouldRemainOnFallback(\n      suspenseContext,\n      current,\n      workInProgress,\n      renderLanes,\n    )\n  ) {\n    // Something in this boundary's subtree already suspended. Switch to\n    // rendering the fallback children.\n    showFallback = true;\n    workInProgress.flags &= ~DidCapture;\n  } else {\n    // Attempting the main content\n    if (\n      current === null ||\n      (current.memoizedState: null | SuspenseState) !== null\n    ) {\n      // This is a new mount or this boundary is already showing a fallback state.\n      // Mark this subtree context as having at least one invisible parent that could\n      // handle the fallback state.\n      // Avoided boundaries are not considered since they cannot handle preferred fallback states.\n      if (nextProps.unstable_avoidThisFallback !== true) {\n        suspenseContext = addSubtreeSuspenseContext(\n          suspenseContext,\n          InvisibleParentSuspenseContext,\n        );\n      }\n    }\n  }\n\n  suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);\n\n  pushSuspenseContext(workInProgress, suspenseContext);\n\n  // OK, the next part is confusing. We're about to reconcile the Suspense\n  // boundary's children. This involves some custom reconciliation logic. Two\n  // main reasons this is so complicated.\n  //\n  // First, Legacy Mode has different semantics for backwards compatibility. The\n  // primary tree will commit in an inconsistent state, so when we do the\n  // second pass to render the fallback, we do some exceedingly, uh, clever\n  // hacks to make that not totally break. Like transferring effects and\n  // deletions from hidden tree. In Concurrent Mode, it's much simpler,\n  // because we bailout on the primary tree completely and leave it in its old\n  // state, no effects. Same as what we do for Offscreen (except that\n  // Offscreen doesn't have the first render pass).\n  //\n  // Second is hydration. During hydration, the Suspense fiber has a slightly\n  // different layout, where the child points to a dehydrated fragment, which\n  // contains the DOM rendered by the server.\n  //\n  // Third, even if you set all that aside, Suspense is like error boundaries in\n  // that we first we try to render one tree, and if that fails, we render again\n  // and switch to a different tree. Like a try/catch block. So we have to track\n  // which branch we're currently rendering. Ideally we would model this using\n  // a stack.\n  if (current === null) {\n    // Initial mount\n    // If we're currently hydrating, try to hydrate this boundary.\n    tryToClaimNextHydratableInstance(workInProgress);\n    // This could've been a dehydrated suspense component.\n    if (enableSuspenseServerRenderer) {\n      const suspenseState: null | SuspenseState = workInProgress.memoizedState;\n      if (suspenseState !== null) {\n        const dehydrated = suspenseState.dehydrated;\n        if (dehydrated !== null) {\n          return mountDehydratedSuspenseComponent(\n            workInProgress,\n            dehydrated,\n            renderLanes,\n          );\n        }\n      }\n    }\n\n    const nextPrimaryChildren = nextProps.children;\n    const nextFallbackChildren = nextProps.fallback;\n    if (showFallback) {\n      const fallbackFragment = mountSuspenseFallbackChildren(\n        workInProgress,\n        nextPrimaryChildren,\n        nextFallbackChildren,\n        renderLanes,\n      );\n      const primaryChildFragment: Fiber = (workInProgress.child: any);\n      primaryChildFragment.memoizedState = mountSuspenseOffscreenState(\n        renderLanes,\n      );\n      workInProgress.memoizedState = SUSPENDED_MARKER;\n      return fallbackFragment;\n    } else if (typeof nextProps.unstable_expectedLoadTime === 'number') {\n      // This is a CPU-bound tree. Skip this tree and show a placeholder to\n      // unblock the surrounding content. Then immediately retry after the\n      // initial commit.\n      const fallbackFragment = mountSuspenseFallbackChildren(\n        workInProgress,\n        nextPrimaryChildren,\n        nextFallbackChildren,\n        renderLanes,\n      );\n      const primaryChildFragment: Fiber = (workInProgress.child: any);\n      primaryChildFragment.memoizedState = mountSuspenseOffscreenState(\n        renderLanes,\n      );\n      workInProgress.memoizedState = SUSPENDED_MARKER;\n\n      // Since nothing actually suspended, there will nothing to ping this to\n      // get it started back up to attempt the next item. While in terms of\n      // priority this work has the same priority as this current render, it's\n      // not part of the same transition once the transition has committed. If\n      // it's sync, we still want to yield so that it can be painted.\n      // Conceptually, this is really the same as pinging. We can use any\n      // RetryLane even if it's the one currently rendering since we're leaving\n      // it behind on this node.\n      workInProgress.lanes = SomeRetryLane;\n      return fallbackFragment;\n    } else {\n      return mountSuspensePrimaryChildren(\n        workInProgress,\n        nextPrimaryChildren,\n        renderLanes,\n      );\n    }\n  } else {\n    // This is an update.\n\n    // If the current fiber has a SuspenseState, that means it's already showing\n    // a fallback.\n    const prevState: null | SuspenseState = current.memoizedState;\n    if (prevState !== null) {\n      // The current tree is already showing a fallback\n\n      // Special path for hydration\n      if (enableSuspenseServerRenderer) {\n        const dehydrated = prevState.dehydrated;\n        if (dehydrated !== null) {\n          if (!didSuspend) {\n            return updateDehydratedSuspenseComponent(\n              current,\n              workInProgress,\n              dehydrated,\n              prevState,\n              renderLanes,\n            );\n          } else if (workInProgress.flags & ForceClientRender) {\n            // Something errored during hydration. Try again without hydrating.\n            workInProgress.flags &= ~ForceClientRender;\n            return retrySuspenseComponentWithoutHydrating(\n              current,\n              workInProgress,\n              renderLanes,\n            );\n          } else if (\n            (workInProgress.memoizedState: null | SuspenseState) !== null\n          ) {\n            // Something suspended and we should still be in dehydrated mode.\n            // Leave the existing child in place.\n            workInProgress.child = current.child;\n            // The dehydrated completion pass expects this flag to be there\n            // but the normal suspense pass doesn't.\n            workInProgress.flags |= DidCapture;\n            return null;\n          } else {\n            // Suspended but we should no longer be in dehydrated mode.\n            // Therefore we now have to render the fallback.\n            const nextPrimaryChildren = nextProps.children;\n            const nextFallbackChildren = nextProps.fallback;\n            const fallbackChildFragment = mountSuspenseFallbackAfterRetryWithoutHydrating(\n              current,\n              workInProgress,\n              nextPrimaryChildren,\n              nextFallbackChildren,\n              renderLanes,\n            );\n            const primaryChildFragment: Fiber = (workInProgress.child: any);\n            primaryChildFragment.memoizedState = mountSuspenseOffscreenState(\n              renderLanes,\n            );\n            workInProgress.memoizedState = SUSPENDED_MARKER;\n            return fallbackChildFragment;\n          }\n        }\n      }\n\n      if (showFallback) {\n        const nextFallbackChildren = nextProps.fallback;\n        const nextPrimaryChildren = nextProps.children;\n        const fallbackChildFragment = updateSuspenseFallbackChildren(\n          current,\n          workInProgress,\n          nextPrimaryChildren,\n          nextFallbackChildren,\n          renderLanes,\n        );\n        const primaryChildFragment: Fiber = (workInProgress.child: any);\n        const prevOffscreenState: OffscreenState | null = (current.child: any)\n          .memoizedState;\n        primaryChildFragment.memoizedState =\n          prevOffscreenState === null\n            ? mountSuspenseOffscreenState(renderLanes)\n            : updateSuspenseOffscreenState(prevOffscreenState, renderLanes);\n        primaryChildFragment.childLanes = getRemainingWorkInPrimaryTree(\n          current,\n          renderLanes,\n        );\n        workInProgress.memoizedState = SUSPENDED_MARKER;\n        return fallbackChildFragment;\n      } else {\n        const nextPrimaryChildren = nextProps.children;\n        const primaryChildFragment = updateSuspensePrimaryChildren(\n          current,\n          workInProgress,\n          nextPrimaryChildren,\n          renderLanes,\n        );\n        workInProgress.memoizedState = null;\n        return primaryChildFragment;\n      }\n    } else {\n      // The current tree is not already showing a fallback.\n      if (showFallback) {\n        // Timed out.\n        const nextFallbackChildren = nextProps.fallback;\n        const nextPrimaryChildren = nextProps.children;\n        const fallbackChildFragment = updateSuspenseFallbackChildren(\n          current,\n          workInProgress,\n          nextPrimaryChildren,\n          nextFallbackChildren,\n          renderLanes,\n        );\n        const primaryChildFragment: Fiber = (workInProgress.child: any);\n        const prevOffscreenState: OffscreenState | null = (current.child: any)\n          .memoizedState;\n        primaryChildFragment.memoizedState =\n          prevOffscreenState === null\n            ? mountSuspenseOffscreenState(renderLanes)\n            : updateSuspenseOffscreenState(prevOffscreenState, renderLanes);\n        primaryChildFragment.childLanes = getRemainingWorkInPrimaryTree(\n          current,\n          renderLanes,\n        );\n        // Skip the primary children, and continue working on the\n        // fallback children.\n        workInProgress.memoizedState = SUSPENDED_MARKER;\n        return fallbackChildFragment;\n      } else {\n        // Still haven't timed out. Continue rendering the children, like we\n        // normally do.\n        const nextPrimaryChildren = nextProps.children;\n        const primaryChildFragment = updateSuspensePrimaryChildren(\n          current,\n          workInProgress,\n          nextPrimaryChildren,\n          renderLanes,\n        );\n        workInProgress.memoizedState = null;\n        return primaryChildFragment;\n      }\n    }\n  }\n}\n\nfunction mountSuspensePrimaryChildren(\n  workInProgress,\n  primaryChildren,\n  renderLanes,\n) {\n  const mode = workInProgress.mode;\n  const primaryChildProps: OffscreenProps = {\n    mode: 'visible',\n    children: primaryChildren,\n  };\n  const primaryChildFragment = mountWorkInProgressOffscreenFiber(\n    primaryChildProps,\n    mode,\n    renderLanes,\n  );\n  primaryChildFragment.return = workInProgress;\n  workInProgress.child = primaryChildFragment;\n  return primaryChildFragment;\n}\n\nfunction mountSuspenseFallbackChildren(\n  workInProgress,\n  primaryChildren,\n  fallbackChildren,\n  renderLanes,\n) {\n  const mode = workInProgress.mode;\n  const progressedPrimaryFragment: Fiber | null = workInProgress.child;\n\n  const primaryChildProps: OffscreenProps = {\n    mode: 'hidden',\n    children: primaryChildren,\n  };\n\n  let primaryChildFragment;\n  let fallbackChildFragment;\n  if (\n    (mode & ConcurrentMode) === NoMode &&\n    progressedPrimaryFragment !== null\n  ) {\n    // In legacy mode, we commit the primary tree as if it successfully\n    // completed, even though it's in an inconsistent state.\n    primaryChildFragment = progressedPrimaryFragment;\n    primaryChildFragment.childLanes = NoLanes;\n    primaryChildFragment.pendingProps = primaryChildProps;\n\n    if (enableProfilerTimer && workInProgress.mode & ProfileMode) {\n      // Reset the durations from the first pass so they aren't included in the\n      // final amounts. This seems counterintuitive, since we're intentionally\n      // not measuring part of the render phase, but this makes it match what we\n      // do in Concurrent Mode.\n      primaryChildFragment.actualDuration = 0;\n      primaryChildFragment.actualStartTime = -1;\n      primaryChildFragment.selfBaseDuration = 0;\n      primaryChildFragment.treeBaseDuration = 0;\n    }\n\n    fallbackChildFragment = createFiberFromFragment(\n      fallbackChildren,\n      mode,\n      renderLanes,\n      null,\n    );\n  } else {\n    primaryChildFragment = mountWorkInProgressOffscreenFiber(\n      primaryChildProps,\n      mode,\n      NoLanes,\n    );\n    fallbackChildFragment = createFiberFromFragment(\n      fallbackChildren,\n      mode,\n      renderLanes,\n      null,\n    );\n  }\n\n  primaryChildFragment.return = workInProgress;\n  fallbackChildFragment.return = workInProgress;\n  primaryChildFragment.sibling = fallbackChildFragment;\n  workInProgress.child = primaryChildFragment;\n  return fallbackChildFragment;\n}\n\nfunction mountWorkInProgressOffscreenFiber(\n  offscreenProps: OffscreenProps,\n  mode: TypeOfMode,\n  renderLanes: Lanes,\n) {\n  // The props argument to `createFiberFromOffscreen` is `any` typed, so we use\n  // this wrapper function to constrain it.\n  return createFiberFromOffscreen(offscreenProps, mode, NoLanes, null);\n}\n\nfunction updateWorkInProgressOffscreenFiber(\n  current: Fiber,\n  offscreenProps: OffscreenProps,\n) {\n  // The props argument to `createWorkInProgress` is `any` typed, so we use this\n  // wrapper function to constrain it.\n  return createWorkInProgress(current, offscreenProps);\n}\n\nfunction updateSuspensePrimaryChildren(\n  current,\n  workInProgress,\n  primaryChildren,\n  renderLanes,\n) {\n  const currentPrimaryChildFragment: Fiber = (current.child: any);\n  const currentFallbackChildFragment: Fiber | null =\n    currentPrimaryChildFragment.sibling;\n\n  const primaryChildFragment = updateWorkInProgressOffscreenFiber(\n    currentPrimaryChildFragment,\n    {\n      mode: 'visible',\n      children: primaryChildren,\n    },\n  );\n  if ((workInProgress.mode & ConcurrentMode) === NoMode) {\n    primaryChildFragment.lanes = renderLanes;\n  }\n  primaryChildFragment.return = workInProgress;\n  primaryChildFragment.sibling = null;\n  if (currentFallbackChildFragment !== null) {\n    // Delete the fallback child fragment\n    const deletions = workInProgress.deletions;\n    if (deletions === null) {\n      workInProgress.deletions = [currentFallbackChildFragment];\n      workInProgress.flags |= ChildDeletion;\n    } else {\n      deletions.push(currentFallbackChildFragment);\n    }\n  }\n\n  workInProgress.child = primaryChildFragment;\n  return primaryChildFragment;\n}\n\nfunction updateSuspenseFallbackChildren(\n  current,\n  workInProgress,\n  primaryChildren,\n  fallbackChildren,\n  renderLanes,\n) {\n  const mode = workInProgress.mode;\n  const currentPrimaryChildFragment: Fiber = (current.child: any);\n  const currentFallbackChildFragment: Fiber | null =\n    currentPrimaryChildFragment.sibling;\n\n  const primaryChildProps: OffscreenProps = {\n    mode: 'hidden',\n    children: primaryChildren,\n  };\n\n  let primaryChildFragment;\n  if (\n    // In legacy mode, we commit the primary tree as if it successfully\n    // completed, even though it's in an inconsistent state.\n    (mode & ConcurrentMode) === NoMode &&\n    // Make sure we're on the second pass, i.e. the primary child fragment was\n    // already cloned. In legacy mode, the only case where this isn't true is\n    // when DevTools forces us to display a fallback; we skip the first render\n    // pass entirely and go straight to rendering the fallback. (In Concurrent\n    // Mode, SuspenseList can also trigger this scenario, but this is a legacy-\n    // only codepath.)\n    workInProgress.child !== currentPrimaryChildFragment\n  ) {\n    const progressedPrimaryFragment: Fiber = (workInProgress.child: any);\n    primaryChildFragment = progressedPrimaryFragment;\n    primaryChildFragment.childLanes = NoLanes;\n    primaryChildFragment.pendingProps = primaryChildProps;\n\n    if (enableProfilerTimer && workInProgress.mode & ProfileMode) {\n      // Reset the durations from the first pass so they aren't included in the\n      // final amounts. This seems counterintuitive, since we're intentionally\n      // not measuring part of the render phase, but this makes it match what we\n      // do in Concurrent Mode.\n      primaryChildFragment.actualDuration = 0;\n      primaryChildFragment.actualStartTime = -1;\n      primaryChildFragment.selfBaseDuration =\n        currentPrimaryChildFragment.selfBaseDuration;\n      primaryChildFragment.treeBaseDuration =\n        currentPrimaryChildFragment.treeBaseDuration;\n    }\n\n    if (enablePersistentOffscreenHostContainer && supportsPersistence) {\n      // In persistent mode, the offscreen children are wrapped in a host node.\n      // We need to complete it now, because we're going to skip over its normal\n      // complete phase and go straight to rendering the fallback.\n      const currentOffscreenContainer = currentPrimaryChildFragment.child;\n      const offscreenContainer: Fiber = (primaryChildFragment.child: any);\n      const containerProps = getOffscreenContainerProps(\n        'hidden',\n        primaryChildren,\n      );\n      offscreenContainer.pendingProps = containerProps;\n      offscreenContainer.memoizedProps = containerProps;\n      completeSuspendedOffscreenHostContainer(\n        currentOffscreenContainer,\n        offscreenContainer,\n      );\n    }\n\n    // The fallback fiber was added as a deletion during the first pass.\n    // However, since we're going to remain on the fallback, we no longer want\n    // to delete it.\n    workInProgress.deletions = null;\n  } else {\n    primaryChildFragment = updateWorkInProgressOffscreenFiber(\n      currentPrimaryChildFragment,\n      primaryChildProps,\n    );\n\n    if (enablePersistentOffscreenHostContainer && supportsPersistence) {\n      // In persistent mode, the offscreen children are wrapped in a host node.\n      // We need to complete it now, because we're going to skip over its normal\n      // complete phase and go straight to rendering the fallback.\n      const currentOffscreenContainer = currentPrimaryChildFragment.child;\n      if (currentOffscreenContainer !== null) {\n        const isHidden = true;\n        const offscreenContainer = reconcileOffscreenHostContainer(\n          currentPrimaryChildFragment,\n          primaryChildFragment,\n          isHidden,\n          primaryChildren,\n          renderLanes,\n        );\n        offscreenContainer.memoizedProps = offscreenContainer.pendingProps;\n        completeSuspendedOffscreenHostContainer(\n          currentOffscreenContainer,\n          offscreenContainer,\n        );\n      }\n    }\n\n    // Since we're reusing a current tree, we need to reuse the flags, too.\n    // (We don't do this in legacy mode, because in legacy mode we don't re-use\n    // the current tree; see previous branch.)\n    primaryChildFragment.subtreeFlags =\n      currentPrimaryChildFragment.subtreeFlags & StaticMask;\n  }\n  let fallbackChildFragment;\n  if (currentFallbackChildFragment !== null) {\n    fallbackChildFragment = createWorkInProgress(\n      currentFallbackChildFragment,\n      fallbackChildren,\n    );\n  } else {\n    fallbackChildFragment = createFiberFromFragment(\n      fallbackChildren,\n      mode,\n      renderLanes,\n      null,\n    );\n    // Needs a placement effect because the parent (the Suspense boundary) already\n    // mounted but this is a new fiber.\n    fallbackChildFragment.flags |= Placement;\n  }\n\n  fallbackChildFragment.return = workInProgress;\n  primaryChildFragment.return = workInProgress;\n  primaryChildFragment.sibling = fallbackChildFragment;\n  workInProgress.child = primaryChildFragment;\n\n  return fallbackChildFragment;\n}\n\nfunction retrySuspenseComponentWithoutHydrating(\n  current: Fiber,\n  workInProgress: Fiber,\n  renderLanes: Lanes,\n) {\n  // This will add the old fiber to the deletion list\n  reconcileChildFibers(workInProgress, current.child, null, renderLanes);\n\n  // We're now not suspended nor dehydrated.\n  const nextProps = workInProgress.pendingProps;\n  const primaryChildren = nextProps.children;\n  const primaryChildFragment = mountSuspensePrimaryChildren(\n    workInProgress,\n    primaryChildren,\n    renderLanes,\n  );\n  // Needs a placement effect because the parent (the Suspense boundary) already\n  // mounted but this is a new fiber.\n  primaryChildFragment.flags |= Placement;\n  workInProgress.memoizedState = null;\n\n  return primaryChildFragment;\n}\n\nfunction mountSuspenseFallbackAfterRetryWithoutHydrating(\n  current,\n  workInProgress,\n  primaryChildren,\n  fallbackChildren,\n  renderLanes,\n) {\n  const fiberMode = workInProgress.mode;\n  const primaryChildProps: OffscreenProps = {\n    mode: 'visible',\n    children: primaryChildren,\n  };\n  const primaryChildFragment = mountWorkInProgressOffscreenFiber(\n    primaryChildProps,\n    fiberMode,\n    NoLanes,\n  );\n  const fallbackChildFragment = createFiberFromFragment(\n    fallbackChildren,\n    fiberMode,\n    renderLanes,\n    null,\n  );\n  // Needs a placement effect because the parent (the Suspense\n  // boundary) already mounted but this is a new fiber.\n  fallbackChildFragment.flags |= Placement;\n\n  primaryChildFragment.return = workInProgress;\n  fallbackChildFragment.return = workInProgress;\n  primaryChildFragment.sibling = fallbackChildFragment;\n  workInProgress.child = primaryChildFragment;\n\n  if ((workInProgress.mode & ConcurrentMode) !== NoMode) {\n    // We will have dropped the effect list which contains the\n    // deletion. We need to reconcile to delete the current child.\n    reconcileChildFibers(workInProgress, current.child, null, renderLanes);\n  }\n\n  return fallbackChildFragment;\n}\n\nfunction mountDehydratedSuspenseComponent(\n  workInProgress: Fiber,\n  suspenseInstance: SuspenseInstance,\n  renderLanes: Lanes,\n): null | Fiber {\n  // During the first pass, we'll bail out and not drill into the children.\n  // Instead, we'll leave the content in place and try to hydrate it later.\n  if ((workInProgress.mode & ConcurrentMode) === NoMode) {\n    if (__DEV__) {\n      console.error(\n        'Cannot hydrate Suspense in legacy mode. Switch from ' +\n          'ReactDOM.hydrate(element, container) to ' +\n          'ReactDOM.createRoot(container, { hydrate: true })' +\n          '.render(element) or remove the Suspense components from ' +\n          'the server rendered components.',\n      );\n    }\n    workInProgress.lanes = laneToLanes(SyncLane);\n  } else if (isSuspenseInstanceFallback(suspenseInstance)) {\n    // This is a client-only boundary. Since we won't get any content from the server\n    // for this, we need to schedule that at a higher priority based on when it would\n    // have timed out. In theory we could render it in this pass but it would have the\n    // wrong priority associated with it and will prevent hydration of parent path.\n    // Instead, we'll leave work left on it to render it in a separate commit.\n\n    // TODO This time should be the time at which the server rendered response that is\n    // a parent to this boundary was displayed. However, since we currently don't have\n    // a protocol to transfer that time, we'll just estimate it by using the current\n    // time. This will mean that Suspense timeouts are slightly shifted to later than\n    // they should be.\n    // Schedule a normal pri update to render this content.\n    workInProgress.lanes = laneToLanes(DefaultHydrationLane);\n  } else {\n    // We'll continue hydrating the rest at offscreen priority since we'll already\n    // be showing the right content coming from the server, it is no rush.\n    workInProgress.lanes = laneToLanes(OffscreenLane);\n  }\n  return null;\n}\n\nfunction updateDehydratedSuspenseComponent(\n  current: Fiber,\n  workInProgress: Fiber,\n  suspenseInstance: SuspenseInstance,\n  suspenseState: SuspenseState,\n  renderLanes: Lanes,\n): null | Fiber {\n  // We should never be hydrating at this point because it is the first pass,\n  // but after we've already committed once.\n  warnIfHydrating();\n\n  if ((getExecutionContext() & RetryAfterError) !== NoContext) {\n    return retrySuspenseComponentWithoutHydrating(\n      current,\n      workInProgress,\n      renderLanes,\n    );\n  }\n\n  if ((workInProgress.mode & ConcurrentMode) === NoMode) {\n    return retrySuspenseComponentWithoutHydrating(\n      current,\n      workInProgress,\n      renderLanes,\n    );\n  }\n\n  if (isSuspenseInstanceFallback(suspenseInstance)) {\n    // This boundary is in a permanent fallback state. In this case, we'll never\n    // get an update and we'll never be able to hydrate the final content. Let's just try the\n    // client side render instead.\n    return retrySuspenseComponentWithoutHydrating(\n      current,\n      workInProgress,\n      renderLanes,\n    );\n  }\n\n  if (\n    enableLazyContextPropagation &&\n    // TODO: Factoring is a little weird, since we check this right below, too.\n    // But don't want to re-arrange the if-else chain until/unless this\n    // feature lands.\n    !didReceiveUpdate\n  ) {\n    // We need to check if any children have context before we decide to bail\n    // out, so propagate the changes now.\n    lazilyPropagateParentContextChanges(current, workInProgress, renderLanes);\n  }\n\n  // We use lanes to indicate that a child might depend on context, so if\n  // any context has changed, we need to treat is as if the input might have changed.\n  const hasContextChanged = includesSomeLane(renderLanes, current.childLanes);\n  if (didReceiveUpdate || hasContextChanged) {\n    // This boundary has changed since the first render. This means that we are now unable to\n    // hydrate it. We might still be able to hydrate it using a higher priority lane.\n    const root = getWorkInProgressRoot();\n    if (root !== null) {\n      const attemptHydrationAtLane = getBumpedLaneForHydration(\n        root,\n        renderLanes,\n      );\n      if (\n        attemptHydrationAtLane !== NoLane &&\n        attemptHydrationAtLane !== suspenseState.retryLane\n      ) {\n        // Intentionally mutating since this render will get interrupted. This\n        // is one of the very rare times where we mutate the current tree\n        // during the render phase.\n        suspenseState.retryLane = attemptHydrationAtLane;\n        // TODO: Ideally this would inherit the event time of the current render\n        const eventTime = NoTimestamp;\n        scheduleUpdateOnFiber(current, attemptHydrationAtLane, eventTime);\n      } else {\n        // We have already tried to ping at a higher priority than we're rendering with\n        // so if we got here, we must have failed to hydrate at those levels. We must\n        // now give up. Instead, we're going to delete the whole subtree and instead inject\n        // a new real Suspense boundary to take its place, which may render content\n        // or fallback. This might suspend for a while and if it does we might still have\n        // an opportunity to hydrate before this pass commits.\n      }\n    }\n\n    // If we have scheduled higher pri work above, this will probably just abort the render\n    // since we now have higher priority work, but in case it doesn't, we need to prepare to\n    // render something, if we time out. Even if that requires us to delete everything and\n    // skip hydration.\n    // Delay having to do this as long as the suspense timeout allows us.\n    renderDidSuspendDelayIfPossible();\n    return retrySuspenseComponentWithoutHydrating(\n      current,\n      workInProgress,\n      renderLanes,\n    );\n  } else if (isSuspenseInstancePending(suspenseInstance)) {\n    // This component is still pending more data from the server, so we can't hydrate its\n    // content. We treat it as if this component suspended itself. It might seem as if\n    // we could just try to render it client-side instead. However, this will perform a\n    // lot of unnecessary work and is unlikely to complete since it often will suspend\n    // on missing data anyway. Additionally, the server might be able to render more\n    // than we can on the client yet. In that case we'd end up with more fallback states\n    // on the client than if we just leave it alone. If the server times out or errors\n    // these should update this boundary to the permanent Fallback state instead.\n    // Mark it as having captured (i.e. suspended).\n    workInProgress.flags |= DidCapture;\n    // Leave the child in place. I.e. the dehydrated fragment.\n    workInProgress.child = current.child;\n    // Register a callback to retry this boundary once the server has sent the result.\n    const retry = retryDehydratedSuspenseBoundary.bind(null, current);\n    registerSuspenseInstanceRetry(suspenseInstance, retry);\n    return null;\n  } else {\n    // This is the first attempt.\n    reenterHydrationStateFromDehydratedSuspenseInstance(\n      workInProgress,\n      suspenseInstance,\n      suspenseState.treeContext,\n    );\n    const nextProps = workInProgress.pendingProps;\n    const primaryChildren = nextProps.children;\n    const primaryChildFragment = mountSuspensePrimaryChildren(\n      workInProgress,\n      primaryChildren,\n      renderLanes,\n    );\n    // Mark the children as hydrating. This is a fast path to know whether this\n    // tree is part of a hydrating tree. This is used to determine if a child\n    // node has fully mounted yet, and for scheduling event replaying.\n    // Conceptually this is similar to Placement in that a new subtree is\n    // inserted into the React tree here. It just happens to not need DOM\n    // mutations because it already exists.\n    primaryChildFragment.flags |= Hydrating;\n    return primaryChildFragment;\n  }\n}\n\nfunction scheduleWorkOnFiber(fiber: Fiber, renderLanes: Lanes) {\n  fiber.lanes = mergeLanes(fiber.lanes, renderLanes);\n  const alternate = fiber.alternate;\n  if (alternate !== null) {\n    alternate.lanes = mergeLanes(alternate.lanes, renderLanes);\n  }\n  scheduleWorkOnParentPath(fiber.return, renderLanes);\n}\n\nfunction propagateSuspenseContextChange(\n  workInProgress: Fiber,\n  firstChild: null | Fiber,\n  renderLanes: Lanes,\n): void {\n  // Mark any Suspense boundaries with fallbacks as having work to do.\n  // If they were previously forced into fallbacks, they may now be able\n  // to unblock.\n  let node = firstChild;\n  while (node !== null) {\n    if (node.tag === SuspenseComponent) {\n      const state: SuspenseState | null = node.memoizedState;\n      if (state !== null) {\n        scheduleWorkOnFiber(node, renderLanes);\n      }\n    } else if (node.tag === SuspenseListComponent) {\n      // If the tail is hidden there might not be an Suspense boundaries\n      // to schedule work on. In this case we have to schedule it on the\n      // list itself.\n      // We don't have to traverse to the children of the list since\n      // the list will propagate the change when it rerenders.\n      scheduleWorkOnFiber(node, renderLanes);\n    } else if (node.child !== null) {\n      node.child.return = node;\n      node = node.child;\n      continue;\n    }\n    if (node === workInProgress) {\n      return;\n    }\n    while (node.sibling === null) {\n      if (node.return === null || node.return === workInProgress) {\n        return;\n      }\n      node = node.return;\n    }\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n}\n\nfunction findLastContentRow(firstChild: null | Fiber): null | Fiber {\n  // This is going to find the last row among these children that is already\n  // showing content on the screen, as opposed to being in fallback state or\n  // new. If a row has multiple Suspense boundaries, any of them being in the\n  // fallback state, counts as the whole row being in a fallback state.\n  // Note that the \"rows\" will be workInProgress, but any nested children\n  // will still be current since we haven't rendered them yet. The mounted\n  // order may not be the same as the new order. We use the new order.\n  let row = firstChild;\n  let lastContentRow: null | Fiber = null;\n  while (row !== null) {\n    const currentRow = row.alternate;\n    // New rows can't be content rows.\n    if (currentRow !== null && findFirstSuspended(currentRow) === null) {\n      lastContentRow = row;\n    }\n    row = row.sibling;\n  }\n  return lastContentRow;\n}\n\ntype SuspenseListRevealOrder = 'forwards' | 'backwards' | 'together' | void;\n\nfunction validateRevealOrder(revealOrder: SuspenseListRevealOrder) {\n  if (__DEV__) {\n    if (\n      revealOrder !== undefined &&\n      revealOrder !== 'forwards' &&\n      revealOrder !== 'backwards' &&\n      revealOrder !== 'together' &&\n      !didWarnAboutRevealOrder[revealOrder]\n    ) {\n      didWarnAboutRevealOrder[revealOrder] = true;\n      if (typeof revealOrder === 'string') {\n        switch (revealOrder.toLowerCase()) {\n          case 'together':\n          case 'forwards':\n          case 'backwards': {\n            console.error(\n              '\"%s\" is not a valid value for revealOrder on <SuspenseList />. ' +\n                'Use lowercase \"%s\" instead.',\n              revealOrder,\n              revealOrder.toLowerCase(),\n            );\n            break;\n          }\n          case 'forward':\n          case 'backward': {\n            console.error(\n              '\"%s\" is not a valid value for revealOrder on <SuspenseList />. ' +\n                'React uses the -s suffix in the spelling. Use \"%ss\" instead.',\n              revealOrder,\n              revealOrder.toLowerCase(),\n            );\n            break;\n          }\n          default:\n            console.error(\n              '\"%s\" is not a supported revealOrder on <SuspenseList />. ' +\n                'Did you mean \"together\", \"forwards\" or \"backwards\"?',\n              revealOrder,\n            );\n            break;\n        }\n      } else {\n        console.error(\n          '%s is not a supported value for revealOrder on <SuspenseList />. ' +\n            'Did you mean \"together\", \"forwards\" or \"backwards\"?',\n          revealOrder,\n        );\n      }\n    }\n  }\n}\n\nfunction validateTailOptions(\n  tailMode: SuspenseListTailMode,\n  revealOrder: SuspenseListRevealOrder,\n) {\n  if (__DEV__) {\n    if (tailMode !== undefined && !didWarnAboutTailOptions[tailMode]) {\n      if (tailMode !== 'collapsed' && tailMode !== 'hidden') {\n        didWarnAboutTailOptions[tailMode] = true;\n        console.error(\n          '\"%s\" is not a supported value for tail on <SuspenseList />. ' +\n            'Did you mean \"collapsed\" or \"hidden\"?',\n          tailMode,\n        );\n      } else if (revealOrder !== 'forwards' && revealOrder !== 'backwards') {\n        didWarnAboutTailOptions[tailMode] = true;\n        console.error(\n          '<SuspenseList tail=\"%s\" /> is only valid if revealOrder is ' +\n            '\"forwards\" or \"backwards\". ' +\n            'Did you mean to specify revealOrder=\"forwards\"?',\n          tailMode,\n        );\n      }\n    }\n  }\n}\n\nfunction validateSuspenseListNestedChild(childSlot: mixed, index: number) {\n  if (__DEV__) {\n    const isAnArray = isArray(childSlot);\n    const isIterable =\n      !isAnArray && typeof getIteratorFn(childSlot) === 'function';\n    if (isAnArray || isIterable) {\n      const type = isAnArray ? 'array' : 'iterable';\n      console.error(\n        'A nested %s was passed to row #%s in <SuspenseList />. Wrap it in ' +\n          'an additional SuspenseList to configure its revealOrder: ' +\n          '<SuspenseList revealOrder=...> ... ' +\n          '<SuspenseList revealOrder=...>{%s}</SuspenseList> ... ' +\n          '</SuspenseList>',\n        type,\n        index,\n        type,\n      );\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction validateSuspenseListChildren(\n  children: mixed,\n  revealOrder: SuspenseListRevealOrder,\n) {\n  if (__DEV__) {\n    if (\n      (revealOrder === 'forwards' || revealOrder === 'backwards') &&\n      children !== undefined &&\n      children !== null &&\n      children !== false\n    ) {\n      if (isArray(children)) {\n        for (let i = 0; i < children.length; i++) {\n          if (!validateSuspenseListNestedChild(children[i], i)) {\n            return;\n          }\n        }\n      } else {\n        const iteratorFn = getIteratorFn(children);\n        if (typeof iteratorFn === 'function') {\n          const childrenIterator = iteratorFn.call(children);\n          if (childrenIterator) {\n            let step = childrenIterator.next();\n            let i = 0;\n            for (; !step.done; step = childrenIterator.next()) {\n              if (!validateSuspenseListNestedChild(step.value, i)) {\n                return;\n              }\n              i++;\n            }\n          }\n        } else {\n          console.error(\n            'A single row was passed to a <SuspenseList revealOrder=\"%s\" />. ' +\n              'This is not useful since it needs multiple rows. ' +\n              'Did you mean to pass multiple children or an array?',\n            revealOrder,\n          );\n        }\n      }\n    }\n  }\n}\n\nfunction initSuspenseListRenderState(\n  workInProgress: Fiber,\n  isBackwards: boolean,\n  tail: null | Fiber,\n  lastContentRow: null | Fiber,\n  tailMode: SuspenseListTailMode,\n): void {\n  const renderState: null | SuspenseListRenderState =\n    workInProgress.memoizedState;\n  if (renderState === null) {\n    workInProgress.memoizedState = ({\n      isBackwards: isBackwards,\n      rendering: null,\n      renderingStartTime: 0,\n      last: lastContentRow,\n      tail: tail,\n      tailMode: tailMode,\n    }: SuspenseListRenderState);\n  } else {\n    // We can reuse the existing object from previous renders.\n    renderState.isBackwards = isBackwards;\n    renderState.rendering = null;\n    renderState.renderingStartTime = 0;\n    renderState.last = lastContentRow;\n    renderState.tail = tail;\n    renderState.tailMode = tailMode;\n  }\n}\n\n// This can end up rendering this component multiple passes.\n// The first pass splits the children fibers into two sets. A head and tail.\n// We first render the head. If anything is in fallback state, we do another\n// pass through beginWork to rerender all children (including the tail) with\n// the force suspend context. If the first render didn't have anything in\n// in fallback state. Then we render each row in the tail one-by-one.\n// That happens in the completeWork phase without going back to beginWork.\nfunction updateSuspenseListComponent(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderLanes: Lanes,\n) {\n  const nextProps = workInProgress.pendingProps;\n  const revealOrder: SuspenseListRevealOrder = nextProps.revealOrder;\n  const tailMode: SuspenseListTailMode = nextProps.tail;\n  const newChildren = nextProps.children;\n\n  validateRevealOrder(revealOrder);\n  validateTailOptions(tailMode, revealOrder);\n  validateSuspenseListChildren(newChildren, revealOrder);\n\n  reconcileChildren(current, workInProgress, newChildren, renderLanes);\n\n  let suspenseContext: SuspenseContext = suspenseStackCursor.current;\n\n  const shouldForceFallback = hasSuspenseContext(\n    suspenseContext,\n    (ForceSuspenseFallback: SuspenseContext),\n  );\n  if (shouldForceFallback) {\n    suspenseContext = setShallowSuspenseContext(\n      suspenseContext,\n      ForceSuspenseFallback,\n    );\n    workInProgress.flags |= DidCapture;\n  } else {\n    const didSuspendBefore =\n      current !== null && (current.flags & DidCapture) !== NoFlags;\n    if (didSuspendBefore) {\n      // If we previously forced a fallback, we need to schedule work\n      // on any nested boundaries to let them know to try to render\n      // again. This is the same as context updating.\n      propagateSuspenseContextChange(\n        workInProgress,\n        workInProgress.child,\n        renderLanes,\n      );\n    }\n    suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);\n  }\n  pushSuspenseContext(workInProgress, suspenseContext);\n\n  if ((workInProgress.mode & ConcurrentMode) === NoMode) {\n    // In legacy mode, SuspenseList doesn't work so we just\n    // use make it a noop by treating it as the default revealOrder.\n    workInProgress.memoizedState = null;\n  } else {\n    switch (revealOrder) {\n      case 'forwards': {\n        const lastContentRow = findLastContentRow(workInProgress.child);\n        let tail;\n        if (lastContentRow === null) {\n          // The whole list is part of the tail.\n          // TODO: We could fast path by just rendering the tail now.\n          tail = workInProgress.child;\n          workInProgress.child = null;\n        } else {\n          // Disconnect the tail rows after the content row.\n          // We're going to render them separately later.\n          tail = lastContentRow.sibling;\n          lastContentRow.sibling = null;\n        }\n        initSuspenseListRenderState(\n          workInProgress,\n          false, // isBackwards\n          tail,\n          lastContentRow,\n          tailMode,\n        );\n        break;\n      }\n      case 'backwards': {\n        // We're going to find the first row that has existing content.\n        // At the same time we're going to reverse the list of everything\n        // we pass in the meantime. That's going to be our tail in reverse\n        // order.\n        let tail = null;\n        let row = workInProgress.child;\n        workInProgress.child = null;\n        while (row !== null) {\n          const currentRow = row.alternate;\n          // New rows can't be content rows.\n          if (currentRow !== null && findFirstSuspended(currentRow) === null) {\n            // This is the beginning of the main content.\n            workInProgress.child = row;\n            break;\n          }\n          const nextRow = row.sibling;\n          row.sibling = tail;\n          tail = row;\n          row = nextRow;\n        }\n        // TODO: If workInProgress.child is null, we can continue on the tail immediately.\n        initSuspenseListRenderState(\n          workInProgress,\n          true, // isBackwards\n          tail,\n          null, // last\n          tailMode,\n        );\n        break;\n      }\n      case 'together': {\n        initSuspenseListRenderState(\n          workInProgress,\n          false, // isBackwards\n          null, // tail\n          null, // last\n          undefined,\n        );\n        break;\n      }\n      default: {\n        // The default reveal order is the same as not having\n        // a boundary.\n        workInProgress.memoizedState = null;\n      }\n    }\n  }\n  return workInProgress.child;\n}\n\nfunction updatePortalComponent(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderLanes: Lanes,\n) {\n  pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n  const nextChildren = workInProgress.pendingProps;\n  if (current === null) {\n    // Portals are special because we don't append the children during mount\n    // but at commit. Therefore we need to track insertions which the normal\n    // flow doesn't do during mount. This doesn't happen at the root because\n    // the root always starts with a \"current\" with a null child.\n    // TODO: Consider unifying this with how the root works.\n    workInProgress.child = reconcileChildFibers(\n      workInProgress,\n      null,\n      nextChildren,\n      renderLanes,\n    );\n  } else {\n    reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  }\n  return workInProgress.child;\n}\n\nlet hasWarnedAboutUsingNoValuePropOnContextProvider = false;\n\nfunction updateContextProvider(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderLanes: Lanes,\n) {\n  const providerType: ReactProviderType<any> = workInProgress.type;\n  const context: ReactContext<any> = providerType._context;\n\n  const newProps = workInProgress.pendingProps;\n  const oldProps = workInProgress.memoizedProps;\n\n  const newValue = newProps.value;\n\n  if (__DEV__) {\n    if (!('value' in newProps)) {\n      if (!hasWarnedAboutUsingNoValuePropOnContextProvider) {\n        hasWarnedAboutUsingNoValuePropOnContextProvider = true;\n        console.error(\n          'The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?',\n        );\n      }\n    }\n    const providerPropTypes = workInProgress.type.propTypes;\n\n    if (providerPropTypes) {\n      checkPropTypes(providerPropTypes, newProps, 'prop', 'Context.Provider');\n    }\n  }\n\n  pushProvider(workInProgress, context, newValue);\n\n  if (enableLazyContextPropagation) {\n    // In the lazy propagation implementation, we don't scan for matching\n    // consumers until something bails out, because until something bails out\n    // we're going to visit those nodes, anyway. The trade-off is that it shifts\n    // responsibility to the consumer to track whether something has changed.\n  } else {\n    if (oldProps !== null) {\n      const oldValue = oldProps.value;\n      if (is(oldValue, newValue)) {\n        // No change. Bailout early if children are the same.\n        if (\n          oldProps.children === newProps.children &&\n          !hasLegacyContextChanged()\n        ) {\n          return bailoutOnAlreadyFinishedWork(\n            current,\n            workInProgress,\n            renderLanes,\n          );\n        }\n      } else {\n        // The context value changed. Search for matching consumers and schedule\n        // them to update.\n        propagateContextChange(workInProgress, context, renderLanes);\n      }\n    }\n  }\n\n  const newChildren = newProps.children;\n  reconcileChildren(current, workInProgress, newChildren, renderLanes);\n  return workInProgress.child;\n}\n\nlet hasWarnedAboutUsingContextAsConsumer = false;\n\nfunction updateContextConsumer(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderLanes: Lanes,\n) {\n  let context: ReactContext<any> = workInProgress.type;\n  // The logic below for Context differs depending on PROD or DEV mode. In\n  // DEV mode, we create a separate object for Context.Consumer that acts\n  // like a proxy to Context. This proxy object adds unnecessary code in PROD\n  // so we use the old behaviour (Context.Consumer references Context) to\n  // reduce size and overhead. The separate object references context via\n  // a property called \"_context\", which also gives us the ability to check\n  // in DEV mode if this property exists or not and warn if it does not.\n  if (__DEV__) {\n    if ((context: any)._context === undefined) {\n      // This may be because it's a Context (rather than a Consumer).\n      // Or it may be because it's older React where they're the same thing.\n      // We only want to warn if we're sure it's a new React.\n      if (context !== context.Consumer) {\n        if (!hasWarnedAboutUsingContextAsConsumer) {\n          hasWarnedAboutUsingContextAsConsumer = true;\n          console.error(\n            'Rendering <Context> directly is not supported and will be removed in ' +\n              'a future major release. Did you mean to render <Context.Consumer> instead?',\n          );\n        }\n      }\n    } else {\n      context = (context: any)._context;\n    }\n  }\n  const newProps = workInProgress.pendingProps;\n  const render = newProps.children;\n\n  if (__DEV__) {\n    if (typeof render !== 'function') {\n      console.error(\n        'A context consumer was rendered with multiple children, or a child ' +\n          \"that isn't a function. A context consumer expects a single child \" +\n          'that is a function. If you did pass a function, make sure there ' +\n          'is no trailing or leading whitespace around it.',\n      );\n    }\n  }\n\n  prepareToReadContext(workInProgress, renderLanes);\n  const newValue = readContext(context);\n  if (enableSchedulingProfiler) {\n    markComponentRenderStarted(workInProgress);\n  }\n  let newChildren;\n  if (__DEV__) {\n    ReactCurrentOwner.current = workInProgress;\n    setIsRendering(true);\n    newChildren = render(newValue);\n    setIsRendering(false);\n  } else {\n    newChildren = render(newValue);\n  }\n  if (enableSchedulingProfiler) {\n    markComponentRenderStopped();\n  }\n\n  // React DevTools reads this flag.\n  workInProgress.flags |= PerformedWork;\n  reconcileChildren(current, workInProgress, newChildren, renderLanes);\n  return workInProgress.child;\n}\n\nfunction updateScopeComponent(current, workInProgress, renderLanes) {\n  const nextProps = workInProgress.pendingProps;\n  const nextChildren = nextProps.children;\n\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\nexport function markWorkInProgressReceivedUpdate() {\n  didReceiveUpdate = true;\n}\n\nexport function checkIfWorkInProgressReceivedUpdate() {\n  return didReceiveUpdate;\n}\n\nfunction bailoutOnAlreadyFinishedWork(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderLanes: Lanes,\n): Fiber | null {\n  if (current !== null) {\n    // Reuse previous dependencies\n    workInProgress.dependencies = current.dependencies;\n  }\n\n  if (enableProfilerTimer) {\n    // Don't update \"base\" render times for bailouts.\n    stopProfilerTimerIfRunning(workInProgress);\n  }\n\n  markSkippedUpdateLanes(workInProgress.lanes);\n\n  // Check if the children have any pending work.\n  if (!includesSomeLane(renderLanes, workInProgress.childLanes)) {\n    // The children don't have any work either. We can skip them.\n    // TODO: Once we add back resuming, we should check if the children are\n    // a work-in-progress set. If so, we need to transfer their effects.\n\n    if (enableLazyContextPropagation && current !== null) {\n      // Before bailing out, check if there are any context changes in\n      // the children.\n      lazilyPropagateParentContextChanges(current, workInProgress, renderLanes);\n      if (!includesSomeLane(renderLanes, workInProgress.childLanes)) {\n        return null;\n      }\n    } else {\n      return null;\n    }\n  }\n\n  // This fiber doesn't have work, but its subtree does. Clone the child\n  // fibers and continue.\n  cloneChildFibers(current, workInProgress);\n  return workInProgress.child;\n}\n\nfunction remountFiber(\n  current: Fiber,\n  oldWorkInProgress: Fiber,\n  newWorkInProgress: Fiber,\n): Fiber | null {\n  if (__DEV__) {\n    const returnFiber = oldWorkInProgress.return;\n    if (returnFiber === null) {\n      // eslint-disable-next-line react-internal/prod-error-codes\n      throw new Error('Cannot swap the root fiber.');\n    }\n\n    // Disconnect from the old current.\n    // It will get deleted.\n    current.alternate = null;\n    oldWorkInProgress.alternate = null;\n\n    // Connect to the new tree.\n    newWorkInProgress.index = oldWorkInProgress.index;\n    newWorkInProgress.sibling = oldWorkInProgress.sibling;\n    newWorkInProgress.return = oldWorkInProgress.return;\n    newWorkInProgress.ref = oldWorkInProgress.ref;\n\n    // Replace the child/sibling pointers above it.\n    if (oldWorkInProgress === returnFiber.child) {\n      returnFiber.child = newWorkInProgress;\n    } else {\n      let prevSibling = returnFiber.child;\n      if (prevSibling === null) {\n        // eslint-disable-next-line react-internal/prod-error-codes\n        throw new Error('Expected parent to have a child.');\n      }\n      while (prevSibling.sibling !== oldWorkInProgress) {\n        prevSibling = prevSibling.sibling;\n        if (prevSibling === null) {\n          // eslint-disable-next-line react-internal/prod-error-codes\n          throw new Error('Expected to find the previous sibling.');\n        }\n      }\n      prevSibling.sibling = newWorkInProgress;\n    }\n\n    // Delete the old fiber and place the new one.\n    // Since the old fiber is disconnected, we have to schedule it manually.\n    const deletions = returnFiber.deletions;\n    if (deletions === null) {\n      returnFiber.deletions = [current];\n      returnFiber.flags |= ChildDeletion;\n    } else {\n      deletions.push(current);\n    }\n\n    newWorkInProgress.flags |= Placement;\n\n    // Restart work from the new fiber.\n    return newWorkInProgress;\n  } else {\n    throw new Error(\n      'Did not expect this call in production. ' +\n        'This is a bug in React. Please file an issue.',\n    );\n  }\n}\n\nfunction checkScheduledUpdateOrContext(\n  current: Fiber,\n  renderLanes: Lanes,\n): boolean {\n  // Before performing an early bailout, we must check if there are pending\n  // updates or context.\n  const updateLanes = current.lanes;\n  if (includesSomeLane(updateLanes, renderLanes)) {\n    return true;\n  }\n  // No pending update, but because context is propagated lazily, we need\n  // to check for a context change before we bail out.\n  if (enableLazyContextPropagation) {\n    const dependencies = current.dependencies;\n    if (dependencies !== null && checkIfContextChanged(dependencies)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction attemptEarlyBailoutIfNoScheduledUpdate(\n  current: Fiber,\n  workInProgress: Fiber,\n  renderLanes: Lanes,\n) {\n  // This fiber does not have any pending work. Bailout without entering\n  // the begin phase. There's still some bookkeeping we that needs to be done\n  // in this optimized path, mostly pushing stuff onto the stack.\n  switch (workInProgress.tag) {\n    case HostRoot:\n      pushHostRootContext(workInProgress);\n      if (enableCache) {\n        const root: FiberRoot = workInProgress.stateNode;\n        const cache: Cache = current.memoizedState.cache;\n        pushCacheProvider(workInProgress, cache);\n        pushRootCachePool(root);\n      }\n      resetHydrationState();\n      break;\n    case HostComponent:\n      pushHostContext(workInProgress);\n      break;\n    case ClassComponent: {\n      const Component = workInProgress.type;\n      if (isLegacyContextProvider(Component)) {\n        pushLegacyContextProvider(workInProgress);\n      }\n      break;\n    }\n    case HostPortal:\n      pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n      break;\n    case ContextProvider: {\n      const newValue = workInProgress.memoizedProps.value;\n      const context: ReactContext<any> = workInProgress.type._context;\n      pushProvider(workInProgress, context, newValue);\n      break;\n    }\n    case Profiler:\n      if (enableProfilerTimer) {\n        // Profiler should only call onRender when one of its descendants actually rendered.\n        const hasChildWork = includesSomeLane(\n          renderLanes,\n          workInProgress.childLanes,\n        );\n        if (hasChildWork) {\n          workInProgress.flags |= Update;\n        }\n\n        if (enableProfilerCommitHooks) {\n          // Reset effect durations for the next eventual effect phase.\n          // These are reset during render to allow the DevTools commit hook a chance to read them,\n          const stateNode = workInProgress.stateNode;\n          stateNode.effectDuration = 0;\n          stateNode.passiveEffectDuration = 0;\n        }\n      }\n      break;\n    case SuspenseComponent: {\n      const state: SuspenseState | null = workInProgress.memoizedState;\n      if (state !== null) {\n        if (enableSuspenseServerRenderer) {\n          if (state.dehydrated !== null) {\n            pushSuspenseContext(\n              workInProgress,\n              setDefaultShallowSuspenseContext(suspenseStackCursor.current),\n            );\n            // We know that this component will suspend again because if it has\n            // been unsuspended it has committed as a resolved Suspense component.\n            // If it needs to be retried, it should have work scheduled on it.\n            workInProgress.flags |= DidCapture;\n            // We should never render the children of a dehydrated boundary until we\n            // upgrade it. We return null instead of bailoutOnAlreadyFinishedWork.\n            return null;\n          }\n        }\n\n        // If this boundary is currently timed out, we need to decide\n        // whether to retry the primary children, or to skip over it and\n        // go straight to the fallback. Check the priority of the primary\n        // child fragment.\n        const primaryChildFragment: Fiber = (workInProgress.child: any);\n        const primaryChildLanes = primaryChildFragment.childLanes;\n        if (includesSomeLane(renderLanes, primaryChildLanes)) {\n          // The primary children have pending work. Use the normal path\n          // to attempt to render the primary children again.\n          return updateSuspenseComponent(current, workInProgress, renderLanes);\n        } else {\n          // The primary child fragment does not have pending work marked\n          // on it\n          pushSuspenseContext(\n            workInProgress,\n            setDefaultShallowSuspenseContext(suspenseStackCursor.current),\n          );\n          // The primary children do not have pending work with sufficient\n          // priority. Bailout.\n          const child = bailoutOnAlreadyFinishedWork(\n            current,\n            workInProgress,\n            renderLanes,\n          );\n          if (child !== null) {\n            // The fallback children have pending work. Skip over the\n            // primary children and work on the fallback.\n            return child.sibling;\n          } else {\n            // Note: We can return `null` here because we already checked\n            // whether there were nested context consumers, via the call to\n            // `bailoutOnAlreadyFinishedWork` above.\n            return null;\n          }\n        }\n      } else {\n        pushSuspenseContext(\n          workInProgress,\n          setDefaultShallowSuspenseContext(suspenseStackCursor.current),\n        );\n      }\n      break;\n    }\n    case SuspenseListComponent: {\n      const didSuspendBefore = (current.flags & DidCapture) !== NoFlags;\n\n      let hasChildWork = includesSomeLane(\n        renderLanes,\n        workInProgress.childLanes,\n      );\n\n      if (enableLazyContextPropagation && !hasChildWork) {\n        // Context changes may not have been propagated yet. We need to do\n        // that now, before we can decide whether to bail out.\n        // TODO: We use `childLanes` as a heuristic for whether there is\n        // remaining work in a few places, including\n        // `bailoutOnAlreadyFinishedWork` and\n        // `updateDehydratedSuspenseComponent`. We should maybe extract this\n        // into a dedicated function.\n        lazilyPropagateParentContextChanges(\n          current,\n          workInProgress,\n          renderLanes,\n        );\n        hasChildWork = includesSomeLane(renderLanes, workInProgress.childLanes);\n      }\n\n      if (didSuspendBefore) {\n        if (hasChildWork) {\n          // If something was in fallback state last time, and we have all the\n          // same children then we're still in progressive loading state.\n          // Something might get unblocked by state updates or retries in the\n          // tree which will affect the tail. So we need to use the normal\n          // path to compute the correct tail.\n          return updateSuspenseListComponent(\n            current,\n            workInProgress,\n            renderLanes,\n          );\n        }\n        // If none of the children had any work, that means that none of\n        // them got retried so they'll still be blocked in the same way\n        // as before. We can fast bail out.\n        workInProgress.flags |= DidCapture;\n      }\n\n      // If nothing suspended before and we're rendering the same children,\n      // then the tail doesn't matter. Anything new that suspends will work\n      // in the \"together\" mode, so we can continue from the state we had.\n      const renderState = workInProgress.memoizedState;\n      if (renderState !== null) {\n        // Reset to the \"together\" mode in case we've started a different\n        // update in the past but didn't complete it.\n        renderState.rendering = null;\n        renderState.tail = null;\n        renderState.lastEffect = null;\n      }\n      pushSuspenseContext(workInProgress, suspenseStackCursor.current);\n\n      if (hasChildWork) {\n        break;\n      } else {\n        // If none of the children had any work, that means that none of\n        // them got retried so they'll still be blocked in the same way\n        // as before. We can fast bail out.\n        return null;\n      }\n    }\n    case OffscreenComponent:\n    case LegacyHiddenComponent: {\n      // Need to check if the tree still needs to be deferred. This is\n      // almost identical to the logic used in the normal update path,\n      // so we'll just enter that. The only difference is we'll bail out\n      // at the next level instead of this one, because the child props\n      // have not changed. Which is fine.\n      // TODO: Probably should refactor `beginWork` to split the bailout\n      // path from the normal path. I'm tempted to do a labeled break here\n      // but I won't :)\n      workInProgress.lanes = NoLanes;\n      return updateOffscreenComponent(current, workInProgress, renderLanes);\n    }\n    case CacheComponent: {\n      if (enableCache) {\n        const cache: Cache = current.memoizedState.cache;\n        pushCacheProvider(workInProgress, cache);\n      }\n      break;\n    }\n  }\n  return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n}\n\nfunction beginWork(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderLanes: Lanes,\n): Fiber | null {\n  if (__DEV__) {\n    if (workInProgress._debugNeedsRemount && current !== null) {\n      // This will restart the begin phase with a new fiber.\n      return remountFiber(\n        current,\n        workInProgress,\n        createFiberFromTypeAndProps(\n          workInProgress.type,\n          workInProgress.key,\n          workInProgress.pendingProps,\n          workInProgress._debugOwner || null,\n          workInProgress.mode,\n          workInProgress.lanes,\n        ),\n      );\n    }\n  }\n\n  if (current !== null) {\n    const oldProps = current.memoizedProps;\n    const newProps = workInProgress.pendingProps;\n\n    if (\n      oldProps !== newProps ||\n      hasLegacyContextChanged() ||\n      // Force a re-render if the implementation changed due to hot reload:\n      (__DEV__ ? workInProgress.type !== current.type : false)\n    ) {\n      // If props or context changed, mark the fiber as having performed work.\n      // This may be unset if the props are determined to be equal later (memo).\n      didReceiveUpdate = true;\n    } else {\n      // Neither props nor legacy context changes. Check if there's a pending\n      // update or context change.\n      const hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(\n        current,\n        renderLanes,\n      );\n      if (\n        !hasScheduledUpdateOrContext &&\n        // If this is the second pass of an error or suspense boundary, there\n        // may not be work scheduled on `current`, so we check for this flag.\n        (workInProgress.flags & DidCapture) === NoFlags\n      ) {\n        // No pending updates or context. Bail out now.\n        didReceiveUpdate = false;\n        return attemptEarlyBailoutIfNoScheduledUpdate(\n          current,\n          workInProgress,\n          renderLanes,\n        );\n      }\n      if ((current.flags & ForceUpdateForLegacySuspense) !== NoFlags) {\n        // This is a special case that only exists for legacy mode.\n        // See https://github.com/facebook/react/pull/19216.\n        didReceiveUpdate = true;\n      } else {\n        // An update was scheduled on this fiber, but there are no new props\n        // nor legacy context. Set this to false. If an update queue or context\n        // consumer produces a changed value, it will set this to true. Otherwise,\n        // the component will assume the children have not changed and bail out.\n        didReceiveUpdate = false;\n      }\n    }\n  } else {\n    didReceiveUpdate = false;\n\n    if (getIsHydrating() && isForkedChild(workInProgress)) {\n      // Check if this child belongs to a list of muliple children in\n      // its parent.\n      //\n      // In a true multi-threaded implementation, we would render children on\n      // parallel threads. This would represent the beginning of a new render\n      // thread for this subtree.\n      //\n      // We only use this for id generation during hydration, which is why the\n      // logic is located in this special branch.\n      const slotIndex = workInProgress.index;\n      const numberOfForks = getForksAtLevel(workInProgress);\n      pushTreeId(workInProgress, numberOfForks, slotIndex);\n    }\n  }\n\n  // Before entering the begin phase, clear pending update priority.\n  // TODO: This assumes that we're about to evaluate the component and process\n  // the update queue. However, there's an exception: SimpleMemoComponent\n  // sometimes bails out later in the begin phase. This indicates that we should\n  // move this assignment out of the common path and into each branch.\n  workInProgress.lanes = NoLanes;\n\n  switch (workInProgress.tag) {\n    case IndeterminateComponent: {\n      return mountIndeterminateComponent(\n        current,\n        workInProgress,\n        workInProgress.type,\n        renderLanes,\n      );\n    }\n    case LazyComponent: {\n      const elementType = workInProgress.elementType;\n      return mountLazyComponent(\n        current,\n        workInProgress,\n        elementType,\n        renderLanes,\n      );\n    }\n    case FunctionComponent: {\n      const Component = workInProgress.type;\n      const unresolvedProps = workInProgress.pendingProps;\n      const resolvedProps =\n        workInProgress.elementType === Component\n          ? unresolvedProps\n          : resolveDefaultProps(Component, unresolvedProps);\n      return updateFunctionComponent(\n        current,\n        workInProgress,\n        Component,\n        resolvedProps,\n        renderLanes,\n      );\n    }\n    case ClassComponent: {\n      const Component = workInProgress.type;\n      const unresolvedProps = workInProgress.pendingProps;\n      const resolvedProps =\n        workInProgress.elementType === Component\n          ? unresolvedProps\n          : resolveDefaultProps(Component, unresolvedProps);\n      return updateClassComponent(\n        current,\n        workInProgress,\n        Component,\n        resolvedProps,\n        renderLanes,\n      );\n    }\n    case HostRoot:\n      return updateHostRoot(current, workInProgress, renderLanes);\n    case HostComponent:\n      return updateHostComponent(current, workInProgress, renderLanes);\n    case HostText:\n      return updateHostText(current, workInProgress);\n    case SuspenseComponent:\n      return updateSuspenseComponent(current, workInProgress, renderLanes);\n    case HostPortal:\n      return updatePortalComponent(current, workInProgress, renderLanes);\n    case ForwardRef: {\n      const type = workInProgress.type;\n      const unresolvedProps = workInProgress.pendingProps;\n      const resolvedProps =\n        workInProgress.elementType === type\n          ? unresolvedProps\n          : resolveDefaultProps(type, unresolvedProps);\n      return updateForwardRef(\n        current,\n        workInProgress,\n        type,\n        resolvedProps,\n        renderLanes,\n      );\n    }\n    case Fragment:\n      return updateFragment(current, workInProgress, renderLanes);\n    case Mode:\n      return updateMode(current, workInProgress, renderLanes);\n    case Profiler:\n      return updateProfiler(current, workInProgress, renderLanes);\n    case ContextProvider:\n      return updateContextProvider(current, workInProgress, renderLanes);\n    case ContextConsumer:\n      return updateContextConsumer(current, workInProgress, renderLanes);\n    case MemoComponent: {\n      const type = workInProgress.type;\n      const unresolvedProps = workInProgress.pendingProps;\n      // Resolve outer props first, then resolve inner props.\n      let resolvedProps = resolveDefaultProps(type, unresolvedProps);\n      if (__DEV__) {\n        if (workInProgress.type !== workInProgress.elementType) {\n          const outerPropTypes = type.propTypes;\n          if (outerPropTypes) {\n            checkPropTypes(\n              outerPropTypes,\n              resolvedProps, // Resolved for outer only\n              'prop',\n              getComponentNameFromType(type),\n            );\n          }\n        }\n      }\n      resolvedProps = resolveDefaultProps(type.type, resolvedProps);\n      return updateMemoComponent(\n        current,\n        workInProgress,\n        type,\n        resolvedProps,\n        renderLanes,\n      );\n    }\n    case SimpleMemoComponent: {\n      return updateSimpleMemoComponent(\n        current,\n        workInProgress,\n        workInProgress.type,\n        workInProgress.pendingProps,\n        renderLanes,\n      );\n    }\n    case IncompleteClassComponent: {\n      const Component = workInProgress.type;\n      const unresolvedProps = workInProgress.pendingProps;\n      const resolvedProps =\n        workInProgress.elementType === Component\n          ? unresolvedProps\n          : resolveDefaultProps(Component, unresolvedProps);\n      return mountIncompleteClassComponent(\n        current,\n        workInProgress,\n        Component,\n        resolvedProps,\n        renderLanes,\n      );\n    }\n    case SuspenseListComponent: {\n      return updateSuspenseListComponent(current, workInProgress, renderLanes);\n    }\n    case ScopeComponent: {\n      if (enableScopeAPI) {\n        return updateScopeComponent(current, workInProgress, renderLanes);\n      }\n      break;\n    }\n    case OffscreenComponent: {\n      return updateOffscreenComponent(current, workInProgress, renderLanes);\n    }\n    case LegacyHiddenComponent: {\n      return updateLegacyHiddenComponent(current, workInProgress, renderLanes);\n    }\n    case CacheComponent: {\n      if (enableCache) {\n        return updateCacheComponent(current, workInProgress, renderLanes);\n      }\n      break;\n    }\n  }\n\n  throw new Error(\n    `Unknown unit of work tag (${workInProgress.tag}). This error is likely caused by a bug in ` +\n      'React. Please file an issue.',\n  );\n}\n\nexport {beginWork};\n"]},"metadata":{},"sourceType":"module"}