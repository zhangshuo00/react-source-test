{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport getActiveElement from './getActiveElement';\nimport { getOffsets, setOffsets } from './ReactDOMSelection';\nimport { ELEMENT_NODE, TEXT_NODE } from '../shared/HTMLNodeType';\n\nfunction isTextNode(node) {\n  return node && node.nodeType === TEXT_NODE;\n}\n\nfunction containsNode(outerNode, innerNode) {\n  if (!outerNode || !innerNode) {\n    return false;\n  } else if (outerNode === innerNode) {\n    return true;\n  } else if (isTextNode(outerNode)) {\n    return false;\n  } else if (isTextNode(innerNode)) {\n    return containsNode(outerNode, innerNode.parentNode);\n  } else if ('contains' in outerNode) {\n    return outerNode.contains(innerNode);\n  } else if (outerNode.compareDocumentPosition) {\n    return !!(outerNode.compareDocumentPosition(innerNode) & 16);\n  } else {\n    return false;\n  }\n}\n\nfunction isInDocument(node) {\n  return node && node.ownerDocument && containsNode(node.ownerDocument.documentElement, node);\n}\n\nfunction isSameOriginFrame(iframe) {\n  try {\n    // Accessing the contentDocument of a HTMLIframeElement can cause the browser\n    // to throw, e.g. if it has a cross-origin src attribute.\n    // Safari will show an error in the console when the access results in \"Blocked a frame with origin\". e.g:\n    // iframe.contentDocument.defaultView;\n    // A safety way is to access one of the cross origin properties: Window or Location\n    // Which might result in \"SecurityError\" DOM Exception and it is compatible to Safari.\n    // https://html.spec.whatwg.org/multipage/browsers.html#integration-with-idl\n    return typeof iframe.contentWindow.location.href === 'string';\n  } catch (err) {\n    return false;\n  }\n}\n\nfunction getActiveElementDeep() {\n  let win = window;\n  let element = getActiveElement();\n\n  while (element instanceof win.HTMLIFrameElement) {\n    if (isSameOriginFrame(element)) {\n      win = element.contentWindow;\n    } else {\n      return element;\n    }\n\n    element = getActiveElement(win.document);\n  }\n\n  return element;\n}\n/**\n * @ReactInputSelection: React input selection module. Based on Selection.js,\n * but modified to be suitable for react and has a couple of bug fixes (doesn't\n * assume buttons have range selections allowed).\n * Input selection module for React.\n */\n\n/**\n * @hasSelectionCapabilities: we get the element types that support selection\n * from https://html.spec.whatwg.org/#do-not-apply, looking at `selectionStart`\n * and `selectionEnd` rows.\n */\n\n\nexport function hasSelectionCapabilities(elem) {\n  const nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();\n  return nodeName && (nodeName === 'input' && (elem.type === 'text' || elem.type === 'search' || elem.type === 'tel' || elem.type === 'url' || elem.type === 'password') || nodeName === 'textarea' || elem.contentEditable === 'true');\n}\nexport function getSelectionInformation() {\n  const focusedElem = getActiveElementDeep();\n  return {\n    focusedElem: focusedElem,\n    selectionRange: hasSelectionCapabilities(focusedElem) ? getSelection(focusedElem) : null\n  };\n}\n/**\n * @restoreSelection: If any selection information was potentially lost,\n * restore it. This is useful when performing operations that could remove dom\n * nodes and place them back in, resulting in focus being lost.\n */\n\nexport function restoreSelection(priorSelectionInformation) {\n  const curFocusedElem = getActiveElementDeep();\n  const priorFocusedElem = priorSelectionInformation.focusedElem;\n  const priorSelectionRange = priorSelectionInformation.selectionRange;\n\n  if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {\n    if (priorSelectionRange !== null && hasSelectionCapabilities(priorFocusedElem)) {\n      setSelection(priorFocusedElem, priorSelectionRange);\n    } // Focusing a node can change the scroll position, which is undesirable\n\n\n    const ancestors = [];\n    let ancestor = priorFocusedElem;\n\n    while (ancestor = ancestor.parentNode) {\n      if (ancestor.nodeType === ELEMENT_NODE) {\n        ancestors.push({\n          element: ancestor,\n          left: ancestor.scrollLeft,\n          top: ancestor.scrollTop\n        });\n      }\n    }\n\n    if (typeof priorFocusedElem.focus === 'function') {\n      priorFocusedElem.focus();\n    }\n\n    for (let i = 0; i < ancestors.length; i++) {\n      const info = ancestors[i];\n      info.element.scrollLeft = info.left;\n      info.element.scrollTop = info.top;\n    }\n  }\n}\n/**\n * @getSelection: Gets the selection bounds of a focused textarea, input or\n * contentEditable node.\n * -@input: Look up selection bounds of this input\n * -@return {start: selectionStart, end: selectionEnd}\n */\n\nexport function getSelection(input) {\n  let selection;\n\n  if ('selectionStart' in input) {\n    // Modern browser with input or textarea.\n    selection = {\n      start: input.selectionStart,\n      end: input.selectionEnd\n    };\n  } else {\n    // Content editable or old IE textarea.\n    selection = getOffsets(input);\n  }\n\n  return selection || {\n    start: 0,\n    end: 0\n  };\n}\n/**\n * @setSelection: Sets the selection bounds of a textarea or input and focuses\n * the input.\n * -@input     Set selection bounds of this input or textarea\n * -@offsets   Object of same form that is returned from get*\n */\n\nexport function setSelection(input, offsets) {\n  const start = offsets.start;\n  let end = offsets.end;\n\n  if (end === undefined) {\n    end = start;\n  }\n\n  if ('selectionStart' in input) {\n    input.selectionStart = start;\n    input.selectionEnd = Math.min(end, input.value.length);\n  } else {\n    setOffsets(input, offsets);\n  }\n}","map":{"version":3,"sources":["/Users/zhangshuo/git/react-source-test/src/react/packages/react-dom/src/client/ReactInputSelection.js"],"names":["getActiveElement","getOffsets","setOffsets","ELEMENT_NODE","TEXT_NODE","isTextNode","node","nodeType","containsNode","outerNode","innerNode","parentNode","contains","compareDocumentPosition","isInDocument","ownerDocument","documentElement","isSameOriginFrame","iframe","contentWindow","location","href","err","getActiveElementDeep","win","window","element","HTMLIFrameElement","document","hasSelectionCapabilities","elem","nodeName","toLowerCase","type","contentEditable","getSelectionInformation","focusedElem","selectionRange","getSelection","restoreSelection","priorSelectionInformation","curFocusedElem","priorFocusedElem","priorSelectionRange","setSelection","ancestors","ancestor","push","left","scrollLeft","top","scrollTop","focus","i","length","info","input","selection","start","selectionStart","end","selectionEnd","offsets","undefined","Math","min","value"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport getActiveElement from './getActiveElement';\n\nimport {getOffsets, setOffsets} from './ReactDOMSelection';\nimport {ELEMENT_NODE, TEXT_NODE} from '../shared/HTMLNodeType';\n\nfunction isTextNode(node) {\n  return node && node.nodeType === TEXT_NODE;\n}\n\nfunction containsNode(outerNode, innerNode) {\n  if (!outerNode || !innerNode) {\n    return false;\n  } else if (outerNode === innerNode) {\n    return true;\n  } else if (isTextNode(outerNode)) {\n    return false;\n  } else if (isTextNode(innerNode)) {\n    return containsNode(outerNode, innerNode.parentNode);\n  } else if ('contains' in outerNode) {\n    return outerNode.contains(innerNode);\n  } else if (outerNode.compareDocumentPosition) {\n    return !!(outerNode.compareDocumentPosition(innerNode) & 16);\n  } else {\n    return false;\n  }\n}\n\nfunction isInDocument(node) {\n  return (\n    node &&\n    node.ownerDocument &&\n    containsNode(node.ownerDocument.documentElement, node)\n  );\n}\n\nfunction isSameOriginFrame(iframe) {\n  try {\n    // Accessing the contentDocument of a HTMLIframeElement can cause the browser\n    // to throw, e.g. if it has a cross-origin src attribute.\n    // Safari will show an error in the console when the access results in \"Blocked a frame with origin\". e.g:\n    // iframe.contentDocument.defaultView;\n    // A safety way is to access one of the cross origin properties: Window or Location\n    // Which might result in \"SecurityError\" DOM Exception and it is compatible to Safari.\n    // https://html.spec.whatwg.org/multipage/browsers.html#integration-with-idl\n\n    return typeof iframe.contentWindow.location.href === 'string';\n  } catch (err) {\n    return false;\n  }\n}\n\nfunction getActiveElementDeep() {\n  let win = window;\n  let element = getActiveElement();\n  while (element instanceof win.HTMLIFrameElement) {\n    if (isSameOriginFrame(element)) {\n      win = element.contentWindow;\n    } else {\n      return element;\n    }\n    element = getActiveElement(win.document);\n  }\n  return element;\n}\n\n/**\n * @ReactInputSelection: React input selection module. Based on Selection.js,\n * but modified to be suitable for react and has a couple of bug fixes (doesn't\n * assume buttons have range selections allowed).\n * Input selection module for React.\n */\n\n/**\n * @hasSelectionCapabilities: we get the element types that support selection\n * from https://html.spec.whatwg.org/#do-not-apply, looking at `selectionStart`\n * and `selectionEnd` rows.\n */\nexport function hasSelectionCapabilities(elem) {\n  const nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();\n  return (\n    nodeName &&\n    ((nodeName === 'input' &&\n      (elem.type === 'text' ||\n        elem.type === 'search' ||\n        elem.type === 'tel' ||\n        elem.type === 'url' ||\n        elem.type === 'password')) ||\n      nodeName === 'textarea' ||\n      elem.contentEditable === 'true')\n  );\n}\n\nexport function getSelectionInformation() {\n  const focusedElem = getActiveElementDeep();\n  return {\n    focusedElem: focusedElem,\n    selectionRange: hasSelectionCapabilities(focusedElem)\n      ? getSelection(focusedElem)\n      : null,\n  };\n}\n\n/**\n * @restoreSelection: If any selection information was potentially lost,\n * restore it. This is useful when performing operations that could remove dom\n * nodes and place them back in, resulting in focus being lost.\n */\nexport function restoreSelection(priorSelectionInformation) {\n  const curFocusedElem = getActiveElementDeep();\n  const priorFocusedElem = priorSelectionInformation.focusedElem;\n  const priorSelectionRange = priorSelectionInformation.selectionRange;\n  if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {\n    if (\n      priorSelectionRange !== null &&\n      hasSelectionCapabilities(priorFocusedElem)\n    ) {\n      setSelection(priorFocusedElem, priorSelectionRange);\n    }\n\n    // Focusing a node can change the scroll position, which is undesirable\n    const ancestors = [];\n    let ancestor = priorFocusedElem;\n    while ((ancestor = ancestor.parentNode)) {\n      if (ancestor.nodeType === ELEMENT_NODE) {\n        ancestors.push({\n          element: ancestor,\n          left: ancestor.scrollLeft,\n          top: ancestor.scrollTop,\n        });\n      }\n    }\n\n    if (typeof priorFocusedElem.focus === 'function') {\n      priorFocusedElem.focus();\n    }\n\n    for (let i = 0; i < ancestors.length; i++) {\n      const info = ancestors[i];\n      info.element.scrollLeft = info.left;\n      info.element.scrollTop = info.top;\n    }\n  }\n}\n\n/**\n * @getSelection: Gets the selection bounds of a focused textarea, input or\n * contentEditable node.\n * -@input: Look up selection bounds of this input\n * -@return {start: selectionStart, end: selectionEnd}\n */\nexport function getSelection(input) {\n  let selection;\n\n  if ('selectionStart' in input) {\n    // Modern browser with input or textarea.\n    selection = {\n      start: input.selectionStart,\n      end: input.selectionEnd,\n    };\n  } else {\n    // Content editable or old IE textarea.\n    selection = getOffsets(input);\n  }\n\n  return selection || {start: 0, end: 0};\n}\n\n/**\n * @setSelection: Sets the selection bounds of a textarea or input and focuses\n * the input.\n * -@input     Set selection bounds of this input or textarea\n * -@offsets   Object of same form that is returned from get*\n */\nexport function setSelection(input, offsets) {\n  const start = offsets.start;\n  let end = offsets.end;\n  if (end === undefined) {\n    end = start;\n  }\n\n  if ('selectionStart' in input) {\n    input.selectionStart = start;\n    input.selectionEnd = Math.min(end, input.value.length);\n  } else {\n    setOffsets(input, offsets);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}