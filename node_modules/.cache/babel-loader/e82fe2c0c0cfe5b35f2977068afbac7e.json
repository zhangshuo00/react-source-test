{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$();\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nimport { enableDebugTracing, enableSchedulingProfiler, enableNewReconciler, enableCache, enableUseRefAccessWarning, enableStrictEffects, enableLazyContextPropagation, enableSuspenseLayoutEffectSemantics, enableUseMutableSource } from 'shared/ReactFeatureFlags';\nimport { NoMode, ConcurrentMode, DebugTracingMode, StrictEffectsMode } from './ReactTypeOfMode';\nimport { NoLane, SyncLane, NoLanes, isSubsetOfLanes, includesBlockingLane, mergeLanes, removeLanes, intersectLanes, isTransitionLane, markRootEntangled, markRootMutableRead, NoTimestamp } from './ReactFiberLane.new';\nimport { ContinuousEventPriority, getCurrentUpdatePriority, setCurrentUpdatePriority, higherEventPriority } from './ReactEventPriorities.new';\nimport { readContext, checkIfContextChanged } from './ReactFiberNewContext.new';\nimport { HostRoot, CacheComponent } from './ReactWorkTags';\nimport { LayoutStatic as LayoutStaticEffect, MountLayoutDev as MountLayoutDevEffect, MountPassiveDev as MountPassiveDevEffect, Passive as PassiveEffect, PassiveStatic as PassiveStaticEffect, StaticMask as StaticMaskEffect, Update as UpdateEffect, StoreConsistency } from './ReactFiberFlags';\nimport { HasEffect as HookHasEffect, Layout as HookLayout, Passive as HookPassive, Insertion as HookInsertion } from './ReactHookEffectTags';\nimport { getWorkInProgressRoot, scheduleUpdateOnFiber, requestUpdateLane, requestEventTime, markSkippedUpdateLanes, isInterleavedUpdate } from './ReactFiberWorkLoop.new';\nimport getComponentNameFromFiber from 'react-reconciler/src/getComponentNameFromFiber';\nimport is from 'shared/objectIs';\nimport isArray from 'shared/isArray';\nimport { markWorkInProgressReceivedUpdate, checkIfWorkInProgressReceivedUpdate } from './ReactFiberBeginWork.new';\nimport { getIsHydrating } from './ReactFiberHydrationContext.new';\nimport { getWorkInProgressVersion, markSourceAsDirty, setWorkInProgressVersion, warnAboutMultipleRenderersDEV } from './ReactMutableSource.new';\nimport { logStateUpdateScheduled } from './DebugTracing';\nimport { markStateUpdateScheduled } from './SchedulingProfiler';\nimport { createCache, CacheContext } from './ReactFiberCacheComponent.new';\nimport { createUpdate as createLegacyQueueUpdate, enqueueUpdate as enqueueLegacyQueueUpdate, entangleTransitions as entangleLegacyQueueTransitions } from './ReactUpdateQueue.new';\nimport { pushInterleavedQueue } from './ReactFiberInterleavedUpdates.new';\nimport { warnOnSubscriptionInsideStartTransition } from 'shared/ReactFeatureFlags';\nimport { getTreeId } from './ReactFiberTreeContext.new';\nconst {\n  ReactCurrentDispatcher,\n  ReactCurrentBatchConfig\n} = ReactSharedInternals;\nlet didWarnAboutMismatchedHooksForComponent;\nlet didWarnUncachedGetSnapshot;\n\nif (__DEV__) {\n  didWarnAboutMismatchedHooksForComponent = new Set();\n}\n\n// These are set right before calling the component.\nlet renderLanes = NoLanes; // The work-in-progress fiber. I've named it differently to distinguish it from\n// the work-in-progress hook.\n\nlet currentlyRenderingFiber = null; // Hooks are stored as a linked list on the fiber's memoizedState field. The\n// current hook list is the list that belongs to the current fiber. The\n// work-in-progress hook list is a new list that will be added to the\n// work-in-progress fiber.\n\nlet currentHook = null;\nlet workInProgressHook = null; // Whether an update was scheduled at any point during the render phase. This\n// does not get reset if we do another render pass; only when we're completely\n// finished evaluating this component. This is an optimization so we know\n// whether we need to clear render phase updates after a throw.\n\nlet didScheduleRenderPhaseUpdate = false; // Where an update was scheduled only during the current render pass. This\n// gets reset after each attempt.\n// TODO: Maybe there's some way to consolidate this with\n// `didScheduleRenderPhaseUpdate`. Or with `numberOfReRenders`.\n\nlet didScheduleRenderPhaseUpdateDuringThisPass = false; // Counts the number of useId hooks in this component.\n\nlet localIdCounter = 0; // Used for ids that are generated completely client-side (i.e. not during\n// hydration). This counter is global, so client ids are not stable across\n// render attempts.\n\nlet globalClientIdCounter = 0;\nconst RE_RENDER_LIMIT = 25; // In DEV, this is the name of the currently executing primitive hook\n\nlet currentHookNameInDev = null; // In DEV, this list ensures that hooks are called in the same order between renders.\n// The list stores the order of hooks used during the initial render (mount).\n// Subsequent renders (updates) reference this list.\n\nlet hookTypesDev = null;\nlet hookTypesUpdateIndexDev = -1; // In DEV, this tracks whether currently rendering component needs to ignore\n// the dependencies for Hooks that need them (e.g. useEffect or useMemo).\n// When true, such Hooks will always be \"remounted\". Only used during hot reload.\n\nlet ignorePreviousDependencies = false;\n\nfunction mountHookTypesDev() {\n  if (__DEV__) {\n    const hookName = currentHookNameInDev;\n\n    if (hookTypesDev === null) {\n      hookTypesDev = [hookName];\n    } else {\n      hookTypesDev.push(hookName);\n    }\n  }\n}\n\nfunction updateHookTypesDev() {\n  if (__DEV__) {\n    const hookName = currentHookNameInDev;\n\n    if (hookTypesDev !== null) {\n      hookTypesUpdateIndexDev++;\n\n      if (hookTypesDev[hookTypesUpdateIndexDev] !== hookName) {\n        warnOnHookMismatchInDev(hookName);\n      }\n    }\n  }\n}\n\nfunction checkDepsAreArrayDev(deps) {\n  if (__DEV__) {\n    if (deps !== undefined && deps !== null && !isArray(deps)) {\n      // Verify deps, but only on mount to avoid extra checks.\n      // It's unlikely their type would change as usually you define them inline.\n      console.error('%s received a final argument that is not an array (instead, received `%s`). When ' + 'specified, the final argument must be an array.', currentHookNameInDev, typeof deps);\n    }\n  }\n}\n\nfunction warnOnHookMismatchInDev(currentHookName) {\n  if (__DEV__) {\n    const componentName = getComponentNameFromFiber(currentlyRenderingFiber);\n\n    if (!didWarnAboutMismatchedHooksForComponent.has(componentName)) {\n      didWarnAboutMismatchedHooksForComponent.add(componentName);\n\n      if (hookTypesDev !== null) {\n        let table = '';\n        const secondColumnStart = 30;\n\n        for (let i = 0; i <= hookTypesUpdateIndexDev; i++) {\n          const oldHookName = hookTypesDev[i];\n          const newHookName = i === hookTypesUpdateIndexDev ? currentHookName : oldHookName;\n          let row = `${i + 1}. ${oldHookName}`; // Extra space so second column lines up\n          // lol @ IE not supporting String#repeat\n\n          while (row.length < secondColumnStart) {\n            row += ' ';\n          }\n\n          row += newHookName + '\\n';\n          table += row;\n        }\n\n        console.error('React has detected a change in the order of Hooks called by %s. ' + 'This will lead to bugs and errors if not fixed. ' + 'For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\\n\\n' + '   Previous render            Next render\\n' + '   ------------------------------------------------------\\n' + '%s' + '   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n', componentName, table);\n      }\n    }\n  }\n}\n\nfunction throwInvalidHookError() {\n  throw new Error('Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' + ' one of the following reasons:\\n' + '1. You might have mismatching versions of React and the renderer (such as React DOM)\\n' + '2. You might be breaking the Rules of Hooks\\n' + '3. You might have more than one copy of React in the same app\\n' + 'See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.');\n}\n\nfunction areHookInputsEqual(nextDeps, prevDeps) {\n  if (__DEV__) {\n    if (ignorePreviousDependencies) {\n      // Only true when this component is being hot reloaded.\n      return false;\n    }\n  }\n\n  if (prevDeps === null) {\n    if (__DEV__) {\n      console.error('%s received a final argument during this render, but not during ' + 'the previous render. Even though the final argument is optional, ' + 'its type cannot change between renders.', currentHookNameInDev);\n    }\n\n    return false;\n  }\n\n  if (__DEV__) {\n    // Don't bother comparing lengths in prod because these arrays should be\n    // passed inline.\n    if (nextDeps.length !== prevDeps.length) {\n      console.error('The final argument passed to %s changed size between renders. The ' + 'order and size of this array must remain constant.\\n\\n' + 'Previous: %s\\n' + 'Incoming: %s', currentHookNameInDev, `[${prevDeps.join(', ')}]`, `[${nextDeps.join(', ')}]`);\n    }\n  }\n\n  for (let i = 0; i < prevDeps.length && i < nextDeps.length; i++) {\n    if (is(nextDeps[i], prevDeps[i])) {\n      continue;\n    }\n\n    return false;\n  }\n\n  return true;\n}\n\nexport function renderWithHooks(current, workInProgress, Component, props, secondArg, nextRenderLanes) {\n  renderLanes = nextRenderLanes;\n  currentlyRenderingFiber = workInProgress;\n\n  if (__DEV__) {\n    hookTypesDev = current !== null ? current._debugHookTypes : null;\n    hookTypesUpdateIndexDev = -1; // Used for hot reloading:\n\n    ignorePreviousDependencies = current !== null && current.type !== workInProgress.type;\n  }\n\n  workInProgress.memoizedState = null;\n  workInProgress.updateQueue = null;\n  workInProgress.lanes = NoLanes; // The following should have already been reset\n  // currentHook = null;\n  // workInProgressHook = null;\n  // didScheduleRenderPhaseUpdate = false;\n  // localIdCounter = 0;\n  // TODO Warn if no hooks are used at all during mount, then some are used during update.\n  // Currently we will identify the update render as a mount because memoizedState === null.\n  // This is tricky because it's valid for certain types of components (e.g. React.lazy)\n  // Using memoizedState to differentiate between mount/update only works if at least one stateful hook is used.\n  // Non-stateful hooks (e.g. context) don't get added to memoizedState,\n  // so memoizedState would be null during updates and mounts.\n\n  if (__DEV__) {\n    if (current !== null && current.memoizedState !== null) {\n      ReactCurrentDispatcher.current = HooksDispatcherOnUpdateInDEV;\n    } else if (hookTypesDev !== null) {\n      // This dispatcher handles an edge case where a component is updating,\n      // but no stateful hooks have been used.\n      // We want to match the production code behavior (which will use HooksDispatcherOnMount),\n      // but with the extra DEV validation to ensure hooks ordering hasn't changed.\n      // This dispatcher does that.\n      ReactCurrentDispatcher.current = HooksDispatcherOnMountWithHookTypesInDEV;\n    } else {\n      ReactCurrentDispatcher.current = HooksDispatcherOnMountInDEV;\n    }\n  } else {\n    ReactCurrentDispatcher.current = current === null || current.memoizedState === null ? HooksDispatcherOnMount : HooksDispatcherOnUpdate;\n  }\n\n  let children = Component(props, secondArg); // Check if there was a render phase update\n\n  if (didScheduleRenderPhaseUpdateDuringThisPass) {\n    // Keep rendering in a loop for as long as render phase updates continue to\n    // be scheduled. Use a counter to prevent infinite loops.\n    let numberOfReRenders = 0;\n\n    do {\n      didScheduleRenderPhaseUpdateDuringThisPass = false;\n      localIdCounter = 0;\n\n      if (numberOfReRenders >= RE_RENDER_LIMIT) {\n        throw new Error('Too many re-renders. React limits the number of renders to prevent ' + 'an infinite loop.');\n      }\n\n      numberOfReRenders += 1;\n\n      if (__DEV__) {\n        // Even when hot reloading, allow dependencies to stabilize\n        // after first render to prevent infinite render phase updates.\n        ignorePreviousDependencies = false;\n      } // Start over from the beginning of the list\n\n\n      currentHook = null;\n      workInProgressHook = null;\n      workInProgress.updateQueue = null;\n\n      if (__DEV__) {\n        // Also validate hook order for cascading updates.\n        hookTypesUpdateIndexDev = -1;\n      }\n\n      ReactCurrentDispatcher.current = __DEV__ ? HooksDispatcherOnRerenderInDEV : HooksDispatcherOnRerender;\n      children = Component(props, secondArg);\n    } while (didScheduleRenderPhaseUpdateDuringThisPass);\n  } // We can assume the previous dispatcher is always this one, since we set it\n  // at the beginning of the render phase and there's no re-entrance.\n\n\n  ReactCurrentDispatcher.current = ContextOnlyDispatcher;\n\n  if (__DEV__) {\n    workInProgress._debugHookTypes = hookTypesDev;\n  } // This check uses currentHook so that it works the same in DEV and prod bundles.\n  // hookTypesDev could catch more cases (e.g. context) but only in DEV bundles.\n\n\n  const didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;\n  renderLanes = NoLanes;\n  currentlyRenderingFiber = null;\n  currentHook = null;\n  workInProgressHook = null;\n\n  if (__DEV__) {\n    currentHookNameInDev = null;\n    hookTypesDev = null;\n    hookTypesUpdateIndexDev = -1; // Confirm that a static flag was not added or removed since the last\n    // render. If this fires, it suggests that we incorrectly reset the static\n    // flags in some other part of the codebase. This has happened before, for\n    // example, in the SuspenseList implementation.\n\n    if (current !== null && (current.flags & StaticMaskEffect) !== (workInProgress.flags & StaticMaskEffect) && // Disable this warning in legacy mode, because legacy Suspense is weird\n    // and creates false positives. To make this work in legacy mode, we'd\n    // need to mark fibers that commit in an incomplete state, somehow. For\n    // now I'll disable the warning that most of the bugs that would trigger\n    // it are either exclusive to concurrent mode or exist in both.\n    (current.mode & ConcurrentMode) !== NoMode) {\n      console.error('Internal React error: Expected static flag was missing. Please ' + 'notify the React team.');\n    }\n  }\n\n  didScheduleRenderPhaseUpdate = false; // This is reset by checkDidRenderIdHook\n  // localIdCounter = 0;\n\n  if (didRenderTooFewHooks) {\n    throw new Error('Rendered fewer hooks than expected. This may be caused by an accidental ' + 'early return statement.');\n  }\n\n  if (enableLazyContextPropagation) {\n    if (current !== null) {\n      if (!checkIfWorkInProgressReceivedUpdate()) {\n        // If there were no changes to props or state, we need to check if there\n        // was a context change. We didn't already do this because there's no\n        // 1:1 correspondence between dependencies and hooks. Although, because\n        // there almost always is in the common case (`readContext` is an\n        // internal API), we could compare in there. OTOH, we only hit this case\n        // if everything else bails out, so on the whole it might be better to\n        // keep the comparison out of the common path.\n        const currentDependencies = current.dependencies;\n\n        if (currentDependencies !== null && checkIfContextChanged(currentDependencies)) {\n          markWorkInProgressReceivedUpdate();\n        }\n      }\n    }\n  }\n\n  return children;\n}\nexport function checkDidRenderIdHook() {\n  // This should be called immediately after every renderWithHooks call.\n  // Conceptually, it's part of the return value of renderWithHooks; it's only a\n  // separate function to avoid using an array tuple.\n  const didRenderIdHook = localIdCounter !== 0;\n  localIdCounter = 0;\n  return didRenderIdHook;\n}\nexport function bailoutHooks(current, workInProgress, lanes) {\n  workInProgress.updateQueue = current.updateQueue; // TODO: Don't need to reset the flags here, because they're reset in the\n  // complete phase (bubbleProperties).\n\n  if (__DEV__ && enableStrictEffects && (workInProgress.mode & StrictEffectsMode) !== NoMode) {\n    workInProgress.flags &= ~(MountPassiveDevEffect | MountLayoutDevEffect | PassiveEffect | UpdateEffect);\n  } else {\n    workInProgress.flags &= ~(PassiveEffect | UpdateEffect);\n  }\n\n  current.lanes = removeLanes(current.lanes, lanes);\n}\nexport function resetHooksAfterThrow() {\n  // We can assume the previous dispatcher is always this one, since we set it\n  // at the beginning of the render phase and there's no re-entrance.\n  ReactCurrentDispatcher.current = ContextOnlyDispatcher;\n\n  if (didScheduleRenderPhaseUpdate) {\n    // There were render phase updates. These are only valid for this render\n    // phase, which we are now aborting. Remove the updates from the queues so\n    // they do not persist to the next render. Do not remove updates from hooks\n    // that weren't processed.\n    //\n    // Only reset the updates from the queue if it has a clone. If it does\n    // not have a clone, that means it wasn't processed, and the updates were\n    // scheduled before we entered the render phase.\n    let hook = currentlyRenderingFiber.memoizedState;\n\n    while (hook !== null) {\n      const queue = hook.queue;\n\n      if (queue !== null) {\n        queue.pending = null;\n      }\n\n      hook = hook.next;\n    }\n\n    didScheduleRenderPhaseUpdate = false;\n  }\n\n  renderLanes = NoLanes;\n  currentlyRenderingFiber = null;\n  currentHook = null;\n  workInProgressHook = null;\n\n  if (__DEV__) {\n    hookTypesDev = null;\n    hookTypesUpdateIndexDev = -1;\n    currentHookNameInDev = null;\n    isUpdatingOpaqueValueInRenderPhase = false;\n  }\n\n  didScheduleRenderPhaseUpdateDuringThisPass = false;\n  localIdCounter = 0;\n}\n\nfunction mountWorkInProgressHook() {\n  const hook = {\n    memoizedState: null,\n    baseState: null,\n    baseQueue: null,\n    queue: null,\n    next: null\n  };\n\n  if (workInProgressHook === null) {\n    // This is the first hook in the list\n    currentlyRenderingFiber.memoizedState = workInProgressHook = hook;\n  } else {\n    // Append to the end of the list\n    workInProgressHook = workInProgressHook.next = hook;\n  }\n\n  return workInProgressHook;\n}\n\nfunction updateWorkInProgressHook() {\n  // This function is used both for updates and for re-renders triggered by a\n  // render phase update. It assumes there is either a current hook we can\n  // clone, or a work-in-progress hook from a previous render pass that we can\n  // use as a base. When we reach the end of the base list, we must switch to\n  // the dispatcher used for mounts.\n  let nextCurrentHook;\n\n  if (currentHook === null) {\n    const current = currentlyRenderingFiber.alternate;\n\n    if (current !== null) {\n      nextCurrentHook = current.memoizedState;\n    } else {\n      nextCurrentHook = null;\n    }\n  } else {\n    nextCurrentHook = currentHook.next;\n  }\n\n  let nextWorkInProgressHook;\n\n  if (workInProgressHook === null) {\n    nextWorkInProgressHook = currentlyRenderingFiber.memoizedState;\n  } else {\n    nextWorkInProgressHook = workInProgressHook.next;\n  }\n\n  if (nextWorkInProgressHook !== null) {\n    // There's already a work-in-progress. Reuse it.\n    workInProgressHook = nextWorkInProgressHook;\n    nextWorkInProgressHook = workInProgressHook.next;\n    currentHook = nextCurrentHook;\n  } else {\n    // Clone from the current hook.\n    if (nextCurrentHook === null) {\n      throw new Error('Rendered more hooks than during the previous render.');\n    }\n\n    currentHook = nextCurrentHook;\n    const newHook = {\n      memoizedState: currentHook.memoizedState,\n      baseState: currentHook.baseState,\n      baseQueue: currentHook.baseQueue,\n      queue: currentHook.queue,\n      next: null\n    };\n\n    if (workInProgressHook === null) {\n      // This is the first hook in the list.\n      currentlyRenderingFiber.memoizedState = workInProgressHook = newHook;\n    } else {\n      // Append to the end of the list.\n      workInProgressHook = workInProgressHook.next = newHook;\n    }\n  }\n\n  return workInProgressHook;\n}\n\nfunction createFunctionComponentUpdateQueue() {\n  return {\n    lastEffect: null,\n    stores: null\n  };\n}\n\nfunction basicStateReducer(state, action) {\n  // $FlowFixMe: Flow doesn't like mixed types\n  return typeof action === 'function' ? action(state) : action;\n}\n\nfunction mountReducer(reducer, initialArg, init) {\n  const hook = mountWorkInProgressHook();\n  let initialState;\n\n  if (init !== undefined) {\n    initialState = init(initialArg);\n  } else {\n    initialState = initialArg;\n  }\n\n  hook.memoizedState = hook.baseState = initialState;\n  const queue = {\n    pending: null,\n    interleaved: null,\n    lanes: NoLanes,\n    dispatch: null,\n    lastRenderedReducer: reducer,\n    lastRenderedState: initialState\n  };\n  hook.queue = queue;\n  const dispatch = queue.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber, queue);\n  return [hook.memoizedState, dispatch];\n}\n\nfunction updateReducer(reducer, initialArg, init) {\n  const hook = updateWorkInProgressHook();\n  const queue = hook.queue;\n\n  if (queue === null) {\n    throw new Error('Should have a queue. This is likely a bug in React. Please file an issue.');\n  }\n\n  queue.lastRenderedReducer = reducer;\n  const current = currentHook; // The last rebase update that is NOT part of the base state.\n\n  let baseQueue = current.baseQueue; // The last pending update that hasn't been processed yet.\n\n  const pendingQueue = queue.pending;\n\n  if (pendingQueue !== null) {\n    // We have new updates that haven't been processed yet.\n    // We'll add them to the base queue.\n    if (baseQueue !== null) {\n      // Merge the pending queue and the base queue.\n      const baseFirst = baseQueue.next;\n      const pendingFirst = pendingQueue.next;\n      baseQueue.next = pendingFirst;\n      pendingQueue.next = baseFirst;\n    }\n\n    if (__DEV__) {\n      if (current.baseQueue !== baseQueue) {\n        // Internal invariant that should never happen, but feasibly could in\n        // the future if we implement resuming, or some form of that.\n        console.error('Internal error: Expected work-in-progress queue to be a clone. ' + 'This is a bug in React.');\n      }\n    }\n\n    current.baseQueue = baseQueue = pendingQueue;\n    queue.pending = null;\n  }\n\n  if (baseQueue !== null) {\n    // We have a queue to process.\n    const first = baseQueue.next;\n    let newState = current.baseState;\n    let newBaseState = null;\n    let newBaseQueueFirst = null;\n    let newBaseQueueLast = null;\n    let update = first;\n\n    do {\n      const updateLane = update.lane;\n\n      if (!isSubsetOfLanes(renderLanes, updateLane)) {\n        // Priority is insufficient. Skip this update. If this is the first\n        // skipped update, the previous update/state is the new base\n        // update/state.\n        const clone = {\n          lane: updateLane,\n          action: update.action,\n          hasEagerState: update.hasEagerState,\n          eagerState: update.eagerState,\n          next: null\n        };\n\n        if (newBaseQueueLast === null) {\n          newBaseQueueFirst = newBaseQueueLast = clone;\n          newBaseState = newState;\n        } else {\n          newBaseQueueLast = newBaseQueueLast.next = clone;\n        } // Update the remaining priority in the queue.\n        // TODO: Don't need to accumulate this. Instead, we can remove\n        // renderLanes from the original lanes.\n\n\n        currentlyRenderingFiber.lanes = mergeLanes(currentlyRenderingFiber.lanes, updateLane);\n        markSkippedUpdateLanes(updateLane);\n      } else {\n        // This update does have sufficient priority.\n        if (newBaseQueueLast !== null) {\n          const clone = {\n            // This update is going to be committed so we never want uncommit\n            // it. Using NoLane works because 0 is a subset of all bitmasks, so\n            // this will never be skipped by the check above.\n            lane: NoLane,\n            action: update.action,\n            hasEagerState: update.hasEagerState,\n            eagerState: update.eagerState,\n            next: null\n          };\n          newBaseQueueLast = newBaseQueueLast.next = clone;\n        } // Process this update.\n\n\n        if (update.hasEagerState) {\n          // If this update is a state update (not a reducer) and was processed eagerly,\n          // we can use the eagerly computed state\n          newState = update.eagerState;\n        } else {\n          const action = update.action;\n          newState = reducer(newState, action);\n        }\n      }\n\n      update = update.next;\n    } while (update !== null && update !== first);\n\n    if (newBaseQueueLast === null) {\n      newBaseState = newState;\n    } else {\n      newBaseQueueLast.next = newBaseQueueFirst;\n    } // Mark that the fiber performed work, but only if the new state is\n    // different from the current state.\n\n\n    if (!is(newState, hook.memoizedState)) {\n      markWorkInProgressReceivedUpdate();\n    }\n\n    hook.memoizedState = newState;\n    hook.baseState = newBaseState;\n    hook.baseQueue = newBaseQueueLast;\n    queue.lastRenderedState = newState;\n  } // Interleaved updates are stored on a separate queue. We aren't going to\n  // process them during this render, but we do need to track which lanes\n  // are remaining.\n\n\n  const lastInterleaved = queue.interleaved;\n\n  if (lastInterleaved !== null) {\n    let interleaved = lastInterleaved;\n\n    do {\n      const interleavedLane = interleaved.lane;\n      currentlyRenderingFiber.lanes = mergeLanes(currentlyRenderingFiber.lanes, interleavedLane);\n      markSkippedUpdateLanes(interleavedLane);\n      interleaved = interleaved.next;\n    } while (interleaved !== lastInterleaved);\n  } else if (baseQueue === null) {\n    // `queue.lanes` is used for entangling transitions. We can set it back to\n    // zero once the queue is empty.\n    queue.lanes = NoLanes;\n  }\n\n  const dispatch = queue.dispatch;\n  return [hook.memoizedState, dispatch];\n}\n\nfunction rerenderReducer(reducer, initialArg, init) {\n  const hook = updateWorkInProgressHook();\n  const queue = hook.queue;\n\n  if (queue === null) {\n    throw new Error('Should have a queue. This is likely a bug in React. Please file an issue.');\n  }\n\n  queue.lastRenderedReducer = reducer; // This is a re-render. Apply the new render phase updates to the previous\n  // work-in-progress hook.\n\n  const dispatch = queue.dispatch;\n  const lastRenderPhaseUpdate = queue.pending;\n  let newState = hook.memoizedState;\n\n  if (lastRenderPhaseUpdate !== null) {\n    // The queue doesn't persist past this render pass.\n    queue.pending = null;\n    const firstRenderPhaseUpdate = lastRenderPhaseUpdate.next;\n    let update = firstRenderPhaseUpdate;\n\n    do {\n      // Process this render phase update. We don't have to check the\n      // priority because it will always be the same as the current\n      // render's.\n      const action = update.action;\n      newState = reducer(newState, action);\n      update = update.next;\n    } while (update !== firstRenderPhaseUpdate); // Mark that the fiber performed work, but only if the new state is\n    // different from the current state.\n\n\n    if (!is(newState, hook.memoizedState)) {\n      markWorkInProgressReceivedUpdate();\n    }\n\n    hook.memoizedState = newState; // Don't persist the state accumulated from the render phase updates to\n    // the base state unless the queue is empty.\n    // TODO: Not sure if this is the desired semantics, but it's what we\n    // do for gDSFP. I can't remember why.\n\n    if (hook.baseQueue === null) {\n      hook.baseState = newState;\n    }\n\n    queue.lastRenderedState = newState;\n  }\n\n  return [newState, dispatch];\n}\n\nfunction readFromUnsubscribedMutableSource(root, source, getSnapshot) {\n  if (__DEV__) {\n    warnAboutMultipleRenderersDEV(source);\n  }\n\n  const getVersion = source._getVersion;\n  const version = getVersion(source._source); // Is it safe for this component to read from this source during the current render?\n\n  let isSafeToReadFromSource = false; // Check the version first.\n  // If this render has already been started with a specific version,\n  // we can use it alone to determine if we can safely read from the source.\n\n  const currentRenderVersion = getWorkInProgressVersion(source);\n\n  if (currentRenderVersion !== null) {\n    // It's safe to read if the store hasn't been mutated since the last time\n    // we read something.\n    isSafeToReadFromSource = currentRenderVersion === version;\n  } else {\n    // If there's no version, then this is the first time we've read from the\n    // source during the current render pass, so we need to do a bit more work.\n    // What we need to determine is if there are any hooks that already\n    // subscribed to the source, and if so, whether there are any pending\n    // mutations that haven't been synchronized yet.\n    //\n    // If there are no pending mutations, then `root.mutableReadLanes` will be\n    // empty, and we know we can safely read.\n    //\n    // If there *are* pending mutations, we may still be able to safely read\n    // if the currently rendering lanes are inclusive of the pending mutation\n    // lanes, since that guarantees that the value we're about to read from\n    // the source is consistent with the values that we read during the most\n    // recent mutation.\n    isSafeToReadFromSource = isSubsetOfLanes(renderLanes, root.mutableReadLanes);\n\n    if (isSafeToReadFromSource) {\n      // If it's safe to read from this source during the current render,\n      // store the version in case other components read from it.\n      // A changed version number will let those components know to throw and restart the render.\n      setWorkInProgressVersion(source, version);\n    }\n  }\n\n  if (isSafeToReadFromSource) {\n    const snapshot = getSnapshot(source._source);\n\n    if (__DEV__) {\n      if (typeof snapshot === 'function') {\n        console.error('Mutable source should not return a function as the snapshot value. ' + 'Functions may close over mutable values and cause tearing.');\n      }\n    }\n\n    return snapshot;\n  } else {\n    // This handles the special case of a mutable source being shared between renderers.\n    // In that case, if the source is mutated between the first and second renderer,\n    // The second renderer don't know that it needs to reset the WIP version during unwind,\n    // (because the hook only marks sources as dirty if it's written to their WIP version).\n    // That would cause this tear check to throw again and eventually be visible to the user.\n    // We can avoid this infinite loop by explicitly marking the source as dirty.\n    //\n    // This can lead to tearing in the first renderer when it resumes,\n    // but there's nothing we can do about that (short of throwing here and refusing to continue the render).\n    markSourceAsDirty(source); // Intentioally throw an error to force React to retry synchronously. During\n    // the synchronous retry, it will block interleaved mutations, so we should\n    // get a consistent read. Therefore, the following error should never be\n    // visible to the user.\n    // We expect this error not to be thrown during the synchronous retry,\n    // because we blocked interleaved mutations.\n\n    throw new Error('Cannot read from mutable source during the current render without tearing. This may be a bug in React. Please file an issue.');\n  }\n}\n\nfunction useMutableSource(hook, source, getSnapshot, subscribe) {\n  _s();\n\n  if (!enableUseMutableSource) {\n    return undefined;\n  }\n\n  const root = getWorkInProgressRoot();\n\n  if (root === null) {\n    throw new Error('Expected a work-in-progress root. This is a bug in React. Please file an issue.');\n  }\n\n  const getVersion = source._getVersion;\n  const version = getVersion(source._source);\n  const dispatcher = ReactCurrentDispatcher.current; // eslint-disable-next-line prefer-const\n\n  let [currentSnapshot, setSnapshot] = dispatcher.useState(() => readFromUnsubscribedMutableSource(root, source, getSnapshot));\n  let snapshot = currentSnapshot; // Grab a handle to the state hook as well.\n  // We use it to clear the pending update queue if we have a new source.\n\n  const stateHook = workInProgressHook;\n  const memoizedState = hook.memoizedState;\n  const refs = memoizedState.refs;\n  const prevGetSnapshot = refs.getSnapshot;\n  const prevSource = memoizedState.source;\n  const prevSubscribe = memoizedState.subscribe;\n  const fiber = currentlyRenderingFiber;\n  hook.memoizedState = {\n    refs,\n    source,\n    subscribe\n  }; // Sync the values needed by our subscription handler after each commit.\n\n  dispatcher.useEffect(() => {\n    refs.getSnapshot = getSnapshot; // Normally the dispatch function for a state hook never changes,\n    // but this hook recreates the queue in certain cases  to avoid updates from stale sources.\n    // handleChange() below needs to reference the dispatch function without re-subscribing,\n    // so we use a ref to ensure that it always has the latest version.\n\n    refs.setSnapshot = setSnapshot; // Check for a possible change between when we last rendered now.\n\n    const maybeNewVersion = getVersion(source._source);\n\n    if (!is(version, maybeNewVersion)) {\n      const maybeNewSnapshot = getSnapshot(source._source);\n\n      if (__DEV__) {\n        if (typeof maybeNewSnapshot === 'function') {\n          console.error('Mutable source should not return a function as the snapshot value. ' + 'Functions may close over mutable values and cause tearing.');\n        }\n      }\n\n      if (!is(snapshot, maybeNewSnapshot)) {\n        setSnapshot(maybeNewSnapshot);\n        const lane = requestUpdateLane(fiber);\n        markRootMutableRead(root, lane);\n      } // If the source mutated between render and now,\n      // there may be state updates already scheduled from the old source.\n      // Entangle the updates so that they render in the same batch.\n\n\n      markRootEntangled(root, root.mutableReadLanes);\n    }\n  }, [getSnapshot, source, subscribe]); // If we got a new source or subscribe function, re-subscribe in a passive effect.\n\n  dispatcher.useEffect(() => {\n    const handleChange = () => {\n      const latestGetSnapshot = refs.getSnapshot;\n      const latestSetSnapshot = refs.setSnapshot;\n\n      try {\n        latestSetSnapshot(latestGetSnapshot(source._source)); // Record a pending mutable source update with the same expiration time.\n\n        const lane = requestUpdateLane(fiber);\n        markRootMutableRead(root, lane);\n      } catch (error) {\n        // A selector might throw after a source mutation.\n        // e.g. it might try to read from a part of the store that no longer exists.\n        // In this case we should still schedule an update with React.\n        // Worst case the selector will throw again and then an error boundary will handle it.\n        latestSetSnapshot(() => {\n          throw error;\n        });\n      }\n    };\n\n    const unsubscribe = subscribe(source._source, handleChange);\n\n    if (__DEV__) {\n      if (typeof unsubscribe !== 'function') {\n        console.error('Mutable source subscribe function must return an unsubscribe function.');\n      }\n    }\n\n    return unsubscribe;\n  }, [source, subscribe]); // If any of the inputs to useMutableSource change, reading is potentially unsafe.\n  //\n  // If either the source or the subscription have changed we can't can't trust the update queue.\n  // Maybe the source changed in a way that the old subscription ignored but the new one depends on.\n  //\n  // If the getSnapshot function changed, we also shouldn't rely on the update queue.\n  // It's possible that the underlying source was mutated between the when the last \"change\" event fired,\n  // and when the current render (with the new getSnapshot function) is processed.\n  //\n  // In both cases, we need to throw away pending updates (since they are no longer relevant)\n  // and treat reading from the source as we do in the mount case.\n\n  if (!is(prevGetSnapshot, getSnapshot) || !is(prevSource, source) || !is(prevSubscribe, subscribe)) {\n    // Create a new queue and setState method,\n    // So if there are interleaved updates, they get pushed to the older queue.\n    // When this becomes current, the previous queue and dispatch method will be discarded,\n    // including any interleaving updates that occur.\n    const newQueue = {\n      pending: null,\n      interleaved: null,\n      lanes: NoLanes,\n      dispatch: null,\n      lastRenderedReducer: basicStateReducer,\n      lastRenderedState: snapshot\n    };\n    newQueue.dispatch = setSnapshot = dispatchSetState.bind(null, currentlyRenderingFiber, newQueue);\n    stateHook.queue = newQueue;\n    stateHook.baseQueue = null;\n    snapshot = readFromUnsubscribedMutableSource(root, source, getSnapshot);\n    stateHook.memoizedState = stateHook.baseState = snapshot;\n  }\n\n  return snapshot;\n}\n\n_s(useMutableSource, \"0UqLyUEVtDvgIghVdgglcUhTwyg=\");\n\nfunction mountMutableSource(source, getSnapshot, subscribe) {\n  _s2();\n\n  if (!enableUseMutableSource) {\n    return undefined;\n  }\n\n  const hook = mountWorkInProgressHook();\n  hook.memoizedState = {\n    refs: {\n      getSnapshot,\n      setSnapshot: null\n    },\n    source,\n    subscribe\n  };\n  return useMutableSource(hook, source, getSnapshot, subscribe);\n}\n\n_s2(mountMutableSource, \"G46HpqTIWGoryMbF+wh82aRle1o=\", false, function () {\n  return [useMutableSource];\n});\n\nfunction updateMutableSource(source, getSnapshot, subscribe) {\n  _s3();\n\n  if (!enableUseMutableSource) {\n    return undefined;\n  }\n\n  const hook = updateWorkInProgressHook();\n  return useMutableSource(hook, source, getSnapshot, subscribe);\n}\n\n_s3(updateMutableSource, \"G46HpqTIWGoryMbF+wh82aRle1o=\", false, function () {\n  return [useMutableSource];\n});\n\nfunction mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n  const fiber = currentlyRenderingFiber;\n  const hook = mountWorkInProgressHook();\n  let nextSnapshot;\n  const isHydrating = getIsHydrating();\n\n  if (isHydrating) {\n    if (getServerSnapshot === undefined) {\n      throw new Error('Missing getServerSnapshot, which is required for ' + 'server-rendered content. Will revert to client rendering.');\n    }\n\n    nextSnapshot = getServerSnapshot();\n\n    if (__DEV__) {\n      if (!didWarnUncachedGetSnapshot) {\n        if (nextSnapshot !== getServerSnapshot()) {\n          console.error('The result of getServerSnapshot should be cached to avoid an infinite loop');\n          didWarnUncachedGetSnapshot = true;\n        }\n      }\n    }\n  } else {\n    nextSnapshot = getSnapshot();\n\n    if (__DEV__) {\n      if (!didWarnUncachedGetSnapshot) {\n        if (nextSnapshot !== getSnapshot()) {\n          console.error('The result of getSnapshot should be cached to avoid an infinite loop');\n          didWarnUncachedGetSnapshot = true;\n        }\n      }\n    } // Unless we're rendering a blocking lane, schedule a consistency check.\n    // Right before committing, we will walk the tree and check if any of the\n    // stores were mutated.\n    //\n    // We won't do this if we're hydrating server-rendered content, because if\n    // the content is stale, it's already visible anyway. Instead we'll patch\n    // it up in a passive effect.\n\n\n    const root = getWorkInProgressRoot();\n\n    if (root === null) {\n      throw new Error('Expected a work-in-progress root. This is a bug in React. Please file an issue.');\n    }\n\n    if (!includesBlockingLane(root, renderLanes)) {\n      pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);\n    }\n  } // Read the current snapshot from the store on every render. This breaks the\n  // normal rules of React, and only works because store updates are\n  // always synchronous.\n\n\n  hook.memoizedState = nextSnapshot;\n  const inst = {\n    value: nextSnapshot,\n    getSnapshot\n  };\n  hook.queue = inst; // Schedule an effect to subscribe to the store.\n\n  mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe]); // Schedule an effect to update the mutable instance fields. We will update\n  // this whenever subscribe, getSnapshot, or value changes. Because there's no\n  // clean-up function, and we track the deps correctly, we can call pushEffect\n  // directly, without storing any additional state. For the same reason, we\n  // don't need to set a static flag, either.\n  // TODO: We can move this to the passive phase once we add a pre-commit\n  // consistency check. See the next comment.\n\n  fiber.flags |= PassiveEffect;\n  pushEffect(HookHasEffect | HookPassive, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), undefined, null);\n  return nextSnapshot;\n}\n\nfunction updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n  const fiber = currentlyRenderingFiber;\n  const hook = updateWorkInProgressHook(); // Read the current snapshot from the store on every render. This breaks the\n  // normal rules of React, and only works because store updates are\n  // always synchronous.\n\n  const nextSnapshot = getSnapshot();\n\n  if (__DEV__) {\n    if (!didWarnUncachedGetSnapshot) {\n      if (nextSnapshot !== getSnapshot()) {\n        console.error('The result of getSnapshot should be cached to avoid an infinite loop');\n        didWarnUncachedGetSnapshot = true;\n      }\n    }\n  }\n\n  const prevSnapshot = hook.memoizedState;\n  const snapshotChanged = !is(prevSnapshot, nextSnapshot);\n\n  if (snapshotChanged) {\n    hook.memoizedState = nextSnapshot;\n    markWorkInProgressReceivedUpdate();\n  }\n\n  const inst = hook.queue;\n  updateEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe]); // Whenever getSnapshot or subscribe changes, we need to check in the\n  // commit phase if there was an interleaved mutation. In concurrent mode\n  // this can happen all the time, but even in synchronous mode, an earlier\n  // effect may have mutated the store.\n\n  if (inst.getSnapshot !== getSnapshot || snapshotChanged || // Check if the susbcribe function changed. We can save some memory by\n  // checking whether we scheduled a subscription effect above.\n  workInProgressHook !== null && workInProgressHook.memoizedState.tag & HookHasEffect) {\n    fiber.flags |= PassiveEffect;\n    pushEffect(HookHasEffect | HookPassive, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), undefined, null); // Unless we're rendering a blocking lane, schedule a consistency check.\n    // Right before committing, we will walk the tree and check if any of the\n    // stores were mutated.\n\n    const root = getWorkInProgressRoot();\n\n    if (root === null) {\n      throw new Error('Expected a work-in-progress root. This is a bug in React. Please file an issue.');\n    }\n\n    if (!includesBlockingLane(root, renderLanes)) {\n      pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);\n    }\n  }\n\n  return nextSnapshot;\n}\n\nfunction pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {\n  fiber.flags |= StoreConsistency;\n  const check = {\n    getSnapshot,\n    value: renderedSnapshot\n  };\n  let componentUpdateQueue = currentlyRenderingFiber.updateQueue;\n\n  if (componentUpdateQueue === null) {\n    componentUpdateQueue = createFunctionComponentUpdateQueue();\n    currentlyRenderingFiber.updateQueue = componentUpdateQueue;\n    componentUpdateQueue.stores = [check];\n  } else {\n    const stores = componentUpdateQueue.stores;\n\n    if (stores === null) {\n      componentUpdateQueue.stores = [check];\n    } else {\n      stores.push(check);\n    }\n  }\n}\n\nfunction updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {\n  // These are updated in the passive phase\n  inst.value = nextSnapshot;\n  inst.getSnapshot = getSnapshot; // Something may have been mutated in between render and commit. This could\n  // have been in an event that fired before the passive effects, or it could\n  // have been in a layout effect. In that case, we would have used the old\n  // snapsho and getSnapshot values to bail out. We need to check one more time.\n\n  if (checkIfSnapshotChanged(inst)) {\n    // Force a re-render.\n    forceStoreRerender(fiber);\n  }\n}\n\nfunction subscribeToStore(fiber, inst, subscribe) {\n  const handleStoreChange = () => {\n    // The store changed. Check if the snapshot changed since the last time we\n    // read from the store.\n    if (checkIfSnapshotChanged(inst)) {\n      // Force a re-render.\n      forceStoreRerender(fiber);\n    }\n  }; // Subscribe to the store and return a clean-up function.\n\n\n  return subscribe(handleStoreChange);\n}\n\nfunction checkIfSnapshotChanged(inst) {\n  const latestGetSnapshot = inst.getSnapshot;\n  const prevValue = inst.value;\n\n  try {\n    const nextValue = latestGetSnapshot();\n    return !is(prevValue, nextValue);\n  } catch (error) {\n    return true;\n  }\n}\n\nfunction forceStoreRerender(fiber) {\n  scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\n}\n\nfunction mountState(initialState) {\n  const hook = mountWorkInProgressHook();\n\n  if (typeof initialState === 'function') {\n    // $FlowFixMe: Flow doesn't like mixed types\n    initialState = initialState();\n  }\n\n  hook.memoizedState = hook.baseState = initialState;\n  const queue = {\n    pending: null,\n    interleaved: null,\n    lanes: NoLanes,\n    dispatch: null,\n    lastRenderedReducer: basicStateReducer,\n    lastRenderedState: initialState\n  };\n  hook.queue = queue;\n  const dispatch = queue.dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue);\n  return [hook.memoizedState, dispatch];\n}\n\nfunction updateState(initialState) {\n  return updateReducer(basicStateReducer, initialState);\n}\n\nfunction rerenderState(initialState) {\n  return rerenderReducer(basicStateReducer, initialState);\n}\n\nfunction pushEffect(tag, create, destroy, deps) {\n  const effect = {\n    tag,\n    create,\n    destroy,\n    deps,\n    // Circular\n    next: null\n  };\n  let componentUpdateQueue = currentlyRenderingFiber.updateQueue;\n\n  if (componentUpdateQueue === null) {\n    componentUpdateQueue = createFunctionComponentUpdateQueue();\n    currentlyRenderingFiber.updateQueue = componentUpdateQueue;\n    componentUpdateQueue.lastEffect = effect.next = effect;\n  } else {\n    const lastEffect = componentUpdateQueue.lastEffect;\n\n    if (lastEffect === null) {\n      componentUpdateQueue.lastEffect = effect.next = effect;\n    } else {\n      const firstEffect = lastEffect.next;\n      lastEffect.next = effect;\n      effect.next = firstEffect;\n      componentUpdateQueue.lastEffect = effect;\n    }\n  }\n\n  return effect;\n}\n\nlet stackContainsErrorMessage = null;\n\nfunction getCallerStackFrame() {\n  // eslint-disable-next-line react-internal/prod-error-codes\n  const stackFrames = new Error('Error message').stack.split('\\n'); // Some browsers (e.g. Chrome) include the error message in the stack\n  // but others (e.g. Firefox) do not.\n\n  if (stackContainsErrorMessage === null) {\n    stackContainsErrorMessage = stackFrames[0].includes('Error message');\n  }\n\n  return stackContainsErrorMessage ? stackFrames.slice(3, 4).join('\\n') : stackFrames.slice(2, 3).join('\\n');\n}\n\nfunction mountRef(initialValue) {\n  const hook = mountWorkInProgressHook();\n\n  if (enableUseRefAccessWarning) {\n    if (__DEV__) {\n      // Support lazy initialization pattern shown in docs.\n      // We need to store the caller stack frame so that we don't warn on subsequent renders.\n      let hasBeenInitialized = initialValue != null;\n      let lazyInitGetterStack = null;\n      let didCheckForLazyInit = false; // Only warn once per component+hook.\n\n      let didWarnAboutRead = false;\n      let didWarnAboutWrite = false;\n      let current = initialValue;\n      const ref = {\n        get current() {\n          if (!hasBeenInitialized) {\n            didCheckForLazyInit = true;\n            lazyInitGetterStack = getCallerStackFrame();\n          } else if (currentlyRenderingFiber !== null && !didWarnAboutRead) {\n            if (lazyInitGetterStack === null || lazyInitGetterStack !== getCallerStackFrame()) {\n              didWarnAboutRead = true;\n              console.warn('%s: Unsafe read of a mutable value during render.\\n\\n' + 'Reading from a ref during render is only safe if:\\n' + '1. The ref value has not been updated, or\\n' + '2. The ref holds a lazily-initialized value that is only set once.\\n', getComponentNameFromFiber(currentlyRenderingFiber) || 'Unknown');\n            }\n          }\n\n          return current;\n        },\n\n        set current(value) {\n          if (currentlyRenderingFiber !== null && !didWarnAboutWrite) {\n            if (hasBeenInitialized || !hasBeenInitialized && !didCheckForLazyInit) {\n              didWarnAboutWrite = true;\n              console.warn('%s: Unsafe write of a mutable value during render.\\n\\n' + 'Writing to a ref during render is only safe if the ref holds ' + 'a lazily-initialized value that is only set once.\\n', getComponentNameFromFiber(currentlyRenderingFiber) || 'Unknown');\n            }\n          }\n\n          hasBeenInitialized = true;\n          current = value;\n        }\n\n      };\n      Object.seal(ref);\n      hook.memoizedState = ref;\n      return ref;\n    } else {\n      const ref = {\n        current: initialValue\n      };\n      hook.memoizedState = ref;\n      return ref;\n    }\n  } else {\n    const ref = {\n      current: initialValue\n    };\n    hook.memoizedState = ref;\n    return ref;\n  }\n}\n\nfunction updateRef(initialValue) {\n  const hook = updateWorkInProgressHook();\n  return hook.memoizedState;\n}\n\nfunction mountEffectImpl(fiberFlags, hookFlags, create, deps) {\n  const hook = mountWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  currentlyRenderingFiber.flags |= fiberFlags;\n  hook.memoizedState = pushEffect(HookHasEffect | hookFlags, create, undefined, nextDeps);\n}\n\nfunction updateEffectImpl(fiberFlags, hookFlags, create, deps) {\n  const hook = updateWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  let destroy = undefined;\n\n  if (currentHook !== null) {\n    const prevEffect = currentHook.memoizedState;\n    destroy = prevEffect.destroy;\n\n    if (nextDeps !== null) {\n      const prevDeps = prevEffect.deps;\n\n      if (areHookInputsEqual(nextDeps, prevDeps)) {\n        hook.memoizedState = pushEffect(hookFlags, create, destroy, nextDeps);\n        return;\n      }\n    }\n  }\n\n  currentlyRenderingFiber.flags |= fiberFlags;\n  hook.memoizedState = pushEffect(HookHasEffect | hookFlags, create, destroy, nextDeps);\n}\n\nfunction mountEffect(create, deps) {\n  if (__DEV__ && enableStrictEffects && (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode) {\n    return mountEffectImpl(MountPassiveDevEffect | PassiveEffect | PassiveStaticEffect, HookPassive, create, deps);\n  } else {\n    return mountEffectImpl(PassiveEffect | PassiveStaticEffect, HookPassive, create, deps);\n  }\n}\n\nfunction updateEffect(create, deps) {\n  return updateEffectImpl(PassiveEffect, HookPassive, create, deps);\n}\n\nfunction mountInsertionEffect(create, deps) {\n  return mountEffectImpl(UpdateEffect, HookInsertion, create, deps);\n}\n\nfunction updateInsertionEffect(create, deps) {\n  return updateEffectImpl(UpdateEffect, HookInsertion, create, deps);\n}\n\nfunction mountLayoutEffect(create, deps) {\n  let fiberFlags = UpdateEffect;\n\n  if (enableSuspenseLayoutEffectSemantics) {\n    fiberFlags |= LayoutStaticEffect;\n  }\n\n  if (__DEV__ && enableStrictEffects && (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode) {\n    fiberFlags |= MountLayoutDevEffect;\n  }\n\n  return mountEffectImpl(fiberFlags, HookLayout, create, deps);\n}\n\nfunction updateLayoutEffect(create, deps) {\n  return updateEffectImpl(UpdateEffect, HookLayout, create, deps);\n}\n\nfunction imperativeHandleEffect(create, ref) {\n  if (typeof ref === 'function') {\n    const refCallback = ref;\n    const inst = create();\n    refCallback(inst);\n    return () => {\n      refCallback(null);\n    };\n  } else if (ref !== null && ref !== undefined) {\n    const refObject = ref;\n\n    if (__DEV__) {\n      if (!refObject.hasOwnProperty('current')) {\n        console.error('Expected useImperativeHandle() first argument to either be a ' + 'ref callback or React.createRef() object. Instead received: %s.', 'an object with keys {' + Object.keys(refObject).join(', ') + '}');\n      }\n    }\n\n    const inst = create();\n    refObject.current = inst;\n    return () => {\n      refObject.current = null;\n    };\n  }\n}\n\nfunction mountImperativeHandle(ref, create, deps) {\n  if (__DEV__) {\n    if (typeof create !== 'function') {\n      console.error('Expected useImperativeHandle() second argument to be a function ' + 'that creates a handle. Instead received: %s.', create !== null ? typeof create : 'null');\n    }\n  } // TODO: If deps are provided, should we skip comparing the ref itself?\n\n\n  const effectDeps = deps !== null && deps !== undefined ? deps.concat([ref]) : null;\n  let fiberFlags = UpdateEffect;\n\n  if (enableSuspenseLayoutEffectSemantics) {\n    fiberFlags |= LayoutStaticEffect;\n  }\n\n  if (__DEV__ && enableStrictEffects && (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode) {\n    fiberFlags |= MountLayoutDevEffect;\n  }\n\n  return mountEffectImpl(fiberFlags, HookLayout, imperativeHandleEffect.bind(null, create, ref), effectDeps);\n}\n\nfunction updateImperativeHandle(ref, create, deps) {\n  if (__DEV__) {\n    if (typeof create !== 'function') {\n      console.error('Expected useImperativeHandle() second argument to be a function ' + 'that creates a handle. Instead received: %s.', create !== null ? typeof create : 'null');\n    }\n  } // TODO: If deps are provided, should we skip comparing the ref itself?\n\n\n  const effectDeps = deps !== null && deps !== undefined ? deps.concat([ref]) : null;\n  return updateEffectImpl(UpdateEffect, HookLayout, imperativeHandleEffect.bind(null, create, ref), effectDeps);\n}\n\nfunction mountDebugValue(value, formatterFn) {// This hook is normally a no-op.\n  // The react-debug-hooks package injects its own implementation\n  // so that e.g. DevTools can display custom hook values.\n}\n\nconst updateDebugValue = mountDebugValue;\n\nfunction mountCallback(callback, deps) {\n  const hook = mountWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  hook.memoizedState = [callback, nextDeps];\n  return callback;\n}\n\nfunction updateCallback(callback, deps) {\n  const hook = updateWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  const prevState = hook.memoizedState;\n\n  if (prevState !== null) {\n    if (nextDeps !== null) {\n      const prevDeps = prevState[1];\n\n      if (areHookInputsEqual(nextDeps, prevDeps)) {\n        return prevState[0];\n      }\n    }\n  }\n\n  hook.memoizedState = [callback, nextDeps];\n  return callback;\n}\n\nfunction mountMemo(nextCreate, deps) {\n  const hook = mountWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  const nextValue = nextCreate();\n  hook.memoizedState = [nextValue, nextDeps];\n  return nextValue;\n}\n\nfunction updateMemo(nextCreate, deps) {\n  const hook = updateWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  const prevState = hook.memoizedState;\n\n  if (prevState !== null) {\n    // Assume these are defined. If they're not, areHookInputsEqual will warn.\n    if (nextDeps !== null) {\n      const prevDeps = prevState[1];\n\n      if (areHookInputsEqual(nextDeps, prevDeps)) {\n        return prevState[0];\n      }\n    }\n  }\n\n  const nextValue = nextCreate();\n  hook.memoizedState = [nextValue, nextDeps];\n  return nextValue;\n}\n\nfunction mountDeferredValue(value) {\n  const [prevValue, setValue] = mountState(value);\n  mountEffect(() => {\n    const prevTransition = ReactCurrentBatchConfig.transition;\n    ReactCurrentBatchConfig.transition = 1;\n\n    try {\n      setValue(value);\n    } finally {\n      ReactCurrentBatchConfig.transition = prevTransition;\n    }\n  }, [value]);\n  return prevValue;\n}\n\nfunction updateDeferredValue(value) {\n  const [prevValue, setValue] = updateState(value);\n  updateEffect(() => {\n    const prevTransition = ReactCurrentBatchConfig.transition;\n    ReactCurrentBatchConfig.transition = 1;\n\n    try {\n      setValue(value);\n    } finally {\n      ReactCurrentBatchConfig.transition = prevTransition;\n    }\n  }, [value]);\n  return prevValue;\n}\n\nfunction rerenderDeferredValue(value) {\n  const [prevValue, setValue] = rerenderState(value);\n  updateEffect(() => {\n    const prevTransition = ReactCurrentBatchConfig.transition;\n    ReactCurrentBatchConfig.transition = 1;\n\n    try {\n      setValue(value);\n    } finally {\n      ReactCurrentBatchConfig.transition = prevTransition;\n    }\n  }, [value]);\n  return prevValue;\n}\n\nfunction startTransition(setPending, callback) {\n  const previousPriority = getCurrentUpdatePriority();\n  setCurrentUpdatePriority(higherEventPriority(previousPriority, ContinuousEventPriority));\n  setPending(true);\n  const prevTransition = ReactCurrentBatchConfig.transition;\n  ReactCurrentBatchConfig.transition = 1;\n\n  try {\n    setPending(false);\n    callback();\n  } finally {\n    setCurrentUpdatePriority(previousPriority);\n    ReactCurrentBatchConfig.transition = prevTransition;\n\n    if (__DEV__) {\n      if (prevTransition !== 1 && warnOnSubscriptionInsideStartTransition && ReactCurrentBatchConfig._updatedFibers) {\n        const updatedFibersCount = ReactCurrentBatchConfig._updatedFibers.size;\n\n        if (updatedFibersCount > 10) {\n          console.warn('Detected a large number of updates inside startTransition. ' + 'If this is due to a subscription please re-write it to use React provided hooks. ' + 'Otherwise concurrent mode guarantees are off the table.');\n        }\n\n        ReactCurrentBatchConfig._updatedFibers.clear();\n      }\n    }\n  }\n}\n\nfunction mountTransition() {\n  const [isPending, setPending] = mountState(false); // The `start` method never changes.\n\n  const start = startTransition.bind(null, setPending);\n  const hook = mountWorkInProgressHook();\n  hook.memoizedState = start;\n  return [isPending, start];\n}\n\nfunction updateTransition() {\n  const [isPending] = updateState(false);\n  const hook = updateWorkInProgressHook();\n  const start = hook.memoizedState;\n  return [isPending, start];\n}\n\nfunction rerenderTransition() {\n  const [isPending] = rerenderState(false);\n  const hook = updateWorkInProgressHook();\n  const start = hook.memoizedState;\n  return [isPending, start];\n}\n\nlet isUpdatingOpaqueValueInRenderPhase = false;\nexport function getIsUpdatingOpaqueValueInRenderPhaseInDEV() {\n  if (__DEV__) {\n    return isUpdatingOpaqueValueInRenderPhase;\n  }\n}\n\nfunction mountId() {\n  const hook = mountWorkInProgressHook();\n  let id;\n\n  if (getIsHydrating()) {\n    const treeId = getTreeId(); // Use a captial R prefix for server-generated ids.\n\n    id = 'R:' + treeId; // Unless this is the first id at this level, append a number at the end\n    // that represents the position of this useId hook among all the useId\n    // hooks for this fiber.\n\n    const localId = localIdCounter++;\n\n    if (localId > 0) {\n      id += ':' + localId.toString(32);\n    }\n  } else {\n    // Use a lowercase r prefix for client-generated ids.\n    const globalClientId = globalClientIdCounter++;\n    id = 'r:' + globalClientId.toString(32);\n  }\n\n  hook.memoizedState = id;\n  return id;\n}\n\nfunction updateId() {\n  const hook = updateWorkInProgressHook();\n  const id = hook.memoizedState;\n  return id;\n}\n\nfunction mountRefresh() {\n  const hook = mountWorkInProgressHook();\n  const refresh = hook.memoizedState = refreshCache.bind(null, currentlyRenderingFiber);\n  return refresh;\n}\n\nfunction updateRefresh() {\n  const hook = updateWorkInProgressHook();\n  return hook.memoizedState;\n}\n\nfunction refreshCache(fiber, seedKey, seedValue) {\n  if (!enableCache) {\n    return;\n  } // TODO: Does Cache work in legacy mode? Should decide and write a test.\n  // TODO: Consider warning if the refresh is at discrete priority, or if we\n  // otherwise suspect that it wasn't batched properly.\n\n\n  let provider = fiber.return;\n\n  while (provider !== null) {\n    switch (provider.tag) {\n      case CacheComponent:\n      case HostRoot:\n        {\n          const lane = requestUpdateLane(provider);\n          const eventTime = requestEventTime();\n          const root = scheduleUpdateOnFiber(provider, lane, eventTime);\n\n          if (root !== null) {\n            entangleLegacyQueueTransitions(root, provider, lane);\n          } // TODO: If a refresh never commits, the new cache created here must be\n          // released. A simple case is start refreshing a cache boundary, but then\n          // unmount that boundary before the refresh completes.\n\n\n          const seededCache = createCache();\n\n          if (seedKey !== null && seedKey !== undefined && root !== null) {\n            // Seed the cache with the value passed by the caller. This could be\n            // from a server mutation, or it could be a streaming response.\n            seededCache.data.set(seedKey, seedValue);\n          } // Schedule an update on the cache boundary to trigger a refresh.\n\n\n          const refreshUpdate = createLegacyQueueUpdate(eventTime, lane);\n          const payload = {\n            cache: seededCache\n          };\n          refreshUpdate.payload = payload;\n          enqueueLegacyQueueUpdate(provider, refreshUpdate, lane);\n          return;\n        }\n    }\n\n    provider = provider.return;\n  } // TODO: Warn if unmounted?\n\n}\n\nfunction dispatchReducerAction(fiber, queue, action) {\n  if (__DEV__) {\n    if (typeof arguments[3] === 'function') {\n      console.error(\"State updates from the useState() and useReducer() Hooks don't support the \" + 'second callback argument. To execute a side effect after ' + 'rendering, declare it in the component body with useEffect().');\n    }\n  }\n\n  const lane = requestUpdateLane(fiber);\n  const update = {\n    lane,\n    action,\n    hasEagerState: false,\n    eagerState: null,\n    next: null\n  };\n\n  if (isRenderPhaseUpdate(fiber)) {\n    enqueueRenderPhaseUpdate(queue, update);\n  } else {\n    enqueueUpdate(fiber, queue, update, lane);\n    const eventTime = requestEventTime();\n    const root = scheduleUpdateOnFiber(fiber, lane, eventTime);\n\n    if (root !== null) {\n      entangleTransitionUpdate(root, queue, lane);\n    }\n  }\n\n  markUpdateInDevTools(fiber, lane, action);\n}\n\nfunction dispatchSetState(fiber, queue, action) {\n  if (__DEV__) {\n    if (typeof arguments[3] === 'function') {\n      console.error(\"State updates from the useState() and useReducer() Hooks don't support the \" + 'second callback argument. To execute a side effect after ' + 'rendering, declare it in the component body with useEffect().');\n    }\n  }\n\n  const lane = requestUpdateLane(fiber);\n  const update = {\n    lane,\n    action,\n    hasEagerState: false,\n    eagerState: null,\n    next: null\n  };\n\n  if (isRenderPhaseUpdate(fiber)) {\n    enqueueRenderPhaseUpdate(queue, update);\n  } else {\n    enqueueUpdate(fiber, queue, update, lane);\n    const alternate = fiber.alternate;\n\n    if (fiber.lanes === NoLanes && (alternate === null || alternate.lanes === NoLanes)) {\n      // The queue is currently empty, which means we can eagerly compute the\n      // next state before entering the render phase. If the new state is the\n      // same as the current state, we may be able to bail out entirely.\n      const lastRenderedReducer = queue.lastRenderedReducer;\n\n      if (lastRenderedReducer !== null) {\n        let prevDispatcher;\n\n        if (__DEV__) {\n          prevDispatcher = ReactCurrentDispatcher.current;\n          ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n        }\n\n        try {\n          const currentState = queue.lastRenderedState;\n          const eagerState = lastRenderedReducer(currentState, action); // Stash the eagerly computed state, and the reducer used to compute\n          // it, on the update object. If the reducer hasn't changed by the\n          // time we enter the render phase, then the eager state can be used\n          // without calling the reducer again.\n\n          update.hasEagerState = true;\n          update.eagerState = eagerState;\n\n          if (is(eagerState, currentState)) {\n            // Fast path. We can bail out without scheduling React to re-render.\n            // It's still possible that we'll need to rebase this update later,\n            // if the component re-renders for a different reason and by that\n            // time the reducer has changed.\n            return;\n          }\n        } catch (error) {// Suppress the error. It will throw again in the render phase.\n        } finally {\n          if (__DEV__) {\n            ReactCurrentDispatcher.current = prevDispatcher;\n          }\n        }\n      }\n    }\n\n    const eventTime = requestEventTime();\n    const root = scheduleUpdateOnFiber(fiber, lane, eventTime);\n\n    if (root !== null) {\n      entangleTransitionUpdate(root, queue, lane);\n    }\n  }\n\n  markUpdateInDevTools(fiber, lane, action);\n}\n\nfunction isRenderPhaseUpdate(fiber) {\n  const alternate = fiber.alternate;\n  return fiber === currentlyRenderingFiber || alternate !== null && alternate === currentlyRenderingFiber;\n}\n\nfunction enqueueRenderPhaseUpdate(queue, update) {\n  // This is a render phase update. Stash it in a lazily-created map of\n  // queue -> linked list of updates. After this render pass, we'll restart\n  // and apply the stashed updates on top of the work-in-progress hook.\n  didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;\n  const pending = queue.pending;\n\n  if (pending === null) {\n    // This is the first update. Create a circular list.\n    update.next = update;\n  } else {\n    update.next = pending.next;\n    pending.next = update;\n  }\n\n  queue.pending = update;\n}\n\nfunction enqueueUpdate(fiber, queue, update, lane) {\n  if (isInterleavedUpdate(fiber, lane)) {\n    const interleaved = queue.interleaved;\n\n    if (interleaved === null) {\n      // This is the first update. Create a circular list.\n      update.next = update; // At the end of the current render, this queue's interleaved updates will\n      // be transferred to the pending queue.\n\n      pushInterleavedQueue(queue);\n    } else {\n      update.next = interleaved.next;\n      interleaved.next = update;\n    }\n\n    queue.interleaved = update;\n  } else {\n    const pending = queue.pending;\n\n    if (pending === null) {\n      // This is the first update. Create a circular list.\n      update.next = update;\n    } else {\n      update.next = pending.next;\n      pending.next = update;\n    }\n\n    queue.pending = update;\n  }\n}\n\nfunction entangleTransitionUpdate(root, queue, lane) {\n  if (isTransitionLane(lane)) {\n    let queueLanes = queue.lanes; // If any entangled lanes are no longer pending on the root, then they\n    // must have finished. We can remove them from the shared queue, which\n    // represents a superset of the actually pending lanes. In some cases we\n    // may entangle more than we need to, but that's OK. In fact it's worse if\n    // we *don't* entangle when we should.\n\n    queueLanes = intersectLanes(queueLanes, root.pendingLanes); // Entangle the new transition lane with the other transition lanes.\n\n    const newQueueLanes = mergeLanes(queueLanes, lane);\n    queue.lanes = newQueueLanes; // Even if queue.lanes already include lane, we don't know for certain if\n    // the lane finished since the last time we entangled it. So we need to\n    // entangle it again, just to be sure.\n\n    markRootEntangled(root, newQueueLanes);\n  }\n}\n\nfunction markUpdateInDevTools(fiber, lane, action) {\n  if (__DEV__) {\n    if (enableDebugTracing) {\n      if (fiber.mode & DebugTracingMode) {\n        const name = getComponentNameFromFiber(fiber) || 'Unknown';\n        logStateUpdateScheduled(name, lane, action);\n      }\n    }\n  }\n\n  if (enableSchedulingProfiler) {\n    markStateUpdateScheduled(fiber, lane);\n  }\n}\n\nfunction getCacheSignal() {\n  if (!enableCache) {\n    throw new Error('Not implemented.');\n  }\n\n  const cache = readContext(CacheContext);\n  return cache.controller.signal;\n}\n\nfunction getCacheForType(resourceType) {\n  if (!enableCache) {\n    throw new Error('Not implemented.');\n  }\n\n  const cache = readContext(CacheContext);\n  let cacheForType = cache.data.get(resourceType);\n\n  if (cacheForType === undefined) {\n    cacheForType = resourceType();\n    cache.data.set(resourceType, cacheForType);\n  }\n\n  return cacheForType;\n}\n\nexport const ContextOnlyDispatcher = {\n  readContext,\n  useCallback: throwInvalidHookError,\n  useContext: throwInvalidHookError,\n  useEffect: throwInvalidHookError,\n  useImperativeHandle: throwInvalidHookError,\n  useInsertionEffect: throwInvalidHookError,\n  useLayoutEffect: throwInvalidHookError,\n  useMemo: throwInvalidHookError,\n  useReducer: throwInvalidHookError,\n  useRef: throwInvalidHookError,\n  useState: throwInvalidHookError,\n  useDebugValue: throwInvalidHookError,\n  useDeferredValue: throwInvalidHookError,\n  useTransition: throwInvalidHookError,\n  useMutableSource: throwInvalidHookError,\n  useSyncExternalStore: throwInvalidHookError,\n  useId: throwInvalidHookError,\n  unstable_isNewReconciler: enableNewReconciler\n};\n\nif (enableCache) {\n  ContextOnlyDispatcher.getCacheSignal = getCacheSignal;\n  ContextOnlyDispatcher.getCacheForType = getCacheForType;\n  ContextOnlyDispatcher.useCacheRefresh = throwInvalidHookError;\n}\n\nconst HooksDispatcherOnMount = {\n  readContext,\n  useCallback: mountCallback,\n  useContext: readContext,\n  useEffect: mountEffect,\n  useImperativeHandle: mountImperativeHandle,\n  useLayoutEffect: mountLayoutEffect,\n  useInsertionEffect: mountInsertionEffect,\n  useMemo: mountMemo,\n  useReducer: mountReducer,\n  useRef: mountRef,\n  useState: mountState,\n  useDebugValue: mountDebugValue,\n  useDeferredValue: mountDeferredValue,\n  useTransition: mountTransition,\n  useMutableSource: mountMutableSource,\n  useSyncExternalStore: mountSyncExternalStore,\n  useId: mountId,\n  unstable_isNewReconciler: enableNewReconciler\n};\n\nif (enableCache) {\n  HooksDispatcherOnMount.getCacheSignal = getCacheSignal;\n  HooksDispatcherOnMount.getCacheForType = getCacheForType;\n  HooksDispatcherOnMount.useCacheRefresh = mountRefresh;\n}\n\nconst HooksDispatcherOnUpdate = {\n  readContext,\n  useCallback: updateCallback,\n  useContext: readContext,\n  useEffect: updateEffect,\n  useImperativeHandle: updateImperativeHandle,\n  useInsertionEffect: updateInsertionEffect,\n  useLayoutEffect: updateLayoutEffect,\n  useMemo: updateMemo,\n  useReducer: updateReducer,\n  useRef: updateRef,\n  useState: updateState,\n  useDebugValue: updateDebugValue,\n  useDeferredValue: updateDeferredValue,\n  useTransition: updateTransition,\n  useMutableSource: updateMutableSource,\n  useSyncExternalStore: updateSyncExternalStore,\n  useId: updateId,\n  unstable_isNewReconciler: enableNewReconciler\n};\n\nif (enableCache) {\n  HooksDispatcherOnUpdate.getCacheSignal = getCacheSignal;\n  HooksDispatcherOnUpdate.getCacheForType = getCacheForType;\n  HooksDispatcherOnUpdate.useCacheRefresh = updateRefresh;\n}\n\nconst HooksDispatcherOnRerender = {\n  readContext,\n  useCallback: updateCallback,\n  useContext: readContext,\n  useEffect: updateEffect,\n  useImperativeHandle: updateImperativeHandle,\n  useInsertionEffect: updateInsertionEffect,\n  useLayoutEffect: updateLayoutEffect,\n  useMemo: updateMemo,\n  useReducer: rerenderReducer,\n  useRef: updateRef,\n  useState: rerenderState,\n  useDebugValue: updateDebugValue,\n  useDeferredValue: rerenderDeferredValue,\n  useTransition: rerenderTransition,\n  useMutableSource: updateMutableSource,\n  useSyncExternalStore: mountSyncExternalStore,\n  useId: updateId,\n  unstable_isNewReconciler: enableNewReconciler\n};\n\nif (enableCache) {\n  HooksDispatcherOnRerender.getCacheSignal = getCacheSignal;\n  HooksDispatcherOnRerender.getCacheForType = getCacheForType;\n  HooksDispatcherOnRerender.useCacheRefresh = updateRefresh;\n}\n\nlet HooksDispatcherOnMountInDEV = null;\nlet HooksDispatcherOnMountWithHookTypesInDEV = null;\nlet HooksDispatcherOnUpdateInDEV = null;\nlet HooksDispatcherOnRerenderInDEV = null;\nlet InvalidNestedHooksDispatcherOnMountInDEV = null;\nlet InvalidNestedHooksDispatcherOnUpdateInDEV = null;\nlet InvalidNestedHooksDispatcherOnRerenderInDEV = null;\n\nif (__DEV__) {\n  const warnInvalidContextAccess = () => {\n    console.error('Context can only be read while React is rendering. ' + 'In classes, you can read it in the render method or getDerivedStateFromProps. ' + 'In function components, you can read it directly in the function body, but not ' + 'inside Hooks like useReducer() or useMemo().');\n  };\n\n  const warnInvalidHookAccess = () => {\n    console.error('Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. ' + 'You can only call Hooks at the top level of your React function. ' + 'For more information, see ' + 'https://reactjs.org/link/rules-of-hooks');\n  };\n\n  HooksDispatcherOnMountInDEV = {\n    readContext(context) {\n      return readContext(context);\n    },\n\n    useCallback(callback, deps) {\n      currentHookNameInDev = 'useCallback';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      return mountCallback(callback, deps);\n    },\n\n    useContext(context) {\n      currentHookNameInDev = 'useContext';\n      mountHookTypesDev();\n      return readContext(context);\n    },\n\n    useEffect(create, deps) {\n      currentHookNameInDev = 'useEffect';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      return mountEffect(create, deps);\n    },\n\n    useImperativeHandle(ref, create, deps) {\n      currentHookNameInDev = 'useImperativeHandle';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      return mountImperativeHandle(ref, create, deps);\n    },\n\n    useInsertionEffect(create, deps) {\n      currentHookNameInDev = 'useInsertionEffect';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      return mountInsertionEffect(create, deps);\n    },\n\n    useLayoutEffect(create, deps) {\n      currentHookNameInDev = 'useLayoutEffect';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      return mountLayoutEffect(create, deps);\n    },\n\n    useMemo(create, deps) {\n      currentHookNameInDev = 'useMemo';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n      try {\n        return mountMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useReducer(reducer, initialArg, init) {\n      currentHookNameInDev = 'useReducer';\n      mountHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n      try {\n        return mountReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useRef(initialValue) {\n      currentHookNameInDev = 'useRef';\n      mountHookTypesDev();\n      return mountRef(initialValue);\n    },\n\n    useState(initialState) {\n      currentHookNameInDev = 'useState';\n      mountHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n      try {\n        return mountState(initialState);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useDebugValue(value, formatterFn) {\n      currentHookNameInDev = 'useDebugValue';\n      mountHookTypesDev();\n      return mountDebugValue(value, formatterFn);\n    },\n\n    useDeferredValue(value) {\n      currentHookNameInDev = 'useDeferredValue';\n      mountHookTypesDev();\n      return mountDeferredValue(value);\n    },\n\n    useTransition() {\n      currentHookNameInDev = 'useTransition';\n      mountHookTypesDev();\n      return mountTransition();\n    },\n\n    useMutableSource(source, getSnapshot, subscribe) {\n      currentHookNameInDev = 'useMutableSource';\n      mountHookTypesDev();\n      return mountMutableSource(source, getSnapshot, subscribe);\n    },\n\n    useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n      currentHookNameInDev = 'useSyncExternalStore';\n      mountHookTypesDev();\n      return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n    },\n\n    useId() {\n      currentHookNameInDev = 'useId';\n      mountHookTypesDev();\n      return mountId();\n    },\n\n    unstable_isNewReconciler: enableNewReconciler\n  };\n\n  if (enableCache) {\n    HooksDispatcherOnMountInDEV.getCacheSignal = getCacheSignal;\n    HooksDispatcherOnMountInDEV.getCacheForType = getCacheForType;\n\n    HooksDispatcherOnMountInDEV.useCacheRefresh = function useCacheRefresh() {\n      currentHookNameInDev = 'useCacheRefresh';\n      mountHookTypesDev();\n      return mountRefresh();\n    };\n  }\n\n  HooksDispatcherOnMountWithHookTypesInDEV = {\n    readContext(context) {\n      return readContext(context);\n    },\n\n    useCallback(callback, deps) {\n      currentHookNameInDev = 'useCallback';\n      updateHookTypesDev();\n      return mountCallback(callback, deps);\n    },\n\n    useContext(context) {\n      currentHookNameInDev = 'useContext';\n      updateHookTypesDev();\n      return readContext(context);\n    },\n\n    useEffect(create, deps) {\n      currentHookNameInDev = 'useEffect';\n      updateHookTypesDev();\n      return mountEffect(create, deps);\n    },\n\n    useImperativeHandle(ref, create, deps) {\n      currentHookNameInDev = 'useImperativeHandle';\n      updateHookTypesDev();\n      return mountImperativeHandle(ref, create, deps);\n    },\n\n    useInsertionEffect(create, deps) {\n      currentHookNameInDev = 'useInsertionEffect';\n      updateHookTypesDev();\n      return mountInsertionEffect(create, deps);\n    },\n\n    useLayoutEffect(create, deps) {\n      currentHookNameInDev = 'useLayoutEffect';\n      updateHookTypesDev();\n      return mountLayoutEffect(create, deps);\n    },\n\n    useMemo(create, deps) {\n      currentHookNameInDev = 'useMemo';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n      try {\n        return mountMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useReducer(reducer, initialArg, init) {\n      currentHookNameInDev = 'useReducer';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n      try {\n        return mountReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useRef(initialValue) {\n      currentHookNameInDev = 'useRef';\n      updateHookTypesDev();\n      return mountRef(initialValue);\n    },\n\n    useState(initialState) {\n      currentHookNameInDev = 'useState';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n      try {\n        return mountState(initialState);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useDebugValue(value, formatterFn) {\n      currentHookNameInDev = 'useDebugValue';\n      updateHookTypesDev();\n      return mountDebugValue(value, formatterFn);\n    },\n\n    useDeferredValue(value) {\n      currentHookNameInDev = 'useDeferredValue';\n      updateHookTypesDev();\n      return mountDeferredValue(value);\n    },\n\n    useTransition() {\n      currentHookNameInDev = 'useTransition';\n      updateHookTypesDev();\n      return mountTransition();\n    },\n\n    useMutableSource(source, getSnapshot, subscribe) {\n      currentHookNameInDev = 'useMutableSource';\n      updateHookTypesDev();\n      return mountMutableSource(source, getSnapshot, subscribe);\n    },\n\n    useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n      currentHookNameInDev = 'useSyncExternalStore';\n      updateHookTypesDev();\n      return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n    },\n\n    useId() {\n      currentHookNameInDev = 'useId';\n      updateHookTypesDev();\n      return mountId();\n    },\n\n    unstable_isNewReconciler: enableNewReconciler\n  };\n\n  if (enableCache) {\n    HooksDispatcherOnMountWithHookTypesInDEV.getCacheSignal = getCacheSignal;\n    HooksDispatcherOnMountWithHookTypesInDEV.getCacheForType = getCacheForType;\n\n    HooksDispatcherOnMountWithHookTypesInDEV.useCacheRefresh = function useCacheRefresh() {\n      currentHookNameInDev = 'useCacheRefresh';\n      updateHookTypesDev();\n      return mountRefresh();\n    };\n  }\n\n  HooksDispatcherOnUpdateInDEV = {\n    readContext(context) {\n      return readContext(context);\n    },\n\n    useCallback(callback, deps) {\n      currentHookNameInDev = 'useCallback';\n      updateHookTypesDev();\n      return updateCallback(callback, deps);\n    },\n\n    useContext(context) {\n      currentHookNameInDev = 'useContext';\n      updateHookTypesDev();\n      return readContext(context);\n    },\n\n    useEffect(create, deps) {\n      currentHookNameInDev = 'useEffect';\n      updateHookTypesDev();\n      return updateEffect(create, deps);\n    },\n\n    useImperativeHandle(ref, create, deps) {\n      currentHookNameInDev = 'useImperativeHandle';\n      updateHookTypesDev();\n      return updateImperativeHandle(ref, create, deps);\n    },\n\n    useInsertionEffect(create, deps) {\n      currentHookNameInDev = 'useInsertionEffect';\n      updateHookTypesDev();\n      return updateInsertionEffect(create, deps);\n    },\n\n    useLayoutEffect(create, deps) {\n      currentHookNameInDev = 'useLayoutEffect';\n      updateHookTypesDev();\n      return updateLayoutEffect(create, deps);\n    },\n\n    useMemo(create, deps) {\n      currentHookNameInDev = 'useMemo';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n      try {\n        return updateMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useReducer(reducer, initialArg, init) {\n      currentHookNameInDev = 'useReducer';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n      try {\n        return updateReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useRef(initialValue) {\n      currentHookNameInDev = 'useRef';\n      updateHookTypesDev();\n      return updateRef(initialValue);\n    },\n\n    useState(initialState) {\n      currentHookNameInDev = 'useState';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n      try {\n        return updateState(initialState);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useDebugValue(value, formatterFn) {\n      currentHookNameInDev = 'useDebugValue';\n      updateHookTypesDev();\n      return updateDebugValue(value, formatterFn);\n    },\n\n    useDeferredValue(value) {\n      currentHookNameInDev = 'useDeferredValue';\n      updateHookTypesDev();\n      return updateDeferredValue(value);\n    },\n\n    useTransition() {\n      currentHookNameInDev = 'useTransition';\n      updateHookTypesDev();\n      return updateTransition();\n    },\n\n    useMutableSource(source, getSnapshot, subscribe) {\n      currentHookNameInDev = 'useMutableSource';\n      updateHookTypesDev();\n      return updateMutableSource(source, getSnapshot, subscribe);\n    },\n\n    useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n      currentHookNameInDev = 'useSyncExternalStore';\n      updateHookTypesDev();\n      return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n    },\n\n    useId() {\n      currentHookNameInDev = 'useId';\n      updateHookTypesDev();\n      return updateId();\n    },\n\n    unstable_isNewReconciler: enableNewReconciler\n  };\n\n  if (enableCache) {\n    HooksDispatcherOnUpdateInDEV.getCacheSignal = getCacheSignal;\n    HooksDispatcherOnUpdateInDEV.getCacheForType = getCacheForType;\n\n    HooksDispatcherOnUpdateInDEV.useCacheRefresh = function useCacheRefresh() {\n      currentHookNameInDev = 'useCacheRefresh';\n      updateHookTypesDev();\n      return updateRefresh();\n    };\n  }\n\n  HooksDispatcherOnRerenderInDEV = {\n    readContext(context) {\n      return readContext(context);\n    },\n\n    useCallback(callback, deps) {\n      currentHookNameInDev = 'useCallback';\n      updateHookTypesDev();\n      return updateCallback(callback, deps);\n    },\n\n    useContext(context) {\n      currentHookNameInDev = 'useContext';\n      updateHookTypesDev();\n      return readContext(context);\n    },\n\n    useEffect(create, deps) {\n      currentHookNameInDev = 'useEffect';\n      updateHookTypesDev();\n      return updateEffect(create, deps);\n    },\n\n    useImperativeHandle(ref, create, deps) {\n      currentHookNameInDev = 'useImperativeHandle';\n      updateHookTypesDev();\n      return updateImperativeHandle(ref, create, deps);\n    },\n\n    useInsertionEffect(create, deps) {\n      currentHookNameInDev = 'useInsertionEffect';\n      updateHookTypesDev();\n      return updateInsertionEffect(create, deps);\n    },\n\n    useLayoutEffect(create, deps) {\n      currentHookNameInDev = 'useLayoutEffect';\n      updateHookTypesDev();\n      return updateLayoutEffect(create, deps);\n    },\n\n    useMemo(create, deps) {\n      currentHookNameInDev = 'useMemo';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnRerenderInDEV;\n\n      try {\n        return updateMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useReducer(reducer, initialArg, init) {\n      currentHookNameInDev = 'useReducer';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnRerenderInDEV;\n\n      try {\n        return rerenderReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useRef(initialValue) {\n      currentHookNameInDev = 'useRef';\n      updateHookTypesDev();\n      return updateRef(initialValue);\n    },\n\n    useState(initialState) {\n      currentHookNameInDev = 'useState';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnRerenderInDEV;\n\n      try {\n        return rerenderState(initialState);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useDebugValue(value, formatterFn) {\n      currentHookNameInDev = 'useDebugValue';\n      updateHookTypesDev();\n      return updateDebugValue(value, formatterFn);\n    },\n\n    useDeferredValue(value) {\n      currentHookNameInDev = 'useDeferredValue';\n      updateHookTypesDev();\n      return rerenderDeferredValue(value);\n    },\n\n    useTransition() {\n      currentHookNameInDev = 'useTransition';\n      updateHookTypesDev();\n      return rerenderTransition();\n    },\n\n    useMutableSource(source, getSnapshot, subscribe) {\n      currentHookNameInDev = 'useMutableSource';\n      updateHookTypesDev();\n      return updateMutableSource(source, getSnapshot, subscribe);\n    },\n\n    useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n      currentHookNameInDev = 'useSyncExternalStore';\n      updateHookTypesDev();\n      return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n    },\n\n    useId() {\n      currentHookNameInDev = 'useId';\n      updateHookTypesDev();\n      return updateId();\n    },\n\n    unstable_isNewReconciler: enableNewReconciler\n  };\n\n  if (enableCache) {\n    HooksDispatcherOnRerenderInDEV.getCacheSignal = getCacheSignal;\n    HooksDispatcherOnRerenderInDEV.getCacheForType = getCacheForType;\n\n    HooksDispatcherOnRerenderInDEV.useCacheRefresh = function useCacheRefresh() {\n      currentHookNameInDev = 'useCacheRefresh';\n      updateHookTypesDev();\n      return updateRefresh();\n    };\n  }\n\n  InvalidNestedHooksDispatcherOnMountInDEV = {\n    readContext(context) {\n      warnInvalidContextAccess();\n      return readContext(context);\n    },\n\n    useCallback(callback, deps) {\n      currentHookNameInDev = 'useCallback';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountCallback(callback, deps);\n    },\n\n    useContext(context) {\n      currentHookNameInDev = 'useContext';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return readContext(context);\n    },\n\n    useEffect(create, deps) {\n      currentHookNameInDev = 'useEffect';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountEffect(create, deps);\n    },\n\n    useImperativeHandle(ref, create, deps) {\n      currentHookNameInDev = 'useImperativeHandle';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountImperativeHandle(ref, create, deps);\n    },\n\n    useInsertionEffect(create, deps) {\n      currentHookNameInDev = 'useInsertionEffect';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountInsertionEffect(create, deps);\n    },\n\n    useLayoutEffect(create, deps) {\n      currentHookNameInDev = 'useLayoutEffect';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountLayoutEffect(create, deps);\n    },\n\n    useMemo(create, deps) {\n      currentHookNameInDev = 'useMemo';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n      try {\n        return mountMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useReducer(reducer, initialArg, init) {\n      currentHookNameInDev = 'useReducer';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n      try {\n        return mountReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useRef(initialValue) {\n      currentHookNameInDev = 'useRef';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountRef(initialValue);\n    },\n\n    useState(initialState) {\n      currentHookNameInDev = 'useState';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n      try {\n        return mountState(initialState);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useDebugValue(value, formatterFn) {\n      currentHookNameInDev = 'useDebugValue';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountDebugValue(value, formatterFn);\n    },\n\n    useDeferredValue(value) {\n      currentHookNameInDev = 'useDeferredValue';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountDeferredValue(value);\n    },\n\n    useTransition() {\n      currentHookNameInDev = 'useTransition';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountTransition();\n    },\n\n    useMutableSource(source, getSnapshot, subscribe) {\n      currentHookNameInDev = 'useMutableSource';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountMutableSource(source, getSnapshot, subscribe);\n    },\n\n    useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n      currentHookNameInDev = 'useSyncExternalStore';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n    },\n\n    useId() {\n      currentHookNameInDev = 'useId';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountId();\n    },\n\n    unstable_isNewReconciler: enableNewReconciler\n  };\n\n  if (enableCache) {\n    InvalidNestedHooksDispatcherOnMountInDEV.getCacheSignal = getCacheSignal;\n    InvalidNestedHooksDispatcherOnMountInDEV.getCacheForType = getCacheForType;\n\n    InvalidNestedHooksDispatcherOnMountInDEV.useCacheRefresh = function useCacheRefresh() {\n      currentHookNameInDev = 'useCacheRefresh';\n      updateHookTypesDev();\n      return mountRefresh();\n    };\n  }\n\n  InvalidNestedHooksDispatcherOnUpdateInDEV = {\n    readContext(context) {\n      warnInvalidContextAccess();\n      return readContext(context);\n    },\n\n    useCallback(callback, deps) {\n      currentHookNameInDev = 'useCallback';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateCallback(callback, deps);\n    },\n\n    useContext(context) {\n      currentHookNameInDev = 'useContext';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return readContext(context);\n    },\n\n    useEffect(create, deps) {\n      currentHookNameInDev = 'useEffect';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateEffect(create, deps);\n    },\n\n    useImperativeHandle(ref, create, deps) {\n      currentHookNameInDev = 'useImperativeHandle';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateImperativeHandle(ref, create, deps);\n    },\n\n    useInsertionEffect(create, deps) {\n      currentHookNameInDev = 'useInsertionEffect';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateInsertionEffect(create, deps);\n    },\n\n    useLayoutEffect(create, deps) {\n      currentHookNameInDev = 'useLayoutEffect';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateLayoutEffect(create, deps);\n    },\n\n    useMemo(create, deps) {\n      currentHookNameInDev = 'useMemo';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n      try {\n        return updateMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useReducer(reducer, initialArg, init) {\n      currentHookNameInDev = 'useReducer';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n      try {\n        return updateReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useRef(initialValue) {\n      currentHookNameInDev = 'useRef';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateRef(initialValue);\n    },\n\n    useState(initialState) {\n      currentHookNameInDev = 'useState';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n      try {\n        return updateState(initialState);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useDebugValue(value, formatterFn) {\n      currentHookNameInDev = 'useDebugValue';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateDebugValue(value, formatterFn);\n    },\n\n    useDeferredValue(value) {\n      currentHookNameInDev = 'useDeferredValue';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateDeferredValue(value);\n    },\n\n    useTransition() {\n      currentHookNameInDev = 'useTransition';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateTransition();\n    },\n\n    useMutableSource(source, getSnapshot, subscribe) {\n      currentHookNameInDev = 'useMutableSource';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateMutableSource(source, getSnapshot, subscribe);\n    },\n\n    useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n      currentHookNameInDev = 'useSyncExternalStore';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n    },\n\n    useId() {\n      currentHookNameInDev = 'useId';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateId();\n    },\n\n    unstable_isNewReconciler: enableNewReconciler\n  };\n\n  if (enableCache) {\n    InvalidNestedHooksDispatcherOnUpdateInDEV.getCacheSignal = getCacheSignal;\n    InvalidNestedHooksDispatcherOnUpdateInDEV.getCacheForType = getCacheForType;\n\n    InvalidNestedHooksDispatcherOnUpdateInDEV.useCacheRefresh = function useCacheRefresh() {\n      currentHookNameInDev = 'useCacheRefresh';\n      updateHookTypesDev();\n      return updateRefresh();\n    };\n  }\n\n  InvalidNestedHooksDispatcherOnRerenderInDEV = {\n    readContext(context) {\n      warnInvalidContextAccess();\n      return readContext(context);\n    },\n\n    useCallback(callback, deps) {\n      currentHookNameInDev = 'useCallback';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateCallback(callback, deps);\n    },\n\n    useContext(context) {\n      currentHookNameInDev = 'useContext';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return readContext(context);\n    },\n\n    useEffect(create, deps) {\n      currentHookNameInDev = 'useEffect';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateEffect(create, deps);\n    },\n\n    useImperativeHandle(ref, create, deps) {\n      currentHookNameInDev = 'useImperativeHandle';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateImperativeHandle(ref, create, deps);\n    },\n\n    useInsertionEffect(create, deps) {\n      currentHookNameInDev = 'useInsertionEffect';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateInsertionEffect(create, deps);\n    },\n\n    useLayoutEffect(create, deps) {\n      currentHookNameInDev = 'useLayoutEffect';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateLayoutEffect(create, deps);\n    },\n\n    useMemo(create, deps) {\n      currentHookNameInDev = 'useMemo';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n      try {\n        return updateMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useReducer(reducer, initialArg, init) {\n      currentHookNameInDev = 'useReducer';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n      try {\n        return rerenderReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useRef(initialValue) {\n      currentHookNameInDev = 'useRef';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateRef(initialValue);\n    },\n\n    useState(initialState) {\n      currentHookNameInDev = 'useState';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n      try {\n        return rerenderState(initialState);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useDebugValue(value, formatterFn) {\n      currentHookNameInDev = 'useDebugValue';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateDebugValue(value, formatterFn);\n    },\n\n    useDeferredValue(value) {\n      currentHookNameInDev = 'useDeferredValue';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return rerenderDeferredValue(value);\n    },\n\n    useTransition() {\n      currentHookNameInDev = 'useTransition';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return rerenderTransition();\n    },\n\n    useMutableSource(source, getSnapshot, subscribe) {\n      currentHookNameInDev = 'useMutableSource';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateMutableSource(source, getSnapshot, subscribe);\n    },\n\n    useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n      currentHookNameInDev = 'useSyncExternalStore';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n    },\n\n    useId() {\n      currentHookNameInDev = 'useId';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateId();\n    },\n\n    unstable_isNewReconciler: enableNewReconciler\n  };\n\n  if (enableCache) {\n    InvalidNestedHooksDispatcherOnRerenderInDEV.getCacheSignal = getCacheSignal;\n    InvalidNestedHooksDispatcherOnRerenderInDEV.getCacheForType = getCacheForType;\n\n    InvalidNestedHooksDispatcherOnRerenderInDEV.useCacheRefresh = function useCacheRefresh() {\n      currentHookNameInDev = 'useCacheRefresh';\n      updateHookTypesDev();\n      return updateRefresh();\n    };\n  }\n}","map":{"version":3,"sources":["/Users/zhangshuo/git/react-source-test/src/react/packages/react-reconciler/src/ReactFiberHooks.new.js"],"names":["ReactSharedInternals","enableDebugTracing","enableSchedulingProfiler","enableNewReconciler","enableCache","enableUseRefAccessWarning","enableStrictEffects","enableLazyContextPropagation","enableSuspenseLayoutEffectSemantics","enableUseMutableSource","NoMode","ConcurrentMode","DebugTracingMode","StrictEffectsMode","NoLane","SyncLane","NoLanes","isSubsetOfLanes","includesBlockingLane","mergeLanes","removeLanes","intersectLanes","isTransitionLane","markRootEntangled","markRootMutableRead","NoTimestamp","ContinuousEventPriority","getCurrentUpdatePriority","setCurrentUpdatePriority","higherEventPriority","readContext","checkIfContextChanged","HostRoot","CacheComponent","LayoutStatic","LayoutStaticEffect","MountLayoutDev","MountLayoutDevEffect","MountPassiveDev","MountPassiveDevEffect","Passive","PassiveEffect","PassiveStatic","PassiveStaticEffect","StaticMask","StaticMaskEffect","Update","UpdateEffect","StoreConsistency","HasEffect","HookHasEffect","Layout","HookLayout","HookPassive","Insertion","HookInsertion","getWorkInProgressRoot","scheduleUpdateOnFiber","requestUpdateLane","requestEventTime","markSkippedUpdateLanes","isInterleavedUpdate","getComponentNameFromFiber","is","isArray","markWorkInProgressReceivedUpdate","checkIfWorkInProgressReceivedUpdate","getIsHydrating","getWorkInProgressVersion","markSourceAsDirty","setWorkInProgressVersion","warnAboutMultipleRenderersDEV","logStateUpdateScheduled","markStateUpdateScheduled","createCache","CacheContext","createUpdate","createLegacyQueueUpdate","enqueueUpdate","enqueueLegacyQueueUpdate","entangleTransitions","entangleLegacyQueueTransitions","pushInterleavedQueue","warnOnSubscriptionInsideStartTransition","getTreeId","ReactCurrentDispatcher","ReactCurrentBatchConfig","didWarnAboutMismatchedHooksForComponent","didWarnUncachedGetSnapshot","__DEV__","Set","renderLanes","currentlyRenderingFiber","currentHook","workInProgressHook","didScheduleRenderPhaseUpdate","didScheduleRenderPhaseUpdateDuringThisPass","localIdCounter","globalClientIdCounter","RE_RENDER_LIMIT","currentHookNameInDev","hookTypesDev","hookTypesUpdateIndexDev","ignorePreviousDependencies","mountHookTypesDev","hookName","push","updateHookTypesDev","warnOnHookMismatchInDev","checkDepsAreArrayDev","deps","undefined","console","error","currentHookName","componentName","has","add","table","secondColumnStart","i","oldHookName","newHookName","row","length","throwInvalidHookError","Error","areHookInputsEqual","nextDeps","prevDeps","join","renderWithHooks","current","workInProgress","Component","props","secondArg","nextRenderLanes","_debugHookTypes","type","memoizedState","updateQueue","lanes","HooksDispatcherOnUpdateInDEV","HooksDispatcherOnMountWithHookTypesInDEV","HooksDispatcherOnMountInDEV","HooksDispatcherOnMount","HooksDispatcherOnUpdate","children","numberOfReRenders","HooksDispatcherOnRerenderInDEV","HooksDispatcherOnRerender","ContextOnlyDispatcher","didRenderTooFewHooks","next","flags","mode","currentDependencies","dependencies","checkDidRenderIdHook","didRenderIdHook","bailoutHooks","resetHooksAfterThrow","hook","queue","pending","isUpdatingOpaqueValueInRenderPhase","mountWorkInProgressHook","baseState","baseQueue","updateWorkInProgressHook","nextCurrentHook","alternate","nextWorkInProgressHook","newHook","createFunctionComponentUpdateQueue","lastEffect","stores","basicStateReducer","state","action","mountReducer","reducer","initialArg","init","initialState","interleaved","dispatch","lastRenderedReducer","lastRenderedState","dispatchReducerAction","bind","updateReducer","pendingQueue","baseFirst","pendingFirst","first","newState","newBaseState","newBaseQueueFirst","newBaseQueueLast","update","updateLane","lane","clone","hasEagerState","eagerState","lastInterleaved","interleavedLane","rerenderReducer","lastRenderPhaseUpdate","firstRenderPhaseUpdate","readFromUnsubscribedMutableSource","root","source","getSnapshot","getVersion","_getVersion","version","_source","isSafeToReadFromSource","currentRenderVersion","mutableReadLanes","snapshot","useMutableSource","subscribe","dispatcher","currentSnapshot","setSnapshot","useState","stateHook","refs","prevGetSnapshot","prevSource","prevSubscribe","fiber","useEffect","maybeNewVersion","maybeNewSnapshot","handleChange","latestGetSnapshot","latestSetSnapshot","unsubscribe","newQueue","dispatchSetState","mountMutableSource","updateMutableSource","mountSyncExternalStore","getServerSnapshot","nextSnapshot","isHydrating","pushStoreConsistencyCheck","inst","value","mountEffect","subscribeToStore","pushEffect","updateStoreInstance","updateSyncExternalStore","prevSnapshot","snapshotChanged","updateEffect","tag","renderedSnapshot","check","componentUpdateQueue","checkIfSnapshotChanged","forceStoreRerender","handleStoreChange","prevValue","nextValue","mountState","updateState","rerenderState","create","destroy","effect","firstEffect","stackContainsErrorMessage","getCallerStackFrame","stackFrames","stack","split","includes","slice","mountRef","initialValue","hasBeenInitialized","lazyInitGetterStack","didCheckForLazyInit","didWarnAboutRead","didWarnAboutWrite","ref","warn","Object","seal","updateRef","mountEffectImpl","fiberFlags","hookFlags","updateEffectImpl","prevEffect","mountInsertionEffect","updateInsertionEffect","mountLayoutEffect","updateLayoutEffect","imperativeHandleEffect","refCallback","refObject","hasOwnProperty","keys","mountImperativeHandle","effectDeps","concat","updateImperativeHandle","mountDebugValue","formatterFn","updateDebugValue","mountCallback","callback","updateCallback","prevState","mountMemo","nextCreate","updateMemo","mountDeferredValue","setValue","prevTransition","transition","updateDeferredValue","rerenderDeferredValue","startTransition","setPending","previousPriority","_updatedFibers","updatedFibersCount","size","clear","mountTransition","isPending","start","updateTransition","rerenderTransition","getIsUpdatingOpaqueValueInRenderPhaseInDEV","mountId","id","treeId","localId","toString","globalClientId","updateId","mountRefresh","refresh","refreshCache","updateRefresh","seedKey","seedValue","provider","return","eventTime","seededCache","data","set","refreshUpdate","payload","cache","arguments","isRenderPhaseUpdate","enqueueRenderPhaseUpdate","entangleTransitionUpdate","markUpdateInDevTools","prevDispatcher","InvalidNestedHooksDispatcherOnUpdateInDEV","currentState","queueLanes","pendingLanes","newQueueLanes","name","getCacheSignal","controller","signal","getCacheForType","resourceType","cacheForType","get","useCallback","useContext","useImperativeHandle","useInsertionEffect","useLayoutEffect","useMemo","useReducer","useRef","useDebugValue","useDeferredValue","useTransition","useSyncExternalStore","useId","unstable_isNewReconciler","useCacheRefresh","InvalidNestedHooksDispatcherOnMountInDEV","InvalidNestedHooksDispatcherOnRerenderInDEV","warnInvalidContextAccess","warnInvalidHookAccess","context"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {\n  MutableSource,\n  MutableSourceGetSnapshotFn,\n  MutableSourceSubscribeFn,\n  ReactContext,\n} from 'shared/ReactTypes';\nimport type {Fiber, Dispatcher, HookType} from './ReactInternalTypes';\nimport type {Lanes, Lane} from './ReactFiberLane.new';\nimport type {HookFlags} from './ReactHookEffectTags';\nimport type {FiberRoot} from './ReactInternalTypes';\nimport type {Cache} from './ReactFiberCacheComponent.new';\nimport type {Flags} from './ReactFiberFlags';\n\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nimport {\n  enableDebugTracing,\n  enableSchedulingProfiler,\n  enableNewReconciler,\n  enableCache,\n  enableUseRefAccessWarning,\n  enableStrictEffects,\n  enableLazyContextPropagation,\n  enableSuspenseLayoutEffectSemantics,\n  enableUseMutableSource,\n} from 'shared/ReactFeatureFlags';\n\nimport {\n  NoMode,\n  ConcurrentMode,\n  DebugTracingMode,\n  StrictEffectsMode,\n} from './ReactTypeOfMode';\nimport {\n  NoLane,\n  SyncLane,\n  NoLanes,\n  isSubsetOfLanes,\n  includesBlockingLane,\n  mergeLanes,\n  removeLanes,\n  intersectLanes,\n  isTransitionLane,\n  markRootEntangled,\n  markRootMutableRead,\n  NoTimestamp,\n} from './ReactFiberLane.new';\nimport {\n  ContinuousEventPriority,\n  getCurrentUpdatePriority,\n  setCurrentUpdatePriority,\n  higherEventPriority,\n} from './ReactEventPriorities.new';\nimport {readContext, checkIfContextChanged} from './ReactFiberNewContext.new';\nimport {HostRoot, CacheComponent} from './ReactWorkTags';\nimport {\n  LayoutStatic as LayoutStaticEffect,\n  MountLayoutDev as MountLayoutDevEffect,\n  MountPassiveDev as MountPassiveDevEffect,\n  Passive as PassiveEffect,\n  PassiveStatic as PassiveStaticEffect,\n  StaticMask as StaticMaskEffect,\n  Update as UpdateEffect,\n  StoreConsistency,\n} from './ReactFiberFlags';\nimport {\n  HasEffect as HookHasEffect,\n  Layout as HookLayout,\n  Passive as HookPassive,\n  Insertion as HookInsertion,\n} from './ReactHookEffectTags';\nimport {\n  getWorkInProgressRoot,\n  scheduleUpdateOnFiber,\n  requestUpdateLane,\n  requestEventTime,\n  markSkippedUpdateLanes,\n  isInterleavedUpdate,\n} from './ReactFiberWorkLoop.new';\n\nimport getComponentNameFromFiber from 'react-reconciler/src/getComponentNameFromFiber';\nimport is from 'shared/objectIs';\nimport isArray from 'shared/isArray';\nimport {\n  markWorkInProgressReceivedUpdate,\n  checkIfWorkInProgressReceivedUpdate,\n} from './ReactFiberBeginWork.new';\nimport {getIsHydrating} from './ReactFiberHydrationContext.new';\nimport {\n  getWorkInProgressVersion,\n  markSourceAsDirty,\n  setWorkInProgressVersion,\n  warnAboutMultipleRenderersDEV,\n} from './ReactMutableSource.new';\nimport {logStateUpdateScheduled} from './DebugTracing';\nimport {markStateUpdateScheduled} from './SchedulingProfiler';\nimport {createCache, CacheContext} from './ReactFiberCacheComponent.new';\nimport {\n  createUpdate as createLegacyQueueUpdate,\n  enqueueUpdate as enqueueLegacyQueueUpdate,\n  entangleTransitions as entangleLegacyQueueTransitions,\n} from './ReactUpdateQueue.new';\nimport {pushInterleavedQueue} from './ReactFiberInterleavedUpdates.new';\nimport {warnOnSubscriptionInsideStartTransition} from 'shared/ReactFeatureFlags';\nimport {getTreeId} from './ReactFiberTreeContext.new';\n\nconst {ReactCurrentDispatcher, ReactCurrentBatchConfig} = ReactSharedInternals;\n\ntype Update<S, A> = {|\n  lane: Lane,\n  action: A,\n  hasEagerState: boolean,\n  eagerState: S | null,\n  next: Update<S, A>,\n|};\n\nexport type UpdateQueue<S, A> = {|\n  pending: Update<S, A> | null,\n  interleaved: Update<S, A> | null,\n  lanes: Lanes,\n  dispatch: (A => mixed) | null,\n  lastRenderedReducer: ((S, A) => S) | null,\n  lastRenderedState: S | null,\n|};\n\nlet didWarnAboutMismatchedHooksForComponent;\nlet didWarnUncachedGetSnapshot;\nif (__DEV__) {\n  didWarnAboutMismatchedHooksForComponent = new Set();\n}\n\nexport type Hook = {|\n  memoizedState: any,\n  baseState: any,\n  baseQueue: Update<any, any> | null,\n  queue: any,\n  next: Hook | null,\n|};\n\nexport type Effect = {|\n  tag: HookFlags,\n  create: () => (() => void) | void,\n  destroy: (() => void) | void,\n  deps: Array<mixed> | null,\n  next: Effect,\n|};\n\ntype StoreInstance<T> = {|\n  value: T,\n  getSnapshot: () => T,\n|};\n\ntype StoreConsistencyCheck<T> = {|\n  value: T,\n  getSnapshot: () => T,\n|};\n\nexport type FunctionComponentUpdateQueue = {|\n  lastEffect: Effect | null,\n  stores: Array<StoreConsistencyCheck<any>> | null,\n|};\n\ntype BasicStateAction<S> = (S => S) | S;\n\ntype Dispatch<A> = A => void;\n\n// These are set right before calling the component.\nlet renderLanes: Lanes = NoLanes;\n// The work-in-progress fiber. I've named it differently to distinguish it from\n// the work-in-progress hook.\nlet currentlyRenderingFiber: Fiber = (null: any);\n\n// Hooks are stored as a linked list on the fiber's memoizedState field. The\n// current hook list is the list that belongs to the current fiber. The\n// work-in-progress hook list is a new list that will be added to the\n// work-in-progress fiber.\nlet currentHook: Hook | null = null;\nlet workInProgressHook: Hook | null = null;\n\n// Whether an update was scheduled at any point during the render phase. This\n// does not get reset if we do another render pass; only when we're completely\n// finished evaluating this component. This is an optimization so we know\n// whether we need to clear render phase updates after a throw.\nlet didScheduleRenderPhaseUpdate: boolean = false;\n// Where an update was scheduled only during the current render pass. This\n// gets reset after each attempt.\n// TODO: Maybe there's some way to consolidate this with\n// `didScheduleRenderPhaseUpdate`. Or with `numberOfReRenders`.\nlet didScheduleRenderPhaseUpdateDuringThisPass: boolean = false;\n// Counts the number of useId hooks in this component.\nlet localIdCounter: number = 0;\n// Used for ids that are generated completely client-side (i.e. not during\n// hydration). This counter is global, so client ids are not stable across\n// render attempts.\nlet globalClientIdCounter: number = 0;\n\nconst RE_RENDER_LIMIT = 25;\n\n// In DEV, this is the name of the currently executing primitive hook\nlet currentHookNameInDev: ?HookType = null;\n\n// In DEV, this list ensures that hooks are called in the same order between renders.\n// The list stores the order of hooks used during the initial render (mount).\n// Subsequent renders (updates) reference this list.\nlet hookTypesDev: Array<HookType> | null = null;\nlet hookTypesUpdateIndexDev: number = -1;\n\n// In DEV, this tracks whether currently rendering component needs to ignore\n// the dependencies for Hooks that need them (e.g. useEffect or useMemo).\n// When true, such Hooks will always be \"remounted\". Only used during hot reload.\nlet ignorePreviousDependencies: boolean = false;\n\nfunction mountHookTypesDev() {\n  if (__DEV__) {\n    const hookName = ((currentHookNameInDev: any): HookType);\n\n    if (hookTypesDev === null) {\n      hookTypesDev = [hookName];\n    } else {\n      hookTypesDev.push(hookName);\n    }\n  }\n}\n\nfunction updateHookTypesDev() {\n  if (__DEV__) {\n    const hookName = ((currentHookNameInDev: any): HookType);\n\n    if (hookTypesDev !== null) {\n      hookTypesUpdateIndexDev++;\n      if (hookTypesDev[hookTypesUpdateIndexDev] !== hookName) {\n        warnOnHookMismatchInDev(hookName);\n      }\n    }\n  }\n}\n\nfunction checkDepsAreArrayDev(deps: mixed) {\n  if (__DEV__) {\n    if (deps !== undefined && deps !== null && !isArray(deps)) {\n      // Verify deps, but only on mount to avoid extra checks.\n      // It's unlikely their type would change as usually you define them inline.\n      console.error(\n        '%s received a final argument that is not an array (instead, received `%s`). When ' +\n          'specified, the final argument must be an array.',\n        currentHookNameInDev,\n        typeof deps,\n      );\n    }\n  }\n}\n\nfunction warnOnHookMismatchInDev(currentHookName: HookType) {\n  if (__DEV__) {\n    const componentName = getComponentNameFromFiber(currentlyRenderingFiber);\n    if (!didWarnAboutMismatchedHooksForComponent.has(componentName)) {\n      didWarnAboutMismatchedHooksForComponent.add(componentName);\n\n      if (hookTypesDev !== null) {\n        let table = '';\n\n        const secondColumnStart = 30;\n\n        for (let i = 0; i <= ((hookTypesUpdateIndexDev: any): number); i++) {\n          const oldHookName = hookTypesDev[i];\n          const newHookName =\n            i === ((hookTypesUpdateIndexDev: any): number)\n              ? currentHookName\n              : oldHookName;\n\n          let row = `${i + 1}. ${oldHookName}`;\n\n          // Extra space so second column lines up\n          // lol @ IE not supporting String#repeat\n          while (row.length < secondColumnStart) {\n            row += ' ';\n          }\n\n          row += newHookName + '\\n';\n\n          table += row;\n        }\n\n        console.error(\n          'React has detected a change in the order of Hooks called by %s. ' +\n            'This will lead to bugs and errors if not fixed. ' +\n            'For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\\n\\n' +\n            '   Previous render            Next render\\n' +\n            '   ------------------------------------------------------\\n' +\n            '%s' +\n            '   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n',\n          componentName,\n          table,\n        );\n      }\n    }\n  }\n}\n\nfunction throwInvalidHookError() {\n  throw new Error(\n    'Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' +\n      ' one of the following reasons:\\n' +\n      '1. You might have mismatching versions of React and the renderer (such as React DOM)\\n' +\n      '2. You might be breaking the Rules of Hooks\\n' +\n      '3. You might have more than one copy of React in the same app\\n' +\n      'See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.',\n  );\n}\n\nfunction areHookInputsEqual(\n  nextDeps: Array<mixed>,\n  prevDeps: Array<mixed> | null,\n) {\n  if (__DEV__) {\n    if (ignorePreviousDependencies) {\n      // Only true when this component is being hot reloaded.\n      return false;\n    }\n  }\n\n  if (prevDeps === null) {\n    if (__DEV__) {\n      console.error(\n        '%s received a final argument during this render, but not during ' +\n          'the previous render. Even though the final argument is optional, ' +\n          'its type cannot change between renders.',\n        currentHookNameInDev,\n      );\n    }\n    return false;\n  }\n\n  if (__DEV__) {\n    // Don't bother comparing lengths in prod because these arrays should be\n    // passed inline.\n    if (nextDeps.length !== prevDeps.length) {\n      console.error(\n        'The final argument passed to %s changed size between renders. The ' +\n          'order and size of this array must remain constant.\\n\\n' +\n          'Previous: %s\\n' +\n          'Incoming: %s',\n        currentHookNameInDev,\n        `[${prevDeps.join(', ')}]`,\n        `[${nextDeps.join(', ')}]`,\n      );\n    }\n  }\n  for (let i = 0; i < prevDeps.length && i < nextDeps.length; i++) {\n    if (is(nextDeps[i], prevDeps[i])) {\n      continue;\n    }\n    return false;\n  }\n  return true;\n}\n\nexport function renderWithHooks<Props, SecondArg>(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  Component: (p: Props, arg: SecondArg) => any,\n  props: Props,\n  secondArg: SecondArg,\n  nextRenderLanes: Lanes,\n): any {\n  renderLanes = nextRenderLanes;\n  currentlyRenderingFiber = workInProgress;\n\n  if (__DEV__) {\n    hookTypesDev =\n      current !== null\n        ? ((current._debugHookTypes: any): Array<HookType>)\n        : null;\n    hookTypesUpdateIndexDev = -1;\n    // Used for hot reloading:\n    ignorePreviousDependencies =\n      current !== null && current.type !== workInProgress.type;\n  }\n\n  workInProgress.memoizedState = null;\n  workInProgress.updateQueue = null;\n  workInProgress.lanes = NoLanes;\n\n  // The following should have already been reset\n  // currentHook = null;\n  // workInProgressHook = null;\n\n  // didScheduleRenderPhaseUpdate = false;\n  // localIdCounter = 0;\n\n  // TODO Warn if no hooks are used at all during mount, then some are used during update.\n  // Currently we will identify the update render as a mount because memoizedState === null.\n  // This is tricky because it's valid for certain types of components (e.g. React.lazy)\n\n  // Using memoizedState to differentiate between mount/update only works if at least one stateful hook is used.\n  // Non-stateful hooks (e.g. context) don't get added to memoizedState,\n  // so memoizedState would be null during updates and mounts.\n  if (__DEV__) {\n    if (current !== null && current.memoizedState !== null) {\n      ReactCurrentDispatcher.current = HooksDispatcherOnUpdateInDEV;\n    } else if (hookTypesDev !== null) {\n      // This dispatcher handles an edge case where a component is updating,\n      // but no stateful hooks have been used.\n      // We want to match the production code behavior (which will use HooksDispatcherOnMount),\n      // but with the extra DEV validation to ensure hooks ordering hasn't changed.\n      // This dispatcher does that.\n      ReactCurrentDispatcher.current = HooksDispatcherOnMountWithHookTypesInDEV;\n    } else {\n      ReactCurrentDispatcher.current = HooksDispatcherOnMountInDEV;\n    }\n  } else {\n    ReactCurrentDispatcher.current =\n      current === null || current.memoizedState === null\n        ? HooksDispatcherOnMount\n        : HooksDispatcherOnUpdate;\n  }\n\n  let children = Component(props, secondArg);\n\n  // Check if there was a render phase update\n  if (didScheduleRenderPhaseUpdateDuringThisPass) {\n    // Keep rendering in a loop for as long as render phase updates continue to\n    // be scheduled. Use a counter to prevent infinite loops.\n    let numberOfReRenders: number = 0;\n    do {\n      didScheduleRenderPhaseUpdateDuringThisPass = false;\n      localIdCounter = 0;\n\n      if (numberOfReRenders >= RE_RENDER_LIMIT) {\n        throw new Error(\n          'Too many re-renders. React limits the number of renders to prevent ' +\n            'an infinite loop.',\n        );\n      }\n\n      numberOfReRenders += 1;\n      if (__DEV__) {\n        // Even when hot reloading, allow dependencies to stabilize\n        // after first render to prevent infinite render phase updates.\n        ignorePreviousDependencies = false;\n      }\n\n      // Start over from the beginning of the list\n      currentHook = null;\n      workInProgressHook = null;\n\n      workInProgress.updateQueue = null;\n\n      if (__DEV__) {\n        // Also validate hook order for cascading updates.\n        hookTypesUpdateIndexDev = -1;\n      }\n\n      ReactCurrentDispatcher.current = __DEV__\n        ? HooksDispatcherOnRerenderInDEV\n        : HooksDispatcherOnRerender;\n\n      children = Component(props, secondArg);\n    } while (didScheduleRenderPhaseUpdateDuringThisPass);\n  }\n\n  // We can assume the previous dispatcher is always this one, since we set it\n  // at the beginning of the render phase and there's no re-entrance.\n  ReactCurrentDispatcher.current = ContextOnlyDispatcher;\n\n  if (__DEV__) {\n    workInProgress._debugHookTypes = hookTypesDev;\n  }\n\n  // This check uses currentHook so that it works the same in DEV and prod bundles.\n  // hookTypesDev could catch more cases (e.g. context) but only in DEV bundles.\n  const didRenderTooFewHooks =\n    currentHook !== null && currentHook.next !== null;\n\n  renderLanes = NoLanes;\n  currentlyRenderingFiber = (null: any);\n\n  currentHook = null;\n  workInProgressHook = null;\n\n  if (__DEV__) {\n    currentHookNameInDev = null;\n    hookTypesDev = null;\n    hookTypesUpdateIndexDev = -1;\n\n    // Confirm that a static flag was not added or removed since the last\n    // render. If this fires, it suggests that we incorrectly reset the static\n    // flags in some other part of the codebase. This has happened before, for\n    // example, in the SuspenseList implementation.\n    if (\n      current !== null &&\n      (current.flags & StaticMaskEffect) !==\n        (workInProgress.flags & StaticMaskEffect) &&\n      // Disable this warning in legacy mode, because legacy Suspense is weird\n      // and creates false positives. To make this work in legacy mode, we'd\n      // need to mark fibers that commit in an incomplete state, somehow. For\n      // now I'll disable the warning that most of the bugs that would trigger\n      // it are either exclusive to concurrent mode or exist in both.\n      (current.mode & ConcurrentMode) !== NoMode\n    ) {\n      console.error(\n        'Internal React error: Expected static flag was missing. Please ' +\n          'notify the React team.',\n      );\n    }\n  }\n\n  didScheduleRenderPhaseUpdate = false;\n  // This is reset by checkDidRenderIdHook\n  // localIdCounter = 0;\n\n  if (didRenderTooFewHooks) {\n    throw new Error(\n      'Rendered fewer hooks than expected. This may be caused by an accidental ' +\n        'early return statement.',\n    );\n  }\n\n  if (enableLazyContextPropagation) {\n    if (current !== null) {\n      if (!checkIfWorkInProgressReceivedUpdate()) {\n        // If there were no changes to props or state, we need to check if there\n        // was a context change. We didn't already do this because there's no\n        // 1:1 correspondence between dependencies and hooks. Although, because\n        // there almost always is in the common case (`readContext` is an\n        // internal API), we could compare in there. OTOH, we only hit this case\n        // if everything else bails out, so on the whole it might be better to\n        // keep the comparison out of the common path.\n        const currentDependencies = current.dependencies;\n        if (\n          currentDependencies !== null &&\n          checkIfContextChanged(currentDependencies)\n        ) {\n          markWorkInProgressReceivedUpdate();\n        }\n      }\n    }\n  }\n  return children;\n}\n\nexport function checkDidRenderIdHook() {\n  // This should be called immediately after every renderWithHooks call.\n  // Conceptually, it's part of the return value of renderWithHooks; it's only a\n  // separate function to avoid using an array tuple.\n  const didRenderIdHook = localIdCounter !== 0;\n  localIdCounter = 0;\n  return didRenderIdHook;\n}\n\nexport function bailoutHooks(\n  current: Fiber,\n  workInProgress: Fiber,\n  lanes: Lanes,\n) {\n  workInProgress.updateQueue = current.updateQueue;\n  // TODO: Don't need to reset the flags here, because they're reset in the\n  // complete phase (bubbleProperties).\n  if (\n    __DEV__ &&\n    enableStrictEffects &&\n    (workInProgress.mode & StrictEffectsMode) !== NoMode\n  ) {\n    workInProgress.flags &= ~(\n      MountPassiveDevEffect |\n      MountLayoutDevEffect |\n      PassiveEffect |\n      UpdateEffect\n    );\n  } else {\n    workInProgress.flags &= ~(PassiveEffect | UpdateEffect);\n  }\n  current.lanes = removeLanes(current.lanes, lanes);\n}\n\nexport function resetHooksAfterThrow(): void {\n  // We can assume the previous dispatcher is always this one, since we set it\n  // at the beginning of the render phase and there's no re-entrance.\n  ReactCurrentDispatcher.current = ContextOnlyDispatcher;\n\n  if (didScheduleRenderPhaseUpdate) {\n    // There were render phase updates. These are only valid for this render\n    // phase, which we are now aborting. Remove the updates from the queues so\n    // they do not persist to the next render. Do not remove updates from hooks\n    // that weren't processed.\n    //\n    // Only reset the updates from the queue if it has a clone. If it does\n    // not have a clone, that means it wasn't processed, and the updates were\n    // scheduled before we entered the render phase.\n    let hook: Hook | null = currentlyRenderingFiber.memoizedState;\n    while (hook !== null) {\n      const queue = hook.queue;\n      if (queue !== null) {\n        queue.pending = null;\n      }\n      hook = hook.next;\n    }\n    didScheduleRenderPhaseUpdate = false;\n  }\n\n  renderLanes = NoLanes;\n  currentlyRenderingFiber = (null: any);\n\n  currentHook = null;\n  workInProgressHook = null;\n\n  if (__DEV__) {\n    hookTypesDev = null;\n    hookTypesUpdateIndexDev = -1;\n\n    currentHookNameInDev = null;\n\n    isUpdatingOpaqueValueInRenderPhase = false;\n  }\n\n  didScheduleRenderPhaseUpdateDuringThisPass = false;\n  localIdCounter = 0;\n}\n\nfunction mountWorkInProgressHook(): Hook {\n  const hook: Hook = {\n    memoizedState: null,\n\n    baseState: null,\n    baseQueue: null,\n    queue: null,\n\n    next: null,\n  };\n\n  if (workInProgressHook === null) {\n    // This is the first hook in the list\n    currentlyRenderingFiber.memoizedState = workInProgressHook = hook;\n  } else {\n    // Append to the end of the list\n    workInProgressHook = workInProgressHook.next = hook;\n  }\n  return workInProgressHook;\n}\n\nfunction updateWorkInProgressHook(): Hook {\n  // This function is used both for updates and for re-renders triggered by a\n  // render phase update. It assumes there is either a current hook we can\n  // clone, or a work-in-progress hook from a previous render pass that we can\n  // use as a base. When we reach the end of the base list, we must switch to\n  // the dispatcher used for mounts.\n  let nextCurrentHook: null | Hook;\n  if (currentHook === null) {\n    const current = currentlyRenderingFiber.alternate;\n    if (current !== null) {\n      nextCurrentHook = current.memoizedState;\n    } else {\n      nextCurrentHook = null;\n    }\n  } else {\n    nextCurrentHook = currentHook.next;\n  }\n\n  let nextWorkInProgressHook: null | Hook;\n  if (workInProgressHook === null) {\n    nextWorkInProgressHook = currentlyRenderingFiber.memoizedState;\n  } else {\n    nextWorkInProgressHook = workInProgressHook.next;\n  }\n\n  if (nextWorkInProgressHook !== null) {\n    // There's already a work-in-progress. Reuse it.\n    workInProgressHook = nextWorkInProgressHook;\n    nextWorkInProgressHook = workInProgressHook.next;\n\n    currentHook = nextCurrentHook;\n  } else {\n    // Clone from the current hook.\n\n    if (nextCurrentHook === null) {\n      throw new Error('Rendered more hooks than during the previous render.');\n    }\n\n    currentHook = nextCurrentHook;\n\n    const newHook: Hook = {\n      memoizedState: currentHook.memoizedState,\n\n      baseState: currentHook.baseState,\n      baseQueue: currentHook.baseQueue,\n      queue: currentHook.queue,\n\n      next: null,\n    };\n\n    if (workInProgressHook === null) {\n      // This is the first hook in the list.\n      currentlyRenderingFiber.memoizedState = workInProgressHook = newHook;\n    } else {\n      // Append to the end of the list.\n      workInProgressHook = workInProgressHook.next = newHook;\n    }\n  }\n  return workInProgressHook;\n}\n\nfunction createFunctionComponentUpdateQueue(): FunctionComponentUpdateQueue {\n  return {\n    lastEffect: null,\n    stores: null,\n  };\n}\n\nfunction basicStateReducer<S>(state: S, action: BasicStateAction<S>): S {\n  // $FlowFixMe: Flow doesn't like mixed types\n  return typeof action === 'function' ? action(state) : action;\n}\n\nfunction mountReducer<S, I, A>(\n  reducer: (S, A) => S,\n  initialArg: I,\n  init?: I => S,\n): [S, Dispatch<A>] {\n  const hook = mountWorkInProgressHook();\n  let initialState;\n  if (init !== undefined) {\n    initialState = init(initialArg);\n  } else {\n    initialState = ((initialArg: any): S);\n  }\n  hook.memoizedState = hook.baseState = initialState;\n  const queue: UpdateQueue<S, A> = {\n    pending: null,\n    interleaved: null,\n    lanes: NoLanes,\n    dispatch: null,\n    lastRenderedReducer: reducer,\n    lastRenderedState: (initialState: any),\n  };\n  hook.queue = queue;\n  const dispatch: Dispatch<A> = (queue.dispatch = (dispatchReducerAction.bind(\n    null,\n    currentlyRenderingFiber,\n    queue,\n  ): any));\n  return [hook.memoizedState, dispatch];\n}\n\nfunction updateReducer<S, I, A>(\n  reducer: (S, A) => S,\n  initialArg: I,\n  init?: I => S,\n): [S, Dispatch<A>] {\n  const hook = updateWorkInProgressHook();\n  const queue = hook.queue;\n\n  if (queue === null) {\n    throw new Error(\n      'Should have a queue. This is likely a bug in React. Please file an issue.',\n    );\n  }\n\n  queue.lastRenderedReducer = reducer;\n\n  const current: Hook = (currentHook: any);\n\n  // The last rebase update that is NOT part of the base state.\n  let baseQueue = current.baseQueue;\n\n  // The last pending update that hasn't been processed yet.\n  const pendingQueue = queue.pending;\n  if (pendingQueue !== null) {\n    // We have new updates that haven't been processed yet.\n    // We'll add them to the base queue.\n    if (baseQueue !== null) {\n      // Merge the pending queue and the base queue.\n      const baseFirst = baseQueue.next;\n      const pendingFirst = pendingQueue.next;\n      baseQueue.next = pendingFirst;\n      pendingQueue.next = baseFirst;\n    }\n    if (__DEV__) {\n      if (current.baseQueue !== baseQueue) {\n        // Internal invariant that should never happen, but feasibly could in\n        // the future if we implement resuming, or some form of that.\n        console.error(\n          'Internal error: Expected work-in-progress queue to be a clone. ' +\n            'This is a bug in React.',\n        );\n      }\n    }\n    current.baseQueue = baseQueue = pendingQueue;\n    queue.pending = null;\n  }\n\n  if (baseQueue !== null) {\n    // We have a queue to process.\n    const first = baseQueue.next;\n    let newState = current.baseState;\n\n    let newBaseState = null;\n    let newBaseQueueFirst = null;\n    let newBaseQueueLast = null;\n    let update = first;\n    do {\n      const updateLane = update.lane;\n      if (!isSubsetOfLanes(renderLanes, updateLane)) {\n        // Priority is insufficient. Skip this update. If this is the first\n        // skipped update, the previous update/state is the new base\n        // update/state.\n        const clone: Update<S, A> = {\n          lane: updateLane,\n          action: update.action,\n          hasEagerState: update.hasEagerState,\n          eagerState: update.eagerState,\n          next: (null: any),\n        };\n        if (newBaseQueueLast === null) {\n          newBaseQueueFirst = newBaseQueueLast = clone;\n          newBaseState = newState;\n        } else {\n          newBaseQueueLast = newBaseQueueLast.next = clone;\n        }\n        // Update the remaining priority in the queue.\n        // TODO: Don't need to accumulate this. Instead, we can remove\n        // renderLanes from the original lanes.\n        currentlyRenderingFiber.lanes = mergeLanes(\n          currentlyRenderingFiber.lanes,\n          updateLane,\n        );\n        markSkippedUpdateLanes(updateLane);\n      } else {\n        // This update does have sufficient priority.\n\n        if (newBaseQueueLast !== null) {\n          const clone: Update<S, A> = {\n            // This update is going to be committed so we never want uncommit\n            // it. Using NoLane works because 0 is a subset of all bitmasks, so\n            // this will never be skipped by the check above.\n            lane: NoLane,\n            action: update.action,\n            hasEagerState: update.hasEagerState,\n            eagerState: update.eagerState,\n            next: (null: any),\n          };\n          newBaseQueueLast = newBaseQueueLast.next = clone;\n        }\n\n        // Process this update.\n        if (update.hasEagerState) {\n          // If this update is a state update (not a reducer) and was processed eagerly,\n          // we can use the eagerly computed state\n          newState = ((update.eagerState: any): S);\n        } else {\n          const action = update.action;\n          newState = reducer(newState, action);\n        }\n      }\n      update = update.next;\n    } while (update !== null && update !== first);\n\n    if (newBaseQueueLast === null) {\n      newBaseState = newState;\n    } else {\n      newBaseQueueLast.next = (newBaseQueueFirst: any);\n    }\n\n    // Mark that the fiber performed work, but only if the new state is\n    // different from the current state.\n    if (!is(newState, hook.memoizedState)) {\n      markWorkInProgressReceivedUpdate();\n    }\n\n    hook.memoizedState = newState;\n    hook.baseState = newBaseState;\n    hook.baseQueue = newBaseQueueLast;\n\n    queue.lastRenderedState = newState;\n  }\n\n  // Interleaved updates are stored on a separate queue. We aren't going to\n  // process them during this render, but we do need to track which lanes\n  // are remaining.\n  const lastInterleaved = queue.interleaved;\n  if (lastInterleaved !== null) {\n    let interleaved = lastInterleaved;\n    do {\n      const interleavedLane = interleaved.lane;\n      currentlyRenderingFiber.lanes = mergeLanes(\n        currentlyRenderingFiber.lanes,\n        interleavedLane,\n      );\n      markSkippedUpdateLanes(interleavedLane);\n      interleaved = ((interleaved: any).next: Update<S, A>);\n    } while (interleaved !== lastInterleaved);\n  } else if (baseQueue === null) {\n    // `queue.lanes` is used for entangling transitions. We can set it back to\n    // zero once the queue is empty.\n    queue.lanes = NoLanes;\n  }\n\n  const dispatch: Dispatch<A> = (queue.dispatch: any);\n  return [hook.memoizedState, dispatch];\n}\n\nfunction rerenderReducer<S, I, A>(\n  reducer: (S, A) => S,\n  initialArg: I,\n  init?: I => S,\n): [S, Dispatch<A>] {\n  const hook = updateWorkInProgressHook();\n  const queue = hook.queue;\n\n  if (queue === null) {\n    throw new Error(\n      'Should have a queue. This is likely a bug in React. Please file an issue.',\n    );\n  }\n\n  queue.lastRenderedReducer = reducer;\n\n  // This is a re-render. Apply the new render phase updates to the previous\n  // work-in-progress hook.\n  const dispatch: Dispatch<A> = (queue.dispatch: any);\n  const lastRenderPhaseUpdate = queue.pending;\n  let newState = hook.memoizedState;\n  if (lastRenderPhaseUpdate !== null) {\n    // The queue doesn't persist past this render pass.\n    queue.pending = null;\n\n    const firstRenderPhaseUpdate = lastRenderPhaseUpdate.next;\n    let update = firstRenderPhaseUpdate;\n    do {\n      // Process this render phase update. We don't have to check the\n      // priority because it will always be the same as the current\n      // render's.\n      const action = update.action;\n      newState = reducer(newState, action);\n      update = update.next;\n    } while (update !== firstRenderPhaseUpdate);\n\n    // Mark that the fiber performed work, but only if the new state is\n    // different from the current state.\n    if (!is(newState, hook.memoizedState)) {\n      markWorkInProgressReceivedUpdate();\n    }\n\n    hook.memoizedState = newState;\n    // Don't persist the state accumulated from the render phase updates to\n    // the base state unless the queue is empty.\n    // TODO: Not sure if this is the desired semantics, but it's what we\n    // do for gDSFP. I can't remember why.\n    if (hook.baseQueue === null) {\n      hook.baseState = newState;\n    }\n\n    queue.lastRenderedState = newState;\n  }\n  return [newState, dispatch];\n}\n\ntype MutableSourceMemoizedState<Source, Snapshot> = {|\n  refs: {\n    getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,\n    setSnapshot: Snapshot => void,\n  },\n  source: MutableSource<any>,\n  subscribe: MutableSourceSubscribeFn<Source, Snapshot>,\n|};\n\nfunction readFromUnsubscribedMutableSource<Source, Snapshot>(\n  root: FiberRoot,\n  source: MutableSource<Source>,\n  getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,\n): Snapshot {\n  if (__DEV__) {\n    warnAboutMultipleRenderersDEV(source);\n  }\n\n  const getVersion = source._getVersion;\n  const version = getVersion(source._source);\n\n  // Is it safe for this component to read from this source during the current render?\n  let isSafeToReadFromSource = false;\n\n  // Check the version first.\n  // If this render has already been started with a specific version,\n  // we can use it alone to determine if we can safely read from the source.\n  const currentRenderVersion = getWorkInProgressVersion(source);\n  if (currentRenderVersion !== null) {\n    // It's safe to read if the store hasn't been mutated since the last time\n    // we read something.\n    isSafeToReadFromSource = currentRenderVersion === version;\n  } else {\n    // If there's no version, then this is the first time we've read from the\n    // source during the current render pass, so we need to do a bit more work.\n    // What we need to determine is if there are any hooks that already\n    // subscribed to the source, and if so, whether there are any pending\n    // mutations that haven't been synchronized yet.\n    //\n    // If there are no pending mutations, then `root.mutableReadLanes` will be\n    // empty, and we know we can safely read.\n    //\n    // If there *are* pending mutations, we may still be able to safely read\n    // if the currently rendering lanes are inclusive of the pending mutation\n    // lanes, since that guarantees that the value we're about to read from\n    // the source is consistent with the values that we read during the most\n    // recent mutation.\n    isSafeToReadFromSource = isSubsetOfLanes(\n      renderLanes,\n      root.mutableReadLanes,\n    );\n\n    if (isSafeToReadFromSource) {\n      // If it's safe to read from this source during the current render,\n      // store the version in case other components read from it.\n      // A changed version number will let those components know to throw and restart the render.\n      setWorkInProgressVersion(source, version);\n    }\n  }\n\n  if (isSafeToReadFromSource) {\n    const snapshot = getSnapshot(source._source);\n    if (__DEV__) {\n      if (typeof snapshot === 'function') {\n        console.error(\n          'Mutable source should not return a function as the snapshot value. ' +\n            'Functions may close over mutable values and cause tearing.',\n        );\n      }\n    }\n    return snapshot;\n  } else {\n    // This handles the special case of a mutable source being shared between renderers.\n    // In that case, if the source is mutated between the first and second renderer,\n    // The second renderer don't know that it needs to reset the WIP version during unwind,\n    // (because the hook only marks sources as dirty if it's written to their WIP version).\n    // That would cause this tear check to throw again and eventually be visible to the user.\n    // We can avoid this infinite loop by explicitly marking the source as dirty.\n    //\n    // This can lead to tearing in the first renderer when it resumes,\n    // but there's nothing we can do about that (short of throwing here and refusing to continue the render).\n    markSourceAsDirty(source);\n\n    // Intentioally throw an error to force React to retry synchronously. During\n    // the synchronous retry, it will block interleaved mutations, so we should\n    // get a consistent read. Therefore, the following error should never be\n    // visible to the user.\n\n    // We expect this error not to be thrown during the synchronous retry,\n    // because we blocked interleaved mutations.\n    throw new Error(\n      'Cannot read from mutable source during the current render without tearing. This may be a bug in React. Please file an issue.',\n    );\n  }\n}\n\nfunction useMutableSource<Source, Snapshot>(\n  hook: Hook,\n  source: MutableSource<Source>,\n  getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,\n  subscribe: MutableSourceSubscribeFn<Source, Snapshot>,\n): Snapshot {\n  if (!enableUseMutableSource) {\n    return (undefined: any);\n  }\n\n  const root = ((getWorkInProgressRoot(): any): FiberRoot);\n\n  if (root === null) {\n    throw new Error(\n      'Expected a work-in-progress root. This is a bug in React. Please file an issue.',\n    );\n  }\n\n  const getVersion = source._getVersion;\n  const version = getVersion(source._source);\n\n  const dispatcher = ReactCurrentDispatcher.current;\n\n  // eslint-disable-next-line prefer-const\n  let [currentSnapshot, setSnapshot] = dispatcher.useState(() =>\n    readFromUnsubscribedMutableSource(root, source, getSnapshot),\n  );\n  let snapshot = currentSnapshot;\n\n  // Grab a handle to the state hook as well.\n  // We use it to clear the pending update queue if we have a new source.\n  const stateHook = ((workInProgressHook: any): Hook);\n\n  const memoizedState = ((hook.memoizedState: any): MutableSourceMemoizedState<\n    Source,\n    Snapshot,\n  >);\n  const refs = memoizedState.refs;\n  const prevGetSnapshot = refs.getSnapshot;\n  const prevSource = memoizedState.source;\n  const prevSubscribe = memoizedState.subscribe;\n\n  const fiber = currentlyRenderingFiber;\n\n  hook.memoizedState = ({\n    refs,\n    source,\n    subscribe,\n  }: MutableSourceMemoizedState<Source, Snapshot>);\n\n  // Sync the values needed by our subscription handler after each commit.\n  dispatcher.useEffect(() => {\n    refs.getSnapshot = getSnapshot;\n\n    // Normally the dispatch function for a state hook never changes,\n    // but this hook recreates the queue in certain cases  to avoid updates from stale sources.\n    // handleChange() below needs to reference the dispatch function without re-subscribing,\n    // so we use a ref to ensure that it always has the latest version.\n    refs.setSnapshot = setSnapshot;\n\n    // Check for a possible change between when we last rendered now.\n    const maybeNewVersion = getVersion(source._source);\n    if (!is(version, maybeNewVersion)) {\n      const maybeNewSnapshot = getSnapshot(source._source);\n      if (__DEV__) {\n        if (typeof maybeNewSnapshot === 'function') {\n          console.error(\n            'Mutable source should not return a function as the snapshot value. ' +\n              'Functions may close over mutable values and cause tearing.',\n          );\n        }\n      }\n\n      if (!is(snapshot, maybeNewSnapshot)) {\n        setSnapshot(maybeNewSnapshot);\n\n        const lane = requestUpdateLane(fiber);\n        markRootMutableRead(root, lane);\n      }\n      // If the source mutated between render and now,\n      // there may be state updates already scheduled from the old source.\n      // Entangle the updates so that they render in the same batch.\n      markRootEntangled(root, root.mutableReadLanes);\n    }\n  }, [getSnapshot, source, subscribe]);\n\n  // If we got a new source or subscribe function, re-subscribe in a passive effect.\n  dispatcher.useEffect(() => {\n    const handleChange = () => {\n      const latestGetSnapshot = refs.getSnapshot;\n      const latestSetSnapshot = refs.setSnapshot;\n\n      try {\n        latestSetSnapshot(latestGetSnapshot(source._source));\n\n        // Record a pending mutable source update with the same expiration time.\n        const lane = requestUpdateLane(fiber);\n\n        markRootMutableRead(root, lane);\n      } catch (error) {\n        // A selector might throw after a source mutation.\n        // e.g. it might try to read from a part of the store that no longer exists.\n        // In this case we should still schedule an update with React.\n        // Worst case the selector will throw again and then an error boundary will handle it.\n        latestSetSnapshot(\n          (() => {\n            throw error;\n          }: any),\n        );\n      }\n    };\n\n    const unsubscribe = subscribe(source._source, handleChange);\n    if (__DEV__) {\n      if (typeof unsubscribe !== 'function') {\n        console.error(\n          'Mutable source subscribe function must return an unsubscribe function.',\n        );\n      }\n    }\n\n    return unsubscribe;\n  }, [source, subscribe]);\n\n  // If any of the inputs to useMutableSource change, reading is potentially unsafe.\n  //\n  // If either the source or the subscription have changed we can't can't trust the update queue.\n  // Maybe the source changed in a way that the old subscription ignored but the new one depends on.\n  //\n  // If the getSnapshot function changed, we also shouldn't rely on the update queue.\n  // It's possible that the underlying source was mutated between the when the last \"change\" event fired,\n  // and when the current render (with the new getSnapshot function) is processed.\n  //\n  // In both cases, we need to throw away pending updates (since they are no longer relevant)\n  // and treat reading from the source as we do in the mount case.\n  if (\n    !is(prevGetSnapshot, getSnapshot) ||\n    !is(prevSource, source) ||\n    !is(prevSubscribe, subscribe)\n  ) {\n    // Create a new queue and setState method,\n    // So if there are interleaved updates, they get pushed to the older queue.\n    // When this becomes current, the previous queue and dispatch method will be discarded,\n    // including any interleaving updates that occur.\n    const newQueue: UpdateQueue<Snapshot, BasicStateAction<Snapshot>> = {\n      pending: null,\n      interleaved: null,\n      lanes: NoLanes,\n      dispatch: null,\n      lastRenderedReducer: basicStateReducer,\n      lastRenderedState: snapshot,\n    };\n    newQueue.dispatch = setSnapshot = (dispatchSetState.bind(\n      null,\n      currentlyRenderingFiber,\n      newQueue,\n    ): any);\n    stateHook.queue = newQueue;\n    stateHook.baseQueue = null;\n    snapshot = readFromUnsubscribedMutableSource(root, source, getSnapshot);\n    stateHook.memoizedState = stateHook.baseState = snapshot;\n  }\n\n  return snapshot;\n}\n\nfunction mountMutableSource<Source, Snapshot>(\n  source: MutableSource<Source>,\n  getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,\n  subscribe: MutableSourceSubscribeFn<Source, Snapshot>,\n): Snapshot {\n  if (!enableUseMutableSource) {\n    return (undefined: any);\n  }\n\n  const hook = mountWorkInProgressHook();\n  hook.memoizedState = ({\n    refs: {\n      getSnapshot,\n      setSnapshot: (null: any),\n    },\n    source,\n    subscribe,\n  }: MutableSourceMemoizedState<Source, Snapshot>);\n  return useMutableSource(hook, source, getSnapshot, subscribe);\n}\n\nfunction updateMutableSource<Source, Snapshot>(\n  source: MutableSource<Source>,\n  getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,\n  subscribe: MutableSourceSubscribeFn<Source, Snapshot>,\n): Snapshot {\n  if (!enableUseMutableSource) {\n    return (undefined: any);\n  }\n\n  const hook = updateWorkInProgressHook();\n  return useMutableSource(hook, source, getSnapshot, subscribe);\n}\n\nfunction mountSyncExternalStore<T>(\n  subscribe: (() => void) => () => void,\n  getSnapshot: () => T,\n  getServerSnapshot?: () => T,\n): T {\n  const fiber = currentlyRenderingFiber;\n  const hook = mountWorkInProgressHook();\n\n  let nextSnapshot;\n  const isHydrating = getIsHydrating();\n  if (isHydrating) {\n    if (getServerSnapshot === undefined) {\n      throw new Error(\n        'Missing getServerSnapshot, which is required for ' +\n          'server-rendered content. Will revert to client rendering.',\n      );\n    }\n    nextSnapshot = getServerSnapshot();\n    if (__DEV__) {\n      if (!didWarnUncachedGetSnapshot) {\n        if (nextSnapshot !== getServerSnapshot()) {\n          console.error(\n            'The result of getServerSnapshot should be cached to avoid an infinite loop',\n          );\n          didWarnUncachedGetSnapshot = true;\n        }\n      }\n    }\n  } else {\n    nextSnapshot = getSnapshot();\n    if (__DEV__) {\n      if (!didWarnUncachedGetSnapshot) {\n        if (nextSnapshot !== getSnapshot()) {\n          console.error(\n            'The result of getSnapshot should be cached to avoid an infinite loop',\n          );\n          didWarnUncachedGetSnapshot = true;\n        }\n      }\n    }\n    // Unless we're rendering a blocking lane, schedule a consistency check.\n    // Right before committing, we will walk the tree and check if any of the\n    // stores were mutated.\n    //\n    // We won't do this if we're hydrating server-rendered content, because if\n    // the content is stale, it's already visible anyway. Instead we'll patch\n    // it up in a passive effect.\n    const root: FiberRoot | null = getWorkInProgressRoot();\n\n    if (root === null) {\n      throw new Error(\n        'Expected a work-in-progress root. This is a bug in React. Please file an issue.',\n      );\n    }\n\n    if (!includesBlockingLane(root, renderLanes)) {\n      pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);\n    }\n  }\n\n  // Read the current snapshot from the store on every render. This breaks the\n  // normal rules of React, and only works because store updates are\n  // always synchronous.\n  hook.memoizedState = nextSnapshot;\n  const inst: StoreInstance<T> = {\n    value: nextSnapshot,\n    getSnapshot,\n  };\n  hook.queue = inst;\n\n  // Schedule an effect to subscribe to the store.\n  mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe]);\n\n  // Schedule an effect to update the mutable instance fields. We will update\n  // this whenever subscribe, getSnapshot, or value changes. Because there's no\n  // clean-up function, and we track the deps correctly, we can call pushEffect\n  // directly, without storing any additional state. For the same reason, we\n  // don't need to set a static flag, either.\n  // TODO: We can move this to the passive phase once we add a pre-commit\n  // consistency check. See the next comment.\n  fiber.flags |= PassiveEffect;\n  pushEffect(\n    HookHasEffect | HookPassive,\n    updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot),\n    undefined,\n    null,\n  );\n\n  return nextSnapshot;\n}\n\nfunction updateSyncExternalStore<T>(\n  subscribe: (() => void) => () => void,\n  getSnapshot: () => T,\n  getServerSnapshot?: () => T,\n): T {\n  const fiber = currentlyRenderingFiber;\n  const hook = updateWorkInProgressHook();\n  // Read the current snapshot from the store on every render. This breaks the\n  // normal rules of React, and only works because store updates are\n  // always synchronous.\n  const nextSnapshot = getSnapshot();\n  if (__DEV__) {\n    if (!didWarnUncachedGetSnapshot) {\n      if (nextSnapshot !== getSnapshot()) {\n        console.error(\n          'The result of getSnapshot should be cached to avoid an infinite loop',\n        );\n        didWarnUncachedGetSnapshot = true;\n      }\n    }\n  }\n  const prevSnapshot = hook.memoizedState;\n  const snapshotChanged = !is(prevSnapshot, nextSnapshot);\n  if (snapshotChanged) {\n    hook.memoizedState = nextSnapshot;\n    markWorkInProgressReceivedUpdate();\n  }\n  const inst = hook.queue;\n\n  updateEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [\n    subscribe,\n  ]);\n\n  // Whenever getSnapshot or subscribe changes, we need to check in the\n  // commit phase if there was an interleaved mutation. In concurrent mode\n  // this can happen all the time, but even in synchronous mode, an earlier\n  // effect may have mutated the store.\n  if (\n    inst.getSnapshot !== getSnapshot ||\n    snapshotChanged ||\n    // Check if the susbcribe function changed. We can save some memory by\n    // checking whether we scheduled a subscription effect above.\n    (workInProgressHook !== null &&\n      workInProgressHook.memoizedState.tag & HookHasEffect)\n  ) {\n    fiber.flags |= PassiveEffect;\n    pushEffect(\n      HookHasEffect | HookPassive,\n      updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot),\n      undefined,\n      null,\n    );\n\n    // Unless we're rendering a blocking lane, schedule a consistency check.\n    // Right before committing, we will walk the tree and check if any of the\n    // stores were mutated.\n    const root: FiberRoot | null = getWorkInProgressRoot();\n\n    if (root === null) {\n      throw new Error(\n        'Expected a work-in-progress root. This is a bug in React. Please file an issue.',\n      );\n    }\n\n    if (!includesBlockingLane(root, renderLanes)) {\n      pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);\n    }\n  }\n\n  return nextSnapshot;\n}\n\nfunction pushStoreConsistencyCheck<T>(\n  fiber: Fiber,\n  getSnapshot: () => T,\n  renderedSnapshot: T,\n) {\n  fiber.flags |= StoreConsistency;\n  const check: StoreConsistencyCheck<T> = {\n    getSnapshot,\n    value: renderedSnapshot,\n  };\n  let componentUpdateQueue: null | FunctionComponentUpdateQueue = (currentlyRenderingFiber.updateQueue: any);\n  if (componentUpdateQueue === null) {\n    componentUpdateQueue = createFunctionComponentUpdateQueue();\n    currentlyRenderingFiber.updateQueue = (componentUpdateQueue: any);\n    componentUpdateQueue.stores = [check];\n  } else {\n    const stores = componentUpdateQueue.stores;\n    if (stores === null) {\n      componentUpdateQueue.stores = [check];\n    } else {\n      stores.push(check);\n    }\n  }\n}\n\nfunction updateStoreInstance<T>(\n  fiber: Fiber,\n  inst: StoreInstance<T>,\n  nextSnapshot: T,\n  getSnapshot: () => T,\n) {\n  // These are updated in the passive phase\n  inst.value = nextSnapshot;\n  inst.getSnapshot = getSnapshot;\n\n  // Something may have been mutated in between render and commit. This could\n  // have been in an event that fired before the passive effects, or it could\n  // have been in a layout effect. In that case, we would have used the old\n  // snapsho and getSnapshot values to bail out. We need to check one more time.\n  if (checkIfSnapshotChanged(inst)) {\n    // Force a re-render.\n    forceStoreRerender(fiber);\n  }\n}\n\nfunction subscribeToStore(fiber, inst, subscribe) {\n  const handleStoreChange = () => {\n    // The store changed. Check if the snapshot changed since the last time we\n    // read from the store.\n    if (checkIfSnapshotChanged(inst)) {\n      // Force a re-render.\n      forceStoreRerender(fiber);\n    }\n  };\n  // Subscribe to the store and return a clean-up function.\n  return subscribe(handleStoreChange);\n}\n\nfunction checkIfSnapshotChanged(inst) {\n  const latestGetSnapshot = inst.getSnapshot;\n  const prevValue = inst.value;\n  try {\n    const nextValue = latestGetSnapshot();\n    return !is(prevValue, nextValue);\n  } catch (error) {\n    return true;\n  }\n}\n\nfunction forceStoreRerender(fiber) {\n  scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\n}\n\nfunction mountState<S>(\n  initialState: (() => S) | S,\n): [S, Dispatch<BasicStateAction<S>>] {\n  const hook = mountWorkInProgressHook();\n  if (typeof initialState === 'function') {\n    // $FlowFixMe: Flow doesn't like mixed types\n    initialState = initialState();\n  }\n  hook.memoizedState = hook.baseState = initialState;\n  const queue: UpdateQueue<S, BasicStateAction<S>> = {\n    pending: null,\n    interleaved: null,\n    lanes: NoLanes,\n    dispatch: null,\n    lastRenderedReducer: basicStateReducer,\n    lastRenderedState: (initialState: any),\n  };\n  hook.queue = queue;\n  const dispatch: Dispatch<\n    BasicStateAction<S>,\n  > = (queue.dispatch = (dispatchSetState.bind(\n    null,\n    currentlyRenderingFiber,\n    queue,\n  ): any));\n  return [hook.memoizedState, dispatch];\n}\n\nfunction updateState<S>(\n  initialState: (() => S) | S,\n): [S, Dispatch<BasicStateAction<S>>] {\n  return updateReducer(basicStateReducer, (initialState: any));\n}\n\nfunction rerenderState<S>(\n  initialState: (() => S) | S,\n): [S, Dispatch<BasicStateAction<S>>] {\n  return rerenderReducer(basicStateReducer, (initialState: any));\n}\n\nfunction pushEffect(tag, create, destroy, deps) {\n  const effect: Effect = {\n    tag,\n    create,\n    destroy,\n    deps,\n    // Circular\n    next: (null: any),\n  };\n  let componentUpdateQueue: null | FunctionComponentUpdateQueue = (currentlyRenderingFiber.updateQueue: any);\n  if (componentUpdateQueue === null) {\n    componentUpdateQueue = createFunctionComponentUpdateQueue();\n    currentlyRenderingFiber.updateQueue = (componentUpdateQueue: any);\n    componentUpdateQueue.lastEffect = effect.next = effect;\n  } else {\n    const lastEffect = componentUpdateQueue.lastEffect;\n    if (lastEffect === null) {\n      componentUpdateQueue.lastEffect = effect.next = effect;\n    } else {\n      const firstEffect = lastEffect.next;\n      lastEffect.next = effect;\n      effect.next = firstEffect;\n      componentUpdateQueue.lastEffect = effect;\n    }\n  }\n  return effect;\n}\n\nlet stackContainsErrorMessage: boolean | null = null;\n\nfunction getCallerStackFrame(): string {\n  // eslint-disable-next-line react-internal/prod-error-codes\n  const stackFrames = new Error('Error message').stack.split('\\n');\n\n  // Some browsers (e.g. Chrome) include the error message in the stack\n  // but others (e.g. Firefox) do not.\n  if (stackContainsErrorMessage === null) {\n    stackContainsErrorMessage = stackFrames[0].includes('Error message');\n  }\n\n  return stackContainsErrorMessage\n    ? stackFrames.slice(3, 4).join('\\n')\n    : stackFrames.slice(2, 3).join('\\n');\n}\n\nfunction mountRef<T>(initialValue: T): {|current: T|} {\n  const hook = mountWorkInProgressHook();\n  if (enableUseRefAccessWarning) {\n    if (__DEV__) {\n      // Support lazy initialization pattern shown in docs.\n      // We need to store the caller stack frame so that we don't warn on subsequent renders.\n      let hasBeenInitialized = initialValue != null;\n      let lazyInitGetterStack = null;\n      let didCheckForLazyInit = false;\n\n      // Only warn once per component+hook.\n      let didWarnAboutRead = false;\n      let didWarnAboutWrite = false;\n\n      let current = initialValue;\n      const ref = {\n        get current() {\n          if (!hasBeenInitialized) {\n            didCheckForLazyInit = true;\n            lazyInitGetterStack = getCallerStackFrame();\n          } else if (currentlyRenderingFiber !== null && !didWarnAboutRead) {\n            if (\n              lazyInitGetterStack === null ||\n              lazyInitGetterStack !== getCallerStackFrame()\n            ) {\n              didWarnAboutRead = true;\n              console.warn(\n                '%s: Unsafe read of a mutable value during render.\\n\\n' +\n                  'Reading from a ref during render is only safe if:\\n' +\n                  '1. The ref value has not been updated, or\\n' +\n                  '2. The ref holds a lazily-initialized value that is only set once.\\n',\n                getComponentNameFromFiber(currentlyRenderingFiber) || 'Unknown',\n              );\n            }\n          }\n          return current;\n        },\n        set current(value) {\n          if (currentlyRenderingFiber !== null && !didWarnAboutWrite) {\n            if (\n              hasBeenInitialized ||\n              (!hasBeenInitialized && !didCheckForLazyInit)\n            ) {\n              didWarnAboutWrite = true;\n              console.warn(\n                '%s: Unsafe write of a mutable value during render.\\n\\n' +\n                  'Writing to a ref during render is only safe if the ref holds ' +\n                  'a lazily-initialized value that is only set once.\\n',\n                getComponentNameFromFiber(currentlyRenderingFiber) || 'Unknown',\n              );\n            }\n          }\n\n          hasBeenInitialized = true;\n          current = value;\n        },\n      };\n      Object.seal(ref);\n      hook.memoizedState = ref;\n      return ref;\n    } else {\n      const ref = {current: initialValue};\n      hook.memoizedState = ref;\n      return ref;\n    }\n  } else {\n    const ref = {current: initialValue};\n    hook.memoizedState = ref;\n    return ref;\n  }\n}\n\nfunction updateRef<T>(initialValue: T): {|current: T|} {\n  const hook = updateWorkInProgressHook();\n  return hook.memoizedState;\n}\n\nfunction mountEffectImpl(fiberFlags, hookFlags, create, deps): void {\n  const hook = mountWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  currentlyRenderingFiber.flags |= fiberFlags;\n  hook.memoizedState = pushEffect(\n    HookHasEffect | hookFlags,\n    create,\n    undefined,\n    nextDeps,\n  );\n}\n\nfunction updateEffectImpl(fiberFlags, hookFlags, create, deps): void {\n  const hook = updateWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  let destroy = undefined;\n\n  if (currentHook !== null) {\n    const prevEffect = currentHook.memoizedState;\n    destroy = prevEffect.destroy;\n    if (nextDeps !== null) {\n      const prevDeps = prevEffect.deps;\n      if (areHookInputsEqual(nextDeps, prevDeps)) {\n        hook.memoizedState = pushEffect(hookFlags, create, destroy, nextDeps);\n        return;\n      }\n    }\n  }\n\n  currentlyRenderingFiber.flags |= fiberFlags;\n\n  hook.memoizedState = pushEffect(\n    HookHasEffect | hookFlags,\n    create,\n    destroy,\n    nextDeps,\n  );\n}\n\nfunction mountEffect(\n  create: () => (() => void) | void,\n  deps: Array<mixed> | void | null,\n): void {\n  if (\n    __DEV__ &&\n    enableStrictEffects &&\n    (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode\n  ) {\n    return mountEffectImpl(\n      MountPassiveDevEffect | PassiveEffect | PassiveStaticEffect,\n      HookPassive,\n      create,\n      deps,\n    );\n  } else {\n    return mountEffectImpl(\n      PassiveEffect | PassiveStaticEffect,\n      HookPassive,\n      create,\n      deps,\n    );\n  }\n}\n\nfunction updateEffect(\n  create: () => (() => void) | void,\n  deps: Array<mixed> | void | null,\n): void {\n  return updateEffectImpl(PassiveEffect, HookPassive, create, deps);\n}\n\nfunction mountInsertionEffect(\n  create: () => (() => void) | void,\n  deps: Array<mixed> | void | null,\n): void {\n  return mountEffectImpl(UpdateEffect, HookInsertion, create, deps);\n}\n\nfunction updateInsertionEffect(\n  create: () => (() => void) | void,\n  deps: Array<mixed> | void | null,\n): void {\n  return updateEffectImpl(UpdateEffect, HookInsertion, create, deps);\n}\n\nfunction mountLayoutEffect(\n  create: () => (() => void) | void,\n  deps: Array<mixed> | void | null,\n): void {\n  let fiberFlags: Flags = UpdateEffect;\n  if (enableSuspenseLayoutEffectSemantics) {\n    fiberFlags |= LayoutStaticEffect;\n  }\n  if (\n    __DEV__ &&\n    enableStrictEffects &&\n    (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode\n  ) {\n    fiberFlags |= MountLayoutDevEffect;\n  }\n  return mountEffectImpl(fiberFlags, HookLayout, create, deps);\n}\n\nfunction updateLayoutEffect(\n  create: () => (() => void) | void,\n  deps: Array<mixed> | void | null,\n): void {\n  return updateEffectImpl(UpdateEffect, HookLayout, create, deps);\n}\n\nfunction imperativeHandleEffect<T>(\n  create: () => T,\n  ref: {|current: T | null|} | ((inst: T | null) => mixed) | null | void,\n) {\n  if (typeof ref === 'function') {\n    const refCallback = ref;\n    const inst = create();\n    refCallback(inst);\n    return () => {\n      refCallback(null);\n    };\n  } else if (ref !== null && ref !== undefined) {\n    const refObject = ref;\n    if (__DEV__) {\n      if (!refObject.hasOwnProperty('current')) {\n        console.error(\n          'Expected useImperativeHandle() first argument to either be a ' +\n            'ref callback or React.createRef() object. Instead received: %s.',\n          'an object with keys {' + Object.keys(refObject).join(', ') + '}',\n        );\n      }\n    }\n    const inst = create();\n    refObject.current = inst;\n    return () => {\n      refObject.current = null;\n    };\n  }\n}\n\nfunction mountImperativeHandle<T>(\n  ref: {|current: T | null|} | ((inst: T | null) => mixed) | null | void,\n  create: () => T,\n  deps: Array<mixed> | void | null,\n): void {\n  if (__DEV__) {\n    if (typeof create !== 'function') {\n      console.error(\n        'Expected useImperativeHandle() second argument to be a function ' +\n          'that creates a handle. Instead received: %s.',\n        create !== null ? typeof create : 'null',\n      );\n    }\n  }\n\n  // TODO: If deps are provided, should we skip comparing the ref itself?\n  const effectDeps =\n    deps !== null && deps !== undefined ? deps.concat([ref]) : null;\n\n  let fiberFlags: Flags = UpdateEffect;\n  if (enableSuspenseLayoutEffectSemantics) {\n    fiberFlags |= LayoutStaticEffect;\n  }\n  if (\n    __DEV__ &&\n    enableStrictEffects &&\n    (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode\n  ) {\n    fiberFlags |= MountLayoutDevEffect;\n  }\n  return mountEffectImpl(\n    fiberFlags,\n    HookLayout,\n    imperativeHandleEffect.bind(null, create, ref),\n    effectDeps,\n  );\n}\n\nfunction updateImperativeHandle<T>(\n  ref: {|current: T | null|} | ((inst: T | null) => mixed) | null | void,\n  create: () => T,\n  deps: Array<mixed> | void | null,\n): void {\n  if (__DEV__) {\n    if (typeof create !== 'function') {\n      console.error(\n        'Expected useImperativeHandle() second argument to be a function ' +\n          'that creates a handle. Instead received: %s.',\n        create !== null ? typeof create : 'null',\n      );\n    }\n  }\n\n  // TODO: If deps are provided, should we skip comparing the ref itself?\n  const effectDeps =\n    deps !== null && deps !== undefined ? deps.concat([ref]) : null;\n\n  return updateEffectImpl(\n    UpdateEffect,\n    HookLayout,\n    imperativeHandleEffect.bind(null, create, ref),\n    effectDeps,\n  );\n}\n\nfunction mountDebugValue<T>(value: T, formatterFn: ?(value: T) => mixed): void {\n  // This hook is normally a no-op.\n  // The react-debug-hooks package injects its own implementation\n  // so that e.g. DevTools can display custom hook values.\n}\n\nconst updateDebugValue = mountDebugValue;\n\nfunction mountCallback<T>(callback: T, deps: Array<mixed> | void | null): T {\n  const hook = mountWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  hook.memoizedState = [callback, nextDeps];\n  return callback;\n}\n\nfunction updateCallback<T>(callback: T, deps: Array<mixed> | void | null): T {\n  const hook = updateWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  const prevState = hook.memoizedState;\n  if (prevState !== null) {\n    if (nextDeps !== null) {\n      const prevDeps: Array<mixed> | null = prevState[1];\n      if (areHookInputsEqual(nextDeps, prevDeps)) {\n        return prevState[0];\n      }\n    }\n  }\n  hook.memoizedState = [callback, nextDeps];\n  return callback;\n}\n\nfunction mountMemo<T>(\n  nextCreate: () => T,\n  deps: Array<mixed> | void | null,\n): T {\n  const hook = mountWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  const nextValue = nextCreate();\n  hook.memoizedState = [nextValue, nextDeps];\n  return nextValue;\n}\n\nfunction updateMemo<T>(\n  nextCreate: () => T,\n  deps: Array<mixed> | void | null,\n): T {\n  const hook = updateWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  const prevState = hook.memoizedState;\n  if (prevState !== null) {\n    // Assume these are defined. If they're not, areHookInputsEqual will warn.\n    if (nextDeps !== null) {\n      const prevDeps: Array<mixed> | null = prevState[1];\n      if (areHookInputsEqual(nextDeps, prevDeps)) {\n        return prevState[0];\n      }\n    }\n  }\n  const nextValue = nextCreate();\n  hook.memoizedState = [nextValue, nextDeps];\n  return nextValue;\n}\n\nfunction mountDeferredValue<T>(value: T): T {\n  const [prevValue, setValue] = mountState(value);\n  mountEffect(() => {\n    const prevTransition = ReactCurrentBatchConfig.transition;\n    ReactCurrentBatchConfig.transition = 1;\n    try {\n      setValue(value);\n    } finally {\n      ReactCurrentBatchConfig.transition = prevTransition;\n    }\n  }, [value]);\n  return prevValue;\n}\n\nfunction updateDeferredValue<T>(value: T): T {\n  const [prevValue, setValue] = updateState(value);\n  updateEffect(() => {\n    const prevTransition = ReactCurrentBatchConfig.transition;\n    ReactCurrentBatchConfig.transition = 1;\n    try {\n      setValue(value);\n    } finally {\n      ReactCurrentBatchConfig.transition = prevTransition;\n    }\n  }, [value]);\n  return prevValue;\n}\n\nfunction rerenderDeferredValue<T>(value: T): T {\n  const [prevValue, setValue] = rerenderState(value);\n  updateEffect(() => {\n    const prevTransition = ReactCurrentBatchConfig.transition;\n    ReactCurrentBatchConfig.transition = 1;\n    try {\n      setValue(value);\n    } finally {\n      ReactCurrentBatchConfig.transition = prevTransition;\n    }\n  }, [value]);\n  return prevValue;\n}\n\nfunction startTransition(setPending, callback) {\n  const previousPriority = getCurrentUpdatePriority();\n  setCurrentUpdatePriority(\n    higherEventPriority(previousPriority, ContinuousEventPriority),\n  );\n\n  setPending(true);\n\n  const prevTransition = ReactCurrentBatchConfig.transition;\n  ReactCurrentBatchConfig.transition = 1;\n  try {\n    setPending(false);\n    callback();\n  } finally {\n    setCurrentUpdatePriority(previousPriority);\n    ReactCurrentBatchConfig.transition = prevTransition;\n    if (__DEV__) {\n      if (\n        prevTransition !== 1 &&\n        warnOnSubscriptionInsideStartTransition &&\n        ReactCurrentBatchConfig._updatedFibers\n      ) {\n        const updatedFibersCount = ReactCurrentBatchConfig._updatedFibers.size;\n        if (updatedFibersCount > 10) {\n          console.warn(\n            'Detected a large number of updates inside startTransition. ' +\n              'If this is due to a subscription please re-write it to use React provided hooks. ' +\n              'Otherwise concurrent mode guarantees are off the table.',\n          );\n        }\n        ReactCurrentBatchConfig._updatedFibers.clear();\n      }\n    }\n  }\n}\n\nfunction mountTransition(): [boolean, (() => void) => void] {\n  const [isPending, setPending] = mountState(false);\n  // The `start` method never changes.\n  const start = startTransition.bind(null, setPending);\n  const hook = mountWorkInProgressHook();\n  hook.memoizedState = start;\n  return [isPending, start];\n}\n\nfunction updateTransition(): [boolean, (() => void) => void] {\n  const [isPending] = updateState(false);\n  const hook = updateWorkInProgressHook();\n  const start = hook.memoizedState;\n  return [isPending, start];\n}\n\nfunction rerenderTransition(): [boolean, (() => void) => void] {\n  const [isPending] = rerenderState(false);\n  const hook = updateWorkInProgressHook();\n  const start = hook.memoizedState;\n  return [isPending, start];\n}\n\nlet isUpdatingOpaqueValueInRenderPhase = false;\nexport function getIsUpdatingOpaqueValueInRenderPhaseInDEV(): boolean | void {\n  if (__DEV__) {\n    return isUpdatingOpaqueValueInRenderPhase;\n  }\n}\n\nfunction mountId(): string {\n  const hook = mountWorkInProgressHook();\n\n  let id;\n  if (getIsHydrating()) {\n    const treeId = getTreeId();\n\n    // Use a captial R prefix for server-generated ids.\n    id = 'R:' + treeId;\n\n    // Unless this is the first id at this level, append a number at the end\n    // that represents the position of this useId hook among all the useId\n    // hooks for this fiber.\n    const localId = localIdCounter++;\n    if (localId > 0) {\n      id += ':' + localId.toString(32);\n    }\n  } else {\n    // Use a lowercase r prefix for client-generated ids.\n    const globalClientId = globalClientIdCounter++;\n    id = 'r:' + globalClientId.toString(32);\n  }\n\n  hook.memoizedState = id;\n  return id;\n}\n\nfunction updateId(): string {\n  const hook = updateWorkInProgressHook();\n  const id: string = hook.memoizedState;\n  return id;\n}\n\nfunction mountRefresh() {\n  const hook = mountWorkInProgressHook();\n  const refresh = (hook.memoizedState = refreshCache.bind(\n    null,\n    currentlyRenderingFiber,\n  ));\n  return refresh;\n}\n\nfunction updateRefresh() {\n  const hook = updateWorkInProgressHook();\n  return hook.memoizedState;\n}\n\nfunction refreshCache<T>(fiber: Fiber, seedKey: ?() => T, seedValue: T) {\n  if (!enableCache) {\n    return;\n  }\n  // TODO: Does Cache work in legacy mode? Should decide and write a test.\n  // TODO: Consider warning if the refresh is at discrete priority, or if we\n  // otherwise suspect that it wasn't batched properly.\n  let provider = fiber.return;\n  while (provider !== null) {\n    switch (provider.tag) {\n      case CacheComponent:\n      case HostRoot: {\n        const lane = requestUpdateLane(provider);\n        const eventTime = requestEventTime();\n        const root = scheduleUpdateOnFiber(provider, lane, eventTime);\n        if (root !== null) {\n          entangleLegacyQueueTransitions(root, provider, lane);\n        }\n\n        // TODO: If a refresh never commits, the new cache created here must be\n        // released. A simple case is start refreshing a cache boundary, but then\n        // unmount that boundary before the refresh completes.\n        const seededCache = createCache();\n        if (seedKey !== null && seedKey !== undefined && root !== null) {\n          // Seed the cache with the value passed by the caller. This could be\n          // from a server mutation, or it could be a streaming response.\n          seededCache.data.set(seedKey, seedValue);\n        }\n\n        // Schedule an update on the cache boundary to trigger a refresh.\n        const refreshUpdate = createLegacyQueueUpdate(eventTime, lane);\n        const payload = {\n          cache: seededCache,\n        };\n        refreshUpdate.payload = payload;\n        enqueueLegacyQueueUpdate(provider, refreshUpdate, lane);\n        return;\n      }\n    }\n    provider = provider.return;\n  }\n  // TODO: Warn if unmounted?\n}\n\nfunction dispatchReducerAction<S, A>(\n  fiber: Fiber,\n  queue: UpdateQueue<S, A>,\n  action: A,\n) {\n  if (__DEV__) {\n    if (typeof arguments[3] === 'function') {\n      console.error(\n        \"State updates from the useState() and useReducer() Hooks don't support the \" +\n          'second callback argument. To execute a side effect after ' +\n          'rendering, declare it in the component body with useEffect().',\n      );\n    }\n  }\n\n  const lane = requestUpdateLane(fiber);\n\n  const update: Update<S, A> = {\n    lane,\n    action,\n    hasEagerState: false,\n    eagerState: null,\n    next: (null: any),\n  };\n\n  if (isRenderPhaseUpdate(fiber)) {\n    enqueueRenderPhaseUpdate(queue, update);\n  } else {\n    enqueueUpdate(fiber, queue, update, lane);\n    const eventTime = requestEventTime();\n    const root = scheduleUpdateOnFiber(fiber, lane, eventTime);\n    if (root !== null) {\n      entangleTransitionUpdate(root, queue, lane);\n    }\n  }\n\n  markUpdateInDevTools(fiber, lane, action);\n}\n\nfunction dispatchSetState<S, A>(\n  fiber: Fiber,\n  queue: UpdateQueue<S, A>,\n  action: A,\n) {\n  if (__DEV__) {\n    if (typeof arguments[3] === 'function') {\n      console.error(\n        \"State updates from the useState() and useReducer() Hooks don't support the \" +\n          'second callback argument. To execute a side effect after ' +\n          'rendering, declare it in the component body with useEffect().',\n      );\n    }\n  }\n\n  const lane = requestUpdateLane(fiber);\n\n  const update: Update<S, A> = {\n    lane,\n    action,\n    hasEagerState: false,\n    eagerState: null,\n    next: (null: any),\n  };\n\n  if (isRenderPhaseUpdate(fiber)) {\n    enqueueRenderPhaseUpdate(queue, update);\n  } else {\n    enqueueUpdate(fiber, queue, update, lane);\n\n    const alternate = fiber.alternate;\n    if (\n      fiber.lanes === NoLanes &&\n      (alternate === null || alternate.lanes === NoLanes)\n    ) {\n      // The queue is currently empty, which means we can eagerly compute the\n      // next state before entering the render phase. If the new state is the\n      // same as the current state, we may be able to bail out entirely.\n      const lastRenderedReducer = queue.lastRenderedReducer;\n      if (lastRenderedReducer !== null) {\n        let prevDispatcher;\n        if (__DEV__) {\n          prevDispatcher = ReactCurrentDispatcher.current;\n          ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n        }\n        try {\n          const currentState: S = (queue.lastRenderedState: any);\n          const eagerState = lastRenderedReducer(currentState, action);\n          // Stash the eagerly computed state, and the reducer used to compute\n          // it, on the update object. If the reducer hasn't changed by the\n          // time we enter the render phase, then the eager state can be used\n          // without calling the reducer again.\n          update.hasEagerState = true;\n          update.eagerState = eagerState;\n          if (is(eagerState, currentState)) {\n            // Fast path. We can bail out without scheduling React to re-render.\n            // It's still possible that we'll need to rebase this update later,\n            // if the component re-renders for a different reason and by that\n            // time the reducer has changed.\n            return;\n          }\n        } catch (error) {\n          // Suppress the error. It will throw again in the render phase.\n        } finally {\n          if (__DEV__) {\n            ReactCurrentDispatcher.current = prevDispatcher;\n          }\n        }\n      }\n    }\n    const eventTime = requestEventTime();\n    const root = scheduleUpdateOnFiber(fiber, lane, eventTime);\n    if (root !== null) {\n      entangleTransitionUpdate(root, queue, lane);\n    }\n  }\n\n  markUpdateInDevTools(fiber, lane, action);\n}\n\nfunction isRenderPhaseUpdate(fiber: Fiber) {\n  const alternate = fiber.alternate;\n  return (\n    fiber === currentlyRenderingFiber ||\n    (alternate !== null && alternate === currentlyRenderingFiber)\n  );\n}\n\nfunction enqueueRenderPhaseUpdate<S, A>(\n  queue: UpdateQueue<S, A>,\n  update: Update<S, A>,\n) {\n  // This is a render phase update. Stash it in a lazily-created map of\n  // queue -> linked list of updates. After this render pass, we'll restart\n  // and apply the stashed updates on top of the work-in-progress hook.\n  didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;\n  const pending = queue.pending;\n  if (pending === null) {\n    // This is the first update. Create a circular list.\n    update.next = update;\n  } else {\n    update.next = pending.next;\n    pending.next = update;\n  }\n  queue.pending = update;\n}\n\nfunction enqueueUpdate<S, A>(\n  fiber: Fiber,\n  queue: UpdateQueue<S, A>,\n  update: Update<S, A>,\n  lane: Lane,\n) {\n  if (isInterleavedUpdate(fiber, lane)) {\n    const interleaved = queue.interleaved;\n    if (interleaved === null) {\n      // This is the first update. Create a circular list.\n      update.next = update;\n      // At the end of the current render, this queue's interleaved updates will\n      // be transferred to the pending queue.\n      pushInterleavedQueue(queue);\n    } else {\n      update.next = interleaved.next;\n      interleaved.next = update;\n    }\n    queue.interleaved = update;\n  } else {\n    const pending = queue.pending;\n    if (pending === null) {\n      // This is the first update. Create a circular list.\n      update.next = update;\n    } else {\n      update.next = pending.next;\n      pending.next = update;\n    }\n    queue.pending = update;\n  }\n}\n\nfunction entangleTransitionUpdate<S, A>(\n  root: FiberRoot,\n  queue: UpdateQueue<S, A>,\n  lane: Lane,\n) {\n  if (isTransitionLane(lane)) {\n    let queueLanes = queue.lanes;\n\n    // If any entangled lanes are no longer pending on the root, then they\n    // must have finished. We can remove them from the shared queue, which\n    // represents a superset of the actually pending lanes. In some cases we\n    // may entangle more than we need to, but that's OK. In fact it's worse if\n    // we *don't* entangle when we should.\n    queueLanes = intersectLanes(queueLanes, root.pendingLanes);\n\n    // Entangle the new transition lane with the other transition lanes.\n    const newQueueLanes = mergeLanes(queueLanes, lane);\n    queue.lanes = newQueueLanes;\n    // Even if queue.lanes already include lane, we don't know for certain if\n    // the lane finished since the last time we entangled it. So we need to\n    // entangle it again, just to be sure.\n    markRootEntangled(root, newQueueLanes);\n  }\n}\n\nfunction markUpdateInDevTools(fiber, lane, action) {\n  if (__DEV__) {\n    if (enableDebugTracing) {\n      if (fiber.mode & DebugTracingMode) {\n        const name = getComponentNameFromFiber(fiber) || 'Unknown';\n        logStateUpdateScheduled(name, lane, action);\n      }\n    }\n  }\n\n  if (enableSchedulingProfiler) {\n    markStateUpdateScheduled(fiber, lane);\n  }\n}\n\nfunction getCacheSignal(): AbortSignal {\n  if (!enableCache) {\n    throw new Error('Not implemented.');\n  }\n  const cache: Cache = readContext(CacheContext);\n  return cache.controller.signal;\n}\n\nfunction getCacheForType<T>(resourceType: () => T): T {\n  if (!enableCache) {\n    throw new Error('Not implemented.');\n  }\n  const cache: Cache = readContext(CacheContext);\n  let cacheForType: T | void = (cache.data.get(resourceType): any);\n  if (cacheForType === undefined) {\n    cacheForType = resourceType();\n    cache.data.set(resourceType, cacheForType);\n  }\n  return cacheForType;\n}\n\nexport const ContextOnlyDispatcher: Dispatcher = {\n  readContext,\n\n  useCallback: throwInvalidHookError,\n  useContext: throwInvalidHookError,\n  useEffect: throwInvalidHookError,\n  useImperativeHandle: throwInvalidHookError,\n  useInsertionEffect: throwInvalidHookError,\n  useLayoutEffect: throwInvalidHookError,\n  useMemo: throwInvalidHookError,\n  useReducer: throwInvalidHookError,\n  useRef: throwInvalidHookError,\n  useState: throwInvalidHookError,\n  useDebugValue: throwInvalidHookError,\n  useDeferredValue: throwInvalidHookError,\n  useTransition: throwInvalidHookError,\n  useMutableSource: throwInvalidHookError,\n  useSyncExternalStore: throwInvalidHookError,\n  useId: throwInvalidHookError,\n\n  unstable_isNewReconciler: enableNewReconciler,\n};\nif (enableCache) {\n  (ContextOnlyDispatcher: Dispatcher).getCacheSignal = getCacheSignal;\n  (ContextOnlyDispatcher: Dispatcher).getCacheForType = getCacheForType;\n  (ContextOnlyDispatcher: Dispatcher).useCacheRefresh = throwInvalidHookError;\n}\n\nconst HooksDispatcherOnMount: Dispatcher = {\n  readContext,\n\n  useCallback: mountCallback,\n  useContext: readContext,\n  useEffect: mountEffect,\n  useImperativeHandle: mountImperativeHandle,\n  useLayoutEffect: mountLayoutEffect,\n  useInsertionEffect: mountInsertionEffect,\n  useMemo: mountMemo,\n  useReducer: mountReducer,\n  useRef: mountRef,\n  useState: mountState,\n  useDebugValue: mountDebugValue,\n  useDeferredValue: mountDeferredValue,\n  useTransition: mountTransition,\n  useMutableSource: mountMutableSource,\n  useSyncExternalStore: mountSyncExternalStore,\n  useId: mountId,\n\n  unstable_isNewReconciler: enableNewReconciler,\n};\nif (enableCache) {\n  (HooksDispatcherOnMount: Dispatcher).getCacheSignal = getCacheSignal;\n  (HooksDispatcherOnMount: Dispatcher).getCacheForType = getCacheForType;\n  (HooksDispatcherOnMount: Dispatcher).useCacheRefresh = mountRefresh;\n}\n\nconst HooksDispatcherOnUpdate: Dispatcher = {\n  readContext,\n\n  useCallback: updateCallback,\n  useContext: readContext,\n  useEffect: updateEffect,\n  useImperativeHandle: updateImperativeHandle,\n  useInsertionEffect: updateInsertionEffect,\n  useLayoutEffect: updateLayoutEffect,\n  useMemo: updateMemo,\n  useReducer: updateReducer,\n  useRef: updateRef,\n  useState: updateState,\n  useDebugValue: updateDebugValue,\n  useDeferredValue: updateDeferredValue,\n  useTransition: updateTransition,\n  useMutableSource: updateMutableSource,\n  useSyncExternalStore: updateSyncExternalStore,\n  useId: updateId,\n\n  unstable_isNewReconciler: enableNewReconciler,\n};\nif (enableCache) {\n  (HooksDispatcherOnUpdate: Dispatcher).getCacheSignal = getCacheSignal;\n  (HooksDispatcherOnUpdate: Dispatcher).getCacheForType = getCacheForType;\n  (HooksDispatcherOnUpdate: Dispatcher).useCacheRefresh = updateRefresh;\n}\n\nconst HooksDispatcherOnRerender: Dispatcher = {\n  readContext,\n\n  useCallback: updateCallback,\n  useContext: readContext,\n  useEffect: updateEffect,\n  useImperativeHandle: updateImperativeHandle,\n  useInsertionEffect: updateInsertionEffect,\n  useLayoutEffect: updateLayoutEffect,\n  useMemo: updateMemo,\n  useReducer: rerenderReducer,\n  useRef: updateRef,\n  useState: rerenderState,\n  useDebugValue: updateDebugValue,\n  useDeferredValue: rerenderDeferredValue,\n  useTransition: rerenderTransition,\n  useMutableSource: updateMutableSource,\n  useSyncExternalStore: mountSyncExternalStore,\n  useId: updateId,\n\n  unstable_isNewReconciler: enableNewReconciler,\n};\nif (enableCache) {\n  (HooksDispatcherOnRerender: Dispatcher).getCacheSignal = getCacheSignal;\n  (HooksDispatcherOnRerender: Dispatcher).getCacheForType = getCacheForType;\n  (HooksDispatcherOnRerender: Dispatcher).useCacheRefresh = updateRefresh;\n}\n\nlet HooksDispatcherOnMountInDEV: Dispatcher | null = null;\nlet HooksDispatcherOnMountWithHookTypesInDEV: Dispatcher | null = null;\nlet HooksDispatcherOnUpdateInDEV: Dispatcher | null = null;\nlet HooksDispatcherOnRerenderInDEV: Dispatcher | null = null;\nlet InvalidNestedHooksDispatcherOnMountInDEV: Dispatcher | null = null;\nlet InvalidNestedHooksDispatcherOnUpdateInDEV: Dispatcher | null = null;\nlet InvalidNestedHooksDispatcherOnRerenderInDEV: Dispatcher | null = null;\n\nif (__DEV__) {\n  const warnInvalidContextAccess = () => {\n    console.error(\n      'Context can only be read while React is rendering. ' +\n        'In classes, you can read it in the render method or getDerivedStateFromProps. ' +\n        'In function components, you can read it directly in the function body, but not ' +\n        'inside Hooks like useReducer() or useMemo().',\n    );\n  };\n\n  const warnInvalidHookAccess = () => {\n    console.error(\n      'Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. ' +\n        'You can only call Hooks at the top level of your React function. ' +\n        'For more information, see ' +\n        'https://reactjs.org/link/rules-of-hooks',\n    );\n  };\n\n  HooksDispatcherOnMountInDEV = {\n    readContext<T>(context: ReactContext<T>): T {\n      return readContext(context);\n    },\n    useCallback<T>(callback: T, deps: Array<mixed> | void | null): T {\n      currentHookNameInDev = 'useCallback';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      return mountCallback(callback, deps);\n    },\n    useContext<T>(context: ReactContext<T>): T {\n      currentHookNameInDev = 'useContext';\n      mountHookTypesDev();\n      return readContext(context);\n    },\n    useEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useEffect';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      return mountEffect(create, deps);\n    },\n    useImperativeHandle<T>(\n      ref: {|current: T | null|} | ((inst: T | null) => mixed) | null | void,\n      create: () => T,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useImperativeHandle';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      return mountImperativeHandle(ref, create, deps);\n    },\n    useInsertionEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useInsertionEffect';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      return mountInsertionEffect(create, deps);\n    },\n    useLayoutEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useLayoutEffect';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      return mountLayoutEffect(create, deps);\n    },\n    useMemo<T>(create: () => T, deps: Array<mixed> | void | null): T {\n      currentHookNameInDev = 'useMemo';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n      try {\n        return mountMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useReducer<S, I, A>(\n      reducer: (S, A) => S,\n      initialArg: I,\n      init?: I => S,\n    ): [S, Dispatch<A>] {\n      currentHookNameInDev = 'useReducer';\n      mountHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n      try {\n        return mountReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useRef<T>(initialValue: T): {|current: T|} {\n      currentHookNameInDev = 'useRef';\n      mountHookTypesDev();\n      return mountRef(initialValue);\n    },\n    useState<S>(\n      initialState: (() => S) | S,\n    ): [S, Dispatch<BasicStateAction<S>>] {\n      currentHookNameInDev = 'useState';\n      mountHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n      try {\n        return mountState(initialState);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useDebugValue<T>(value: T, formatterFn: ?(value: T) => mixed): void {\n      currentHookNameInDev = 'useDebugValue';\n      mountHookTypesDev();\n      return mountDebugValue(value, formatterFn);\n    },\n    useDeferredValue<T>(value: T): T {\n      currentHookNameInDev = 'useDeferredValue';\n      mountHookTypesDev();\n      return mountDeferredValue(value);\n    },\n    useTransition(): [boolean, (() => void) => void] {\n      currentHookNameInDev = 'useTransition';\n      mountHookTypesDev();\n      return mountTransition();\n    },\n    useMutableSource<Source, Snapshot>(\n      source: MutableSource<Source>,\n      getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,\n      subscribe: MutableSourceSubscribeFn<Source, Snapshot>,\n    ): Snapshot {\n      currentHookNameInDev = 'useMutableSource';\n      mountHookTypesDev();\n      return mountMutableSource(source, getSnapshot, subscribe);\n    },\n    useSyncExternalStore<T>(\n      subscribe: (() => void) => () => void,\n      getSnapshot: () => T,\n      getServerSnapshot?: () => T,\n    ): T {\n      currentHookNameInDev = 'useSyncExternalStore';\n      mountHookTypesDev();\n      return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n    },\n    useId(): string {\n      currentHookNameInDev = 'useId';\n      mountHookTypesDev();\n      return mountId();\n    },\n\n    unstable_isNewReconciler: enableNewReconciler,\n  };\n  if (enableCache) {\n    (HooksDispatcherOnMountInDEV: Dispatcher).getCacheSignal = getCacheSignal;\n    (HooksDispatcherOnMountInDEV: Dispatcher).getCacheForType = getCacheForType;\n    (HooksDispatcherOnMountInDEV: Dispatcher).useCacheRefresh = function useCacheRefresh() {\n      currentHookNameInDev = 'useCacheRefresh';\n      mountHookTypesDev();\n      return mountRefresh();\n    };\n  }\n\n  HooksDispatcherOnMountWithHookTypesInDEV = {\n    readContext<T>(context: ReactContext<T>): T {\n      return readContext(context);\n    },\n    useCallback<T>(callback: T, deps: Array<mixed> | void | null): T {\n      currentHookNameInDev = 'useCallback';\n      updateHookTypesDev();\n      return mountCallback(callback, deps);\n    },\n    useContext<T>(context: ReactContext<T>): T {\n      currentHookNameInDev = 'useContext';\n      updateHookTypesDev();\n      return readContext(context);\n    },\n    useEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useEffect';\n      updateHookTypesDev();\n      return mountEffect(create, deps);\n    },\n    useImperativeHandle<T>(\n      ref: {|current: T | null|} | ((inst: T | null) => mixed) | null | void,\n      create: () => T,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useImperativeHandle';\n      updateHookTypesDev();\n      return mountImperativeHandle(ref, create, deps);\n    },\n    useInsertionEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useInsertionEffect';\n      updateHookTypesDev();\n      return mountInsertionEffect(create, deps);\n    },\n    useLayoutEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useLayoutEffect';\n      updateHookTypesDev();\n      return mountLayoutEffect(create, deps);\n    },\n    useMemo<T>(create: () => T, deps: Array<mixed> | void | null): T {\n      currentHookNameInDev = 'useMemo';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n      try {\n        return mountMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useReducer<S, I, A>(\n      reducer: (S, A) => S,\n      initialArg: I,\n      init?: I => S,\n    ): [S, Dispatch<A>] {\n      currentHookNameInDev = 'useReducer';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n      try {\n        return mountReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useRef<T>(initialValue: T): {|current: T|} {\n      currentHookNameInDev = 'useRef';\n      updateHookTypesDev();\n      return mountRef(initialValue);\n    },\n    useState<S>(\n      initialState: (() => S) | S,\n    ): [S, Dispatch<BasicStateAction<S>>] {\n      currentHookNameInDev = 'useState';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n      try {\n        return mountState(initialState);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useDebugValue<T>(value: T, formatterFn: ?(value: T) => mixed): void {\n      currentHookNameInDev = 'useDebugValue';\n      updateHookTypesDev();\n      return mountDebugValue(value, formatterFn);\n    },\n    useDeferredValue<T>(value: T): T {\n      currentHookNameInDev = 'useDeferredValue';\n      updateHookTypesDev();\n      return mountDeferredValue(value);\n    },\n    useTransition(): [boolean, (() => void) => void] {\n      currentHookNameInDev = 'useTransition';\n      updateHookTypesDev();\n      return mountTransition();\n    },\n    useMutableSource<Source, Snapshot>(\n      source: MutableSource<Source>,\n      getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,\n      subscribe: MutableSourceSubscribeFn<Source, Snapshot>,\n    ): Snapshot {\n      currentHookNameInDev = 'useMutableSource';\n      updateHookTypesDev();\n      return mountMutableSource(source, getSnapshot, subscribe);\n    },\n    useSyncExternalStore<T>(\n      subscribe: (() => void) => () => void,\n      getSnapshot: () => T,\n      getServerSnapshot?: () => T,\n    ): T {\n      currentHookNameInDev = 'useSyncExternalStore';\n      updateHookTypesDev();\n      return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n    },\n    useId(): string {\n      currentHookNameInDev = 'useId';\n      updateHookTypesDev();\n      return mountId();\n    },\n\n    unstable_isNewReconciler: enableNewReconciler,\n  };\n  if (enableCache) {\n    (HooksDispatcherOnMountWithHookTypesInDEV: Dispatcher).getCacheSignal = getCacheSignal;\n    (HooksDispatcherOnMountWithHookTypesInDEV: Dispatcher).getCacheForType = getCacheForType;\n    (HooksDispatcherOnMountWithHookTypesInDEV: Dispatcher).useCacheRefresh = function useCacheRefresh() {\n      currentHookNameInDev = 'useCacheRefresh';\n      updateHookTypesDev();\n      return mountRefresh();\n    };\n  }\n\n  HooksDispatcherOnUpdateInDEV = {\n    readContext<T>(context: ReactContext<T>): T {\n      return readContext(context);\n    },\n    useCallback<T>(callback: T, deps: Array<mixed> | void | null): T {\n      currentHookNameInDev = 'useCallback';\n      updateHookTypesDev();\n      return updateCallback(callback, deps);\n    },\n    useContext<T>(context: ReactContext<T>): T {\n      currentHookNameInDev = 'useContext';\n      updateHookTypesDev();\n      return readContext(context);\n    },\n    useEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useEffect';\n      updateHookTypesDev();\n      return updateEffect(create, deps);\n    },\n    useImperativeHandle<T>(\n      ref: {|current: T | null|} | ((inst: T | null) => mixed) | null | void,\n      create: () => T,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useImperativeHandle';\n      updateHookTypesDev();\n      return updateImperativeHandle(ref, create, deps);\n    },\n    useInsertionEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useInsertionEffect';\n      updateHookTypesDev();\n      return updateInsertionEffect(create, deps);\n    },\n    useLayoutEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useLayoutEffect';\n      updateHookTypesDev();\n      return updateLayoutEffect(create, deps);\n    },\n    useMemo<T>(create: () => T, deps: Array<mixed> | void | null): T {\n      currentHookNameInDev = 'useMemo';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n      try {\n        return updateMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useReducer<S, I, A>(\n      reducer: (S, A) => S,\n      initialArg: I,\n      init?: I => S,\n    ): [S, Dispatch<A>] {\n      currentHookNameInDev = 'useReducer';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n      try {\n        return updateReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useRef<T>(initialValue: T): {|current: T|} {\n      currentHookNameInDev = 'useRef';\n      updateHookTypesDev();\n      return updateRef(initialValue);\n    },\n    useState<S>(\n      initialState: (() => S) | S,\n    ): [S, Dispatch<BasicStateAction<S>>] {\n      currentHookNameInDev = 'useState';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n      try {\n        return updateState(initialState);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useDebugValue<T>(value: T, formatterFn: ?(value: T) => mixed): void {\n      currentHookNameInDev = 'useDebugValue';\n      updateHookTypesDev();\n      return updateDebugValue(value, formatterFn);\n    },\n    useDeferredValue<T>(value: T): T {\n      currentHookNameInDev = 'useDeferredValue';\n      updateHookTypesDev();\n      return updateDeferredValue(value);\n    },\n    useTransition(): [boolean, (() => void) => void] {\n      currentHookNameInDev = 'useTransition';\n      updateHookTypesDev();\n      return updateTransition();\n    },\n    useMutableSource<Source, Snapshot>(\n      source: MutableSource<Source>,\n      getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,\n      subscribe: MutableSourceSubscribeFn<Source, Snapshot>,\n    ): Snapshot {\n      currentHookNameInDev = 'useMutableSource';\n      updateHookTypesDev();\n      return updateMutableSource(source, getSnapshot, subscribe);\n    },\n    useSyncExternalStore<T>(\n      subscribe: (() => void) => () => void,\n      getSnapshot: () => T,\n      getServerSnapshot?: () => T,\n    ): T {\n      currentHookNameInDev = 'useSyncExternalStore';\n      updateHookTypesDev();\n      return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n    },\n    useId(): string {\n      currentHookNameInDev = 'useId';\n      updateHookTypesDev();\n      return updateId();\n    },\n\n    unstable_isNewReconciler: enableNewReconciler,\n  };\n  if (enableCache) {\n    (HooksDispatcherOnUpdateInDEV: Dispatcher).getCacheSignal = getCacheSignal;\n    (HooksDispatcherOnUpdateInDEV: Dispatcher).getCacheForType = getCacheForType;\n    (HooksDispatcherOnUpdateInDEV: Dispatcher).useCacheRefresh = function useCacheRefresh() {\n      currentHookNameInDev = 'useCacheRefresh';\n      updateHookTypesDev();\n      return updateRefresh();\n    };\n  }\n\n  HooksDispatcherOnRerenderInDEV = {\n    readContext<T>(context: ReactContext<T>): T {\n      return readContext(context);\n    },\n\n    useCallback<T>(callback: T, deps: Array<mixed> | void | null): T {\n      currentHookNameInDev = 'useCallback';\n      updateHookTypesDev();\n      return updateCallback(callback, deps);\n    },\n    useContext<T>(context: ReactContext<T>): T {\n      currentHookNameInDev = 'useContext';\n      updateHookTypesDev();\n      return readContext(context);\n    },\n    useEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useEffect';\n      updateHookTypesDev();\n      return updateEffect(create, deps);\n    },\n    useImperativeHandle<T>(\n      ref: {|current: T | null|} | ((inst: T | null) => mixed) | null | void,\n      create: () => T,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useImperativeHandle';\n      updateHookTypesDev();\n      return updateImperativeHandle(ref, create, deps);\n    },\n    useInsertionEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useInsertionEffect';\n      updateHookTypesDev();\n      return updateInsertionEffect(create, deps);\n    },\n    useLayoutEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useLayoutEffect';\n      updateHookTypesDev();\n      return updateLayoutEffect(create, deps);\n    },\n    useMemo<T>(create: () => T, deps: Array<mixed> | void | null): T {\n      currentHookNameInDev = 'useMemo';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnRerenderInDEV;\n      try {\n        return updateMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useReducer<S, I, A>(\n      reducer: (S, A) => S,\n      initialArg: I,\n      init?: I => S,\n    ): [S, Dispatch<A>] {\n      currentHookNameInDev = 'useReducer';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnRerenderInDEV;\n      try {\n        return rerenderReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useRef<T>(initialValue: T): {|current: T|} {\n      currentHookNameInDev = 'useRef';\n      updateHookTypesDev();\n      return updateRef(initialValue);\n    },\n    useState<S>(\n      initialState: (() => S) | S,\n    ): [S, Dispatch<BasicStateAction<S>>] {\n      currentHookNameInDev = 'useState';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnRerenderInDEV;\n      try {\n        return rerenderState(initialState);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useDebugValue<T>(value: T, formatterFn: ?(value: T) => mixed): void {\n      currentHookNameInDev = 'useDebugValue';\n      updateHookTypesDev();\n      return updateDebugValue(value, formatterFn);\n    },\n    useDeferredValue<T>(value: T): T {\n      currentHookNameInDev = 'useDeferredValue';\n      updateHookTypesDev();\n      return rerenderDeferredValue(value);\n    },\n    useTransition(): [boolean, (() => void) => void] {\n      currentHookNameInDev = 'useTransition';\n      updateHookTypesDev();\n      return rerenderTransition();\n    },\n    useMutableSource<Source, Snapshot>(\n      source: MutableSource<Source>,\n      getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,\n      subscribe: MutableSourceSubscribeFn<Source, Snapshot>,\n    ): Snapshot {\n      currentHookNameInDev = 'useMutableSource';\n      updateHookTypesDev();\n      return updateMutableSource(source, getSnapshot, subscribe);\n    },\n    useSyncExternalStore<T>(\n      subscribe: (() => void) => () => void,\n      getSnapshot: () => T,\n      getServerSnapshot?: () => T,\n    ): T {\n      currentHookNameInDev = 'useSyncExternalStore';\n      updateHookTypesDev();\n      return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n    },\n    useId(): string {\n      currentHookNameInDev = 'useId';\n      updateHookTypesDev();\n      return updateId();\n    },\n\n    unstable_isNewReconciler: enableNewReconciler,\n  };\n  if (enableCache) {\n    (HooksDispatcherOnRerenderInDEV: Dispatcher).getCacheSignal = getCacheSignal;\n    (HooksDispatcherOnRerenderInDEV: Dispatcher).getCacheForType = getCacheForType;\n    (HooksDispatcherOnRerenderInDEV: Dispatcher).useCacheRefresh = function useCacheRefresh() {\n      currentHookNameInDev = 'useCacheRefresh';\n      updateHookTypesDev();\n      return updateRefresh();\n    };\n  }\n\n  InvalidNestedHooksDispatcherOnMountInDEV = {\n    readContext<T>(context: ReactContext<T>): T {\n      warnInvalidContextAccess();\n      return readContext(context);\n    },\n    useCallback<T>(callback: T, deps: Array<mixed> | void | null): T {\n      currentHookNameInDev = 'useCallback';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountCallback(callback, deps);\n    },\n    useContext<T>(context: ReactContext<T>): T {\n      currentHookNameInDev = 'useContext';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return readContext(context);\n    },\n    useEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useEffect';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountEffect(create, deps);\n    },\n    useImperativeHandle<T>(\n      ref: {|current: T | null|} | ((inst: T | null) => mixed) | null | void,\n      create: () => T,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useImperativeHandle';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountImperativeHandle(ref, create, deps);\n    },\n    useInsertionEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useInsertionEffect';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountInsertionEffect(create, deps);\n    },\n    useLayoutEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useLayoutEffect';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountLayoutEffect(create, deps);\n    },\n    useMemo<T>(create: () => T, deps: Array<mixed> | void | null): T {\n      currentHookNameInDev = 'useMemo';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n      try {\n        return mountMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useReducer<S, I, A>(\n      reducer: (S, A) => S,\n      initialArg: I,\n      init?: I => S,\n    ): [S, Dispatch<A>] {\n      currentHookNameInDev = 'useReducer';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n      try {\n        return mountReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useRef<T>(initialValue: T): {|current: T|} {\n      currentHookNameInDev = 'useRef';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountRef(initialValue);\n    },\n    useState<S>(\n      initialState: (() => S) | S,\n    ): [S, Dispatch<BasicStateAction<S>>] {\n      currentHookNameInDev = 'useState';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n      try {\n        return mountState(initialState);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useDebugValue<T>(value: T, formatterFn: ?(value: T) => mixed): void {\n      currentHookNameInDev = 'useDebugValue';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountDebugValue(value, formatterFn);\n    },\n    useDeferredValue<T>(value: T): T {\n      currentHookNameInDev = 'useDeferredValue';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountDeferredValue(value);\n    },\n    useTransition(): [boolean, (() => void) => void] {\n      currentHookNameInDev = 'useTransition';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountTransition();\n    },\n    useMutableSource<Source, Snapshot>(\n      source: MutableSource<Source>,\n      getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,\n      subscribe: MutableSourceSubscribeFn<Source, Snapshot>,\n    ): Snapshot {\n      currentHookNameInDev = 'useMutableSource';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountMutableSource(source, getSnapshot, subscribe);\n    },\n    useSyncExternalStore<T>(\n      subscribe: (() => void) => () => void,\n      getSnapshot: () => T,\n      getServerSnapshot?: () => T,\n    ): T {\n      currentHookNameInDev = 'useSyncExternalStore';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n    },\n    useId(): string {\n      currentHookNameInDev = 'useId';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountId();\n    },\n\n    unstable_isNewReconciler: enableNewReconciler,\n  };\n  if (enableCache) {\n    (InvalidNestedHooksDispatcherOnMountInDEV: Dispatcher).getCacheSignal = getCacheSignal;\n    (InvalidNestedHooksDispatcherOnMountInDEV: Dispatcher).getCacheForType = getCacheForType;\n    (InvalidNestedHooksDispatcherOnMountInDEV: Dispatcher).useCacheRefresh = function useCacheRefresh() {\n      currentHookNameInDev = 'useCacheRefresh';\n      updateHookTypesDev();\n      return mountRefresh();\n    };\n  }\n\n  InvalidNestedHooksDispatcherOnUpdateInDEV = {\n    readContext<T>(context: ReactContext<T>): T {\n      warnInvalidContextAccess();\n      return readContext(context);\n    },\n    useCallback<T>(callback: T, deps: Array<mixed> | void | null): T {\n      currentHookNameInDev = 'useCallback';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateCallback(callback, deps);\n    },\n    useContext<T>(context: ReactContext<T>): T {\n      currentHookNameInDev = 'useContext';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return readContext(context);\n    },\n    useEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useEffect';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateEffect(create, deps);\n    },\n    useImperativeHandle<T>(\n      ref: {|current: T | null|} | ((inst: T | null) => mixed) | null | void,\n      create: () => T,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useImperativeHandle';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateImperativeHandle(ref, create, deps);\n    },\n    useInsertionEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useInsertionEffect';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateInsertionEffect(create, deps);\n    },\n    useLayoutEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useLayoutEffect';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateLayoutEffect(create, deps);\n    },\n    useMemo<T>(create: () => T, deps: Array<mixed> | void | null): T {\n      currentHookNameInDev = 'useMemo';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n      try {\n        return updateMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useReducer<S, I, A>(\n      reducer: (S, A) => S,\n      initialArg: I,\n      init?: I => S,\n    ): [S, Dispatch<A>] {\n      currentHookNameInDev = 'useReducer';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n      try {\n        return updateReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useRef<T>(initialValue: T): {|current: T|} {\n      currentHookNameInDev = 'useRef';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateRef(initialValue);\n    },\n    useState<S>(\n      initialState: (() => S) | S,\n    ): [S, Dispatch<BasicStateAction<S>>] {\n      currentHookNameInDev = 'useState';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n      try {\n        return updateState(initialState);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useDebugValue<T>(value: T, formatterFn: ?(value: T) => mixed): void {\n      currentHookNameInDev = 'useDebugValue';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateDebugValue(value, formatterFn);\n    },\n    useDeferredValue<T>(value: T): T {\n      currentHookNameInDev = 'useDeferredValue';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateDeferredValue(value);\n    },\n    useTransition(): [boolean, (() => void) => void] {\n      currentHookNameInDev = 'useTransition';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateTransition();\n    },\n    useMutableSource<Source, Snapshot>(\n      source: MutableSource<Source>,\n      getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,\n      subscribe: MutableSourceSubscribeFn<Source, Snapshot>,\n    ): Snapshot {\n      currentHookNameInDev = 'useMutableSource';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateMutableSource(source, getSnapshot, subscribe);\n    },\n    useSyncExternalStore<T>(\n      subscribe: (() => void) => () => void,\n      getSnapshot: () => T,\n      getServerSnapshot?: () => T,\n    ): T {\n      currentHookNameInDev = 'useSyncExternalStore';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n    },\n    useId(): string {\n      currentHookNameInDev = 'useId';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateId();\n    },\n\n    unstable_isNewReconciler: enableNewReconciler,\n  };\n  if (enableCache) {\n    (InvalidNestedHooksDispatcherOnUpdateInDEV: Dispatcher).getCacheSignal = getCacheSignal;\n    (InvalidNestedHooksDispatcherOnUpdateInDEV: Dispatcher).getCacheForType = getCacheForType;\n    (InvalidNestedHooksDispatcherOnUpdateInDEV: Dispatcher).useCacheRefresh = function useCacheRefresh() {\n      currentHookNameInDev = 'useCacheRefresh';\n      updateHookTypesDev();\n      return updateRefresh();\n    };\n  }\n\n  InvalidNestedHooksDispatcherOnRerenderInDEV = {\n    readContext<T>(context: ReactContext<T>): T {\n      warnInvalidContextAccess();\n      return readContext(context);\n    },\n\n    useCallback<T>(callback: T, deps: Array<mixed> | void | null): T {\n      currentHookNameInDev = 'useCallback';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateCallback(callback, deps);\n    },\n    useContext<T>(context: ReactContext<T>): T {\n      currentHookNameInDev = 'useContext';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return readContext(context);\n    },\n    useEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useEffect';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateEffect(create, deps);\n    },\n    useImperativeHandle<T>(\n      ref: {|current: T | null|} | ((inst: T | null) => mixed) | null | void,\n      create: () => T,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useImperativeHandle';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateImperativeHandle(ref, create, deps);\n    },\n    useInsertionEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useInsertionEffect';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateInsertionEffect(create, deps);\n    },\n    useLayoutEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useLayoutEffect';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateLayoutEffect(create, deps);\n    },\n    useMemo<T>(create: () => T, deps: Array<mixed> | void | null): T {\n      currentHookNameInDev = 'useMemo';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n      try {\n        return updateMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useReducer<S, I, A>(\n      reducer: (S, A) => S,\n      initialArg: I,\n      init?: I => S,\n    ): [S, Dispatch<A>] {\n      currentHookNameInDev = 'useReducer';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n      try {\n        return rerenderReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useRef<T>(initialValue: T): {|current: T|} {\n      currentHookNameInDev = 'useRef';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateRef(initialValue);\n    },\n    useState<S>(\n      initialState: (() => S) | S,\n    ): [S, Dispatch<BasicStateAction<S>>] {\n      currentHookNameInDev = 'useState';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n      try {\n        return rerenderState(initialState);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useDebugValue<T>(value: T, formatterFn: ?(value: T) => mixed): void {\n      currentHookNameInDev = 'useDebugValue';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateDebugValue(value, formatterFn);\n    },\n    useDeferredValue<T>(value: T): T {\n      currentHookNameInDev = 'useDeferredValue';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return rerenderDeferredValue(value);\n    },\n    useTransition(): [boolean, (() => void) => void] {\n      currentHookNameInDev = 'useTransition';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return rerenderTransition();\n    },\n    useMutableSource<Source, Snapshot>(\n      source: MutableSource<Source>,\n      getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,\n      subscribe: MutableSourceSubscribeFn<Source, Snapshot>,\n    ): Snapshot {\n      currentHookNameInDev = 'useMutableSource';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateMutableSource(source, getSnapshot, subscribe);\n    },\n    useSyncExternalStore<T>(\n      subscribe: (() => void) => () => void,\n      getSnapshot: () => T,\n      getServerSnapshot?: () => T,\n    ): T {\n      currentHookNameInDev = 'useSyncExternalStore';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n    },\n    useId(): string {\n      currentHookNameInDev = 'useId';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateId();\n    },\n\n    unstable_isNewReconciler: enableNewReconciler,\n  };\n  if (enableCache) {\n    (InvalidNestedHooksDispatcherOnRerenderInDEV: Dispatcher).getCacheSignal = getCacheSignal;\n    (InvalidNestedHooksDispatcherOnRerenderInDEV: Dispatcher).getCacheForType = getCacheForType;\n    (InvalidNestedHooksDispatcherOnRerenderInDEV: Dispatcher).useCacheRefresh = function useCacheRefresh() {\n      currentHookNameInDev = 'useCacheRefresh';\n      updateHookTypesDev();\n      return updateRefresh();\n    };\n  }\n}\n"]},"metadata":{},"sourceType":"module"}