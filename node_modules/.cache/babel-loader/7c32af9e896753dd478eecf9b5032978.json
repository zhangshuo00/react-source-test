{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { enableCreateEventHandleAPI, enableProfilerTimer, enableProfilerCommitHooks, enableProfilerNestedUpdatePhase, enableSchedulingProfiler, enableSuspenseServerRenderer, enableSuspenseCallback, enableScopeAPI, enableStrictEffects, deletedTreeCleanUpLevel, enableSuspenseLayoutEffectSemantics, enableUpdaterTracking, warnAboutCallbackRefReturningFunction, enableCache } from 'shared/ReactFeatureFlags';\nimport { FunctionComponent, ForwardRef, ClassComponent, HostRoot, HostComponent, HostText, HostPortal, Profiler, SuspenseComponent, DehydratedFragment, IncompleteClassComponent, MemoComponent, SimpleMemoComponent, SuspenseListComponent, ScopeComponent, OffscreenComponent, LegacyHiddenComponent, CacheComponent } from './ReactWorkTags';\nimport { detachDeletedInstance } from './ReactFiberHostConfig';\nimport { NoFlags, ContentReset, Placement, PlacementAndUpdate, ChildDeletion, Snapshot, Update, Ref, Hydrating, HydratingAndUpdate, Passive, BeforeMutationMask, MutationMask, LayoutMask, PassiveMask, Visibility } from './ReactFiberFlags';\nimport getComponentNameFromFiber from 'react-reconciler/src/getComponentNameFromFiber';\nimport { resetCurrentFiber as resetCurrentDebugFiberInDEV, setCurrentFiber as setCurrentDebugFiberInDEV } from './ReactCurrentFiber';\nimport { isDevToolsPresent } from './ReactFiberDevToolsHook.new';\nimport { onCommitUnmount } from './ReactFiberDevToolsHook.new';\nimport { resolveDefaultProps } from './ReactFiberLazyComponent.new';\nimport { isCurrentUpdateNested, getCommitTime, recordLayoutEffectDuration, startLayoutEffectTimer, recordPassiveEffectDuration, startPassiveEffectTimer } from './ReactProfilerTimer.new';\nimport { ConcurrentMode, NoMode, ProfileMode } from './ReactTypeOfMode';\nimport { commitUpdateQueue } from './ReactUpdateQueue.new';\nimport { getPublicInstance, supportsMutation, supportsPersistence, supportsHydration, commitMount, commitUpdate, resetTextContent, commitTextUpdate, appendChild, appendChildToContainer, insertBefore, insertInContainerBefore, removeChild, removeChildFromContainer, clearSuspenseBoundary, clearSuspenseBoundaryFromContainer, replaceContainerChildren, createContainerChildSet, hideInstance, hideTextInstance, unhideInstance, unhideTextInstance, commitHydratedContainer, commitHydratedSuspenseInstance, clearContainer, prepareScopeUpdate, prepareForCommit, beforeActiveInstanceBlur } from './ReactFiberHostConfig';\nimport { captureCommitPhaseError, resolveRetryWakeable, markCommitTimeOfFallback, enqueuePendingPassiveProfilerEffect, restorePendingUpdaters } from './ReactFiberWorkLoop.new';\nimport { NoFlags as NoHookEffect, HasEffect as HookHasEffect, Layout as HookLayout, Insertion as HookInsertion, Passive as HookPassive } from './ReactHookEffectTags';\nimport { didWarnAboutReassigningProps } from './ReactFiberBeginWork.new';\nimport { doesFiberContain } from './ReactFiberTreeReflection';\nimport { invokeGuardedCallback, clearCaughtError } from 'shared/ReactErrorUtils';\nimport { markComponentPassiveEffectMountStarted, markComponentPassiveEffectMountStopped, markComponentPassiveEffectUnmountStarted, markComponentPassiveEffectUnmountStopped, markComponentLayoutEffectMountStarted, markComponentLayoutEffectMountStopped, markComponentLayoutEffectUnmountStarted, markComponentLayoutEffectUnmountStopped } from './SchedulingProfiler';\nimport { releaseCache, retainCache } from './ReactFiberCacheComponent.new';\nlet didWarnAboutUndefinedSnapshotBeforeUpdate = null;\n\nif (__DEV__) {\n  didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();\n} // Used during the commit phase to track the state of the Offscreen component stack.\n// Allows us to avoid traversing the return path to find the nearest Offscreen ancestor.\n// Only used when enableSuspenseLayoutEffectSemantics is enabled.\n\n\nlet offscreenSubtreeIsHidden = false;\nlet offscreenSubtreeWasHidden = false;\nconst PossiblyWeakSet = typeof WeakSet === 'function' ? WeakSet : Set;\nlet nextEffect = null; // Used for Profiling builds to track updaters.\n\nlet inProgressLanes = null;\nlet inProgressRoot = null;\n\nfunction reportUncaughtErrorInDEV(error) {\n  // Wrapping each small part of the commit phase into a guarded\n  // callback is a bit too slow (https://github.com/facebook/react/pull/21666).\n  // But we rely on it to surface errors to DEV tools like overlays\n  // (https://github.com/facebook/react/issues/21712).\n  // As a compromise, rethrow only caught errors in a guard.\n  if (__DEV__) {\n    invokeGuardedCallback(null, () => {\n      throw error;\n    });\n    clearCaughtError();\n  }\n}\n\nconst callComponentWillUnmountWithTimer = function (current, instance) {\n  instance.props = current.memoizedProps;\n  instance.state = current.memoizedState;\n\n  if (enableProfilerTimer && enableProfilerCommitHooks && current.mode & ProfileMode) {\n    try {\n      startLayoutEffectTimer();\n      instance.componentWillUnmount();\n    } finally {\n      recordLayoutEffectDuration(current);\n    }\n  } else {\n    instance.componentWillUnmount();\n  }\n}; // Capture errors so they don't interrupt mounting.\n\n\nfunction safelyCallCommitHookLayoutEffectListMount(current, nearestMountedAncestor) {\n  try {\n    commitHookEffectListMount(HookLayout, current);\n  } catch (error) {\n    reportUncaughtErrorInDEV(error);\n    captureCommitPhaseError(current, nearestMountedAncestor, error);\n  }\n} // Capture errors so they don't interrupt unmounting.\n\n\nfunction safelyCallComponentWillUnmount(current, nearestMountedAncestor, instance) {\n  try {\n    callComponentWillUnmountWithTimer(current, instance);\n  } catch (error) {\n    reportUncaughtErrorInDEV(error);\n    captureCommitPhaseError(current, nearestMountedAncestor, error);\n  }\n} // Capture errors so they don't interrupt mounting.\n\n\nfunction safelyCallComponentDidMount(current, nearestMountedAncestor, instance) {\n  try {\n    instance.componentDidMount();\n  } catch (error) {\n    reportUncaughtErrorInDEV(error);\n    captureCommitPhaseError(current, nearestMountedAncestor, error);\n  }\n} // Capture errors so they don't interrupt mounting.\n\n\nfunction safelyAttachRef(current, nearestMountedAncestor) {\n  try {\n    commitAttachRef(current);\n  } catch (error) {\n    reportUncaughtErrorInDEV(error);\n    captureCommitPhaseError(current, nearestMountedAncestor, error);\n  }\n}\n\nfunction safelyDetachRef(current, nearestMountedAncestor) {\n  const ref = current.ref;\n\n  if (ref !== null) {\n    if (typeof ref === 'function') {\n      let retVal;\n\n      try {\n        if (enableProfilerTimer && enableProfilerCommitHooks && current.mode & ProfileMode) {\n          try {\n            startLayoutEffectTimer();\n            retVal = ref(null);\n          } finally {\n            recordLayoutEffectDuration(current);\n          }\n        } else {\n          retVal = ref(null);\n        }\n      } catch (error) {\n        reportUncaughtErrorInDEV(error);\n        captureCommitPhaseError(current, nearestMountedAncestor, error);\n      }\n\n      if (__DEV__) {\n        if (warnAboutCallbackRefReturningFunction && typeof retVal === 'function') {\n          console.error('Unexpected return value from a callback ref in %s. ' + 'A callback ref should not return a function.', getComponentNameFromFiber(current));\n        }\n      }\n    } else {\n      ref.current = null;\n    }\n  }\n}\n\nfunction safelyCallDestroy(current, nearestMountedAncestor, destroy) {\n  try {\n    destroy();\n  } catch (error) {\n    reportUncaughtErrorInDEV(error);\n    captureCommitPhaseError(current, nearestMountedAncestor, error);\n  }\n}\n\nlet focusedInstanceHandle = null;\nlet shouldFireAfterActiveInstanceBlur = false;\nexport function commitBeforeMutationEffects(root, firstChild) {\n  focusedInstanceHandle = prepareForCommit(root.containerInfo);\n  nextEffect = firstChild;\n  commitBeforeMutationEffects_begin(); // We no longer need to track the active instance fiber\n\n  const shouldFire = shouldFireAfterActiveInstanceBlur;\n  shouldFireAfterActiveInstanceBlur = false;\n  focusedInstanceHandle = null;\n  return shouldFire;\n}\n\nfunction commitBeforeMutationEffects_begin() {\n  while (nextEffect !== null) {\n    const fiber = nextEffect; // This phase is only used for beforeActiveInstanceBlur.\n    // Let's skip the whole loop if it's off.\n\n    if (enableCreateEventHandleAPI) {\n      // TODO: Should wrap this in flags check, too, as optimization\n      const deletions = fiber.deletions;\n\n      if (deletions !== null) {\n        for (let i = 0; i < deletions.length; i++) {\n          const deletion = deletions[i];\n          commitBeforeMutationEffectsDeletion(deletion);\n        }\n      }\n    }\n\n    const child = fiber.child;\n\n    if ((fiber.subtreeFlags & BeforeMutationMask) !== NoFlags && child !== null) {\n      ensureCorrectReturnPointer(child, fiber);\n      nextEffect = child;\n    } else {\n      commitBeforeMutationEffects_complete();\n    }\n  }\n}\n\nfunction commitBeforeMutationEffects_complete() {\n  while (nextEffect !== null) {\n    const fiber = nextEffect;\n    setCurrentDebugFiberInDEV(fiber);\n\n    try {\n      commitBeforeMutationEffectsOnFiber(fiber);\n    } catch (error) {\n      reportUncaughtErrorInDEV(error);\n      captureCommitPhaseError(fiber, fiber.return, error);\n    }\n\n    resetCurrentDebugFiberInDEV();\n    const sibling = fiber.sibling;\n\n    if (sibling !== null) {\n      ensureCorrectReturnPointer(sibling, fiber.return);\n      nextEffect = sibling;\n      return;\n    }\n\n    nextEffect = fiber.return;\n  }\n}\n\nfunction commitBeforeMutationEffectsOnFiber(finishedWork) {\n  const current = finishedWork.alternate;\n  const flags = finishedWork.flags;\n\n  if (enableCreateEventHandleAPI) {\n    if (!shouldFireAfterActiveInstanceBlur && focusedInstanceHandle !== null) {\n      // Check to see if the focused element was inside of a hidden (Suspense) subtree.\n      // TODO: Move this out of the hot path using a dedicated effect tag.\n      if (finishedWork.tag === SuspenseComponent && isSuspenseBoundaryBeingHidden(current, finishedWork) && doesFiberContain(finishedWork, focusedInstanceHandle)) {\n        shouldFireAfterActiveInstanceBlur = true;\n        beforeActiveInstanceBlur(finishedWork);\n      }\n    }\n  }\n\n  if ((flags & Snapshot) !== NoFlags) {\n    setCurrentDebugFiberInDEV(finishedWork);\n\n    switch (finishedWork.tag) {\n      case FunctionComponent:\n      case ForwardRef:\n      case SimpleMemoComponent:\n        {\n          break;\n        }\n\n      case ClassComponent:\n        {\n          if (current !== null) {\n            const prevProps = current.memoizedProps;\n            const prevState = current.memoizedState;\n            const instance = finishedWork.stateNode; // We could update instance props and state here,\n            // but instead we rely on them being set during last render.\n            // TODO: revisit this when we implement resuming.\n\n            if (__DEV__) {\n              if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {\n                if (instance.props !== finishedWork.memoizedProps) {\n                  console.error('Expected %s props to match memoized props before ' + 'getSnapshotBeforeUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                }\n\n                if (instance.state !== finishedWork.memoizedState) {\n                  console.error('Expected %s state to match memoized state before ' + 'getSnapshotBeforeUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.state`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                }\n              }\n            }\n\n            const snapshot = instance.getSnapshotBeforeUpdate(finishedWork.elementType === finishedWork.type ? prevProps : resolveDefaultProps(finishedWork.type, prevProps), prevState);\n\n            if (__DEV__) {\n              const didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;\n\n              if (snapshot === undefined && !didWarnSet.has(finishedWork.type)) {\n                didWarnSet.add(finishedWork.type);\n                console.error('%s.getSnapshotBeforeUpdate(): A snapshot value (or null) ' + 'must be returned. You have returned undefined.', getComponentNameFromFiber(finishedWork));\n              }\n            }\n\n            instance.__reactInternalSnapshotBeforeUpdate = snapshot;\n          }\n\n          break;\n        }\n\n      case HostRoot:\n        {\n          if (supportsMutation) {\n            const root = finishedWork.stateNode;\n            clearContainer(root.containerInfo);\n          }\n\n          break;\n        }\n\n      case HostComponent:\n      case HostText:\n      case HostPortal:\n      case IncompleteClassComponent:\n        // Nothing to do for these component types\n        break;\n\n      default:\n        {\n          throw new Error('This unit of work tag should not have side-effects. This error is ' + 'likely caused by a bug in React. Please file an issue.');\n        }\n    }\n\n    resetCurrentDebugFiberInDEV();\n  }\n}\n\nfunction commitBeforeMutationEffectsDeletion(deletion) {\n  if (enableCreateEventHandleAPI) {\n    // TODO (effects) It would be nice to avoid calling doesFiberContain()\n    // Maybe we can repurpose one of the subtreeFlags positions for this instead?\n    // Use it to store which part of the tree the focused instance is in?\n    // This assumes we can safely determine that instance during the \"render\" phase.\n    if (doesFiberContain(deletion, focusedInstanceHandle)) {\n      shouldFireAfterActiveInstanceBlur = true;\n      beforeActiveInstanceBlur(deletion);\n    }\n  }\n}\n\nfunction commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {\n  const updateQueue = finishedWork.updateQueue;\n  const lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;\n\n  if (lastEffect !== null) {\n    const firstEffect = lastEffect.next;\n    let effect = firstEffect;\n\n    do {\n      if ((effect.tag & flags) === flags) {\n        // Unmount\n        const destroy = effect.destroy;\n        effect.destroy = undefined;\n\n        if (destroy !== undefined) {\n          if (enableSchedulingProfiler) {\n            if ((flags & HookPassive) !== NoHookEffect) {\n              markComponentPassiveEffectUnmountStarted(finishedWork);\n            } else if ((flags & HookLayout) !== NoHookEffect) {\n              markComponentLayoutEffectUnmountStarted(finishedWork);\n            }\n          }\n\n          safelyCallDestroy(finishedWork, nearestMountedAncestor, destroy);\n\n          if (enableSchedulingProfiler) {\n            if ((flags & HookPassive) !== NoHookEffect) {\n              markComponentPassiveEffectUnmountStopped();\n            } else if ((flags & HookLayout) !== NoHookEffect) {\n              markComponentLayoutEffectUnmountStopped();\n            }\n          }\n        }\n      }\n\n      effect = effect.next;\n    } while (effect !== firstEffect);\n  }\n}\n\nfunction commitHookEffectListMount(flags, finishedWork) {\n  const updateQueue = finishedWork.updateQueue;\n  const lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;\n\n  if (lastEffect !== null) {\n    const firstEffect = lastEffect.next;\n    let effect = firstEffect;\n\n    do {\n      if ((effect.tag & flags) === flags) {\n        if (enableSchedulingProfiler) {\n          if ((flags & HookPassive) !== NoHookEffect) {\n            markComponentPassiveEffectMountStarted(finishedWork);\n          } else if ((flags & HookLayout) !== NoHookEffect) {\n            markComponentLayoutEffectMountStarted(finishedWork);\n          }\n        } // Mount\n\n\n        const create = effect.create;\n        effect.destroy = create();\n\n        if (enableSchedulingProfiler) {\n          if ((flags & HookPassive) !== NoHookEffect) {\n            markComponentPassiveEffectMountStopped();\n          } else if ((flags & HookLayout) !== NoHookEffect) {\n            markComponentLayoutEffectMountStopped();\n          }\n        }\n\n        if (__DEV__) {\n          const destroy = effect.destroy;\n\n          if (destroy !== undefined && typeof destroy !== 'function') {\n            let hookName;\n\n            if ((effect.tag & HookLayout) !== NoFlags) {\n              hookName = 'useLayoutEffect';\n            } else if ((effect.tag & HookInsertion) !== NoFlags) {\n              hookName = 'useInsertionEffect';\n            } else {\n              hookName = 'useEffect';\n            }\n\n            let addendum;\n\n            if (destroy === null) {\n              addendum = ' You returned null. If your effect does not require clean ' + 'up, return undefined (or nothing).';\n            } else if (typeof destroy.then === 'function') {\n              addendum = '\\n\\nIt looks like you wrote ' + hookName + '(async () => ...) or returned a Promise. ' + 'Instead, write the async function inside your effect ' + 'and call it immediately:\\n\\n' + hookName + '(() => {\\n' + '  async function fetchData() {\\n' + '    // You can await here\\n' + '    const response = await MyAPI.getData(someId);\\n' + '    // ...\\n' + '  }\\n' + '  fetchData();\\n' + `}, [someId]); // Or [] if effect doesn't need props or state\\n\\n` + 'Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching';\n            } else {\n              addendum = ' You returned: ' + destroy;\n            }\n\n            console.error('%s must not return anything besides a function, ' + 'which is used for clean-up.%s', hookName, addendum);\n          }\n        }\n      }\n\n      effect = effect.next;\n    } while (effect !== firstEffect);\n  }\n}\n\nexport function commitPassiveEffectDurations(finishedRoot, finishedWork) {\n  if (enableProfilerTimer && enableProfilerCommitHooks) {\n    // Only Profilers with work in their subtree will have an Update effect scheduled.\n    if ((finishedWork.flags & Update) !== NoFlags) {\n      switch (finishedWork.tag) {\n        case Profiler:\n          {\n            const {\n              passiveEffectDuration\n            } = finishedWork.stateNode;\n            const {\n              id,\n              onPostCommit\n            } = finishedWork.memoizedProps; // This value will still reflect the previous commit phase.\n            // It does not get reset until the start of the next commit phase.\n\n            const commitTime = getCommitTime();\n            let phase = finishedWork.alternate === null ? 'mount' : 'update';\n\n            if (enableProfilerNestedUpdatePhase) {\n              if (isCurrentUpdateNested()) {\n                phase = 'nested-update';\n              }\n            }\n\n            if (typeof onPostCommit === 'function') {\n              onPostCommit(id, phase, passiveEffectDuration, commitTime);\n            } // Bubble times to the next nearest ancestor Profiler.\n            // After we process that Profiler, we'll bubble further up.\n\n\n            let parentFiber = finishedWork.return;\n\n            outer: while (parentFiber !== null) {\n              switch (parentFiber.tag) {\n                case HostRoot:\n                  const root = parentFiber.stateNode;\n                  root.passiveEffectDuration += passiveEffectDuration;\n                  break outer;\n\n                case Profiler:\n                  const parentStateNode = parentFiber.stateNode;\n                  parentStateNode.passiveEffectDuration += passiveEffectDuration;\n                  break outer;\n              }\n\n              parentFiber = parentFiber.return;\n            }\n\n            break;\n          }\n\n        default:\n          break;\n      }\n    }\n  }\n}\n\nfunction commitLayoutEffectOnFiber(finishedRoot, current, finishedWork, committedLanes) {\n  if ((finishedWork.flags & LayoutMask) !== NoFlags) {\n    switch (finishedWork.tag) {\n      case FunctionComponent:\n      case ForwardRef:\n      case SimpleMemoComponent:\n        {\n          if (!enableSuspenseLayoutEffectSemantics || !offscreenSubtreeWasHidden) {\n            // At this point layout effects have already been destroyed (during mutation phase).\n            // This is done to prevent sibling component effects from interfering with each other,\n            // e.g. a destroy function in one component should never override a ref set\n            // by a create function in another component during the same commit.\n            if (enableProfilerTimer && enableProfilerCommitHooks && finishedWork.mode & ProfileMode) {\n              try {\n                startLayoutEffectTimer();\n                commitHookEffectListMount(HookLayout | HookHasEffect, finishedWork);\n              } finally {\n                recordLayoutEffectDuration(finishedWork);\n              }\n            } else {\n              commitHookEffectListMount(HookLayout | HookHasEffect, finishedWork);\n            }\n          }\n\n          break;\n        }\n\n      case ClassComponent:\n        {\n          const instance = finishedWork.stateNode;\n\n          if (finishedWork.flags & Update) {\n            if (!offscreenSubtreeWasHidden) {\n              if (current === null) {\n                // We could update instance props and state here,\n                // but instead we rely on them being set during last render.\n                // TODO: revisit this when we implement resuming.\n                if (__DEV__) {\n                  if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {\n                    if (instance.props !== finishedWork.memoizedProps) {\n                      console.error('Expected %s props to match memoized props before ' + 'componentDidMount. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                    }\n\n                    if (instance.state !== finishedWork.memoizedState) {\n                      console.error('Expected %s state to match memoized state before ' + 'componentDidMount. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.state`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                    }\n                  }\n                }\n\n                if (enableProfilerTimer && enableProfilerCommitHooks && finishedWork.mode & ProfileMode) {\n                  try {\n                    startLayoutEffectTimer();\n                    instance.componentDidMount();\n                  } finally {\n                    recordLayoutEffectDuration(finishedWork);\n                  }\n                } else {\n                  instance.componentDidMount();\n                }\n              } else {\n                const prevProps = finishedWork.elementType === finishedWork.type ? current.memoizedProps : resolveDefaultProps(finishedWork.type, current.memoizedProps);\n                const prevState = current.memoizedState; // We could update instance props and state here,\n                // but instead we rely on them being set during last render.\n                // TODO: revisit this when we implement resuming.\n\n                if (__DEV__) {\n                  if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {\n                    if (instance.props !== finishedWork.memoizedProps) {\n                      console.error('Expected %s props to match memoized props before ' + 'componentDidUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                    }\n\n                    if (instance.state !== finishedWork.memoizedState) {\n                      console.error('Expected %s state to match memoized state before ' + 'componentDidUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.state`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                    }\n                  }\n                }\n\n                if (enableProfilerTimer && enableProfilerCommitHooks && finishedWork.mode & ProfileMode) {\n                  try {\n                    startLayoutEffectTimer();\n                    instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);\n                  } finally {\n                    recordLayoutEffectDuration(finishedWork);\n                  }\n                } else {\n                  instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);\n                }\n              }\n            }\n          } // TODO: I think this is now always non-null by the time it reaches the\n          // commit phase. Consider removing the type check.\n\n\n          const updateQueue = finishedWork.updateQueue;\n\n          if (updateQueue !== null) {\n            if (__DEV__) {\n              if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {\n                if (instance.props !== finishedWork.memoizedProps) {\n                  console.error('Expected %s props to match memoized props before ' + 'processing the update queue. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                }\n\n                if (instance.state !== finishedWork.memoizedState) {\n                  console.error('Expected %s state to match memoized state before ' + 'processing the update queue. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.state`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                }\n              }\n            } // We could update instance props and state here,\n            // but instead we rely on them being set during last render.\n            // TODO: revisit this when we implement resuming.\n\n\n            commitUpdateQueue(finishedWork, updateQueue, instance);\n          }\n\n          break;\n        }\n\n      case HostRoot:\n        {\n          // TODO: I think this is now always non-null by the time it reaches the\n          // commit phase. Consider removing the type check.\n          const updateQueue = finishedWork.updateQueue;\n\n          if (updateQueue !== null) {\n            let instance = null;\n\n            if (finishedWork.child !== null) {\n              switch (finishedWork.child.tag) {\n                case HostComponent:\n                  instance = getPublicInstance(finishedWork.child.stateNode);\n                  break;\n\n                case ClassComponent:\n                  instance = finishedWork.child.stateNode;\n                  break;\n              }\n            }\n\n            commitUpdateQueue(finishedWork, updateQueue, instance);\n          }\n\n          break;\n        }\n\n      case HostComponent:\n        {\n          const instance = finishedWork.stateNode; // Renderers may schedule work to be done after host components are mounted\n          // (eg DOM renderer may schedule auto-focus for inputs and form controls).\n          // These effects should only be committed when components are first mounted,\n          // aka when there is no current/alternate.\n\n          if (current === null && finishedWork.flags & Update) {\n            const type = finishedWork.type;\n            const props = finishedWork.memoizedProps;\n            commitMount(instance, type, props, finishedWork);\n          }\n\n          break;\n        }\n\n      case HostText:\n        {\n          // We have no life-cycles associated with text.\n          break;\n        }\n\n      case HostPortal:\n        {\n          // We have no life-cycles associated with portals.\n          break;\n        }\n\n      case Profiler:\n        {\n          if (enableProfilerTimer) {\n            const {\n              onCommit,\n              onRender\n            } = finishedWork.memoizedProps;\n            const {\n              effectDuration\n            } = finishedWork.stateNode;\n            const commitTime = getCommitTime();\n            let phase = current === null ? 'mount' : 'update';\n\n            if (enableProfilerNestedUpdatePhase) {\n              if (isCurrentUpdateNested()) {\n                phase = 'nested-update';\n              }\n            }\n\n            if (typeof onRender === 'function') {\n              onRender(finishedWork.memoizedProps.id, phase, finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, commitTime);\n            }\n\n            if (enableProfilerCommitHooks) {\n              if (typeof onCommit === 'function') {\n                onCommit(finishedWork.memoizedProps.id, phase, effectDuration, commitTime);\n              } // Schedule a passive effect for this Profiler to call onPostCommit hooks.\n              // This effect should be scheduled even if there is no onPostCommit callback for this Profiler,\n              // because the effect is also where times bubble to parent Profilers.\n\n\n              enqueuePendingPassiveProfilerEffect(finishedWork); // Propagate layout effect durations to the next nearest Profiler ancestor.\n              // Do not reset these values until the next render so DevTools has a chance to read them first.\n\n              let parentFiber = finishedWork.return;\n\n              outer: while (parentFiber !== null) {\n                switch (parentFiber.tag) {\n                  case HostRoot:\n                    const root = parentFiber.stateNode;\n                    root.effectDuration += effectDuration;\n                    break outer;\n\n                  case Profiler:\n                    const parentStateNode = parentFiber.stateNode;\n                    parentStateNode.effectDuration += effectDuration;\n                    break outer;\n                }\n\n                parentFiber = parentFiber.return;\n              }\n            }\n          }\n\n          break;\n        }\n\n      case SuspenseComponent:\n        {\n          commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);\n          break;\n        }\n\n      case SuspenseListComponent:\n      case IncompleteClassComponent:\n      case ScopeComponent:\n      case OffscreenComponent:\n      case LegacyHiddenComponent:\n        break;\n\n      default:\n        throw new Error('This unit of work tag should not have side-effects. This error is ' + 'likely caused by a bug in React. Please file an issue.');\n    }\n  }\n\n  if (!enableSuspenseLayoutEffectSemantics || !offscreenSubtreeWasHidden) {\n    if (enableScopeAPI) {\n      // TODO: This is a temporary solution that allowed us to transition away\n      // from React Flare on www.\n      if (finishedWork.flags & Ref && finishedWork.tag !== ScopeComponent) {\n        commitAttachRef(finishedWork);\n      }\n    } else {\n      if (finishedWork.flags & Ref) {\n        commitAttachRef(finishedWork);\n      }\n    }\n  }\n}\n\nfunction reappearLayoutEffectsOnFiber(node) {\n  // Turn on layout effects in a tree that previously disappeared.\n  // TODO (Offscreen) Check: flags & LayoutStatic\n  switch (node.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case SimpleMemoComponent:\n      {\n        if (enableProfilerTimer && enableProfilerCommitHooks && node.mode & ProfileMode) {\n          try {\n            startLayoutEffectTimer();\n            safelyCallCommitHookLayoutEffectListMount(node, node.return);\n          } finally {\n            recordLayoutEffectDuration(node);\n          }\n        } else {\n          safelyCallCommitHookLayoutEffectListMount(node, node.return);\n        }\n\n        break;\n      }\n\n    case ClassComponent:\n      {\n        const instance = node.stateNode;\n\n        if (typeof instance.componentDidMount === 'function') {\n          safelyCallComponentDidMount(node, node.return, instance);\n        }\n\n        safelyAttachRef(node, node.return);\n        break;\n      }\n\n    case HostComponent:\n      {\n        safelyAttachRef(node, node.return);\n        break;\n      }\n  }\n}\n\nfunction hideOrUnhideAllChildren(finishedWork, isHidden) {\n  // Only hide or unhide the top-most host nodes.\n  let hostSubtreeRoot = null;\n\n  if (supportsMutation) {\n    // We only have the top Fiber that was inserted but we need to recurse down its\n    // children to find all the terminal nodes.\n    let node = finishedWork;\n\n    while (true) {\n      if (node.tag === HostComponent) {\n        if (hostSubtreeRoot === null) {\n          hostSubtreeRoot = node;\n          const instance = node.stateNode;\n\n          if (isHidden) {\n            hideInstance(instance);\n          } else {\n            unhideInstance(node.stateNode, node.memoizedProps);\n          }\n        }\n      } else if (node.tag === HostText) {\n        if (hostSubtreeRoot === null) {\n          const instance = node.stateNode;\n\n          if (isHidden) {\n            hideTextInstance(instance);\n          } else {\n            unhideTextInstance(instance, node.memoizedProps);\n          }\n        }\n      } else if ((node.tag === OffscreenComponent || node.tag === LegacyHiddenComponent) && node.memoizedState !== null && node !== finishedWork) {// Found a nested Offscreen component that is hidden.\n        // Don't search any deeper. This tree should remain hidden.\n      } else if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n\n      if (node === finishedWork) {\n        return;\n      }\n\n      while (node.sibling === null) {\n        if (node.return === null || node.return === finishedWork) {\n          return;\n        }\n\n        if (hostSubtreeRoot === node) {\n          hostSubtreeRoot = null;\n        }\n\n        node = node.return;\n      }\n\n      if (hostSubtreeRoot === node) {\n        hostSubtreeRoot = null;\n      }\n\n      node.sibling.return = node.return;\n      node = node.sibling;\n    }\n  }\n}\n\nfunction commitAttachRef(finishedWork) {\n  const ref = finishedWork.ref;\n\n  if (ref !== null) {\n    const instance = finishedWork.stateNode;\n    let instanceToUse;\n\n    switch (finishedWork.tag) {\n      case HostComponent:\n        instanceToUse = getPublicInstance(instance);\n        break;\n\n      default:\n        instanceToUse = instance;\n    } // Moved outside to ensure DCE works with this flag\n\n\n    if (enableScopeAPI && finishedWork.tag === ScopeComponent) {\n      instanceToUse = instance;\n    }\n\n    if (typeof ref === 'function') {\n      let retVal;\n\n      if (enableProfilerTimer && enableProfilerCommitHooks && finishedWork.mode & ProfileMode) {\n        try {\n          startLayoutEffectTimer();\n          retVal = ref(instanceToUse);\n        } finally {\n          recordLayoutEffectDuration(finishedWork);\n        }\n      } else {\n        retVal = ref(instanceToUse);\n      }\n\n      if (__DEV__) {\n        if (warnAboutCallbackRefReturningFunction && typeof retVal === 'function') {\n          console.error('Unexpected return value from a callback ref in %s. ' + 'A callback ref should not return a function.', getComponentNameFromFiber(finishedWork));\n        }\n      }\n    } else {\n      if (__DEV__) {\n        if (!ref.hasOwnProperty('current')) {\n          console.error('Unexpected ref object provided for %s. ' + 'Use either a ref-setter function or React.createRef().', getComponentNameFromFiber(finishedWork));\n        }\n      }\n\n      ref.current = instanceToUse;\n    }\n  }\n}\n\nfunction commitDetachRef(current) {\n  const currentRef = current.ref;\n\n  if (currentRef !== null) {\n    if (typeof currentRef === 'function') {\n      if (enableProfilerTimer && enableProfilerCommitHooks && current.mode & ProfileMode) {\n        try {\n          startLayoutEffectTimer();\n          currentRef(null);\n        } finally {\n          recordLayoutEffectDuration(current);\n        }\n      } else {\n        currentRef(null);\n      }\n    } else {\n      currentRef.current = null;\n    }\n  }\n} // User-originating errors (lifecycles and refs) should not interrupt\n// deletion, so don't let them throw. Host-originating errors should\n// interrupt deletion, so it's okay\n\n\nfunction commitUnmount(finishedRoot, current, nearestMountedAncestor) {\n  onCommitUnmount(current);\n\n  switch (current.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case MemoComponent:\n    case SimpleMemoComponent:\n      {\n        const updateQueue = current.updateQueue;\n\n        if (updateQueue !== null) {\n          const lastEffect = updateQueue.lastEffect;\n\n          if (lastEffect !== null) {\n            const firstEffect = lastEffect.next;\n            let effect = firstEffect;\n\n            do {\n              const {\n                destroy,\n                tag\n              } = effect;\n\n              if (destroy !== undefined) {\n                if ((tag & HookInsertion) !== NoHookEffect) {\n                  safelyCallDestroy(current, nearestMountedAncestor, destroy);\n                } else if ((tag & HookLayout) !== NoHookEffect) {\n                  if (enableSchedulingProfiler) {\n                    markComponentLayoutEffectUnmountStarted(current);\n                  }\n\n                  if (enableProfilerTimer && enableProfilerCommitHooks && current.mode & ProfileMode) {\n                    startLayoutEffectTimer();\n                    safelyCallDestroy(current, nearestMountedAncestor, destroy);\n                    recordLayoutEffectDuration(current);\n                  } else {\n                    safelyCallDestroy(current, nearestMountedAncestor, destroy);\n                  }\n\n                  if (enableSchedulingProfiler) {\n                    markComponentLayoutEffectUnmountStopped();\n                  }\n                }\n              }\n\n              effect = effect.next;\n            } while (effect !== firstEffect);\n          }\n        }\n\n        return;\n      }\n\n    case ClassComponent:\n      {\n        safelyDetachRef(current, nearestMountedAncestor);\n        const instance = current.stateNode;\n\n        if (typeof instance.componentWillUnmount === 'function') {\n          safelyCallComponentWillUnmount(current, nearestMountedAncestor, instance);\n        }\n\n        return;\n      }\n\n    case HostComponent:\n      {\n        safelyDetachRef(current, nearestMountedAncestor);\n        return;\n      }\n\n    case HostPortal:\n      {\n        // TODO: this is recursive.\n        // We are also not using this parent because\n        // the portal will get pushed immediately.\n        if (supportsMutation) {\n          unmountHostComponents(finishedRoot, current, nearestMountedAncestor);\n        } else if (supportsPersistence) {\n          emptyPortalContainer(current);\n        }\n\n        return;\n      }\n\n    case DehydratedFragment:\n      {\n        if (enableSuspenseCallback) {\n          const hydrationCallbacks = finishedRoot.hydrationCallbacks;\n\n          if (hydrationCallbacks !== null) {\n            const onDeleted = hydrationCallbacks.onDeleted;\n\n            if (onDeleted) {\n              onDeleted(current.stateNode);\n            }\n          }\n        }\n\n        return;\n      }\n\n    case ScopeComponent:\n      {\n        if (enableScopeAPI) {\n          safelyDetachRef(current, nearestMountedAncestor);\n        }\n\n        return;\n      }\n  }\n}\n\nfunction commitNestedUnmounts(finishedRoot, root, nearestMountedAncestor) {\n  // While we're inside a removed host node we don't want to call\n  // removeChild on the inner nodes because they're removed by the top\n  // call anyway. We also want to call componentWillUnmount on all\n  // composites before this host node is removed from the tree. Therefore\n  // we do an inner loop while we're still inside the host node.\n  let node = root;\n\n  while (true) {\n    commitUnmount(finishedRoot, node, nearestMountedAncestor); // Visit children because they may contain more composite or host nodes.\n    // Skip portals because commitUnmount() currently visits them recursively.\n\n    if (node.child !== null && ( // If we use mutation we drill down into portals using commitUnmount above.\n    // If we don't use mutation we drill down into portals here instead.\n    !supportsMutation || node.tag !== HostPortal)) {\n      node.child.return = node;\n      node = node.child;\n      continue;\n    }\n\n    if (node === root) {\n      return;\n    }\n\n    while (node.sibling === null) {\n      if (node.return === null || node.return === root) {\n        return;\n      }\n\n      node = node.return;\n    }\n\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n}\n\nfunction detachFiberMutation(fiber) {\n  // Cut off the return pointer to disconnect it from the tree.\n  // This enables us to detect and warn against state updates on an unmounted component.\n  // It also prevents events from bubbling from within disconnected components.\n  //\n  // Ideally, we should also clear the child pointer of the parent alternate to let this\n  // get GC:ed but we don't know which for sure which parent is the current\n  // one so we'll settle for GC:ing the subtree of this child.\n  // This child itself will be GC:ed when the parent updates the next time.\n  //\n  // Note that we can't clear child or sibling pointers yet.\n  // They're needed for passive effects and for findDOMNode.\n  // We defer those fields, and all other cleanup, to the passive phase (see detachFiberAfterEffects).\n  //\n  // Don't reset the alternate yet, either. We need that so we can detach the\n  // alternate's fields in the passive phase. Clearing the return pointer is\n  // sufficient for findDOMNode semantics.\n  const alternate = fiber.alternate;\n\n  if (alternate !== null) {\n    alternate.return = null;\n  }\n\n  fiber.return = null;\n}\n\nfunction detachFiberAfterEffects(fiber) {\n  const alternate = fiber.alternate;\n\n  if (alternate !== null) {\n    fiber.alternate = null;\n    detachFiberAfterEffects(alternate);\n  } // Note: Defensively using negation instead of < in case\n  // `deletedTreeCleanUpLevel` is undefined.\n\n\n  if (!(deletedTreeCleanUpLevel >= 2)) {\n    // This is the default branch (level 0).\n    fiber.child = null;\n    fiber.deletions = null;\n    fiber.dependencies = null;\n    fiber.memoizedProps = null;\n    fiber.memoizedState = null;\n    fiber.pendingProps = null;\n    fiber.sibling = null;\n    fiber.stateNode = null;\n    fiber.updateQueue = null;\n\n    if (__DEV__) {\n      fiber._debugOwner = null;\n    }\n  } else {\n    // Clear cyclical Fiber fields. This level alone is designed to roughly\n    // approximate the planned Fiber refactor. In that world, `setState` will be\n    // bound to a special \"instance\" object instead of a Fiber. The Instance\n    // object will not have any of these fields. It will only be connected to\n    // the fiber tree via a single link at the root. So if this level alone is\n    // sufficient to fix memory issues, that bodes well for our plans.\n    fiber.child = null;\n    fiber.deletions = null;\n    fiber.sibling = null; // The `stateNode` is cyclical because on host nodes it points to the host\n    // tree, which has its own pointers to children, parents, and siblings.\n    // The other host nodes also point back to fibers, so we should detach that\n    // one, too.\n\n    if (fiber.tag === HostComponent) {\n      const hostInstance = fiber.stateNode;\n\n      if (hostInstance !== null) {\n        detachDeletedInstance(hostInstance);\n      }\n    }\n\n    fiber.stateNode = null; // I'm intentionally not clearing the `return` field in this level. We\n    // already disconnect the `return` pointer at the root of the deleted\n    // subtree (in `detachFiberMutation`). Besides, `return` by itself is not\n    // cyclical — it's only cyclical when combined with `child`, `sibling`, and\n    // `alternate`. But we'll clear it in the next level anyway, just in case.\n\n    if (__DEV__) {\n      fiber._debugOwner = null;\n    }\n\n    if (deletedTreeCleanUpLevel >= 3) {\n      // Theoretically, nothing in here should be necessary, because we already\n      // disconnected the fiber from the tree. So even if something leaks this\n      // particular fiber, it won't leak anything else\n      //\n      // The purpose of this branch is to be super aggressive so we can measure\n      // if there's any difference in memory impact. If there is, that could\n      // indicate a React leak we don't know about.\n      fiber.return = null;\n      fiber.dependencies = null;\n      fiber.memoizedProps = null;\n      fiber.memoizedState = null;\n      fiber.pendingProps = null;\n      fiber.stateNode = null; // TODO: Move to `commitPassiveUnmountInsideDeletedTreeOnFiber` instead.\n\n      fiber.updateQueue = null;\n    }\n  }\n}\n\nfunction emptyPortalContainer(current) {\n  if (!supportsPersistence) {\n    return;\n  }\n\n  const portal = current.stateNode;\n  const {\n    containerInfo\n  } = portal;\n  const emptyChildSet = createContainerChildSet(containerInfo);\n  replaceContainerChildren(containerInfo, emptyChildSet);\n}\n\nfunction commitContainer(finishedWork) {\n  if (!supportsPersistence) {\n    return;\n  }\n\n  switch (finishedWork.tag) {\n    case ClassComponent:\n    case HostComponent:\n    case HostText:\n      {\n        return;\n      }\n\n    case HostRoot:\n    case HostPortal:\n      {\n        const portalOrRoot = finishedWork.stateNode;\n        const {\n          containerInfo,\n          pendingChildren\n        } = portalOrRoot;\n        replaceContainerChildren(containerInfo, pendingChildren);\n        return;\n      }\n  }\n\n  throw new Error('This unit of work tag should not have side-effects. This error is ' + 'likely caused by a bug in React. Please file an issue.');\n}\n\nfunction getHostParentFiber(fiber) {\n  let parent = fiber.return;\n\n  while (parent !== null) {\n    if (isHostParent(parent)) {\n      return parent;\n    }\n\n    parent = parent.return;\n  }\n\n  throw new Error('Expected to find a host parent. This error is likely caused by a bug ' + 'in React. Please file an issue.');\n}\n\nfunction isHostParent(fiber) {\n  return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;\n}\n\nfunction getHostSibling(fiber) {\n  // We're going to search forward into the tree until we find a sibling host\n  // node. Unfortunately, if multiple insertions are done in a row we have to\n  // search past them. This leads to exponential search for the next sibling.\n  // TODO: Find a more efficient way to do this.\n  let node = fiber;\n\n  siblings: while (true) {\n    // If we didn't find anything, let's try the next sibling.\n    while (node.sibling === null) {\n      if (node.return === null || isHostParent(node.return)) {\n        // If we pop out of the root or hit the parent the fiber we are the\n        // last sibling.\n        return null;\n      }\n\n      node = node.return;\n    }\n\n    node.sibling.return = node.return;\n    node = node.sibling;\n\n    while (node.tag !== HostComponent && node.tag !== HostText && node.tag !== DehydratedFragment) {\n      // If it is not host node and, we might have a host node inside it.\n      // Try to search down until we find one.\n      if (node.flags & Placement) {\n        // If we don't have a child, try the siblings instead.\n        continue siblings;\n      } // If we don't have a child, try the siblings instead.\n      // We also skip portals because they are not part of this host tree.\n\n\n      if (node.child === null || node.tag === HostPortal) {\n        continue siblings;\n      } else {\n        node.child.return = node;\n        node = node.child;\n      }\n    } // Check if this host node is stable or about to be placed.\n\n\n    if (!(node.flags & Placement)) {\n      // Found it!\n      return node.stateNode;\n    }\n  }\n}\n\nfunction commitPlacement(finishedWork) {\n  if (!supportsMutation) {\n    return;\n  } // Recursively insert all host nodes into the parent.\n\n\n  const parentFiber = getHostParentFiber(finishedWork); // Note: these two variables *must* always be updated together.\n\n  let parent;\n  let isContainer;\n  const parentStateNode = parentFiber.stateNode;\n\n  switch (parentFiber.tag) {\n    case HostComponent:\n      parent = parentStateNode;\n      isContainer = false;\n      break;\n\n    case HostRoot:\n      parent = parentStateNode.containerInfo;\n      isContainer = true;\n      break;\n\n    case HostPortal:\n      parent = parentStateNode.containerInfo;\n      isContainer = true;\n      break;\n    // eslint-disable-next-line-no-fallthrough\n\n    default:\n      throw new Error('Invalid host parent fiber. This error is likely caused by a bug ' + 'in React. Please file an issue.');\n  }\n\n  if (parentFiber.flags & ContentReset) {\n    // Reset the text content of the parent before doing any insertions\n    resetTextContent(parent); // Clear ContentReset from the effect tag\n\n    parentFiber.flags &= ~ContentReset;\n  }\n\n  const before = getHostSibling(finishedWork); // We only have the top Fiber that was inserted but we need to recurse down its\n  // children to find all the terminal nodes.\n\n  if (isContainer) {\n    insertOrAppendPlacementNodeIntoContainer(finishedWork, before, parent);\n  } else {\n    insertOrAppendPlacementNode(finishedWork, before, parent);\n  }\n}\n\nfunction insertOrAppendPlacementNodeIntoContainer(node, before, parent) {\n  const {\n    tag\n  } = node;\n  const isHost = tag === HostComponent || tag === HostText;\n\n  if (isHost) {\n    const stateNode = node.stateNode;\n\n    if (before) {\n      insertInContainerBefore(parent, stateNode, before);\n    } else {\n      appendChildToContainer(parent, stateNode);\n    }\n  } else if (tag === HostPortal) {// If the insertion itself is a portal, then we don't want to traverse\n    // down its children. Instead, we'll get insertions from each child in\n    // the portal directly.\n  } else {\n    const child = node.child;\n\n    if (child !== null) {\n      insertOrAppendPlacementNodeIntoContainer(child, before, parent);\n      let sibling = child.sibling;\n\n      while (sibling !== null) {\n        insertOrAppendPlacementNodeIntoContainer(sibling, before, parent);\n        sibling = sibling.sibling;\n      }\n    }\n  }\n}\n\nfunction insertOrAppendPlacementNode(node, before, parent) {\n  const {\n    tag\n  } = node;\n  const isHost = tag === HostComponent || tag === HostText;\n\n  if (isHost) {\n    const stateNode = node.stateNode;\n\n    if (before) {\n      insertBefore(parent, stateNode, before);\n    } else {\n      appendChild(parent, stateNode);\n    }\n  } else if (tag === HostPortal) {// If the insertion itself is a portal, then we don't want to traverse\n    // down its children. Instead, we'll get insertions from each child in\n    // the portal directly.\n  } else {\n    const child = node.child;\n\n    if (child !== null) {\n      insertOrAppendPlacementNode(child, before, parent);\n      let sibling = child.sibling;\n\n      while (sibling !== null) {\n        insertOrAppendPlacementNode(sibling, before, parent);\n        sibling = sibling.sibling;\n      }\n    }\n  }\n}\n\nfunction unmountHostComponents(finishedRoot, current, nearestMountedAncestor) {\n  // We only have the top Fiber that was deleted but we need to recurse down its\n  // children to find all the terminal nodes.\n  let node = current; // Each iteration, currentParent is populated with node's host parent if not\n  // currentParentIsValid.\n\n  let currentParentIsValid = false; // Note: these two variables *must* always be updated together.\n\n  let currentParent;\n  let currentParentIsContainer;\n\n  while (true) {\n    if (!currentParentIsValid) {\n      let parent = node.return;\n\n      findParent: while (true) {\n        if (parent === null) {\n          throw new Error('Expected to find a host parent. This error is likely caused by ' + 'a bug in React. Please file an issue.');\n        }\n\n        const parentStateNode = parent.stateNode;\n\n        switch (parent.tag) {\n          case HostComponent:\n            currentParent = parentStateNode;\n            currentParentIsContainer = false;\n            break findParent;\n\n          case HostRoot:\n            currentParent = parentStateNode.containerInfo;\n            currentParentIsContainer = true;\n            break findParent;\n\n          case HostPortal:\n            currentParent = parentStateNode.containerInfo;\n            currentParentIsContainer = true;\n            break findParent;\n        }\n\n        parent = parent.return;\n      }\n\n      currentParentIsValid = true;\n    }\n\n    if (node.tag === HostComponent || node.tag === HostText) {\n      commitNestedUnmounts(finishedRoot, node, nearestMountedAncestor); // After all the children have unmounted, it is now safe to remove the\n      // node from the tree.\n\n      if (currentParentIsContainer) {\n        removeChildFromContainer(currentParent, node.stateNode);\n      } else {\n        removeChild(currentParent, node.stateNode);\n      } // Don't visit children because we already visited them.\n\n    } else if (enableSuspenseServerRenderer && node.tag === DehydratedFragment) {\n      if (enableSuspenseCallback) {\n        const hydrationCallbacks = finishedRoot.hydrationCallbacks;\n\n        if (hydrationCallbacks !== null) {\n          const onDeleted = hydrationCallbacks.onDeleted;\n\n          if (onDeleted) {\n            onDeleted(node.stateNode);\n          }\n        }\n      } // Delete the dehydrated suspense boundary and all of its content.\n\n\n      if (currentParentIsContainer) {\n        clearSuspenseBoundaryFromContainer(currentParent, node.stateNode);\n      } else {\n        clearSuspenseBoundary(currentParent, node.stateNode);\n      }\n    } else if (node.tag === HostPortal) {\n      if (node.child !== null) {\n        // When we go into a portal, it becomes the parent to remove from.\n        // We will reassign it back when we pop the portal on the way up.\n        currentParent = node.stateNode.containerInfo;\n        currentParentIsContainer = true; // Visit children because portals might contain host components.\n\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n    } else {\n      commitUnmount(finishedRoot, node, nearestMountedAncestor); // Visit children because we may find more host components below.\n\n      if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n    }\n\n    if (node === current) {\n      return;\n    }\n\n    while (node.sibling === null) {\n      if (node.return === null || node.return === current) {\n        return;\n      }\n\n      node = node.return;\n\n      if (node.tag === HostPortal) {\n        // When we go out of the portal, we need to restore the parent.\n        // Since we don't keep a stack of them, we will search for it.\n        currentParentIsValid = false;\n      }\n    }\n\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n}\n\nfunction commitDeletion(finishedRoot, current, nearestMountedAncestor) {\n  if (supportsMutation) {\n    // Recursively delete all host nodes from the parent.\n    // Detach refs and call componentWillUnmount() on the whole subtree.\n    unmountHostComponents(finishedRoot, current, nearestMountedAncestor);\n  } else {\n    // Detach refs and call componentWillUnmount() on the whole subtree.\n    commitNestedUnmounts(finishedRoot, current, nearestMountedAncestor);\n  }\n\n  detachFiberMutation(current);\n}\n\nfunction commitWork(current, finishedWork) {\n  if (!supportsMutation) {\n    switch (finishedWork.tag) {\n      case FunctionComponent:\n      case ForwardRef:\n      case MemoComponent:\n      case SimpleMemoComponent:\n        {\n          commitHookEffectListUnmount(HookInsertion | HookHasEffect, finishedWork, finishedWork.return);\n          commitHookEffectListMount(HookInsertion | HookHasEffect, finishedWork); // Layout effects are destroyed during the mutation phase so that all\n          // destroy functions for all fibers are called before any create functions.\n          // This prevents sibling component effects from interfering with each other,\n          // e.g. a destroy function in one component should never override a ref set\n          // by a create function in another component during the same commit.\n          // TODO: Check if we're inside an Offscreen subtree that disappeared\n          // during this commit. If so, we would have already unmounted its\n          // layout hooks. (However, since we null out the `destroy` function\n          // right before calling it, the behavior is already correct, so this\n          // would mostly be for modeling purposes.)\n\n          if (enableProfilerTimer && enableProfilerCommitHooks && finishedWork.mode & ProfileMode) {\n            try {\n              startLayoutEffectTimer();\n              commitHookEffectListUnmount(HookLayout | HookHasEffect, finishedWork, finishedWork.return);\n            } finally {\n              recordLayoutEffectDuration(finishedWork);\n            }\n          } else {\n            commitHookEffectListUnmount(HookLayout | HookHasEffect, finishedWork, finishedWork.return);\n          }\n\n          return;\n        }\n\n      case Profiler:\n        {\n          return;\n        }\n\n      case SuspenseComponent:\n        {\n          commitSuspenseCallback(finishedWork);\n          attachSuspenseRetryListeners(finishedWork);\n          return;\n        }\n\n      case SuspenseListComponent:\n        {\n          attachSuspenseRetryListeners(finishedWork);\n          return;\n        }\n\n      case HostRoot:\n        {\n          if (supportsHydration) {\n            const root = finishedWork.stateNode;\n\n            if (root.isDehydrated) {\n              // We've just hydrated. No need to hydrate again.\n              root.isDehydrated = false;\n              commitHydratedContainer(root.containerInfo);\n            }\n          }\n\n          break;\n        }\n\n      case OffscreenComponent:\n      case LegacyHiddenComponent:\n        {\n          return;\n        }\n    }\n\n    commitContainer(finishedWork);\n    return;\n  }\n\n  switch (finishedWork.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case MemoComponent:\n    case SimpleMemoComponent:\n      {\n        commitHookEffectListUnmount(HookInsertion | HookHasEffect, finishedWork, finishedWork.return);\n        commitHookEffectListMount(HookInsertion | HookHasEffect, finishedWork); // Layout effects are destroyed during the mutation phase so that all\n        // destroy functions for all fibers are called before any create functions.\n        // This prevents sibling component effects from interfering with each other,\n        // e.g. a destroy function in one component should never override a ref set\n        // by a create function in another component during the same commit.\n\n        if (enableProfilerTimer && enableProfilerCommitHooks && finishedWork.mode & ProfileMode) {\n          try {\n            startLayoutEffectTimer();\n            commitHookEffectListUnmount(HookLayout | HookHasEffect, finishedWork, finishedWork.return);\n          } finally {\n            recordLayoutEffectDuration(finishedWork);\n          }\n        } else {\n          commitHookEffectListUnmount(HookLayout | HookHasEffect, finishedWork, finishedWork.return);\n        }\n\n        return;\n      }\n\n    case ClassComponent:\n      {\n        return;\n      }\n\n    case HostComponent:\n      {\n        const instance = finishedWork.stateNode;\n\n        if (instance != null) {\n          // Commit the work prepared earlier.\n          const newProps = finishedWork.memoizedProps; // For hydration we reuse the update path but we treat the oldProps\n          // as the newProps. The updatePayload will contain the real change in\n          // this case.\n\n          const oldProps = current !== null ? current.memoizedProps : newProps;\n          const type = finishedWork.type; // TODO: Type the updateQueue to be specific to host components.\n\n          const updatePayload = finishedWork.updateQueue;\n          finishedWork.updateQueue = null;\n\n          if (updatePayload !== null) {\n            commitUpdate(instance, updatePayload, type, oldProps, newProps, finishedWork);\n          }\n        }\n\n        return;\n      }\n\n    case HostText:\n      {\n        if (finishedWork.stateNode === null) {\n          throw new Error('This should have a text node initialized. This error is likely ' + 'caused by a bug in React. Please file an issue.');\n        }\n\n        const textInstance = finishedWork.stateNode;\n        const newText = finishedWork.memoizedProps; // For hydration we reuse the update path but we treat the oldProps\n        // as the newProps. The updatePayload will contain the real change in\n        // this case.\n\n        const oldText = current !== null ? current.memoizedProps : newText;\n        commitTextUpdate(textInstance, oldText, newText);\n        return;\n      }\n\n    case HostRoot:\n      {\n        if (supportsHydration) {\n          const root = finishedWork.stateNode;\n\n          if (root.isDehydrated) {\n            // We've just hydrated. No need to hydrate again.\n            root.isDehydrated = false;\n            commitHydratedContainer(root.containerInfo);\n          }\n        }\n\n        return;\n      }\n\n    case Profiler:\n      {\n        return;\n      }\n\n    case SuspenseComponent:\n      {\n        commitSuspenseCallback(finishedWork);\n        attachSuspenseRetryListeners(finishedWork);\n        return;\n      }\n\n    case SuspenseListComponent:\n      {\n        attachSuspenseRetryListeners(finishedWork);\n        return;\n      }\n\n    case IncompleteClassComponent:\n      {\n        return;\n      }\n\n    case ScopeComponent:\n      {\n        if (enableScopeAPI) {\n          const scopeInstance = finishedWork.stateNode;\n          prepareScopeUpdate(scopeInstance, finishedWork);\n          return;\n        }\n\n        break;\n      }\n  }\n\n  throw new Error('This unit of work tag should not have side-effects. This error is ' + 'likely caused by a bug in React. Please file an issue.');\n}\n\nfunction commitSuspenseCallback(finishedWork) {\n  // TODO: Move this to passive phase\n  const newState = finishedWork.memoizedState;\n\n  if (enableSuspenseCallback && newState !== null) {\n    const suspenseCallback = finishedWork.memoizedProps.suspenseCallback;\n\n    if (typeof suspenseCallback === 'function') {\n      const wakeables = finishedWork.updateQueue;\n\n      if (wakeables !== null) {\n        suspenseCallback(new Set(wakeables));\n      }\n    } else if (__DEV__) {\n      if (suspenseCallback !== undefined) {\n        console.error('Unexpected type for suspenseCallback.');\n      }\n    }\n  }\n}\n\nfunction commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {\n  if (!supportsHydration) {\n    return;\n  }\n\n  const newState = finishedWork.memoizedState;\n\n  if (newState === null) {\n    const current = finishedWork.alternate;\n\n    if (current !== null) {\n      const prevState = current.memoizedState;\n\n      if (prevState !== null) {\n        const suspenseInstance = prevState.dehydrated;\n\n        if (suspenseInstance !== null) {\n          commitHydratedSuspenseInstance(suspenseInstance);\n\n          if (enableSuspenseCallback) {\n            const hydrationCallbacks = finishedRoot.hydrationCallbacks;\n\n            if (hydrationCallbacks !== null) {\n              const onHydrated = hydrationCallbacks.onHydrated;\n\n              if (onHydrated) {\n                onHydrated(suspenseInstance);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\nfunction attachSuspenseRetryListeners(finishedWork) {\n  // If this boundary just timed out, then it will have a set of wakeables.\n  // For each wakeable, attach a listener so that when it resolves, React\n  // attempts to re-render the boundary in the primary (pre-timeout) state.\n  const wakeables = finishedWork.updateQueue;\n\n  if (wakeables !== null) {\n    finishedWork.updateQueue = null;\n    let retryCache = finishedWork.stateNode;\n\n    if (retryCache === null) {\n      retryCache = finishedWork.stateNode = new PossiblyWeakSet();\n    }\n\n    wakeables.forEach(wakeable => {\n      // Memoize using the boundary fiber to prevent redundant listeners.\n      const retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);\n\n      if (!retryCache.has(wakeable)) {\n        retryCache.add(wakeable);\n\n        if (enableUpdaterTracking) {\n          if (isDevToolsPresent) {\n            if (inProgressLanes !== null && inProgressRoot !== null) {\n              // If we have pending work still, associate the original updaters with it.\n              restorePendingUpdaters(inProgressRoot, inProgressLanes);\n            } else {\n              throw Error('Expected finished root and lanes to be set. This is a bug in React.');\n            }\n          }\n        }\n\n        wakeable.then(retry, retry);\n      }\n    });\n  }\n} // This function detects when a Suspense boundary goes from visible to hidden.\n// It returns false if the boundary is already hidden.\n// TODO: Use an effect tag.\n\n\nexport function isSuspenseBoundaryBeingHidden(current, finishedWork) {\n  if (current !== null) {\n    const oldState = current.memoizedState;\n\n    if (oldState === null || oldState.dehydrated !== null) {\n      const newState = finishedWork.memoizedState;\n      return newState !== null && newState.dehydrated === null;\n    }\n  }\n\n  return false;\n}\n\nfunction commitResetTextContent(current) {\n  if (!supportsMutation) {\n    return;\n  }\n\n  resetTextContent(current.stateNode);\n}\n\nexport function commitMutationEffects(root, firstChild, committedLanes) {\n  inProgressLanes = committedLanes;\n  inProgressRoot = root;\n  nextEffect = firstChild;\n  commitMutationEffects_begin(root);\n  inProgressLanes = null;\n  inProgressRoot = null;\n}\n\nfunction commitMutationEffects_begin(root) {\n  while (nextEffect !== null) {\n    const fiber = nextEffect; // TODO: Should wrap this in flags check, too, as optimization\n\n    const deletions = fiber.deletions;\n\n    if (deletions !== null) {\n      for (let i = 0; i < deletions.length; i++) {\n        const childToDelete = deletions[i];\n\n        try {\n          commitDeletion(root, childToDelete, fiber);\n        } catch (error) {\n          reportUncaughtErrorInDEV(error);\n          captureCommitPhaseError(childToDelete, fiber, error);\n        }\n      }\n    }\n\n    const child = fiber.child;\n\n    if ((fiber.subtreeFlags & MutationMask) !== NoFlags && child !== null) {\n      ensureCorrectReturnPointer(child, fiber);\n      nextEffect = child;\n    } else {\n      commitMutationEffects_complete(root);\n    }\n  }\n}\n\nfunction commitMutationEffects_complete(root) {\n  while (nextEffect !== null) {\n    const fiber = nextEffect;\n    setCurrentDebugFiberInDEV(fiber);\n\n    try {\n      commitMutationEffectsOnFiber(fiber, root);\n    } catch (error) {\n      reportUncaughtErrorInDEV(error);\n      captureCommitPhaseError(fiber, fiber.return, error);\n    }\n\n    resetCurrentDebugFiberInDEV();\n    const sibling = fiber.sibling;\n\n    if (sibling !== null) {\n      ensureCorrectReturnPointer(sibling, fiber.return);\n      nextEffect = sibling;\n      return;\n    }\n\n    nextEffect = fiber.return;\n  }\n}\n\nfunction commitMutationEffectsOnFiber(finishedWork, root) {\n  // TODO: The factoring of this phase could probably be improved. Consider\n  // switching on the type of work before checking the flags. That's what\n  // we do in all the other phases. I think this one is only different\n  // because of the shared reconciliation logic below.\n  const flags = finishedWork.flags;\n\n  if (flags & ContentReset) {\n    commitResetTextContent(finishedWork);\n  }\n\n  if (flags & Ref) {\n    const current = finishedWork.alternate;\n\n    if (current !== null) {\n      commitDetachRef(current);\n    }\n\n    if (enableScopeAPI) {\n      // TODO: This is a temporary solution that allowed us to transition away\n      // from React Flare on www.\n      if (finishedWork.tag === ScopeComponent) {\n        commitAttachRef(finishedWork);\n      }\n    }\n  }\n\n  if (flags & Visibility) {\n    switch (finishedWork.tag) {\n      case SuspenseComponent:\n        {\n          const newState = finishedWork.memoizedState;\n          const isHidden = newState !== null;\n\n          if (isHidden) {\n            const current = finishedWork.alternate;\n            const wasHidden = current !== null && current.memoizedState !== null;\n\n            if (!wasHidden) {\n              // TODO: Move to passive phase\n              markCommitTimeOfFallback();\n            }\n          }\n\n          break;\n        }\n\n      case OffscreenComponent:\n        {\n          const newState = finishedWork.memoizedState;\n          const isHidden = newState !== null;\n          const current = finishedWork.alternate;\n          const wasHidden = current !== null && current.memoizedState !== null;\n          const offscreenBoundary = finishedWork;\n\n          if (supportsMutation) {\n            // TODO: This needs to run whenever there's an insertion or update\n            // inside a hidden Offscreen tree.\n            hideOrUnhideAllChildren(offscreenBoundary, isHidden);\n          }\n\n          if (enableSuspenseLayoutEffectSemantics) {\n            if (isHidden) {\n              if (!wasHidden) {\n                if ((offscreenBoundary.mode & ConcurrentMode) !== NoMode) {\n                  nextEffect = offscreenBoundary;\n                  let offscreenChild = offscreenBoundary.child;\n\n                  while (offscreenChild !== null) {\n                    nextEffect = offscreenChild;\n                    disappearLayoutEffects_begin(offscreenChild);\n                    offscreenChild = offscreenChild.sibling;\n                  }\n                }\n              }\n            } else {\n              if (wasHidden) {// TODO: Move re-appear call here for symmetry?\n              }\n            }\n\n            break;\n          }\n        }\n    }\n  } // The following switch statement is only concerned about placement,\n  // updates, and deletions. To avoid needing to add a case for every possible\n  // bitmap value, we remove the secondary effects from the effect tag and\n  // switch on that value.\n\n\n  const primaryFlags = flags & (Placement | Update | Hydrating);\n\n  outer: switch (primaryFlags) {\n    case Placement:\n      {\n        commitPlacement(finishedWork); // Clear the \"placement\" from effect tag so that we know that this is\n        // inserted, before any life-cycles like componentDidMount gets called.\n        // TODO: findDOMNode doesn't rely on this any more but isMounted does\n        // and isMounted is deprecated anyway so we should be able to kill this.\n\n        finishedWork.flags &= ~Placement;\n        break;\n      }\n\n    case PlacementAndUpdate:\n      {\n        // Placement\n        commitPlacement(finishedWork); // Clear the \"placement\" from effect tag so that we know that this is\n        // inserted, before any life-cycles like componentDidMount gets called.\n\n        finishedWork.flags &= ~Placement; // Update\n\n        const current = finishedWork.alternate;\n        commitWork(current, finishedWork);\n        break;\n      }\n\n    case Hydrating:\n      {\n        finishedWork.flags &= ~Hydrating;\n        break;\n      }\n\n    case HydratingAndUpdate:\n      {\n        finishedWork.flags &= ~Hydrating; // Update\n\n        const current = finishedWork.alternate;\n        commitWork(current, finishedWork);\n        break;\n      }\n\n    case Update:\n      {\n        const current = finishedWork.alternate;\n        commitWork(current, finishedWork);\n        break;\n      }\n  }\n}\n\nexport function commitLayoutEffects(finishedWork, root, committedLanes) {\n  inProgressLanes = committedLanes;\n  inProgressRoot = root;\n  nextEffect = finishedWork;\n  commitLayoutEffects_begin(finishedWork, root, committedLanes);\n  inProgressLanes = null;\n  inProgressRoot = null;\n}\n\nfunction commitLayoutEffects_begin(subtreeRoot, root, committedLanes) {\n  // Suspense layout effects semantics don't change for legacy roots.\n  const isModernRoot = (subtreeRoot.mode & ConcurrentMode) !== NoMode;\n\n  while (nextEffect !== null) {\n    const fiber = nextEffect;\n    const firstChild = fiber.child;\n\n    if (enableSuspenseLayoutEffectSemantics && fiber.tag === OffscreenComponent && isModernRoot) {\n      // Keep track of the current Offscreen stack's state.\n      const isHidden = fiber.memoizedState !== null;\n      const newOffscreenSubtreeIsHidden = isHidden || offscreenSubtreeIsHidden;\n\n      if (newOffscreenSubtreeIsHidden) {\n        // The Offscreen tree is hidden. Skip over its layout effects.\n        commitLayoutMountEffects_complete(subtreeRoot, root, committedLanes);\n        continue;\n      } else {\n        // TODO (Offscreen) Also check: subtreeFlags & LayoutMask\n        const current = fiber.alternate;\n        const wasHidden = current !== null && current.memoizedState !== null;\n        const newOffscreenSubtreeWasHidden = wasHidden || offscreenSubtreeWasHidden;\n        const prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden;\n        const prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden; // Traverse the Offscreen subtree with the current Offscreen as the root.\n\n        offscreenSubtreeIsHidden = newOffscreenSubtreeIsHidden;\n        offscreenSubtreeWasHidden = newOffscreenSubtreeWasHidden;\n\n        if (offscreenSubtreeWasHidden && !prevOffscreenSubtreeWasHidden) {\n          // This is the root of a reappearing boundary. Turn its layout effects\n          // back on.\n          nextEffect = fiber;\n          reappearLayoutEffects_begin(fiber);\n        }\n\n        let child = firstChild;\n\n        while (child !== null) {\n          nextEffect = child;\n          commitLayoutEffects_begin(child, // New root; bubble back up to here and stop.\n          root, committedLanes);\n          child = child.sibling;\n        } // Restore Offscreen state and resume in our-progress traversal.\n\n\n        nextEffect = fiber;\n        offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;\n        offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\n        commitLayoutMountEffects_complete(subtreeRoot, root, committedLanes);\n        continue;\n      }\n    }\n\n    if ((fiber.subtreeFlags & LayoutMask) !== NoFlags && firstChild !== null) {\n      ensureCorrectReturnPointer(firstChild, fiber);\n      nextEffect = firstChild;\n    } else {\n      commitLayoutMountEffects_complete(subtreeRoot, root, committedLanes);\n    }\n  }\n}\n\nfunction commitLayoutMountEffects_complete(subtreeRoot, root, committedLanes) {\n  while (nextEffect !== null) {\n    const fiber = nextEffect;\n\n    if ((fiber.flags & LayoutMask) !== NoFlags) {\n      const current = fiber.alternate;\n      setCurrentDebugFiberInDEV(fiber);\n\n      try {\n        commitLayoutEffectOnFiber(root, current, fiber, committedLanes);\n      } catch (error) {\n        reportUncaughtErrorInDEV(error);\n        captureCommitPhaseError(fiber, fiber.return, error);\n      }\n\n      resetCurrentDebugFiberInDEV();\n    }\n\n    if (fiber === subtreeRoot) {\n      nextEffect = null;\n      return;\n    }\n\n    const sibling = fiber.sibling;\n\n    if (sibling !== null) {\n      ensureCorrectReturnPointer(sibling, fiber.return);\n      nextEffect = sibling;\n      return;\n    }\n\n    nextEffect = fiber.return;\n  }\n}\n\nfunction disappearLayoutEffects_begin(subtreeRoot) {\n  while (nextEffect !== null) {\n    const fiber = nextEffect;\n    const firstChild = fiber.child; // TODO (Offscreen) Check: flags & (RefStatic | LayoutStatic)\n\n    switch (fiber.tag) {\n      case FunctionComponent:\n      case ForwardRef:\n      case MemoComponent:\n      case SimpleMemoComponent:\n        {\n          if (enableProfilerTimer && enableProfilerCommitHooks && fiber.mode & ProfileMode) {\n            try {\n              startLayoutEffectTimer();\n              commitHookEffectListUnmount(HookLayout, fiber, fiber.return);\n            } finally {\n              recordLayoutEffectDuration(fiber);\n            }\n          } else {\n            commitHookEffectListUnmount(HookLayout, fiber, fiber.return);\n          }\n\n          break;\n        }\n\n      case ClassComponent:\n        {\n          // TODO (Offscreen) Check: flags & RefStatic\n          safelyDetachRef(fiber, fiber.return);\n          const instance = fiber.stateNode;\n\n          if (typeof instance.componentWillUnmount === 'function') {\n            safelyCallComponentWillUnmount(fiber, fiber.return, instance);\n          }\n\n          break;\n        }\n\n      case HostComponent:\n        {\n          safelyDetachRef(fiber, fiber.return);\n          break;\n        }\n\n      case OffscreenComponent:\n        {\n          // Check if this is a\n          const isHidden = fiber.memoizedState !== null;\n\n          if (isHidden) {\n            // Nested Offscreen tree is already hidden. Don't disappear\n            // its effects.\n            disappearLayoutEffects_complete(subtreeRoot);\n            continue;\n          }\n\n          break;\n        }\n    } // TODO (Offscreen) Check: subtreeFlags & LayoutStatic\n\n\n    if (firstChild !== null) {\n      firstChild.return = fiber;\n      nextEffect = firstChild;\n    } else {\n      disappearLayoutEffects_complete(subtreeRoot);\n    }\n  }\n}\n\nfunction disappearLayoutEffects_complete(subtreeRoot) {\n  while (nextEffect !== null) {\n    const fiber = nextEffect;\n\n    if (fiber === subtreeRoot) {\n      nextEffect = null;\n      return;\n    }\n\n    const sibling = fiber.sibling;\n\n    if (sibling !== null) {\n      sibling.return = fiber.return;\n      nextEffect = sibling;\n      return;\n    }\n\n    nextEffect = fiber.return;\n  }\n}\n\nfunction reappearLayoutEffects_begin(subtreeRoot) {\n  while (nextEffect !== null) {\n    const fiber = nextEffect;\n    const firstChild = fiber.child;\n\n    if (fiber.tag === OffscreenComponent) {\n      const isHidden = fiber.memoizedState !== null;\n\n      if (isHidden) {\n        // Nested Offscreen tree is still hidden. Don't re-appear its effects.\n        reappearLayoutEffects_complete(subtreeRoot);\n        continue;\n      }\n    } // TODO (Offscreen) Check: subtreeFlags & LayoutStatic\n\n\n    if (firstChild !== null) {\n      // This node may have been reused from a previous render, so we can't\n      // assume its return pointer is correct.\n      firstChild.return = fiber;\n      nextEffect = firstChild;\n    } else {\n      reappearLayoutEffects_complete(subtreeRoot);\n    }\n  }\n}\n\nfunction reappearLayoutEffects_complete(subtreeRoot) {\n  while (nextEffect !== null) {\n    const fiber = nextEffect; // TODO (Offscreen) Check: flags & LayoutStatic\n\n    setCurrentDebugFiberInDEV(fiber);\n\n    try {\n      reappearLayoutEffectsOnFiber(fiber);\n    } catch (error) {\n      reportUncaughtErrorInDEV(error);\n      captureCommitPhaseError(fiber, fiber.return, error);\n    }\n\n    resetCurrentDebugFiberInDEV();\n\n    if (fiber === subtreeRoot) {\n      nextEffect = null;\n      return;\n    }\n\n    const sibling = fiber.sibling;\n\n    if (sibling !== null) {\n      // This node may have been reused from a previous render, so we can't\n      // assume its return pointer is correct.\n      sibling.return = fiber.return;\n      nextEffect = sibling;\n      return;\n    }\n\n    nextEffect = fiber.return;\n  }\n}\n\nexport function commitPassiveMountEffects(root, finishedWork) {\n  nextEffect = finishedWork;\n  commitPassiveMountEffects_begin(finishedWork, root);\n}\n\nfunction commitPassiveMountEffects_begin(subtreeRoot, root) {\n  while (nextEffect !== null) {\n    const fiber = nextEffect;\n    const firstChild = fiber.child;\n\n    if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && firstChild !== null) {\n      ensureCorrectReturnPointer(firstChild, fiber);\n      nextEffect = firstChild;\n    } else {\n      commitPassiveMountEffects_complete(subtreeRoot, root);\n    }\n  }\n}\n\nfunction commitPassiveMountEffects_complete(subtreeRoot, root) {\n  while (nextEffect !== null) {\n    const fiber = nextEffect;\n\n    if ((fiber.flags & Passive) !== NoFlags) {\n      setCurrentDebugFiberInDEV(fiber);\n\n      try {\n        commitPassiveMountOnFiber(root, fiber);\n      } catch (error) {\n        reportUncaughtErrorInDEV(error);\n        captureCommitPhaseError(fiber, fiber.return, error);\n      }\n\n      resetCurrentDebugFiberInDEV();\n    }\n\n    if (fiber === subtreeRoot) {\n      nextEffect = null;\n      return;\n    }\n\n    const sibling = fiber.sibling;\n\n    if (sibling !== null) {\n      ensureCorrectReturnPointer(sibling, fiber.return);\n      nextEffect = sibling;\n      return;\n    }\n\n    nextEffect = fiber.return;\n  }\n}\n\nfunction commitPassiveMountOnFiber(finishedRoot, finishedWork) {\n  switch (finishedWork.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case SimpleMemoComponent:\n      {\n        if (enableProfilerTimer && enableProfilerCommitHooks && finishedWork.mode & ProfileMode) {\n          startPassiveEffectTimer();\n\n          try {\n            commitHookEffectListMount(HookPassive | HookHasEffect, finishedWork);\n          } finally {\n            recordPassiveEffectDuration(finishedWork);\n          }\n        } else {\n          commitHookEffectListMount(HookPassive | HookHasEffect, finishedWork);\n        }\n\n        break;\n      }\n\n    case HostRoot:\n      {\n        if (enableCache) {\n          let previousCache = null;\n\n          if (finishedWork.alternate !== null) {\n            previousCache = finishedWork.alternate.memoizedState.cache;\n          }\n\n          const nextCache = finishedWork.memoizedState.cache; // Retain/release the root cache.\n          // Note that on initial mount, previousCache and nextCache will be the same\n          // and this retain won't occur. To counter this, we instead retain the HostRoot's\n          // initial cache when creating the root itself (see createFiberRoot() in\n          // ReactFiberRoot.js). Subsequent updates that change the cache are reflected\n          // here, such that previous/next caches are retained correctly.\n\n          if (nextCache !== previousCache) {\n            retainCache(nextCache);\n\n            if (previousCache != null) {\n              releaseCache(previousCache);\n            }\n          }\n        }\n\n        break;\n      }\n\n    case LegacyHiddenComponent:\n    case OffscreenComponent:\n      {\n        if (enableCache) {\n          let previousCache = null;\n\n          if (finishedWork.alternate !== null && finishedWork.alternate.memoizedState !== null && finishedWork.alternate.memoizedState.cachePool !== null) {\n            previousCache = finishedWork.alternate.memoizedState.cachePool.pool;\n          }\n\n          let nextCache = null;\n\n          if (finishedWork.memoizedState !== null && finishedWork.memoizedState.cachePool !== null) {\n            nextCache = finishedWork.memoizedState.cachePool.pool;\n          } // Retain/release the cache used for pending (suspended) nodes.\n          // Note that this is only reached in the non-suspended/visible case:\n          // when the content is suspended/hidden, the retain/release occurs\n          // via the parent Suspense component (see case above).\n\n\n          if (nextCache !== previousCache) {\n            if (nextCache != null) {\n              retainCache(nextCache);\n            }\n\n            if (previousCache != null) {\n              releaseCache(previousCache);\n            }\n          }\n        }\n\n        break;\n      }\n\n    case CacheComponent:\n      {\n        if (enableCache) {\n          let previousCache = null;\n\n          if (finishedWork.alternate !== null) {\n            previousCache = finishedWork.alternate.memoizedState.cache;\n          }\n\n          const nextCache = finishedWork.memoizedState.cache; // Retain/release the cache. In theory the cache component\n          // could be \"borrowing\" a cache instance owned by some parent,\n          // in which case we could avoid retaining/releasing. But it\n          // is non-trivial to determine when that is the case, so we\n          // always retain/release.\n\n          if (nextCache !== previousCache) {\n            retainCache(nextCache);\n\n            if (previousCache != null) {\n              releaseCache(previousCache);\n            }\n          }\n        }\n\n        break;\n      }\n  }\n}\n\nexport function commitPassiveUnmountEffects(firstChild) {\n  nextEffect = firstChild;\n  commitPassiveUnmountEffects_begin();\n}\n\nfunction commitPassiveUnmountEffects_begin() {\n  while (nextEffect !== null) {\n    const fiber = nextEffect;\n    const child = fiber.child;\n\n    if ((nextEffect.flags & ChildDeletion) !== NoFlags) {\n      const deletions = fiber.deletions;\n\n      if (deletions !== null) {\n        for (let i = 0; i < deletions.length; i++) {\n          const fiberToDelete = deletions[i];\n          nextEffect = fiberToDelete;\n          commitPassiveUnmountEffectsInsideOfDeletedTree_begin(fiberToDelete, fiber);\n        }\n\n        if (deletedTreeCleanUpLevel >= 1) {\n          // A fiber was deleted from this parent fiber, but it's still part of\n          // the previous (alternate) parent fiber's list of children. Because\n          // children are a linked list, an earlier sibling that's still alive\n          // will be connected to the deleted fiber via its `alternate`:\n          //\n          //   live fiber\n          //   --alternate--> previous live fiber\n          //   --sibling--> deleted fiber\n          //\n          // We can't disconnect `alternate` on nodes that haven't been deleted\n          // yet, but we can disconnect the `sibling` and `child` pointers.\n          const previousFiber = fiber.alternate;\n\n          if (previousFiber !== null) {\n            let detachedChild = previousFiber.child;\n\n            if (detachedChild !== null) {\n              previousFiber.child = null;\n\n              do {\n                const detachedSibling = detachedChild.sibling;\n                detachedChild.sibling = null;\n                detachedChild = detachedSibling;\n              } while (detachedChild !== null);\n            }\n          }\n        }\n\n        nextEffect = fiber;\n      }\n    }\n\n    if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && child !== null) {\n      ensureCorrectReturnPointer(child, fiber);\n      nextEffect = child;\n    } else {\n      commitPassiveUnmountEffects_complete();\n    }\n  }\n}\n\nfunction commitPassiveUnmountEffects_complete() {\n  while (nextEffect !== null) {\n    const fiber = nextEffect;\n\n    if ((fiber.flags & Passive) !== NoFlags) {\n      setCurrentDebugFiberInDEV(fiber);\n      commitPassiveUnmountOnFiber(fiber);\n      resetCurrentDebugFiberInDEV();\n    }\n\n    const sibling = fiber.sibling;\n\n    if (sibling !== null) {\n      ensureCorrectReturnPointer(sibling, fiber.return);\n      nextEffect = sibling;\n      return;\n    }\n\n    nextEffect = fiber.return;\n  }\n}\n\nfunction commitPassiveUnmountOnFiber(finishedWork) {\n  switch (finishedWork.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case SimpleMemoComponent:\n      {\n        if (enableProfilerTimer && enableProfilerCommitHooks && finishedWork.mode & ProfileMode) {\n          startPassiveEffectTimer();\n          commitHookEffectListUnmount(HookPassive | HookHasEffect, finishedWork, finishedWork.return);\n          recordPassiveEffectDuration(finishedWork);\n        } else {\n          commitHookEffectListUnmount(HookPassive | HookHasEffect, finishedWork, finishedWork.return);\n        }\n\n        break;\n      }\n  }\n}\n\nfunction commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {\n  while (nextEffect !== null) {\n    const fiber = nextEffect; // Deletion effects fire in parent -> child order\n    // TODO: Check if fiber has a PassiveStatic flag\n\n    setCurrentDebugFiberInDEV(fiber);\n    commitPassiveUnmountInsideDeletedTreeOnFiber(fiber, nearestMountedAncestor);\n    resetCurrentDebugFiberInDEV();\n    const child = fiber.child; // TODO: Only traverse subtree if it has a PassiveStatic flag. (But, if we\n    // do this, still need to handle `deletedTreeCleanUpLevel` correctly.)\n\n    if (child !== null) {\n      ensureCorrectReturnPointer(child, fiber);\n      nextEffect = child;\n    } else {\n      commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot);\n    }\n  }\n}\n\nfunction commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot) {\n  while (nextEffect !== null) {\n    const fiber = nextEffect;\n    const sibling = fiber.sibling;\n    const returnFiber = fiber.return;\n\n    if (deletedTreeCleanUpLevel >= 2) {\n      // Recursively traverse the entire deleted tree and clean up fiber fields.\n      // This is more aggressive than ideal, and the long term goal is to only\n      // have to detach the deleted tree at the root.\n      detachFiberAfterEffects(fiber);\n\n      if (fiber === deletedSubtreeRoot) {\n        nextEffect = null;\n        return;\n      }\n    } else {\n      // This is the default branch (level 0). We do not recursively clear all\n      // the fiber fields. Only the root of the deleted subtree.\n      if (fiber === deletedSubtreeRoot) {\n        detachFiberAfterEffects(fiber);\n        nextEffect = null;\n        return;\n      }\n    }\n\n    if (sibling !== null) {\n      ensureCorrectReturnPointer(sibling, returnFiber);\n      nextEffect = sibling;\n      return;\n    }\n\n    nextEffect = returnFiber;\n  }\n}\n\nfunction commitPassiveUnmountInsideDeletedTreeOnFiber(current, nearestMountedAncestor) {\n  switch (current.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case SimpleMemoComponent:\n      {\n        if (enableProfilerTimer && enableProfilerCommitHooks && current.mode & ProfileMode) {\n          startPassiveEffectTimer();\n          commitHookEffectListUnmount(HookPassive, current, nearestMountedAncestor);\n          recordPassiveEffectDuration(current);\n        } else {\n          commitHookEffectListUnmount(HookPassive, current, nearestMountedAncestor);\n        }\n\n        break;\n      }\n    // TODO: run passive unmount effects when unmounting a root.\n    // Because passive unmount effects are not currently run,\n    // the cache instance owned by the root will never be freed.\n    // When effects are run, the cache should be freed here:\n    // case HostRoot: {\n    //   if (enableCache) {\n    //     const cache = current.memoizedState.cache;\n    //     releaseCache(cache);\n    //   }\n    //   break;\n    // }\n\n    case LegacyHiddenComponent:\n    case OffscreenComponent:\n      {\n        if (enableCache) {\n          if (current.memoizedState !== null && current.memoizedState.cachePool !== null) {\n            const cache = current.memoizedState.cachePool.pool; // Retain/release the cache used for pending (suspended) nodes.\n            // Note that this is only reached in the non-suspended/visible case:\n            // when the content is suspended/hidden, the retain/release occurs\n            // via the parent Suspense component (see case above).\n\n            if (cache != null) {\n              retainCache(cache);\n            }\n          }\n        }\n\n        break;\n      }\n\n    case CacheComponent:\n      {\n        if (enableCache) {\n          const cache = current.memoizedState.cache;\n          releaseCache(cache);\n        }\n\n        break;\n      }\n  }\n}\n\nlet didWarnWrongReturnPointer = false;\n\nfunction ensureCorrectReturnPointer(fiber, expectedReturnFiber) {\n  if (__DEV__) {\n    if (!didWarnWrongReturnPointer && fiber.return !== expectedReturnFiber) {\n      didWarnWrongReturnPointer = true;\n      console.error('Internal React error: Return pointer is inconsistent ' + 'with parent.');\n    }\n  } // TODO: Remove this assignment once we're confident that it won't break\n  // anything, by checking the warning logs for the above invariant\n\n\n  fiber.return = expectedReturnFiber;\n} // TODO: Reuse reappearLayoutEffects traversal here?\n\n\nfunction invokeLayoutEffectMountInDEV(fiber) {\n  if (__DEV__ && enableStrictEffects) {\n    // We don't need to re-check StrictEffectsMode here.\n    // This function is only called if that check has already passed.\n    switch (fiber.tag) {\n      case FunctionComponent:\n      case ForwardRef:\n      case SimpleMemoComponent:\n        {\n          try {\n            commitHookEffectListMount(HookLayout | HookHasEffect, fiber);\n          } catch (error) {\n            reportUncaughtErrorInDEV(error);\n            captureCommitPhaseError(fiber, fiber.return, error);\n          }\n\n          break;\n        }\n\n      case ClassComponent:\n        {\n          const instance = fiber.stateNode;\n\n          try {\n            instance.componentDidMount();\n          } catch (error) {\n            reportUncaughtErrorInDEV(error);\n            captureCommitPhaseError(fiber, fiber.return, error);\n          }\n\n          break;\n        }\n    }\n  }\n}\n\nfunction invokePassiveEffectMountInDEV(fiber) {\n  if (__DEV__ && enableStrictEffects) {\n    // We don't need to re-check StrictEffectsMode here.\n    // This function is only called if that check has already passed.\n    switch (fiber.tag) {\n      case FunctionComponent:\n      case ForwardRef:\n      case SimpleMemoComponent:\n        {\n          try {\n            commitHookEffectListMount(HookPassive | HookHasEffect, fiber);\n          } catch (error) {\n            reportUncaughtErrorInDEV(error);\n            captureCommitPhaseError(fiber, fiber.return, error);\n          }\n\n          break;\n        }\n    }\n  }\n}\n\nfunction invokeLayoutEffectUnmountInDEV(fiber) {\n  if (__DEV__ && enableStrictEffects) {\n    // We don't need to re-check StrictEffectsMode here.\n    // This function is only called if that check has already passed.\n    switch (fiber.tag) {\n      case FunctionComponent:\n      case ForwardRef:\n      case SimpleMemoComponent:\n        {\n          try {\n            commitHookEffectListUnmount(HookLayout | HookHasEffect, fiber, fiber.return);\n          } catch (error) {\n            reportUncaughtErrorInDEV(error);\n            captureCommitPhaseError(fiber, fiber.return, error);\n          }\n\n          break;\n        }\n\n      case ClassComponent:\n        {\n          const instance = fiber.stateNode;\n\n          if (typeof instance.componentWillUnmount === 'function') {\n            safelyCallComponentWillUnmount(fiber, fiber.return, instance);\n          }\n\n          break;\n        }\n    }\n  }\n}\n\nfunction invokePassiveEffectUnmountInDEV(fiber) {\n  if (__DEV__ && enableStrictEffects) {\n    // We don't need to re-check StrictEffectsMode here.\n    // This function is only called if that check has already passed.\n    switch (fiber.tag) {\n      case FunctionComponent:\n      case ForwardRef:\n      case SimpleMemoComponent:\n        {\n          try {\n            commitHookEffectListUnmount(HookPassive | HookHasEffect, fiber, fiber.return);\n          } catch (error) {\n            reportUncaughtErrorInDEV(error);\n            captureCommitPhaseError(fiber, fiber.return, error);\n          }\n        }\n    }\n  }\n}\n\nexport { commitResetTextContent, commitPlacement, commitDeletion, commitWork, commitAttachRef, commitDetachRef, invokeLayoutEffectMountInDEV, invokeLayoutEffectUnmountInDEV, invokePassiveEffectMountInDEV, invokePassiveEffectUnmountInDEV };","map":{"version":3,"sources":["/Users/zhangshuo/git/react-source-test/src/react/packages/react-reconciler/src/ReactFiberCommitWork.new.js"],"names":["enableCreateEventHandleAPI","enableProfilerTimer","enableProfilerCommitHooks","enableProfilerNestedUpdatePhase","enableSchedulingProfiler","enableSuspenseServerRenderer","enableSuspenseCallback","enableScopeAPI","enableStrictEffects","deletedTreeCleanUpLevel","enableSuspenseLayoutEffectSemantics","enableUpdaterTracking","warnAboutCallbackRefReturningFunction","enableCache","FunctionComponent","ForwardRef","ClassComponent","HostRoot","HostComponent","HostText","HostPortal","Profiler","SuspenseComponent","DehydratedFragment","IncompleteClassComponent","MemoComponent","SimpleMemoComponent","SuspenseListComponent","ScopeComponent","OffscreenComponent","LegacyHiddenComponent","CacheComponent","detachDeletedInstance","NoFlags","ContentReset","Placement","PlacementAndUpdate","ChildDeletion","Snapshot","Update","Ref","Hydrating","HydratingAndUpdate","Passive","BeforeMutationMask","MutationMask","LayoutMask","PassiveMask","Visibility","getComponentNameFromFiber","resetCurrentFiber","resetCurrentDebugFiberInDEV","setCurrentFiber","setCurrentDebugFiberInDEV","isDevToolsPresent","onCommitUnmount","resolveDefaultProps","isCurrentUpdateNested","getCommitTime","recordLayoutEffectDuration","startLayoutEffectTimer","recordPassiveEffectDuration","startPassiveEffectTimer","ConcurrentMode","NoMode","ProfileMode","commitUpdateQueue","getPublicInstance","supportsMutation","supportsPersistence","supportsHydration","commitMount","commitUpdate","resetTextContent","commitTextUpdate","appendChild","appendChildToContainer","insertBefore","insertInContainerBefore","removeChild","removeChildFromContainer","clearSuspenseBoundary","clearSuspenseBoundaryFromContainer","replaceContainerChildren","createContainerChildSet","hideInstance","hideTextInstance","unhideInstance","unhideTextInstance","commitHydratedContainer","commitHydratedSuspenseInstance","clearContainer","prepareScopeUpdate","prepareForCommit","beforeActiveInstanceBlur","captureCommitPhaseError","resolveRetryWakeable","markCommitTimeOfFallback","enqueuePendingPassiveProfilerEffect","restorePendingUpdaters","NoHookEffect","HasEffect","HookHasEffect","Layout","HookLayout","Insertion","HookInsertion","HookPassive","didWarnAboutReassigningProps","doesFiberContain","invokeGuardedCallback","clearCaughtError","markComponentPassiveEffectMountStarted","markComponentPassiveEffectMountStopped","markComponentPassiveEffectUnmountStarted","markComponentPassiveEffectUnmountStopped","markComponentLayoutEffectMountStarted","markComponentLayoutEffectMountStopped","markComponentLayoutEffectUnmountStarted","markComponentLayoutEffectUnmountStopped","releaseCache","retainCache","didWarnAboutUndefinedSnapshotBeforeUpdate","__DEV__","Set","offscreenSubtreeIsHidden","offscreenSubtreeWasHidden","PossiblyWeakSet","WeakSet","nextEffect","inProgressLanes","inProgressRoot","reportUncaughtErrorInDEV","error","callComponentWillUnmountWithTimer","current","instance","props","memoizedProps","state","memoizedState","mode","componentWillUnmount","safelyCallCommitHookLayoutEffectListMount","nearestMountedAncestor","commitHookEffectListMount","safelyCallComponentWillUnmount","safelyCallComponentDidMount","componentDidMount","safelyAttachRef","commitAttachRef","safelyDetachRef","ref","retVal","console","safelyCallDestroy","destroy","focusedInstanceHandle","shouldFireAfterActiveInstanceBlur","commitBeforeMutationEffects","root","firstChild","containerInfo","commitBeforeMutationEffects_begin","shouldFire","fiber","deletions","i","length","deletion","commitBeforeMutationEffectsDeletion","child","subtreeFlags","ensureCorrectReturnPointer","commitBeforeMutationEffects_complete","commitBeforeMutationEffectsOnFiber","return","sibling","finishedWork","alternate","flags","tag","isSuspenseBoundaryBeingHidden","prevProps","prevState","stateNode","type","elementType","snapshot","getSnapshotBeforeUpdate","didWarnSet","undefined","has","add","__reactInternalSnapshotBeforeUpdate","Error","commitHookEffectListUnmount","updateQueue","lastEffect","firstEffect","next","effect","create","hookName","addendum","then","commitPassiveEffectDurations","finishedRoot","passiveEffectDuration","id","onPostCommit","commitTime","phase","parentFiber","outer","parentStateNode","commitLayoutEffectOnFiber","committedLanes","componentDidUpdate","onCommit","onRender","effectDuration","actualDuration","treeBaseDuration","actualStartTime","commitSuspenseHydrationCallbacks","reappearLayoutEffectsOnFiber","node","hideOrUnhideAllChildren","isHidden","hostSubtreeRoot","instanceToUse","hasOwnProperty","commitDetachRef","currentRef","commitUnmount","unmountHostComponents","emptyPortalContainer","hydrationCallbacks","onDeleted","commitNestedUnmounts","detachFiberMutation","detachFiberAfterEffects","dependencies","pendingProps","_debugOwner","hostInstance","portal","emptyChildSet","commitContainer","portalOrRoot","pendingChildren","getHostParentFiber","parent","isHostParent","getHostSibling","siblings","commitPlacement","isContainer","before","insertOrAppendPlacementNodeIntoContainer","insertOrAppendPlacementNode","isHost","currentParentIsValid","currentParent","currentParentIsContainer","findParent","commitDeletion","commitWork","commitSuspenseCallback","attachSuspenseRetryListeners","isDehydrated","newProps","oldProps","updatePayload","textInstance","newText","oldText","scopeInstance","newState","suspenseCallback","wakeables","suspenseInstance","dehydrated","onHydrated","retryCache","forEach","wakeable","retry","bind","oldState","commitResetTextContent","commitMutationEffects","commitMutationEffects_begin","childToDelete","commitMutationEffects_complete","commitMutationEffectsOnFiber","wasHidden","offscreenBoundary","offscreenChild","disappearLayoutEffects_begin","primaryFlags","commitLayoutEffects","commitLayoutEffects_begin","subtreeRoot","isModernRoot","newOffscreenSubtreeIsHidden","commitLayoutMountEffects_complete","newOffscreenSubtreeWasHidden","prevOffscreenSubtreeIsHidden","prevOffscreenSubtreeWasHidden","reappearLayoutEffects_begin","disappearLayoutEffects_complete","reappearLayoutEffects_complete","commitPassiveMountEffects","commitPassiveMountEffects_begin","commitPassiveMountEffects_complete","commitPassiveMountOnFiber","previousCache","cache","nextCache","cachePool","pool","commitPassiveUnmountEffects","commitPassiveUnmountEffects_begin","fiberToDelete","commitPassiveUnmountEffectsInsideOfDeletedTree_begin","previousFiber","detachedChild","detachedSibling","commitPassiveUnmountEffects_complete","commitPassiveUnmountOnFiber","deletedSubtreeRoot","commitPassiveUnmountInsideDeletedTreeOnFiber","commitPassiveUnmountEffectsInsideOfDeletedTree_complete","returnFiber","didWarnWrongReturnPointer","expectedReturnFiber","invokeLayoutEffectMountInDEV","invokePassiveEffectMountInDEV","invokeLayoutEffectUnmountInDEV","invokePassiveEffectUnmountInDEV"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {\n  Instance,\n  TextInstance,\n  SuspenseInstance,\n  Container,\n  ChildSet,\n  UpdatePayload,\n} from './ReactFiberHostConfig';\nimport type {Fiber} from './ReactInternalTypes';\nimport type {FiberRoot} from './ReactInternalTypes';\nimport type {Lanes} from './ReactFiberLane.new';\nimport type {SuspenseState} from './ReactFiberSuspenseComponent.new';\nimport type {UpdateQueue} from './ReactUpdateQueue.new';\nimport type {FunctionComponentUpdateQueue} from './ReactFiberHooks.new';\nimport type {Wakeable} from 'shared/ReactTypes';\nimport type {OffscreenState} from './ReactFiberOffscreenComponent';\nimport type {HookFlags} from './ReactHookEffectTags';\nimport type {Cache} from './ReactFiberCacheComponent.new';\n\nimport {\n  enableCreateEventHandleAPI,\n  enableProfilerTimer,\n  enableProfilerCommitHooks,\n  enableProfilerNestedUpdatePhase,\n  enableSchedulingProfiler,\n  enableSuspenseServerRenderer,\n  enableSuspenseCallback,\n  enableScopeAPI,\n  enableStrictEffects,\n  deletedTreeCleanUpLevel,\n  enableSuspenseLayoutEffectSemantics,\n  enableUpdaterTracking,\n  warnAboutCallbackRefReturningFunction,\n  enableCache,\n} from 'shared/ReactFeatureFlags';\nimport {\n  FunctionComponent,\n  ForwardRef,\n  ClassComponent,\n  HostRoot,\n  HostComponent,\n  HostText,\n  HostPortal,\n  Profiler,\n  SuspenseComponent,\n  DehydratedFragment,\n  IncompleteClassComponent,\n  MemoComponent,\n  SimpleMemoComponent,\n  SuspenseListComponent,\n  ScopeComponent,\n  OffscreenComponent,\n  LegacyHiddenComponent,\n  CacheComponent,\n} from './ReactWorkTags';\nimport {detachDeletedInstance} from './ReactFiberHostConfig';\nimport {\n  NoFlags,\n  ContentReset,\n  Placement,\n  PlacementAndUpdate,\n  ChildDeletion,\n  Snapshot,\n  Update,\n  Ref,\n  Hydrating,\n  HydratingAndUpdate,\n  Passive,\n  BeforeMutationMask,\n  MutationMask,\n  LayoutMask,\n  PassiveMask,\n  Visibility,\n} from './ReactFiberFlags';\nimport getComponentNameFromFiber from 'react-reconciler/src/getComponentNameFromFiber';\nimport {\n  resetCurrentFiber as resetCurrentDebugFiberInDEV,\n  setCurrentFiber as setCurrentDebugFiberInDEV,\n} from './ReactCurrentFiber';\nimport {isDevToolsPresent} from './ReactFiberDevToolsHook.new';\nimport {onCommitUnmount} from './ReactFiberDevToolsHook.new';\nimport {resolveDefaultProps} from './ReactFiberLazyComponent.new';\nimport {\n  isCurrentUpdateNested,\n  getCommitTime,\n  recordLayoutEffectDuration,\n  startLayoutEffectTimer,\n  recordPassiveEffectDuration,\n  startPassiveEffectTimer,\n} from './ReactProfilerTimer.new';\nimport {ConcurrentMode, NoMode, ProfileMode} from './ReactTypeOfMode';\nimport {commitUpdateQueue} from './ReactUpdateQueue.new';\nimport {\n  getPublicInstance,\n  supportsMutation,\n  supportsPersistence,\n  supportsHydration,\n  commitMount,\n  commitUpdate,\n  resetTextContent,\n  commitTextUpdate,\n  appendChild,\n  appendChildToContainer,\n  insertBefore,\n  insertInContainerBefore,\n  removeChild,\n  removeChildFromContainer,\n  clearSuspenseBoundary,\n  clearSuspenseBoundaryFromContainer,\n  replaceContainerChildren,\n  createContainerChildSet,\n  hideInstance,\n  hideTextInstance,\n  unhideInstance,\n  unhideTextInstance,\n  commitHydratedContainer,\n  commitHydratedSuspenseInstance,\n  clearContainer,\n  prepareScopeUpdate,\n  prepareForCommit,\n  beforeActiveInstanceBlur,\n} from './ReactFiberHostConfig';\nimport {\n  captureCommitPhaseError,\n  resolveRetryWakeable,\n  markCommitTimeOfFallback,\n  enqueuePendingPassiveProfilerEffect,\n  restorePendingUpdaters,\n} from './ReactFiberWorkLoop.new';\nimport {\n  NoFlags as NoHookEffect,\n  HasEffect as HookHasEffect,\n  Layout as HookLayout,\n  Insertion as HookInsertion,\n  Passive as HookPassive,\n} from './ReactHookEffectTags';\nimport {didWarnAboutReassigningProps} from './ReactFiberBeginWork.new';\nimport {doesFiberContain} from './ReactFiberTreeReflection';\nimport {invokeGuardedCallback, clearCaughtError} from 'shared/ReactErrorUtils';\nimport {\n  markComponentPassiveEffectMountStarted,\n  markComponentPassiveEffectMountStopped,\n  markComponentPassiveEffectUnmountStarted,\n  markComponentPassiveEffectUnmountStopped,\n  markComponentLayoutEffectMountStarted,\n  markComponentLayoutEffectMountStopped,\n  markComponentLayoutEffectUnmountStarted,\n  markComponentLayoutEffectUnmountStopped,\n} from './SchedulingProfiler';\nimport {releaseCache, retainCache} from './ReactFiberCacheComponent.new';\n\nlet didWarnAboutUndefinedSnapshotBeforeUpdate: Set<mixed> | null = null;\nif (__DEV__) {\n  didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();\n}\n\n// Used during the commit phase to track the state of the Offscreen component stack.\n// Allows us to avoid traversing the return path to find the nearest Offscreen ancestor.\n// Only used when enableSuspenseLayoutEffectSemantics is enabled.\nlet offscreenSubtreeIsHidden: boolean = false;\nlet offscreenSubtreeWasHidden: boolean = false;\n\nconst PossiblyWeakSet = typeof WeakSet === 'function' ? WeakSet : Set;\n\nlet nextEffect: Fiber | null = null;\n\n// Used for Profiling builds to track updaters.\nlet inProgressLanes: Lanes | null = null;\nlet inProgressRoot: FiberRoot | null = null;\n\nfunction reportUncaughtErrorInDEV(error) {\n  // Wrapping each small part of the commit phase into a guarded\n  // callback is a bit too slow (https://github.com/facebook/react/pull/21666).\n  // But we rely on it to surface errors to DEV tools like overlays\n  // (https://github.com/facebook/react/issues/21712).\n  // As a compromise, rethrow only caught errors in a guard.\n  if (__DEV__) {\n    invokeGuardedCallback(null, () => {\n      throw error;\n    });\n    clearCaughtError();\n  }\n}\n\nconst callComponentWillUnmountWithTimer = function(current, instance) {\n  instance.props = current.memoizedProps;\n  instance.state = current.memoizedState;\n  if (\n    enableProfilerTimer &&\n    enableProfilerCommitHooks &&\n    current.mode & ProfileMode\n  ) {\n    try {\n      startLayoutEffectTimer();\n      instance.componentWillUnmount();\n    } finally {\n      recordLayoutEffectDuration(current);\n    }\n  } else {\n    instance.componentWillUnmount();\n  }\n};\n\n// Capture errors so they don't interrupt mounting.\nfunction safelyCallCommitHookLayoutEffectListMount(\n  current: Fiber,\n  nearestMountedAncestor: Fiber | null,\n) {\n  try {\n    commitHookEffectListMount(HookLayout, current);\n  } catch (error) {\n    reportUncaughtErrorInDEV(error);\n    captureCommitPhaseError(current, nearestMountedAncestor, error);\n  }\n}\n\n// Capture errors so they don't interrupt unmounting.\nfunction safelyCallComponentWillUnmount(\n  current: Fiber,\n  nearestMountedAncestor: Fiber | null,\n  instance: any,\n) {\n  try {\n    callComponentWillUnmountWithTimer(current, instance);\n  } catch (error) {\n    reportUncaughtErrorInDEV(error);\n    captureCommitPhaseError(current, nearestMountedAncestor, error);\n  }\n}\n\n// Capture errors so they don't interrupt mounting.\nfunction safelyCallComponentDidMount(\n  current: Fiber,\n  nearestMountedAncestor: Fiber | null,\n  instance: any,\n) {\n  try {\n    instance.componentDidMount();\n  } catch (error) {\n    reportUncaughtErrorInDEV(error);\n    captureCommitPhaseError(current, nearestMountedAncestor, error);\n  }\n}\n\n// Capture errors so they don't interrupt mounting.\nfunction safelyAttachRef(current: Fiber, nearestMountedAncestor: Fiber | null) {\n  try {\n    commitAttachRef(current);\n  } catch (error) {\n    reportUncaughtErrorInDEV(error);\n    captureCommitPhaseError(current, nearestMountedAncestor, error);\n  }\n}\n\nfunction safelyDetachRef(current: Fiber, nearestMountedAncestor: Fiber | null) {\n  const ref = current.ref;\n  if (ref !== null) {\n    if (typeof ref === 'function') {\n      let retVal;\n      try {\n        if (\n          enableProfilerTimer &&\n          enableProfilerCommitHooks &&\n          current.mode & ProfileMode\n        ) {\n          try {\n            startLayoutEffectTimer();\n            retVal = ref(null);\n          } finally {\n            recordLayoutEffectDuration(current);\n          }\n        } else {\n          retVal = ref(null);\n        }\n      } catch (error) {\n        reportUncaughtErrorInDEV(error);\n        captureCommitPhaseError(current, nearestMountedAncestor, error);\n      }\n      if (__DEV__) {\n        if (\n          warnAboutCallbackRefReturningFunction &&\n          typeof retVal === 'function'\n        ) {\n          console.error(\n            'Unexpected return value from a callback ref in %s. ' +\n              'A callback ref should not return a function.',\n            getComponentNameFromFiber(current),\n          );\n        }\n      }\n    } else {\n      ref.current = null;\n    }\n  }\n}\n\nfunction safelyCallDestroy(\n  current: Fiber,\n  nearestMountedAncestor: Fiber | null,\n  destroy: () => void,\n) {\n  try {\n    destroy();\n  } catch (error) {\n    reportUncaughtErrorInDEV(error);\n    captureCommitPhaseError(current, nearestMountedAncestor, error);\n  }\n}\n\nlet focusedInstanceHandle: null | Fiber = null;\nlet shouldFireAfterActiveInstanceBlur: boolean = false;\n\nexport function commitBeforeMutationEffects(\n  root: FiberRoot,\n  firstChild: Fiber,\n) {\n  focusedInstanceHandle = prepareForCommit(root.containerInfo);\n\n  nextEffect = firstChild;\n  commitBeforeMutationEffects_begin();\n\n  // We no longer need to track the active instance fiber\n  const shouldFire = shouldFireAfterActiveInstanceBlur;\n  shouldFireAfterActiveInstanceBlur = false;\n  focusedInstanceHandle = null;\n\n  return shouldFire;\n}\n\nfunction commitBeforeMutationEffects_begin() {\n  while (nextEffect !== null) {\n    const fiber = nextEffect;\n\n    // This phase is only used for beforeActiveInstanceBlur.\n    // Let's skip the whole loop if it's off.\n    if (enableCreateEventHandleAPI) {\n      // TODO: Should wrap this in flags check, too, as optimization\n      const deletions = fiber.deletions;\n      if (deletions !== null) {\n        for (let i = 0; i < deletions.length; i++) {\n          const deletion = deletions[i];\n          commitBeforeMutationEffectsDeletion(deletion);\n        }\n      }\n    }\n\n    const child = fiber.child;\n    if (\n      (fiber.subtreeFlags & BeforeMutationMask) !== NoFlags &&\n      child !== null\n    ) {\n      ensureCorrectReturnPointer(child, fiber);\n      nextEffect = child;\n    } else {\n      commitBeforeMutationEffects_complete();\n    }\n  }\n}\n\nfunction commitBeforeMutationEffects_complete() {\n  while (nextEffect !== null) {\n    const fiber = nextEffect;\n    setCurrentDebugFiberInDEV(fiber);\n    try {\n      commitBeforeMutationEffectsOnFiber(fiber);\n    } catch (error) {\n      reportUncaughtErrorInDEV(error);\n      captureCommitPhaseError(fiber, fiber.return, error);\n    }\n    resetCurrentDebugFiberInDEV();\n\n    const sibling = fiber.sibling;\n    if (sibling !== null) {\n      ensureCorrectReturnPointer(sibling, fiber.return);\n      nextEffect = sibling;\n      return;\n    }\n\n    nextEffect = fiber.return;\n  }\n}\n\nfunction commitBeforeMutationEffectsOnFiber(finishedWork: Fiber) {\n  const current = finishedWork.alternate;\n  const flags = finishedWork.flags;\n\n  if (enableCreateEventHandleAPI) {\n    if (!shouldFireAfterActiveInstanceBlur && focusedInstanceHandle !== null) {\n      // Check to see if the focused element was inside of a hidden (Suspense) subtree.\n      // TODO: Move this out of the hot path using a dedicated effect tag.\n      if (\n        finishedWork.tag === SuspenseComponent &&\n        isSuspenseBoundaryBeingHidden(current, finishedWork) &&\n        doesFiberContain(finishedWork, focusedInstanceHandle)\n      ) {\n        shouldFireAfterActiveInstanceBlur = true;\n        beforeActiveInstanceBlur(finishedWork);\n      }\n    }\n  }\n\n  if ((flags & Snapshot) !== NoFlags) {\n    setCurrentDebugFiberInDEV(finishedWork);\n\n    switch (finishedWork.tag) {\n      case FunctionComponent:\n      case ForwardRef:\n      case SimpleMemoComponent: {\n        break;\n      }\n      case ClassComponent: {\n        if (current !== null) {\n          const prevProps = current.memoizedProps;\n          const prevState = current.memoizedState;\n          const instance = finishedWork.stateNode;\n          // We could update instance props and state here,\n          // but instead we rely on them being set during last render.\n          // TODO: revisit this when we implement resuming.\n          if (__DEV__) {\n            if (\n              finishedWork.type === finishedWork.elementType &&\n              !didWarnAboutReassigningProps\n            ) {\n              if (instance.props !== finishedWork.memoizedProps) {\n                console.error(\n                  'Expected %s props to match memoized props before ' +\n                    'getSnapshotBeforeUpdate. ' +\n                    'This might either be because of a bug in React, or because ' +\n                    'a component reassigns its own `this.props`. ' +\n                    'Please file an issue.',\n                  getComponentNameFromFiber(finishedWork) || 'instance',\n                );\n              }\n              if (instance.state !== finishedWork.memoizedState) {\n                console.error(\n                  'Expected %s state to match memoized state before ' +\n                    'getSnapshotBeforeUpdate. ' +\n                    'This might either be because of a bug in React, or because ' +\n                    'a component reassigns its own `this.state`. ' +\n                    'Please file an issue.',\n                  getComponentNameFromFiber(finishedWork) || 'instance',\n                );\n              }\n            }\n          }\n          const snapshot = instance.getSnapshotBeforeUpdate(\n            finishedWork.elementType === finishedWork.type\n              ? prevProps\n              : resolveDefaultProps(finishedWork.type, prevProps),\n            prevState,\n          );\n          if (__DEV__) {\n            const didWarnSet = ((didWarnAboutUndefinedSnapshotBeforeUpdate: any): Set<mixed>);\n            if (snapshot === undefined && !didWarnSet.has(finishedWork.type)) {\n              didWarnSet.add(finishedWork.type);\n              console.error(\n                '%s.getSnapshotBeforeUpdate(): A snapshot value (or null) ' +\n                  'must be returned. You have returned undefined.',\n                getComponentNameFromFiber(finishedWork),\n              );\n            }\n          }\n          instance.__reactInternalSnapshotBeforeUpdate = snapshot;\n        }\n        break;\n      }\n      case HostRoot: {\n        if (supportsMutation) {\n          const root = finishedWork.stateNode;\n          clearContainer(root.containerInfo);\n        }\n        break;\n      }\n      case HostComponent:\n      case HostText:\n      case HostPortal:\n      case IncompleteClassComponent:\n        // Nothing to do for these component types\n        break;\n      default: {\n        throw new Error(\n          'This unit of work tag should not have side-effects. This error is ' +\n            'likely caused by a bug in React. Please file an issue.',\n        );\n      }\n    }\n\n    resetCurrentDebugFiberInDEV();\n  }\n}\n\nfunction commitBeforeMutationEffectsDeletion(deletion: Fiber) {\n  if (enableCreateEventHandleAPI) {\n    // TODO (effects) It would be nice to avoid calling doesFiberContain()\n    // Maybe we can repurpose one of the subtreeFlags positions for this instead?\n    // Use it to store which part of the tree the focused instance is in?\n    // This assumes we can safely determine that instance during the \"render\" phase.\n    if (doesFiberContain(deletion, ((focusedInstanceHandle: any): Fiber))) {\n      shouldFireAfterActiveInstanceBlur = true;\n      beforeActiveInstanceBlur(deletion);\n    }\n  }\n}\n\nfunction commitHookEffectListUnmount(\n  flags: HookFlags,\n  finishedWork: Fiber,\n  nearestMountedAncestor: Fiber | null,\n) {\n  const updateQueue: FunctionComponentUpdateQueue | null = (finishedWork.updateQueue: any);\n  const lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;\n  if (lastEffect !== null) {\n    const firstEffect = lastEffect.next;\n    let effect = firstEffect;\n    do {\n      if ((effect.tag & flags) === flags) {\n        // Unmount\n        const destroy = effect.destroy;\n        effect.destroy = undefined;\n        if (destroy !== undefined) {\n          if (enableSchedulingProfiler) {\n            if ((flags & HookPassive) !== NoHookEffect) {\n              markComponentPassiveEffectUnmountStarted(finishedWork);\n            } else if ((flags & HookLayout) !== NoHookEffect) {\n              markComponentLayoutEffectUnmountStarted(finishedWork);\n            }\n          }\n\n          safelyCallDestroy(finishedWork, nearestMountedAncestor, destroy);\n\n          if (enableSchedulingProfiler) {\n            if ((flags & HookPassive) !== NoHookEffect) {\n              markComponentPassiveEffectUnmountStopped();\n            } else if ((flags & HookLayout) !== NoHookEffect) {\n              markComponentLayoutEffectUnmountStopped();\n            }\n          }\n        }\n      }\n      effect = effect.next;\n    } while (effect !== firstEffect);\n  }\n}\n\nfunction commitHookEffectListMount(flags: HookFlags, finishedWork: Fiber) {\n  const updateQueue: FunctionComponentUpdateQueue | null = (finishedWork.updateQueue: any);\n  const lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;\n  if (lastEffect !== null) {\n    const firstEffect = lastEffect.next;\n    let effect = firstEffect;\n    do {\n      if ((effect.tag & flags) === flags) {\n        if (enableSchedulingProfiler) {\n          if ((flags & HookPassive) !== NoHookEffect) {\n            markComponentPassiveEffectMountStarted(finishedWork);\n          } else if ((flags & HookLayout) !== NoHookEffect) {\n            markComponentLayoutEffectMountStarted(finishedWork);\n          }\n        }\n\n        // Mount\n        const create = effect.create;\n        effect.destroy = create();\n\n        if (enableSchedulingProfiler) {\n          if ((flags & HookPassive) !== NoHookEffect) {\n            markComponentPassiveEffectMountStopped();\n          } else if ((flags & HookLayout) !== NoHookEffect) {\n            markComponentLayoutEffectMountStopped();\n          }\n        }\n\n        if (__DEV__) {\n          const destroy = effect.destroy;\n          if (destroy !== undefined && typeof destroy !== 'function') {\n            let hookName;\n            if ((effect.tag & HookLayout) !== NoFlags) {\n              hookName = 'useLayoutEffect';\n            } else if ((effect.tag & HookInsertion) !== NoFlags) {\n              hookName = 'useInsertionEffect';\n            } else {\n              hookName = 'useEffect';\n            }\n            let addendum;\n            if (destroy === null) {\n              addendum =\n                ' You returned null. If your effect does not require clean ' +\n                'up, return undefined (or nothing).';\n            } else if (typeof destroy.then === 'function') {\n              addendum =\n                '\\n\\nIt looks like you wrote ' +\n                hookName +\n                '(async () => ...) or returned a Promise. ' +\n                'Instead, write the async function inside your effect ' +\n                'and call it immediately:\\n\\n' +\n                hookName +\n                '(() => {\\n' +\n                '  async function fetchData() {\\n' +\n                '    // You can await here\\n' +\n                '    const response = await MyAPI.getData(someId);\\n' +\n                '    // ...\\n' +\n                '  }\\n' +\n                '  fetchData();\\n' +\n                `}, [someId]); // Or [] if effect doesn't need props or state\\n\\n` +\n                'Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching';\n            } else {\n              addendum = ' You returned: ' + destroy;\n            }\n            console.error(\n              '%s must not return anything besides a function, ' +\n                'which is used for clean-up.%s',\n              hookName,\n              addendum,\n            );\n          }\n        }\n      }\n      effect = effect.next;\n    } while (effect !== firstEffect);\n  }\n}\n\nexport function commitPassiveEffectDurations(\n  finishedRoot: FiberRoot,\n  finishedWork: Fiber,\n): void {\n  if (enableProfilerTimer && enableProfilerCommitHooks) {\n    // Only Profilers with work in their subtree will have an Update effect scheduled.\n    if ((finishedWork.flags & Update) !== NoFlags) {\n      switch (finishedWork.tag) {\n        case Profiler: {\n          const {passiveEffectDuration} = finishedWork.stateNode;\n          const {id, onPostCommit} = finishedWork.memoizedProps;\n\n          // This value will still reflect the previous commit phase.\n          // It does not get reset until the start of the next commit phase.\n          const commitTime = getCommitTime();\n\n          let phase = finishedWork.alternate === null ? 'mount' : 'update';\n          if (enableProfilerNestedUpdatePhase) {\n            if (isCurrentUpdateNested()) {\n              phase = 'nested-update';\n            }\n          }\n\n          if (typeof onPostCommit === 'function') {\n            onPostCommit(id, phase, passiveEffectDuration, commitTime);\n          }\n\n          // Bubble times to the next nearest ancestor Profiler.\n          // After we process that Profiler, we'll bubble further up.\n          let parentFiber = finishedWork.return;\n          outer: while (parentFiber !== null) {\n            switch (parentFiber.tag) {\n              case HostRoot:\n                const root = parentFiber.stateNode;\n                root.passiveEffectDuration += passiveEffectDuration;\n                break outer;\n              case Profiler:\n                const parentStateNode = parentFiber.stateNode;\n                parentStateNode.passiveEffectDuration += passiveEffectDuration;\n                break outer;\n            }\n            parentFiber = parentFiber.return;\n          }\n          break;\n        }\n        default:\n          break;\n      }\n    }\n  }\n}\n\nfunction commitLayoutEffectOnFiber(\n  finishedRoot: FiberRoot,\n  current: Fiber | null,\n  finishedWork: Fiber,\n  committedLanes: Lanes,\n): void {\n  if ((finishedWork.flags & LayoutMask) !== NoFlags) {\n    switch (finishedWork.tag) {\n      case FunctionComponent:\n      case ForwardRef:\n      case SimpleMemoComponent: {\n        if (\n          !enableSuspenseLayoutEffectSemantics ||\n          !offscreenSubtreeWasHidden\n        ) {\n          // At this point layout effects have already been destroyed (during mutation phase).\n          // This is done to prevent sibling component effects from interfering with each other,\n          // e.g. a destroy function in one component should never override a ref set\n          // by a create function in another component during the same commit.\n          if (\n            enableProfilerTimer &&\n            enableProfilerCommitHooks &&\n            finishedWork.mode & ProfileMode\n          ) {\n            try {\n              startLayoutEffectTimer();\n              commitHookEffectListMount(\n                HookLayout | HookHasEffect,\n                finishedWork,\n              );\n            } finally {\n              recordLayoutEffectDuration(finishedWork);\n            }\n          } else {\n            commitHookEffectListMount(HookLayout | HookHasEffect, finishedWork);\n          }\n        }\n        break;\n      }\n      case ClassComponent: {\n        const instance = finishedWork.stateNode;\n        if (finishedWork.flags & Update) {\n          if (!offscreenSubtreeWasHidden) {\n            if (current === null) {\n              // We could update instance props and state here,\n              // but instead we rely on them being set during last render.\n              // TODO: revisit this when we implement resuming.\n              if (__DEV__) {\n                if (\n                  finishedWork.type === finishedWork.elementType &&\n                  !didWarnAboutReassigningProps\n                ) {\n                  if (instance.props !== finishedWork.memoizedProps) {\n                    console.error(\n                      'Expected %s props to match memoized props before ' +\n                        'componentDidMount. ' +\n                        'This might either be because of a bug in React, or because ' +\n                        'a component reassigns its own `this.props`. ' +\n                        'Please file an issue.',\n                      getComponentNameFromFiber(finishedWork) || 'instance',\n                    );\n                  }\n                  if (instance.state !== finishedWork.memoizedState) {\n                    console.error(\n                      'Expected %s state to match memoized state before ' +\n                        'componentDidMount. ' +\n                        'This might either be because of a bug in React, or because ' +\n                        'a component reassigns its own `this.state`. ' +\n                        'Please file an issue.',\n                      getComponentNameFromFiber(finishedWork) || 'instance',\n                    );\n                  }\n                }\n              }\n              if (\n                enableProfilerTimer &&\n                enableProfilerCommitHooks &&\n                finishedWork.mode & ProfileMode\n              ) {\n                try {\n                  startLayoutEffectTimer();\n                  instance.componentDidMount();\n                } finally {\n                  recordLayoutEffectDuration(finishedWork);\n                }\n              } else {\n                instance.componentDidMount();\n              }\n            } else {\n              const prevProps =\n                finishedWork.elementType === finishedWork.type\n                  ? current.memoizedProps\n                  : resolveDefaultProps(\n                      finishedWork.type,\n                      current.memoizedProps,\n                    );\n              const prevState = current.memoizedState;\n              // We could update instance props and state here,\n              // but instead we rely on them being set during last render.\n              // TODO: revisit this when we implement resuming.\n              if (__DEV__) {\n                if (\n                  finishedWork.type === finishedWork.elementType &&\n                  !didWarnAboutReassigningProps\n                ) {\n                  if (instance.props !== finishedWork.memoizedProps) {\n                    console.error(\n                      'Expected %s props to match memoized props before ' +\n                        'componentDidUpdate. ' +\n                        'This might either be because of a bug in React, or because ' +\n                        'a component reassigns its own `this.props`. ' +\n                        'Please file an issue.',\n                      getComponentNameFromFiber(finishedWork) || 'instance',\n                    );\n                  }\n                  if (instance.state !== finishedWork.memoizedState) {\n                    console.error(\n                      'Expected %s state to match memoized state before ' +\n                        'componentDidUpdate. ' +\n                        'This might either be because of a bug in React, or because ' +\n                        'a component reassigns its own `this.state`. ' +\n                        'Please file an issue.',\n                      getComponentNameFromFiber(finishedWork) || 'instance',\n                    );\n                  }\n                }\n              }\n              if (\n                enableProfilerTimer &&\n                enableProfilerCommitHooks &&\n                finishedWork.mode & ProfileMode\n              ) {\n                try {\n                  startLayoutEffectTimer();\n                  instance.componentDidUpdate(\n                    prevProps,\n                    prevState,\n                    instance.__reactInternalSnapshotBeforeUpdate,\n                  );\n                } finally {\n                  recordLayoutEffectDuration(finishedWork);\n                }\n              } else {\n                instance.componentDidUpdate(\n                  prevProps,\n                  prevState,\n                  instance.__reactInternalSnapshotBeforeUpdate,\n                );\n              }\n            }\n          }\n        }\n\n        // TODO: I think this is now always non-null by the time it reaches the\n        // commit phase. Consider removing the type check.\n        const updateQueue: UpdateQueue<\n          *,\n        > | null = (finishedWork.updateQueue: any);\n        if (updateQueue !== null) {\n          if (__DEV__) {\n            if (\n              finishedWork.type === finishedWork.elementType &&\n              !didWarnAboutReassigningProps\n            ) {\n              if (instance.props !== finishedWork.memoizedProps) {\n                console.error(\n                  'Expected %s props to match memoized props before ' +\n                    'processing the update queue. ' +\n                    'This might either be because of a bug in React, or because ' +\n                    'a component reassigns its own `this.props`. ' +\n                    'Please file an issue.',\n                  getComponentNameFromFiber(finishedWork) || 'instance',\n                );\n              }\n              if (instance.state !== finishedWork.memoizedState) {\n                console.error(\n                  'Expected %s state to match memoized state before ' +\n                    'processing the update queue. ' +\n                    'This might either be because of a bug in React, or because ' +\n                    'a component reassigns its own `this.state`. ' +\n                    'Please file an issue.',\n                  getComponentNameFromFiber(finishedWork) || 'instance',\n                );\n              }\n            }\n          }\n          // We could update instance props and state here,\n          // but instead we rely on them being set during last render.\n          // TODO: revisit this when we implement resuming.\n          commitUpdateQueue(finishedWork, updateQueue, instance);\n        }\n        break;\n      }\n      case HostRoot: {\n        // TODO: I think this is now always non-null by the time it reaches the\n        // commit phase. Consider removing the type check.\n        const updateQueue: UpdateQueue<\n          *,\n        > | null = (finishedWork.updateQueue: any);\n        if (updateQueue !== null) {\n          let instance = null;\n          if (finishedWork.child !== null) {\n            switch (finishedWork.child.tag) {\n              case HostComponent:\n                instance = getPublicInstance(finishedWork.child.stateNode);\n                break;\n              case ClassComponent:\n                instance = finishedWork.child.stateNode;\n                break;\n            }\n          }\n          commitUpdateQueue(finishedWork, updateQueue, instance);\n        }\n        break;\n      }\n      case HostComponent: {\n        const instance: Instance = finishedWork.stateNode;\n\n        // Renderers may schedule work to be done after host components are mounted\n        // (eg DOM renderer may schedule auto-focus for inputs and form controls).\n        // These effects should only be committed when components are first mounted,\n        // aka when there is no current/alternate.\n        if (current === null && finishedWork.flags & Update) {\n          const type = finishedWork.type;\n          const props = finishedWork.memoizedProps;\n          commitMount(instance, type, props, finishedWork);\n        }\n\n        break;\n      }\n      case HostText: {\n        // We have no life-cycles associated with text.\n        break;\n      }\n      case HostPortal: {\n        // We have no life-cycles associated with portals.\n        break;\n      }\n      case Profiler: {\n        if (enableProfilerTimer) {\n          const {onCommit, onRender} = finishedWork.memoizedProps;\n          const {effectDuration} = finishedWork.stateNode;\n\n          const commitTime = getCommitTime();\n\n          let phase = current === null ? 'mount' : 'update';\n          if (enableProfilerNestedUpdatePhase) {\n            if (isCurrentUpdateNested()) {\n              phase = 'nested-update';\n            }\n          }\n\n          if (typeof onRender === 'function') {\n            onRender(\n              finishedWork.memoizedProps.id,\n              phase,\n              finishedWork.actualDuration,\n              finishedWork.treeBaseDuration,\n              finishedWork.actualStartTime,\n              commitTime,\n            );\n          }\n\n          if (enableProfilerCommitHooks) {\n            if (typeof onCommit === 'function') {\n              onCommit(\n                finishedWork.memoizedProps.id,\n                phase,\n                effectDuration,\n                commitTime,\n              );\n            }\n\n            // Schedule a passive effect for this Profiler to call onPostCommit hooks.\n            // This effect should be scheduled even if there is no onPostCommit callback for this Profiler,\n            // because the effect is also where times bubble to parent Profilers.\n            enqueuePendingPassiveProfilerEffect(finishedWork);\n\n            // Propagate layout effect durations to the next nearest Profiler ancestor.\n            // Do not reset these values until the next render so DevTools has a chance to read them first.\n            let parentFiber = finishedWork.return;\n            outer: while (parentFiber !== null) {\n              switch (parentFiber.tag) {\n                case HostRoot:\n                  const root = parentFiber.stateNode;\n                  root.effectDuration += effectDuration;\n                  break outer;\n                case Profiler:\n                  const parentStateNode = parentFiber.stateNode;\n                  parentStateNode.effectDuration += effectDuration;\n                  break outer;\n              }\n              parentFiber = parentFiber.return;\n            }\n          }\n        }\n        break;\n      }\n      case SuspenseComponent: {\n        commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);\n        break;\n      }\n      case SuspenseListComponent:\n      case IncompleteClassComponent:\n      case ScopeComponent:\n      case OffscreenComponent:\n      case LegacyHiddenComponent:\n        break;\n      default:\n        throw new Error(\n          'This unit of work tag should not have side-effects. This error is ' +\n            'likely caused by a bug in React. Please file an issue.',\n        );\n    }\n  }\n\n  if (!enableSuspenseLayoutEffectSemantics || !offscreenSubtreeWasHidden) {\n    if (enableScopeAPI) {\n      // TODO: This is a temporary solution that allowed us to transition away\n      // from React Flare on www.\n      if (finishedWork.flags & Ref && finishedWork.tag !== ScopeComponent) {\n        commitAttachRef(finishedWork);\n      }\n    } else {\n      if (finishedWork.flags & Ref) {\n        commitAttachRef(finishedWork);\n      }\n    }\n  }\n}\n\nfunction reappearLayoutEffectsOnFiber(node: Fiber) {\n  // Turn on layout effects in a tree that previously disappeared.\n  // TODO (Offscreen) Check: flags & LayoutStatic\n  switch (node.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case SimpleMemoComponent: {\n      if (\n        enableProfilerTimer &&\n        enableProfilerCommitHooks &&\n        node.mode & ProfileMode\n      ) {\n        try {\n          startLayoutEffectTimer();\n          safelyCallCommitHookLayoutEffectListMount(node, node.return);\n        } finally {\n          recordLayoutEffectDuration(node);\n        }\n      } else {\n        safelyCallCommitHookLayoutEffectListMount(node, node.return);\n      }\n      break;\n    }\n    case ClassComponent: {\n      const instance = node.stateNode;\n      if (typeof instance.componentDidMount === 'function') {\n        safelyCallComponentDidMount(node, node.return, instance);\n      }\n      safelyAttachRef(node, node.return);\n      break;\n    }\n    case HostComponent: {\n      safelyAttachRef(node, node.return);\n      break;\n    }\n  }\n}\n\nfunction hideOrUnhideAllChildren(finishedWork, isHidden) {\n  // Only hide or unhide the top-most host nodes.\n  let hostSubtreeRoot = null;\n\n  if (supportsMutation) {\n    // We only have the top Fiber that was inserted but we need to recurse down its\n    // children to find all the terminal nodes.\n    let node: Fiber = finishedWork;\n    while (true) {\n      if (node.tag === HostComponent) {\n        if (hostSubtreeRoot === null) {\n          hostSubtreeRoot = node;\n\n          const instance = node.stateNode;\n          if (isHidden) {\n            hideInstance(instance);\n          } else {\n            unhideInstance(node.stateNode, node.memoizedProps);\n          }\n        }\n      } else if (node.tag === HostText) {\n        if (hostSubtreeRoot === null) {\n          const instance = node.stateNode;\n          if (isHidden) {\n            hideTextInstance(instance);\n          } else {\n            unhideTextInstance(instance, node.memoizedProps);\n          }\n        }\n      } else if (\n        (node.tag === OffscreenComponent ||\n          node.tag === LegacyHiddenComponent) &&\n        (node.memoizedState: OffscreenState) !== null &&\n        node !== finishedWork\n      ) {\n        // Found a nested Offscreen component that is hidden.\n        // Don't search any deeper. This tree should remain hidden.\n      } else if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n\n      if (node === finishedWork) {\n        return;\n      }\n      while (node.sibling === null) {\n        if (node.return === null || node.return === finishedWork) {\n          return;\n        }\n\n        if (hostSubtreeRoot === node) {\n          hostSubtreeRoot = null;\n        }\n\n        node = node.return;\n      }\n\n      if (hostSubtreeRoot === node) {\n        hostSubtreeRoot = null;\n      }\n\n      node.sibling.return = node.return;\n      node = node.sibling;\n    }\n  }\n}\n\nfunction commitAttachRef(finishedWork: Fiber) {\n  const ref = finishedWork.ref;\n  if (ref !== null) {\n    const instance = finishedWork.stateNode;\n    let instanceToUse;\n    switch (finishedWork.tag) {\n      case HostComponent:\n        instanceToUse = getPublicInstance(instance);\n        break;\n      default:\n        instanceToUse = instance;\n    }\n    // Moved outside to ensure DCE works with this flag\n    if (enableScopeAPI && finishedWork.tag === ScopeComponent) {\n      instanceToUse = instance;\n    }\n    if (typeof ref === 'function') {\n      let retVal;\n      if (\n        enableProfilerTimer &&\n        enableProfilerCommitHooks &&\n        finishedWork.mode & ProfileMode\n      ) {\n        try {\n          startLayoutEffectTimer();\n          retVal = ref(instanceToUse);\n        } finally {\n          recordLayoutEffectDuration(finishedWork);\n        }\n      } else {\n        retVal = ref(instanceToUse);\n      }\n      if (__DEV__) {\n        if (\n          warnAboutCallbackRefReturningFunction &&\n          typeof retVal === 'function'\n        ) {\n          console.error(\n            'Unexpected return value from a callback ref in %s. ' +\n              'A callback ref should not return a function.',\n            getComponentNameFromFiber(finishedWork),\n          );\n        }\n      }\n    } else {\n      if (__DEV__) {\n        if (!ref.hasOwnProperty('current')) {\n          console.error(\n            'Unexpected ref object provided for %s. ' +\n              'Use either a ref-setter function or React.createRef().',\n            getComponentNameFromFiber(finishedWork),\n          );\n        }\n      }\n\n      ref.current = instanceToUse;\n    }\n  }\n}\n\nfunction commitDetachRef(current: Fiber) {\n  const currentRef = current.ref;\n  if (currentRef !== null) {\n    if (typeof currentRef === 'function') {\n      if (\n        enableProfilerTimer &&\n        enableProfilerCommitHooks &&\n        current.mode & ProfileMode\n      ) {\n        try {\n          startLayoutEffectTimer();\n          currentRef(null);\n        } finally {\n          recordLayoutEffectDuration(current);\n        }\n      } else {\n        currentRef(null);\n      }\n    } else {\n      currentRef.current = null;\n    }\n  }\n}\n\n// User-originating errors (lifecycles and refs) should not interrupt\n// deletion, so don't let them throw. Host-originating errors should\n// interrupt deletion, so it's okay\nfunction commitUnmount(\n  finishedRoot: FiberRoot,\n  current: Fiber,\n  nearestMountedAncestor: Fiber,\n): void {\n  onCommitUnmount(current);\n\n  switch (current.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case MemoComponent:\n    case SimpleMemoComponent: {\n      const updateQueue: FunctionComponentUpdateQueue | null = (current.updateQueue: any);\n      if (updateQueue !== null) {\n        const lastEffect = updateQueue.lastEffect;\n        if (lastEffect !== null) {\n          const firstEffect = lastEffect.next;\n\n          let effect = firstEffect;\n          do {\n            const {destroy, tag} = effect;\n            if (destroy !== undefined) {\n              if ((tag & HookInsertion) !== NoHookEffect) {\n                safelyCallDestroy(current, nearestMountedAncestor, destroy);\n              } else if ((tag & HookLayout) !== NoHookEffect) {\n                if (enableSchedulingProfiler) {\n                  markComponentLayoutEffectUnmountStarted(current);\n                }\n\n                if (\n                  enableProfilerTimer &&\n                  enableProfilerCommitHooks &&\n                  current.mode & ProfileMode\n                ) {\n                  startLayoutEffectTimer();\n                  safelyCallDestroy(current, nearestMountedAncestor, destroy);\n                  recordLayoutEffectDuration(current);\n                } else {\n                  safelyCallDestroy(current, nearestMountedAncestor, destroy);\n                }\n\n                if (enableSchedulingProfiler) {\n                  markComponentLayoutEffectUnmountStopped();\n                }\n              }\n            }\n            effect = effect.next;\n          } while (effect !== firstEffect);\n        }\n      }\n      return;\n    }\n    case ClassComponent: {\n      safelyDetachRef(current, nearestMountedAncestor);\n      const instance = current.stateNode;\n      if (typeof instance.componentWillUnmount === 'function') {\n        safelyCallComponentWillUnmount(\n          current,\n          nearestMountedAncestor,\n          instance,\n        );\n      }\n      return;\n    }\n    case HostComponent: {\n      safelyDetachRef(current, nearestMountedAncestor);\n      return;\n    }\n    case HostPortal: {\n      // TODO: this is recursive.\n      // We are also not using this parent because\n      // the portal will get pushed immediately.\n      if (supportsMutation) {\n        unmountHostComponents(finishedRoot, current, nearestMountedAncestor);\n      } else if (supportsPersistence) {\n        emptyPortalContainer(current);\n      }\n      return;\n    }\n    case DehydratedFragment: {\n      if (enableSuspenseCallback) {\n        const hydrationCallbacks = finishedRoot.hydrationCallbacks;\n        if (hydrationCallbacks !== null) {\n          const onDeleted = hydrationCallbacks.onDeleted;\n          if (onDeleted) {\n            onDeleted((current.stateNode: SuspenseInstance));\n          }\n        }\n      }\n      return;\n    }\n    case ScopeComponent: {\n      if (enableScopeAPI) {\n        safelyDetachRef(current, nearestMountedAncestor);\n      }\n      return;\n    }\n  }\n}\n\nfunction commitNestedUnmounts(\n  finishedRoot: FiberRoot,\n  root: Fiber,\n  nearestMountedAncestor: Fiber,\n): void {\n  // While we're inside a removed host node we don't want to call\n  // removeChild on the inner nodes because they're removed by the top\n  // call anyway. We also want to call componentWillUnmount on all\n  // composites before this host node is removed from the tree. Therefore\n  // we do an inner loop while we're still inside the host node.\n  let node: Fiber = root;\n  while (true) {\n    commitUnmount(finishedRoot, node, nearestMountedAncestor);\n    // Visit children because they may contain more composite or host nodes.\n    // Skip portals because commitUnmount() currently visits them recursively.\n    if (\n      node.child !== null &&\n      // If we use mutation we drill down into portals using commitUnmount above.\n      // If we don't use mutation we drill down into portals here instead.\n      (!supportsMutation || node.tag !== HostPortal)\n    ) {\n      node.child.return = node;\n      node = node.child;\n      continue;\n    }\n    if (node === root) {\n      return;\n    }\n    while (node.sibling === null) {\n      if (node.return === null || node.return === root) {\n        return;\n      }\n      node = node.return;\n    }\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n}\n\nfunction detachFiberMutation(fiber: Fiber) {\n  // Cut off the return pointer to disconnect it from the tree.\n  // This enables us to detect and warn against state updates on an unmounted component.\n  // It also prevents events from bubbling from within disconnected components.\n  //\n  // Ideally, we should also clear the child pointer of the parent alternate to let this\n  // get GC:ed but we don't know which for sure which parent is the current\n  // one so we'll settle for GC:ing the subtree of this child.\n  // This child itself will be GC:ed when the parent updates the next time.\n  //\n  // Note that we can't clear child or sibling pointers yet.\n  // They're needed for passive effects and for findDOMNode.\n  // We defer those fields, and all other cleanup, to the passive phase (see detachFiberAfterEffects).\n  //\n  // Don't reset the alternate yet, either. We need that so we can detach the\n  // alternate's fields in the passive phase. Clearing the return pointer is\n  // sufficient for findDOMNode semantics.\n  const alternate = fiber.alternate;\n  if (alternate !== null) {\n    alternate.return = null;\n  }\n  fiber.return = null;\n}\n\nfunction detachFiberAfterEffects(fiber: Fiber) {\n  const alternate = fiber.alternate;\n  if (alternate !== null) {\n    fiber.alternate = null;\n    detachFiberAfterEffects(alternate);\n  }\n\n  // Note: Defensively using negation instead of < in case\n  // `deletedTreeCleanUpLevel` is undefined.\n  if (!(deletedTreeCleanUpLevel >= 2)) {\n    // This is the default branch (level 0).\n    fiber.child = null;\n    fiber.deletions = null;\n    fiber.dependencies = null;\n    fiber.memoizedProps = null;\n    fiber.memoizedState = null;\n    fiber.pendingProps = null;\n    fiber.sibling = null;\n    fiber.stateNode = null;\n    fiber.updateQueue = null;\n\n    if (__DEV__) {\n      fiber._debugOwner = null;\n    }\n  } else {\n    // Clear cyclical Fiber fields. This level alone is designed to roughly\n    // approximate the planned Fiber refactor. In that world, `setState` will be\n    // bound to a special \"instance\" object instead of a Fiber. The Instance\n    // object will not have any of these fields. It will only be connected to\n    // the fiber tree via a single link at the root. So if this level alone is\n    // sufficient to fix memory issues, that bodes well for our plans.\n    fiber.child = null;\n    fiber.deletions = null;\n    fiber.sibling = null;\n\n    // The `stateNode` is cyclical because on host nodes it points to the host\n    // tree, which has its own pointers to children, parents, and siblings.\n    // The other host nodes also point back to fibers, so we should detach that\n    // one, too.\n    if (fiber.tag === HostComponent) {\n      const hostInstance: Instance = fiber.stateNode;\n      if (hostInstance !== null) {\n        detachDeletedInstance(hostInstance);\n      }\n    }\n    fiber.stateNode = null;\n\n    // I'm intentionally not clearing the `return` field in this level. We\n    // already disconnect the `return` pointer at the root of the deleted\n    // subtree (in `detachFiberMutation`). Besides, `return` by itself is not\n    // cyclical — it's only cyclical when combined with `child`, `sibling`, and\n    // `alternate`. But we'll clear it in the next level anyway, just in case.\n\n    if (__DEV__) {\n      fiber._debugOwner = null;\n    }\n\n    if (deletedTreeCleanUpLevel >= 3) {\n      // Theoretically, nothing in here should be necessary, because we already\n      // disconnected the fiber from the tree. So even if something leaks this\n      // particular fiber, it won't leak anything else\n      //\n      // The purpose of this branch is to be super aggressive so we can measure\n      // if there's any difference in memory impact. If there is, that could\n      // indicate a React leak we don't know about.\n      fiber.return = null;\n      fiber.dependencies = null;\n      fiber.memoizedProps = null;\n      fiber.memoizedState = null;\n      fiber.pendingProps = null;\n      fiber.stateNode = null;\n      // TODO: Move to `commitPassiveUnmountInsideDeletedTreeOnFiber` instead.\n      fiber.updateQueue = null;\n    }\n  }\n}\n\nfunction emptyPortalContainer(current: Fiber) {\n  if (!supportsPersistence) {\n    return;\n  }\n\n  const portal: {\n    containerInfo: Container,\n    pendingChildren: ChildSet,\n    ...\n  } = current.stateNode;\n  const {containerInfo} = portal;\n  const emptyChildSet = createContainerChildSet(containerInfo);\n  replaceContainerChildren(containerInfo, emptyChildSet);\n}\n\nfunction commitContainer(finishedWork: Fiber) {\n  if (!supportsPersistence) {\n    return;\n  }\n\n  switch (finishedWork.tag) {\n    case ClassComponent:\n    case HostComponent:\n    case HostText: {\n      return;\n    }\n    case HostRoot:\n    case HostPortal: {\n      const portalOrRoot: {\n        containerInfo: Container,\n        pendingChildren: ChildSet,\n        ...\n      } = finishedWork.stateNode;\n      const {containerInfo, pendingChildren} = portalOrRoot;\n      replaceContainerChildren(containerInfo, pendingChildren);\n      return;\n    }\n  }\n\n  throw new Error(\n    'This unit of work tag should not have side-effects. This error is ' +\n      'likely caused by a bug in React. Please file an issue.',\n  );\n}\n\nfunction getHostParentFiber(fiber: Fiber): Fiber {\n  let parent = fiber.return;\n  while (parent !== null) {\n    if (isHostParent(parent)) {\n      return parent;\n    }\n    parent = parent.return;\n  }\n\n  throw new Error(\n    'Expected to find a host parent. This error is likely caused by a bug ' +\n      'in React. Please file an issue.',\n  );\n}\n\nfunction isHostParent(fiber: Fiber): boolean {\n  return (\n    fiber.tag === HostComponent ||\n    fiber.tag === HostRoot ||\n    fiber.tag === HostPortal\n  );\n}\n\nfunction getHostSibling(fiber: Fiber): ?Instance {\n  // We're going to search forward into the tree until we find a sibling host\n  // node. Unfortunately, if multiple insertions are done in a row we have to\n  // search past them. This leads to exponential search for the next sibling.\n  // TODO: Find a more efficient way to do this.\n  let node: Fiber = fiber;\n  siblings: while (true) {\n    // If we didn't find anything, let's try the next sibling.\n    while (node.sibling === null) {\n      if (node.return === null || isHostParent(node.return)) {\n        // If we pop out of the root or hit the parent the fiber we are the\n        // last sibling.\n        return null;\n      }\n      node = node.return;\n    }\n    node.sibling.return = node.return;\n    node = node.sibling;\n    while (\n      node.tag !== HostComponent &&\n      node.tag !== HostText &&\n      node.tag !== DehydratedFragment\n    ) {\n      // If it is not host node and, we might have a host node inside it.\n      // Try to search down until we find one.\n      if (node.flags & Placement) {\n        // If we don't have a child, try the siblings instead.\n        continue siblings;\n      }\n      // If we don't have a child, try the siblings instead.\n      // We also skip portals because they are not part of this host tree.\n      if (node.child === null || node.tag === HostPortal) {\n        continue siblings;\n      } else {\n        node.child.return = node;\n        node = node.child;\n      }\n    }\n    // Check if this host node is stable or about to be placed.\n    if (!(node.flags & Placement)) {\n      // Found it!\n      return node.stateNode;\n    }\n  }\n}\n\nfunction commitPlacement(finishedWork: Fiber): void {\n  if (!supportsMutation) {\n    return;\n  }\n\n  // Recursively insert all host nodes into the parent.\n  const parentFiber = getHostParentFiber(finishedWork);\n\n  // Note: these two variables *must* always be updated together.\n  let parent;\n  let isContainer;\n  const parentStateNode = parentFiber.stateNode;\n  switch (parentFiber.tag) {\n    case HostComponent:\n      parent = parentStateNode;\n      isContainer = false;\n      break;\n    case HostRoot:\n      parent = parentStateNode.containerInfo;\n      isContainer = true;\n      break;\n    case HostPortal:\n      parent = parentStateNode.containerInfo;\n      isContainer = true;\n      break;\n    // eslint-disable-next-line-no-fallthrough\n    default:\n      throw new Error(\n        'Invalid host parent fiber. This error is likely caused by a bug ' +\n          'in React. Please file an issue.',\n      );\n  }\n  if (parentFiber.flags & ContentReset) {\n    // Reset the text content of the parent before doing any insertions\n    resetTextContent(parent);\n    // Clear ContentReset from the effect tag\n    parentFiber.flags &= ~ContentReset;\n  }\n\n  const before = getHostSibling(finishedWork);\n  // We only have the top Fiber that was inserted but we need to recurse down its\n  // children to find all the terminal nodes.\n  if (isContainer) {\n    insertOrAppendPlacementNodeIntoContainer(finishedWork, before, parent);\n  } else {\n    insertOrAppendPlacementNode(finishedWork, before, parent);\n  }\n}\n\nfunction insertOrAppendPlacementNodeIntoContainer(\n  node: Fiber,\n  before: ?Instance,\n  parent: Container,\n): void {\n  const {tag} = node;\n  const isHost = tag === HostComponent || tag === HostText;\n  if (isHost) {\n    const stateNode = node.stateNode;\n    if (before) {\n      insertInContainerBefore(parent, stateNode, before);\n    } else {\n      appendChildToContainer(parent, stateNode);\n    }\n  } else if (tag === HostPortal) {\n    // If the insertion itself is a portal, then we don't want to traverse\n    // down its children. Instead, we'll get insertions from each child in\n    // the portal directly.\n  } else {\n    const child = node.child;\n    if (child !== null) {\n      insertOrAppendPlacementNodeIntoContainer(child, before, parent);\n      let sibling = child.sibling;\n      while (sibling !== null) {\n        insertOrAppendPlacementNodeIntoContainer(sibling, before, parent);\n        sibling = sibling.sibling;\n      }\n    }\n  }\n}\n\nfunction insertOrAppendPlacementNode(\n  node: Fiber,\n  before: ?Instance,\n  parent: Instance,\n): void {\n  const {tag} = node;\n  const isHost = tag === HostComponent || tag === HostText;\n  if (isHost) {\n    const stateNode = node.stateNode;\n    if (before) {\n      insertBefore(parent, stateNode, before);\n    } else {\n      appendChild(parent, stateNode);\n    }\n  } else if (tag === HostPortal) {\n    // If the insertion itself is a portal, then we don't want to traverse\n    // down its children. Instead, we'll get insertions from each child in\n    // the portal directly.\n  } else {\n    const child = node.child;\n    if (child !== null) {\n      insertOrAppendPlacementNode(child, before, parent);\n      let sibling = child.sibling;\n      while (sibling !== null) {\n        insertOrAppendPlacementNode(sibling, before, parent);\n        sibling = sibling.sibling;\n      }\n    }\n  }\n}\n\nfunction unmountHostComponents(\n  finishedRoot: FiberRoot,\n  current: Fiber,\n  nearestMountedAncestor: Fiber,\n): void {\n  // We only have the top Fiber that was deleted but we need to recurse down its\n  // children to find all the terminal nodes.\n  let node: Fiber = current;\n\n  // Each iteration, currentParent is populated with node's host parent if not\n  // currentParentIsValid.\n  let currentParentIsValid = false;\n\n  // Note: these two variables *must* always be updated together.\n  let currentParent;\n  let currentParentIsContainer;\n\n  while (true) {\n    if (!currentParentIsValid) {\n      let parent = node.return;\n      findParent: while (true) {\n        if (parent === null) {\n          throw new Error(\n            'Expected to find a host parent. This error is likely caused by ' +\n              'a bug in React. Please file an issue.',\n          );\n        }\n\n        const parentStateNode = parent.stateNode;\n        switch (parent.tag) {\n          case HostComponent:\n            currentParent = parentStateNode;\n            currentParentIsContainer = false;\n            break findParent;\n          case HostRoot:\n            currentParent = parentStateNode.containerInfo;\n            currentParentIsContainer = true;\n            break findParent;\n          case HostPortal:\n            currentParent = parentStateNode.containerInfo;\n            currentParentIsContainer = true;\n            break findParent;\n        }\n        parent = parent.return;\n      }\n      currentParentIsValid = true;\n    }\n\n    if (node.tag === HostComponent || node.tag === HostText) {\n      commitNestedUnmounts(finishedRoot, node, nearestMountedAncestor);\n      // After all the children have unmounted, it is now safe to remove the\n      // node from the tree.\n      if (currentParentIsContainer) {\n        removeChildFromContainer(\n          ((currentParent: any): Container),\n          (node.stateNode: Instance | TextInstance),\n        );\n      } else {\n        removeChild(\n          ((currentParent: any): Instance),\n          (node.stateNode: Instance | TextInstance),\n        );\n      }\n      // Don't visit children because we already visited them.\n    } else if (\n      enableSuspenseServerRenderer &&\n      node.tag === DehydratedFragment\n    ) {\n      if (enableSuspenseCallback) {\n        const hydrationCallbacks = finishedRoot.hydrationCallbacks;\n        if (hydrationCallbacks !== null) {\n          const onDeleted = hydrationCallbacks.onDeleted;\n          if (onDeleted) {\n            onDeleted((node.stateNode: SuspenseInstance));\n          }\n        }\n      }\n\n      // Delete the dehydrated suspense boundary and all of its content.\n      if (currentParentIsContainer) {\n        clearSuspenseBoundaryFromContainer(\n          ((currentParent: any): Container),\n          (node.stateNode: SuspenseInstance),\n        );\n      } else {\n        clearSuspenseBoundary(\n          ((currentParent: any): Instance),\n          (node.stateNode: SuspenseInstance),\n        );\n      }\n    } else if (node.tag === HostPortal) {\n      if (node.child !== null) {\n        // When we go into a portal, it becomes the parent to remove from.\n        // We will reassign it back when we pop the portal on the way up.\n        currentParent = node.stateNode.containerInfo;\n        currentParentIsContainer = true;\n        // Visit children because portals might contain host components.\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n    } else {\n      commitUnmount(finishedRoot, node, nearestMountedAncestor);\n      // Visit children because we may find more host components below.\n      if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n    }\n    if (node === current) {\n      return;\n    }\n    while (node.sibling === null) {\n      if (node.return === null || node.return === current) {\n        return;\n      }\n      node = node.return;\n      if (node.tag === HostPortal) {\n        // When we go out of the portal, we need to restore the parent.\n        // Since we don't keep a stack of them, we will search for it.\n        currentParentIsValid = false;\n      }\n    }\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n}\n\nfunction commitDeletion(\n  finishedRoot: FiberRoot,\n  current: Fiber,\n  nearestMountedAncestor: Fiber,\n): void {\n  if (supportsMutation) {\n    // Recursively delete all host nodes from the parent.\n    // Detach refs and call componentWillUnmount() on the whole subtree.\n    unmountHostComponents(finishedRoot, current, nearestMountedAncestor);\n  } else {\n    // Detach refs and call componentWillUnmount() on the whole subtree.\n    commitNestedUnmounts(finishedRoot, current, nearestMountedAncestor);\n  }\n\n  detachFiberMutation(current);\n}\n\nfunction commitWork(current: Fiber | null, finishedWork: Fiber): void {\n  if (!supportsMutation) {\n    switch (finishedWork.tag) {\n      case FunctionComponent:\n      case ForwardRef:\n      case MemoComponent:\n      case SimpleMemoComponent: {\n        commitHookEffectListUnmount(\n          HookInsertion | HookHasEffect,\n          finishedWork,\n          finishedWork.return,\n        );\n        commitHookEffectListMount(HookInsertion | HookHasEffect, finishedWork);\n\n        // Layout effects are destroyed during the mutation phase so that all\n        // destroy functions for all fibers are called before any create functions.\n        // This prevents sibling component effects from interfering with each other,\n        // e.g. a destroy function in one component should never override a ref set\n        // by a create function in another component during the same commit.\n        // TODO: Check if we're inside an Offscreen subtree that disappeared\n        // during this commit. If so, we would have already unmounted its\n        // layout hooks. (However, since we null out the `destroy` function\n        // right before calling it, the behavior is already correct, so this\n        // would mostly be for modeling purposes.)\n        if (\n          enableProfilerTimer &&\n          enableProfilerCommitHooks &&\n          finishedWork.mode & ProfileMode\n        ) {\n          try {\n            startLayoutEffectTimer();\n            commitHookEffectListUnmount(\n              HookLayout | HookHasEffect,\n              finishedWork,\n              finishedWork.return,\n            );\n          } finally {\n            recordLayoutEffectDuration(finishedWork);\n          }\n        } else {\n          commitHookEffectListUnmount(\n            HookLayout | HookHasEffect,\n            finishedWork,\n            finishedWork.return,\n          );\n        }\n        return;\n      }\n      case Profiler: {\n        return;\n      }\n      case SuspenseComponent: {\n        commitSuspenseCallback(finishedWork);\n        attachSuspenseRetryListeners(finishedWork);\n        return;\n      }\n      case SuspenseListComponent: {\n        attachSuspenseRetryListeners(finishedWork);\n        return;\n      }\n      case HostRoot: {\n        if (supportsHydration) {\n          const root: FiberRoot = finishedWork.stateNode;\n          if (root.isDehydrated) {\n            // We've just hydrated. No need to hydrate again.\n            root.isDehydrated = false;\n            commitHydratedContainer(root.containerInfo);\n          }\n        }\n        break;\n      }\n      case OffscreenComponent:\n      case LegacyHiddenComponent: {\n        return;\n      }\n    }\n\n    commitContainer(finishedWork);\n    return;\n  }\n\n  switch (finishedWork.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case MemoComponent:\n    case SimpleMemoComponent: {\n      commitHookEffectListUnmount(\n        HookInsertion | HookHasEffect,\n        finishedWork,\n        finishedWork.return,\n      );\n      commitHookEffectListMount(HookInsertion | HookHasEffect, finishedWork);\n      // Layout effects are destroyed during the mutation phase so that all\n      // destroy functions for all fibers are called before any create functions.\n      // This prevents sibling component effects from interfering with each other,\n      // e.g. a destroy function in one component should never override a ref set\n      // by a create function in another component during the same commit.\n      if (\n        enableProfilerTimer &&\n        enableProfilerCommitHooks &&\n        finishedWork.mode & ProfileMode\n      ) {\n        try {\n          startLayoutEffectTimer();\n          commitHookEffectListUnmount(\n            HookLayout | HookHasEffect,\n            finishedWork,\n            finishedWork.return,\n          );\n        } finally {\n          recordLayoutEffectDuration(finishedWork);\n        }\n      } else {\n        commitHookEffectListUnmount(\n          HookLayout | HookHasEffect,\n          finishedWork,\n          finishedWork.return,\n        );\n      }\n      return;\n    }\n    case ClassComponent: {\n      return;\n    }\n    case HostComponent: {\n      const instance: Instance = finishedWork.stateNode;\n      if (instance != null) {\n        // Commit the work prepared earlier.\n        const newProps = finishedWork.memoizedProps;\n        // For hydration we reuse the update path but we treat the oldProps\n        // as the newProps. The updatePayload will contain the real change in\n        // this case.\n        const oldProps = current !== null ? current.memoizedProps : newProps;\n        const type = finishedWork.type;\n        // TODO: Type the updateQueue to be specific to host components.\n        const updatePayload: null | UpdatePayload = (finishedWork.updateQueue: any);\n        finishedWork.updateQueue = null;\n        if (updatePayload !== null) {\n          commitUpdate(\n            instance,\n            updatePayload,\n            type,\n            oldProps,\n            newProps,\n            finishedWork,\n          );\n        }\n      }\n      return;\n    }\n    case HostText: {\n      if (finishedWork.stateNode === null) {\n        throw new Error(\n          'This should have a text node initialized. This error is likely ' +\n            'caused by a bug in React. Please file an issue.',\n        );\n      }\n\n      const textInstance: TextInstance = finishedWork.stateNode;\n      const newText: string = finishedWork.memoizedProps;\n      // For hydration we reuse the update path but we treat the oldProps\n      // as the newProps. The updatePayload will contain the real change in\n      // this case.\n      const oldText: string =\n        current !== null ? current.memoizedProps : newText;\n      commitTextUpdate(textInstance, oldText, newText);\n      return;\n    }\n    case HostRoot: {\n      if (supportsHydration) {\n        const root: FiberRoot = finishedWork.stateNode;\n        if (root.isDehydrated) {\n          // We've just hydrated. No need to hydrate again.\n          root.isDehydrated = false;\n          commitHydratedContainer(root.containerInfo);\n        }\n      }\n      return;\n    }\n    case Profiler: {\n      return;\n    }\n    case SuspenseComponent: {\n      commitSuspenseCallback(finishedWork);\n      attachSuspenseRetryListeners(finishedWork);\n      return;\n    }\n    case SuspenseListComponent: {\n      attachSuspenseRetryListeners(finishedWork);\n      return;\n    }\n    case IncompleteClassComponent: {\n      return;\n    }\n    case ScopeComponent: {\n      if (enableScopeAPI) {\n        const scopeInstance = finishedWork.stateNode;\n        prepareScopeUpdate(scopeInstance, finishedWork);\n        return;\n      }\n      break;\n    }\n  }\n\n  throw new Error(\n    'This unit of work tag should not have side-effects. This error is ' +\n      'likely caused by a bug in React. Please file an issue.',\n  );\n}\n\nfunction commitSuspenseCallback(finishedWork: Fiber) {\n  // TODO: Move this to passive phase\n  const newState: SuspenseState | null = finishedWork.memoizedState;\n  if (enableSuspenseCallback && newState !== null) {\n    const suspenseCallback = finishedWork.memoizedProps.suspenseCallback;\n    if (typeof suspenseCallback === 'function') {\n      const wakeables: Set<Wakeable> | null = (finishedWork.updateQueue: any);\n      if (wakeables !== null) {\n        suspenseCallback(new Set(wakeables));\n      }\n    } else if (__DEV__) {\n      if (suspenseCallback !== undefined) {\n        console.error('Unexpected type for suspenseCallback.');\n      }\n    }\n  }\n}\n\nfunction commitSuspenseHydrationCallbacks(\n  finishedRoot: FiberRoot,\n  finishedWork: Fiber,\n) {\n  if (!supportsHydration) {\n    return;\n  }\n  const newState: SuspenseState | null = finishedWork.memoizedState;\n  if (newState === null) {\n    const current = finishedWork.alternate;\n    if (current !== null) {\n      const prevState: SuspenseState | null = current.memoizedState;\n      if (prevState !== null) {\n        const suspenseInstance = prevState.dehydrated;\n        if (suspenseInstance !== null) {\n          commitHydratedSuspenseInstance(suspenseInstance);\n          if (enableSuspenseCallback) {\n            const hydrationCallbacks = finishedRoot.hydrationCallbacks;\n            if (hydrationCallbacks !== null) {\n              const onHydrated = hydrationCallbacks.onHydrated;\n              if (onHydrated) {\n                onHydrated(suspenseInstance);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\nfunction attachSuspenseRetryListeners(finishedWork: Fiber) {\n  // If this boundary just timed out, then it will have a set of wakeables.\n  // For each wakeable, attach a listener so that when it resolves, React\n  // attempts to re-render the boundary in the primary (pre-timeout) state.\n  const wakeables: Set<Wakeable> | null = (finishedWork.updateQueue: any);\n  if (wakeables !== null) {\n    finishedWork.updateQueue = null;\n    let retryCache = finishedWork.stateNode;\n    if (retryCache === null) {\n      retryCache = finishedWork.stateNode = new PossiblyWeakSet();\n    }\n    wakeables.forEach(wakeable => {\n      // Memoize using the boundary fiber to prevent redundant listeners.\n      const retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);\n      if (!retryCache.has(wakeable)) {\n        retryCache.add(wakeable);\n\n        if (enableUpdaterTracking) {\n          if (isDevToolsPresent) {\n            if (inProgressLanes !== null && inProgressRoot !== null) {\n              // If we have pending work still, associate the original updaters with it.\n              restorePendingUpdaters(inProgressRoot, inProgressLanes);\n            } else {\n              throw Error(\n                'Expected finished root and lanes to be set. This is a bug in React.',\n              );\n            }\n          }\n        }\n\n        wakeable.then(retry, retry);\n      }\n    });\n  }\n}\n\n// This function detects when a Suspense boundary goes from visible to hidden.\n// It returns false if the boundary is already hidden.\n// TODO: Use an effect tag.\nexport function isSuspenseBoundaryBeingHidden(\n  current: Fiber | null,\n  finishedWork: Fiber,\n): boolean {\n  if (current !== null) {\n    const oldState: SuspenseState | null = current.memoizedState;\n    if (oldState === null || oldState.dehydrated !== null) {\n      const newState: SuspenseState | null = finishedWork.memoizedState;\n      return newState !== null && newState.dehydrated === null;\n    }\n  }\n  return false;\n}\n\nfunction commitResetTextContent(current: Fiber) {\n  if (!supportsMutation) {\n    return;\n  }\n  resetTextContent(current.stateNode);\n}\n\nexport function commitMutationEffects(\n  root: FiberRoot,\n  firstChild: Fiber,\n  committedLanes: Lanes,\n) {\n  inProgressLanes = committedLanes;\n  inProgressRoot = root;\n  nextEffect = firstChild;\n\n  commitMutationEffects_begin(root);\n\n  inProgressLanes = null;\n  inProgressRoot = null;\n}\n\nfunction commitMutationEffects_begin(root: FiberRoot) {\n  while (nextEffect !== null) {\n    const fiber = nextEffect;\n\n    // TODO: Should wrap this in flags check, too, as optimization\n    const deletions = fiber.deletions;\n    if (deletions !== null) {\n      for (let i = 0; i < deletions.length; i++) {\n        const childToDelete = deletions[i];\n        try {\n          commitDeletion(root, childToDelete, fiber);\n        } catch (error) {\n          reportUncaughtErrorInDEV(error);\n          captureCommitPhaseError(childToDelete, fiber, error);\n        }\n      }\n    }\n\n    const child = fiber.child;\n    if ((fiber.subtreeFlags & MutationMask) !== NoFlags && child !== null) {\n      ensureCorrectReturnPointer(child, fiber);\n      nextEffect = child;\n    } else {\n      commitMutationEffects_complete(root);\n    }\n  }\n}\n\nfunction commitMutationEffects_complete(root: FiberRoot) {\n  while (nextEffect !== null) {\n    const fiber = nextEffect;\n    setCurrentDebugFiberInDEV(fiber);\n    try {\n      commitMutationEffectsOnFiber(fiber, root);\n    } catch (error) {\n      reportUncaughtErrorInDEV(error);\n      captureCommitPhaseError(fiber, fiber.return, error);\n    }\n    resetCurrentDebugFiberInDEV();\n\n    const sibling = fiber.sibling;\n    if (sibling !== null) {\n      ensureCorrectReturnPointer(sibling, fiber.return);\n      nextEffect = sibling;\n      return;\n    }\n\n    nextEffect = fiber.return;\n  }\n}\n\nfunction commitMutationEffectsOnFiber(finishedWork: Fiber, root: FiberRoot) {\n  // TODO: The factoring of this phase could probably be improved. Consider\n  // switching on the type of work before checking the flags. That's what\n  // we do in all the other phases. I think this one is only different\n  // because of the shared reconciliation logic below.\n  const flags = finishedWork.flags;\n\n  if (flags & ContentReset) {\n    commitResetTextContent(finishedWork);\n  }\n\n  if (flags & Ref) {\n    const current = finishedWork.alternate;\n    if (current !== null) {\n      commitDetachRef(current);\n    }\n    if (enableScopeAPI) {\n      // TODO: This is a temporary solution that allowed us to transition away\n      // from React Flare on www.\n      if (finishedWork.tag === ScopeComponent) {\n        commitAttachRef(finishedWork);\n      }\n    }\n  }\n\n  if (flags & Visibility) {\n    switch (finishedWork.tag) {\n      case SuspenseComponent: {\n        const newState: OffscreenState | null = finishedWork.memoizedState;\n        const isHidden = newState !== null;\n        if (isHidden) {\n          const current = finishedWork.alternate;\n          const wasHidden = current !== null && current.memoizedState !== null;\n          if (!wasHidden) {\n            // TODO: Move to passive phase\n            markCommitTimeOfFallback();\n          }\n        }\n        break;\n      }\n      case OffscreenComponent: {\n        const newState: OffscreenState | null = finishedWork.memoizedState;\n        const isHidden = newState !== null;\n        const current = finishedWork.alternate;\n        const wasHidden = current !== null && current.memoizedState !== null;\n        const offscreenBoundary: Fiber = finishedWork;\n\n        if (supportsMutation) {\n          // TODO: This needs to run whenever there's an insertion or update\n          // inside a hidden Offscreen tree.\n          hideOrUnhideAllChildren(offscreenBoundary, isHidden);\n        }\n\n        if (enableSuspenseLayoutEffectSemantics) {\n          if (isHidden) {\n            if (!wasHidden) {\n              if ((offscreenBoundary.mode & ConcurrentMode) !== NoMode) {\n                nextEffect = offscreenBoundary;\n                let offscreenChild = offscreenBoundary.child;\n                while (offscreenChild !== null) {\n                  nextEffect = offscreenChild;\n                  disappearLayoutEffects_begin(offscreenChild);\n                  offscreenChild = offscreenChild.sibling;\n                }\n              }\n            }\n          } else {\n            if (wasHidden) {\n              // TODO: Move re-appear call here for symmetry?\n            }\n          }\n          break;\n        }\n      }\n    }\n  }\n\n  // The following switch statement is only concerned about placement,\n  // updates, and deletions. To avoid needing to add a case for every possible\n  // bitmap value, we remove the secondary effects from the effect tag and\n  // switch on that value.\n  const primaryFlags = flags & (Placement | Update | Hydrating);\n  outer: switch (primaryFlags) {\n    case Placement: {\n      commitPlacement(finishedWork);\n      // Clear the \"placement\" from effect tag so that we know that this is\n      // inserted, before any life-cycles like componentDidMount gets called.\n      // TODO: findDOMNode doesn't rely on this any more but isMounted does\n      // and isMounted is deprecated anyway so we should be able to kill this.\n      finishedWork.flags &= ~Placement;\n      break;\n    }\n    case PlacementAndUpdate: {\n      // Placement\n      commitPlacement(finishedWork);\n      // Clear the \"placement\" from effect tag so that we know that this is\n      // inserted, before any life-cycles like componentDidMount gets called.\n      finishedWork.flags &= ~Placement;\n\n      // Update\n      const current = finishedWork.alternate;\n      commitWork(current, finishedWork);\n      break;\n    }\n    case Hydrating: {\n      finishedWork.flags &= ~Hydrating;\n      break;\n    }\n    case HydratingAndUpdate: {\n      finishedWork.flags &= ~Hydrating;\n\n      // Update\n      const current = finishedWork.alternate;\n      commitWork(current, finishedWork);\n      break;\n    }\n    case Update: {\n      const current = finishedWork.alternate;\n      commitWork(current, finishedWork);\n      break;\n    }\n  }\n}\n\nexport function commitLayoutEffects(\n  finishedWork: Fiber,\n  root: FiberRoot,\n  committedLanes: Lanes,\n): void {\n  inProgressLanes = committedLanes;\n  inProgressRoot = root;\n  nextEffect = finishedWork;\n\n  commitLayoutEffects_begin(finishedWork, root, committedLanes);\n\n  inProgressLanes = null;\n  inProgressRoot = null;\n}\n\nfunction commitLayoutEffects_begin(\n  subtreeRoot: Fiber,\n  root: FiberRoot,\n  committedLanes: Lanes,\n) {\n  // Suspense layout effects semantics don't change for legacy roots.\n  const isModernRoot = (subtreeRoot.mode & ConcurrentMode) !== NoMode;\n\n  while (nextEffect !== null) {\n    const fiber = nextEffect;\n    const firstChild = fiber.child;\n\n    if (\n      enableSuspenseLayoutEffectSemantics &&\n      fiber.tag === OffscreenComponent &&\n      isModernRoot\n    ) {\n      // Keep track of the current Offscreen stack's state.\n      const isHidden = fiber.memoizedState !== null;\n      const newOffscreenSubtreeIsHidden = isHidden || offscreenSubtreeIsHidden;\n      if (newOffscreenSubtreeIsHidden) {\n        // The Offscreen tree is hidden. Skip over its layout effects.\n        commitLayoutMountEffects_complete(subtreeRoot, root, committedLanes);\n        continue;\n      } else {\n        // TODO (Offscreen) Also check: subtreeFlags & LayoutMask\n        const current = fiber.alternate;\n        const wasHidden = current !== null && current.memoizedState !== null;\n        const newOffscreenSubtreeWasHidden =\n          wasHidden || offscreenSubtreeWasHidden;\n        const prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden;\n        const prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;\n\n        // Traverse the Offscreen subtree with the current Offscreen as the root.\n        offscreenSubtreeIsHidden = newOffscreenSubtreeIsHidden;\n        offscreenSubtreeWasHidden = newOffscreenSubtreeWasHidden;\n\n        if (offscreenSubtreeWasHidden && !prevOffscreenSubtreeWasHidden) {\n          // This is the root of a reappearing boundary. Turn its layout effects\n          // back on.\n          nextEffect = fiber;\n          reappearLayoutEffects_begin(fiber);\n        }\n\n        let child = firstChild;\n        while (child !== null) {\n          nextEffect = child;\n          commitLayoutEffects_begin(\n            child, // New root; bubble back up to here and stop.\n            root,\n            committedLanes,\n          );\n          child = child.sibling;\n        }\n\n        // Restore Offscreen state and resume in our-progress traversal.\n        nextEffect = fiber;\n        offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;\n        offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\n        commitLayoutMountEffects_complete(subtreeRoot, root, committedLanes);\n\n        continue;\n      }\n    }\n\n    if ((fiber.subtreeFlags & LayoutMask) !== NoFlags && firstChild !== null) {\n      ensureCorrectReturnPointer(firstChild, fiber);\n      nextEffect = firstChild;\n    } else {\n      commitLayoutMountEffects_complete(subtreeRoot, root, committedLanes);\n    }\n  }\n}\n\nfunction commitLayoutMountEffects_complete(\n  subtreeRoot: Fiber,\n  root: FiberRoot,\n  committedLanes: Lanes,\n) {\n  while (nextEffect !== null) {\n    const fiber = nextEffect;\n    if ((fiber.flags & LayoutMask) !== NoFlags) {\n      const current = fiber.alternate;\n      setCurrentDebugFiberInDEV(fiber);\n      try {\n        commitLayoutEffectOnFiber(root, current, fiber, committedLanes);\n      } catch (error) {\n        reportUncaughtErrorInDEV(error);\n        captureCommitPhaseError(fiber, fiber.return, error);\n      }\n      resetCurrentDebugFiberInDEV();\n    }\n\n    if (fiber === subtreeRoot) {\n      nextEffect = null;\n      return;\n    }\n\n    const sibling = fiber.sibling;\n    if (sibling !== null) {\n      ensureCorrectReturnPointer(sibling, fiber.return);\n      nextEffect = sibling;\n      return;\n    }\n\n    nextEffect = fiber.return;\n  }\n}\n\nfunction disappearLayoutEffects_begin(subtreeRoot: Fiber) {\n  while (nextEffect !== null) {\n    const fiber = nextEffect;\n    const firstChild = fiber.child;\n\n    // TODO (Offscreen) Check: flags & (RefStatic | LayoutStatic)\n    switch (fiber.tag) {\n      case FunctionComponent:\n      case ForwardRef:\n      case MemoComponent:\n      case SimpleMemoComponent: {\n        if (\n          enableProfilerTimer &&\n          enableProfilerCommitHooks &&\n          fiber.mode & ProfileMode\n        ) {\n          try {\n            startLayoutEffectTimer();\n            commitHookEffectListUnmount(HookLayout, fiber, fiber.return);\n          } finally {\n            recordLayoutEffectDuration(fiber);\n          }\n        } else {\n          commitHookEffectListUnmount(HookLayout, fiber, fiber.return);\n        }\n        break;\n      }\n      case ClassComponent: {\n        // TODO (Offscreen) Check: flags & RefStatic\n        safelyDetachRef(fiber, fiber.return);\n\n        const instance = fiber.stateNode;\n        if (typeof instance.componentWillUnmount === 'function') {\n          safelyCallComponentWillUnmount(fiber, fiber.return, instance);\n        }\n        break;\n      }\n      case HostComponent: {\n        safelyDetachRef(fiber, fiber.return);\n        break;\n      }\n      case OffscreenComponent: {\n        // Check if this is a\n        const isHidden = fiber.memoizedState !== null;\n        if (isHidden) {\n          // Nested Offscreen tree is already hidden. Don't disappear\n          // its effects.\n          disappearLayoutEffects_complete(subtreeRoot);\n          continue;\n        }\n        break;\n      }\n    }\n\n    // TODO (Offscreen) Check: subtreeFlags & LayoutStatic\n    if (firstChild !== null) {\n      firstChild.return = fiber;\n      nextEffect = firstChild;\n    } else {\n      disappearLayoutEffects_complete(subtreeRoot);\n    }\n  }\n}\n\nfunction disappearLayoutEffects_complete(subtreeRoot: Fiber) {\n  while (nextEffect !== null) {\n    const fiber = nextEffect;\n\n    if (fiber === subtreeRoot) {\n      nextEffect = null;\n      return;\n    }\n\n    const sibling = fiber.sibling;\n    if (sibling !== null) {\n      sibling.return = fiber.return;\n      nextEffect = sibling;\n      return;\n    }\n\n    nextEffect = fiber.return;\n  }\n}\n\nfunction reappearLayoutEffects_begin(subtreeRoot: Fiber) {\n  while (nextEffect !== null) {\n    const fiber = nextEffect;\n    const firstChild = fiber.child;\n\n    if (fiber.tag === OffscreenComponent) {\n      const isHidden = fiber.memoizedState !== null;\n      if (isHidden) {\n        // Nested Offscreen tree is still hidden. Don't re-appear its effects.\n        reappearLayoutEffects_complete(subtreeRoot);\n        continue;\n      }\n    }\n\n    // TODO (Offscreen) Check: subtreeFlags & LayoutStatic\n    if (firstChild !== null) {\n      // This node may have been reused from a previous render, so we can't\n      // assume its return pointer is correct.\n      firstChild.return = fiber;\n      nextEffect = firstChild;\n    } else {\n      reappearLayoutEffects_complete(subtreeRoot);\n    }\n  }\n}\n\nfunction reappearLayoutEffects_complete(subtreeRoot: Fiber) {\n  while (nextEffect !== null) {\n    const fiber = nextEffect;\n\n    // TODO (Offscreen) Check: flags & LayoutStatic\n    setCurrentDebugFiberInDEV(fiber);\n    try {\n      reappearLayoutEffectsOnFiber(fiber);\n    } catch (error) {\n      reportUncaughtErrorInDEV(error);\n      captureCommitPhaseError(fiber, fiber.return, error);\n    }\n    resetCurrentDebugFiberInDEV();\n\n    if (fiber === subtreeRoot) {\n      nextEffect = null;\n      return;\n    }\n\n    const sibling = fiber.sibling;\n    if (sibling !== null) {\n      // This node may have been reused from a previous render, so we can't\n      // assume its return pointer is correct.\n      sibling.return = fiber.return;\n      nextEffect = sibling;\n      return;\n    }\n\n    nextEffect = fiber.return;\n  }\n}\n\nexport function commitPassiveMountEffects(\n  root: FiberRoot,\n  finishedWork: Fiber,\n): void {\n  nextEffect = finishedWork;\n  commitPassiveMountEffects_begin(finishedWork, root);\n}\n\nfunction commitPassiveMountEffects_begin(subtreeRoot: Fiber, root: FiberRoot) {\n  while (nextEffect !== null) {\n    const fiber = nextEffect;\n    const firstChild = fiber.child;\n    if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && firstChild !== null) {\n      ensureCorrectReturnPointer(firstChild, fiber);\n      nextEffect = firstChild;\n    } else {\n      commitPassiveMountEffects_complete(subtreeRoot, root);\n    }\n  }\n}\n\nfunction commitPassiveMountEffects_complete(\n  subtreeRoot: Fiber,\n  root: FiberRoot,\n) {\n  while (nextEffect !== null) {\n    const fiber = nextEffect;\n    if ((fiber.flags & Passive) !== NoFlags) {\n      setCurrentDebugFiberInDEV(fiber);\n      try {\n        commitPassiveMountOnFiber(root, fiber);\n      } catch (error) {\n        reportUncaughtErrorInDEV(error);\n        captureCommitPhaseError(fiber, fiber.return, error);\n      }\n      resetCurrentDebugFiberInDEV();\n    }\n\n    if (fiber === subtreeRoot) {\n      nextEffect = null;\n      return;\n    }\n\n    const sibling = fiber.sibling;\n    if (sibling !== null) {\n      ensureCorrectReturnPointer(sibling, fiber.return);\n      nextEffect = sibling;\n      return;\n    }\n\n    nextEffect = fiber.return;\n  }\n}\n\nfunction commitPassiveMountOnFiber(\n  finishedRoot: FiberRoot,\n  finishedWork: Fiber,\n): void {\n  switch (finishedWork.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case SimpleMemoComponent: {\n      if (\n        enableProfilerTimer &&\n        enableProfilerCommitHooks &&\n        finishedWork.mode & ProfileMode\n      ) {\n        startPassiveEffectTimer();\n        try {\n          commitHookEffectListMount(HookPassive | HookHasEffect, finishedWork);\n        } finally {\n          recordPassiveEffectDuration(finishedWork);\n        }\n      } else {\n        commitHookEffectListMount(HookPassive | HookHasEffect, finishedWork);\n      }\n      break;\n    }\n    case HostRoot: {\n      if (enableCache) {\n        let previousCache: Cache | null = null;\n        if (finishedWork.alternate !== null) {\n          previousCache = finishedWork.alternate.memoizedState.cache;\n        }\n        const nextCache = finishedWork.memoizedState.cache;\n        // Retain/release the root cache.\n        // Note that on initial mount, previousCache and nextCache will be the same\n        // and this retain won't occur. To counter this, we instead retain the HostRoot's\n        // initial cache when creating the root itself (see createFiberRoot() in\n        // ReactFiberRoot.js). Subsequent updates that change the cache are reflected\n        // here, such that previous/next caches are retained correctly.\n        if (nextCache !== previousCache) {\n          retainCache(nextCache);\n          if (previousCache != null) {\n            releaseCache(previousCache);\n          }\n        }\n      }\n      break;\n    }\n    case LegacyHiddenComponent:\n    case OffscreenComponent: {\n      if (enableCache) {\n        let previousCache: Cache | null = null;\n        if (\n          finishedWork.alternate !== null &&\n          finishedWork.alternate.memoizedState !== null &&\n          finishedWork.alternate.memoizedState.cachePool !== null\n        ) {\n          previousCache = finishedWork.alternate.memoizedState.cachePool.pool;\n        }\n        let nextCache: Cache | null = null;\n        if (\n          finishedWork.memoizedState !== null &&\n          finishedWork.memoizedState.cachePool !== null\n        ) {\n          nextCache = finishedWork.memoizedState.cachePool.pool;\n        }\n        // Retain/release the cache used for pending (suspended) nodes.\n        // Note that this is only reached in the non-suspended/visible case:\n        // when the content is suspended/hidden, the retain/release occurs\n        // via the parent Suspense component (see case above).\n        if (nextCache !== previousCache) {\n          if (nextCache != null) {\n            retainCache(nextCache);\n          }\n          if (previousCache != null) {\n            releaseCache(previousCache);\n          }\n        }\n      }\n      break;\n    }\n    case CacheComponent: {\n      if (enableCache) {\n        let previousCache: Cache | null = null;\n        if (finishedWork.alternate !== null) {\n          previousCache = finishedWork.alternate.memoizedState.cache;\n        }\n        const nextCache = finishedWork.memoizedState.cache;\n        // Retain/release the cache. In theory the cache component\n        // could be \"borrowing\" a cache instance owned by some parent,\n        // in which case we could avoid retaining/releasing. But it\n        // is non-trivial to determine when that is the case, so we\n        // always retain/release.\n        if (nextCache !== previousCache) {\n          retainCache(nextCache);\n          if (previousCache != null) {\n            releaseCache(previousCache);\n          }\n        }\n      }\n      break;\n    }\n  }\n}\n\nexport function commitPassiveUnmountEffects(firstChild: Fiber): void {\n  nextEffect = firstChild;\n  commitPassiveUnmountEffects_begin();\n}\n\nfunction commitPassiveUnmountEffects_begin() {\n  while (nextEffect !== null) {\n    const fiber = nextEffect;\n    const child = fiber.child;\n\n    if ((nextEffect.flags & ChildDeletion) !== NoFlags) {\n      const deletions = fiber.deletions;\n      if (deletions !== null) {\n        for (let i = 0; i < deletions.length; i++) {\n          const fiberToDelete = deletions[i];\n          nextEffect = fiberToDelete;\n          commitPassiveUnmountEffectsInsideOfDeletedTree_begin(\n            fiberToDelete,\n            fiber,\n          );\n        }\n\n        if (deletedTreeCleanUpLevel >= 1) {\n          // A fiber was deleted from this parent fiber, but it's still part of\n          // the previous (alternate) parent fiber's list of children. Because\n          // children are a linked list, an earlier sibling that's still alive\n          // will be connected to the deleted fiber via its `alternate`:\n          //\n          //   live fiber\n          //   --alternate--> previous live fiber\n          //   --sibling--> deleted fiber\n          //\n          // We can't disconnect `alternate` on nodes that haven't been deleted\n          // yet, but we can disconnect the `sibling` and `child` pointers.\n          const previousFiber = fiber.alternate;\n          if (previousFiber !== null) {\n            let detachedChild = previousFiber.child;\n            if (detachedChild !== null) {\n              previousFiber.child = null;\n              do {\n                const detachedSibling = detachedChild.sibling;\n                detachedChild.sibling = null;\n                detachedChild = detachedSibling;\n              } while (detachedChild !== null);\n            }\n          }\n        }\n\n        nextEffect = fiber;\n      }\n    }\n\n    if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && child !== null) {\n      ensureCorrectReturnPointer(child, fiber);\n      nextEffect = child;\n    } else {\n      commitPassiveUnmountEffects_complete();\n    }\n  }\n}\n\nfunction commitPassiveUnmountEffects_complete() {\n  while (nextEffect !== null) {\n    const fiber = nextEffect;\n    if ((fiber.flags & Passive) !== NoFlags) {\n      setCurrentDebugFiberInDEV(fiber);\n      commitPassiveUnmountOnFiber(fiber);\n      resetCurrentDebugFiberInDEV();\n    }\n\n    const sibling = fiber.sibling;\n    if (sibling !== null) {\n      ensureCorrectReturnPointer(sibling, fiber.return);\n      nextEffect = sibling;\n      return;\n    }\n\n    nextEffect = fiber.return;\n  }\n}\n\nfunction commitPassiveUnmountOnFiber(finishedWork: Fiber): void {\n  switch (finishedWork.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case SimpleMemoComponent: {\n      if (\n        enableProfilerTimer &&\n        enableProfilerCommitHooks &&\n        finishedWork.mode & ProfileMode\n      ) {\n        startPassiveEffectTimer();\n        commitHookEffectListUnmount(\n          HookPassive | HookHasEffect,\n          finishedWork,\n          finishedWork.return,\n        );\n        recordPassiveEffectDuration(finishedWork);\n      } else {\n        commitHookEffectListUnmount(\n          HookPassive | HookHasEffect,\n          finishedWork,\n          finishedWork.return,\n        );\n      }\n      break;\n    }\n  }\n}\n\nfunction commitPassiveUnmountEffectsInsideOfDeletedTree_begin(\n  deletedSubtreeRoot: Fiber,\n  nearestMountedAncestor: Fiber | null,\n) {\n  while (nextEffect !== null) {\n    const fiber = nextEffect;\n\n    // Deletion effects fire in parent -> child order\n    // TODO: Check if fiber has a PassiveStatic flag\n    setCurrentDebugFiberInDEV(fiber);\n    commitPassiveUnmountInsideDeletedTreeOnFiber(fiber, nearestMountedAncestor);\n    resetCurrentDebugFiberInDEV();\n\n    const child = fiber.child;\n    // TODO: Only traverse subtree if it has a PassiveStatic flag. (But, if we\n    // do this, still need to handle `deletedTreeCleanUpLevel` correctly.)\n    if (child !== null) {\n      ensureCorrectReturnPointer(child, fiber);\n      nextEffect = child;\n    } else {\n      commitPassiveUnmountEffectsInsideOfDeletedTree_complete(\n        deletedSubtreeRoot,\n      );\n    }\n  }\n}\n\nfunction commitPassiveUnmountEffectsInsideOfDeletedTree_complete(\n  deletedSubtreeRoot: Fiber,\n) {\n  while (nextEffect !== null) {\n    const fiber = nextEffect;\n    const sibling = fiber.sibling;\n    const returnFiber = fiber.return;\n\n    if (deletedTreeCleanUpLevel >= 2) {\n      // Recursively traverse the entire deleted tree and clean up fiber fields.\n      // This is more aggressive than ideal, and the long term goal is to only\n      // have to detach the deleted tree at the root.\n      detachFiberAfterEffects(fiber);\n      if (fiber === deletedSubtreeRoot) {\n        nextEffect = null;\n        return;\n      }\n    } else {\n      // This is the default branch (level 0). We do not recursively clear all\n      // the fiber fields. Only the root of the deleted subtree.\n      if (fiber === deletedSubtreeRoot) {\n        detachFiberAfterEffects(fiber);\n        nextEffect = null;\n        return;\n      }\n    }\n\n    if (sibling !== null) {\n      ensureCorrectReturnPointer(sibling, returnFiber);\n      nextEffect = sibling;\n      return;\n    }\n\n    nextEffect = returnFiber;\n  }\n}\n\nfunction commitPassiveUnmountInsideDeletedTreeOnFiber(\n  current: Fiber,\n  nearestMountedAncestor: Fiber | null,\n): void {\n  switch (current.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case SimpleMemoComponent: {\n      if (\n        enableProfilerTimer &&\n        enableProfilerCommitHooks &&\n        current.mode & ProfileMode\n      ) {\n        startPassiveEffectTimer();\n        commitHookEffectListUnmount(\n          HookPassive,\n          current,\n          nearestMountedAncestor,\n        );\n        recordPassiveEffectDuration(current);\n      } else {\n        commitHookEffectListUnmount(\n          HookPassive,\n          current,\n          nearestMountedAncestor,\n        );\n      }\n      break;\n    }\n    // TODO: run passive unmount effects when unmounting a root.\n    // Because passive unmount effects are not currently run,\n    // the cache instance owned by the root will never be freed.\n    // When effects are run, the cache should be freed here:\n    // case HostRoot: {\n    //   if (enableCache) {\n    //     const cache = current.memoizedState.cache;\n    //     releaseCache(cache);\n    //   }\n    //   break;\n    // }\n    case LegacyHiddenComponent:\n    case OffscreenComponent: {\n      if (enableCache) {\n        if (\n          current.memoizedState !== null &&\n          current.memoizedState.cachePool !== null\n        ) {\n          const cache: Cache = current.memoizedState.cachePool.pool;\n          // Retain/release the cache used for pending (suspended) nodes.\n          // Note that this is only reached in the non-suspended/visible case:\n          // when the content is suspended/hidden, the retain/release occurs\n          // via the parent Suspense component (see case above).\n          if (cache != null) {\n            retainCache(cache);\n          }\n        }\n      }\n      break;\n    }\n    case CacheComponent: {\n      if (enableCache) {\n        const cache = current.memoizedState.cache;\n        releaseCache(cache);\n      }\n      break;\n    }\n  }\n}\n\nlet didWarnWrongReturnPointer = false;\nfunction ensureCorrectReturnPointer(fiber, expectedReturnFiber) {\n  if (__DEV__) {\n    if (!didWarnWrongReturnPointer && fiber.return !== expectedReturnFiber) {\n      didWarnWrongReturnPointer = true;\n      console.error(\n        'Internal React error: Return pointer is inconsistent ' +\n          'with parent.',\n      );\n    }\n  }\n\n  // TODO: Remove this assignment once we're confident that it won't break\n  // anything, by checking the warning logs for the above invariant\n  fiber.return = expectedReturnFiber;\n}\n\n// TODO: Reuse reappearLayoutEffects traversal here?\nfunction invokeLayoutEffectMountInDEV(fiber: Fiber): void {\n  if (__DEV__ && enableStrictEffects) {\n    // We don't need to re-check StrictEffectsMode here.\n    // This function is only called if that check has already passed.\n    switch (fiber.tag) {\n      case FunctionComponent:\n      case ForwardRef:\n      case SimpleMemoComponent: {\n        try {\n          commitHookEffectListMount(HookLayout | HookHasEffect, fiber);\n        } catch (error) {\n          reportUncaughtErrorInDEV(error);\n          captureCommitPhaseError(fiber, fiber.return, error);\n        }\n        break;\n      }\n      case ClassComponent: {\n        const instance = fiber.stateNode;\n        try {\n          instance.componentDidMount();\n        } catch (error) {\n          reportUncaughtErrorInDEV(error);\n          captureCommitPhaseError(fiber, fiber.return, error);\n        }\n        break;\n      }\n    }\n  }\n}\n\nfunction invokePassiveEffectMountInDEV(fiber: Fiber): void {\n  if (__DEV__ && enableStrictEffects) {\n    // We don't need to re-check StrictEffectsMode here.\n    // This function is only called if that check has already passed.\n    switch (fiber.tag) {\n      case FunctionComponent:\n      case ForwardRef:\n      case SimpleMemoComponent: {\n        try {\n          commitHookEffectListMount(HookPassive | HookHasEffect, fiber);\n        } catch (error) {\n          reportUncaughtErrorInDEV(error);\n          captureCommitPhaseError(fiber, fiber.return, error);\n        }\n        break;\n      }\n    }\n  }\n}\n\nfunction invokeLayoutEffectUnmountInDEV(fiber: Fiber): void {\n  if (__DEV__ && enableStrictEffects) {\n    // We don't need to re-check StrictEffectsMode here.\n    // This function is only called if that check has already passed.\n    switch (fiber.tag) {\n      case FunctionComponent:\n      case ForwardRef:\n      case SimpleMemoComponent: {\n        try {\n          commitHookEffectListUnmount(\n            HookLayout | HookHasEffect,\n            fiber,\n            fiber.return,\n          );\n        } catch (error) {\n          reportUncaughtErrorInDEV(error);\n          captureCommitPhaseError(fiber, fiber.return, error);\n        }\n        break;\n      }\n      case ClassComponent: {\n        const instance = fiber.stateNode;\n        if (typeof instance.componentWillUnmount === 'function') {\n          safelyCallComponentWillUnmount(fiber, fiber.return, instance);\n        }\n        break;\n      }\n    }\n  }\n}\n\nfunction invokePassiveEffectUnmountInDEV(fiber: Fiber): void {\n  if (__DEV__ && enableStrictEffects) {\n    // We don't need to re-check StrictEffectsMode here.\n    // This function is only called if that check has already passed.\n    switch (fiber.tag) {\n      case FunctionComponent:\n      case ForwardRef:\n      case SimpleMemoComponent: {\n        try {\n          commitHookEffectListUnmount(\n            HookPassive | HookHasEffect,\n            fiber,\n            fiber.return,\n          );\n        } catch (error) {\n          reportUncaughtErrorInDEV(error);\n          captureCommitPhaseError(fiber, fiber.return, error);\n        }\n      }\n    }\n  }\n}\n\nexport {\n  commitResetTextContent,\n  commitPlacement,\n  commitDeletion,\n  commitWork,\n  commitAttachRef,\n  commitDetachRef,\n  invokeLayoutEffectMountInDEV,\n  invokeLayoutEffectUnmountInDEV,\n  invokePassiveEffectMountInDEV,\n  invokePassiveEffectUnmountInDEV,\n};\n"]},"metadata":{},"sourceType":"module"}