{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport getComponentNameFromFiber from 'react-reconciler/src/getComponentNameFromFiber';\nimport { Placement, ChildDeletion, Forked } from './ReactFiberFlags';\nimport { getIteratorFn, REACT_ELEMENT_TYPE, REACT_FRAGMENT_TYPE, REACT_PORTAL_TYPE, REACT_LAZY_TYPE } from 'shared/ReactSymbols';\nimport { ClassComponent, HostText, HostPortal, Fragment } from './ReactWorkTags';\nimport isArray from 'shared/isArray';\nimport { warnAboutStringRefs, enableLazyElements } from 'shared/ReactFeatureFlags';\nimport { checkPropStringCoercion } from 'shared/CheckStringCoercion';\nimport { createWorkInProgress, resetWorkInProgress, createFiberFromElement, createFiberFromFragment, createFiberFromText, createFiberFromPortal } from './ReactFiber.new';\nimport { emptyRefsObject } from './ReactFiberClassComponent.new';\nimport { isCompatibleFamilyForHotReloading } from './ReactFiberHotReloading.new';\nimport { StrictLegacyMode } from './ReactTypeOfMode';\nimport { getIsHydrating } from './ReactFiberHydrationContext.new';\nimport { pushTreeFork } from './ReactFiberTreeContext.new';\nlet didWarnAboutMaps;\nlet didWarnAboutGenerators;\nlet didWarnAboutStringRefs;\nlet ownerHasKeyUseWarning;\nlet ownerHasFunctionTypeWarning;\n\nlet warnForMissingKey = (child, returnFiber) => {};\n\nif (__DEV__) {\n  didWarnAboutMaps = false;\n  didWarnAboutGenerators = false;\n  didWarnAboutStringRefs = {};\n  /**\n   * Warn if there's no key explicitly set on dynamic arrays of children or\n   * object keys are not valid. This allows us to keep track of children between\n   * updates.\n   */\n\n  ownerHasKeyUseWarning = {};\n  ownerHasFunctionTypeWarning = {};\n\n  warnForMissingKey = (child, returnFiber) => {\n    if (child === null || typeof child !== 'object') {\n      return;\n    }\n\n    if (!child._store || child._store.validated || child.key != null) {\n      return;\n    }\n\n    if (typeof child._store !== 'object') {\n      throw new Error('React Component in warnForMissingKey should have a _store. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n    }\n\n    child._store.validated = true;\n    const componentName = getComponentNameFromFiber(returnFiber) || 'Component';\n\n    if (ownerHasKeyUseWarning[componentName]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[componentName] = true;\n    console.error('Each child in a list should have a unique ' + '\"key\" prop. See https://reactjs.org/link/warning-keys for ' + 'more information.');\n  };\n}\n\nfunction coerceRef(returnFiber, current, element) {\n  const mixedRef = element.ref;\n\n  if (mixedRef !== null && typeof mixedRef !== 'function' && typeof mixedRef !== 'object') {\n    if (__DEV__) {\n      // TODO: Clean this up once we turn on the string ref warning for\n      // everyone, because the strict mode case will no longer be relevant\n      if ((returnFiber.mode & StrictLegacyMode || warnAboutStringRefs) && // We warn in ReactElement.js if owner and self are equal for string refs\n      // because these cannot be automatically converted to an arrow function\n      // using a codemod. Therefore, we don't have to warn about string refs again.\n      !(element._owner && element._self && element._owner.stateNode !== element._self)) {\n        const componentName = getComponentNameFromFiber(returnFiber) || 'Component';\n\n        if (!didWarnAboutStringRefs[componentName]) {\n          if (warnAboutStringRefs) {\n            console.error('Component \"%s\" contains the string ref \"%s\". Support for string refs ' + 'will be removed in a future major release. We recommend using ' + 'useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', componentName, mixedRef);\n          } else {\n            console.error('A string ref, \"%s\", has been found within a strict mode tree. ' + 'String refs are a source of potential bugs and should be avoided. ' + 'We recommend using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', mixedRef);\n          }\n\n          didWarnAboutStringRefs[componentName] = true;\n        }\n      }\n    }\n\n    if (element._owner) {\n      const owner = element._owner;\n      let inst;\n\n      if (owner) {\n        const ownerFiber = owner;\n\n        if (ownerFiber.tag !== ClassComponent) {\n          throw new Error('Function components cannot have string refs. ' + 'We recommend using useRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref');\n        }\n\n        inst = ownerFiber.stateNode;\n      }\n\n      if (!inst) {\n        throw new Error(`Missing owner for string ref ${mixedRef}. This error is likely caused by a ` + 'bug in React. Please file an issue.');\n      } // Assigning this to a const so Flow knows it won't change in the closure\n\n\n      const resolvedInst = inst;\n\n      if (__DEV__) {\n        checkPropStringCoercion(mixedRef, 'ref');\n      }\n\n      const stringRef = '' + mixedRef; // Check if previous string ref matches new string ref\n\n      if (current !== null && current.ref !== null && typeof current.ref === 'function' && current.ref._stringRef === stringRef) {\n        return current.ref;\n      }\n\n      const ref = function (value) {\n        let refs = resolvedInst.refs;\n\n        if (refs === emptyRefsObject) {\n          // This is a lazy pooled frozen object, so we need to initialize.\n          refs = resolvedInst.refs = {};\n        }\n\n        if (value === null) {\n          delete refs[stringRef];\n        } else {\n          refs[stringRef] = value;\n        }\n      };\n\n      ref._stringRef = stringRef;\n      return ref;\n    } else {\n      if (typeof mixedRef !== 'string') {\n        throw new Error('Expected ref to be a function, a string, an object returned by React.createRef(), or null.');\n      }\n\n      if (!element._owner) {\n        throw new Error(`Element ref was specified as a string (${mixedRef}) but no owner was set. This could happen for one of` + ' the following reasons:\\n' + '1. You may be adding a ref to a function component\\n' + \"2. You may be adding a ref to a component that was not created inside a component's render method\\n\" + '3. You have multiple copies of React loaded\\n' + 'See https://reactjs.org/link/refs-must-have-owner for more information.');\n      }\n    }\n  }\n\n  return mixedRef;\n}\n\nfunction throwOnInvalidObjectType(returnFiber, newChild) {\n  const childString = Object.prototype.toString.call(newChild);\n  throw new Error(`Objects are not valid as a React child (found: ${childString === '[object Object]' ? 'object with keys {' + Object.keys(newChild).join(', ') + '}' : childString}). ` + 'If you meant to render a collection of children, use an array ' + 'instead.');\n}\n\nfunction warnOnFunctionType(returnFiber) {\n  if (__DEV__) {\n    const componentName = getComponentNameFromFiber(returnFiber) || 'Component';\n\n    if (ownerHasFunctionTypeWarning[componentName]) {\n      return;\n    }\n\n    ownerHasFunctionTypeWarning[componentName] = true;\n    console.error('Functions are not valid as a React child. This may happen if ' + 'you return a Component instead of <Component /> from render. ' + 'Or maybe you meant to call this function rather than return it.');\n  }\n}\n\nfunction resolveLazy(lazyType) {\n  const payload = lazyType._payload;\n  const init = lazyType._init;\n  return init(payload);\n} // This wrapper function exists because I expect to clone the code in each path\n// to be able to optimize each path individually by branching early. This needs\n// a compiler or we can do it manually. Helpers that don't need this branching\n// live outside of this function.\n\n\nfunction ChildReconciler(shouldTrackSideEffects) {\n  var _s = $RefreshSig$(),\n      _s2 = $RefreshSig$(),\n      _s3 = $RefreshSig$(),\n      _s4 = $RefreshSig$(),\n      _s5 = $RefreshSig$(),\n      _s6 = $RefreshSig$(),\n      _s7 = $RefreshSig$();\n\n  function deleteChild(returnFiber, childToDelete) {\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return;\n    }\n\n    const deletions = returnFiber.deletions;\n\n    if (deletions === null) {\n      returnFiber.deletions = [childToDelete];\n      returnFiber.flags |= ChildDeletion;\n    } else {\n      deletions.push(childToDelete);\n    }\n  }\n\n  function deleteRemainingChildren(returnFiber, currentFirstChild) {\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return null;\n    } // TODO: For the shouldClone case, this could be micro-optimized a bit by\n    // assuming that after the first child we've already added everything.\n\n\n    let childToDelete = currentFirstChild;\n\n    while (childToDelete !== null) {\n      deleteChild(returnFiber, childToDelete);\n      childToDelete = childToDelete.sibling;\n    }\n\n    return null;\n  }\n\n  function mapRemainingChildren(returnFiber, currentFirstChild) {\n    // Add the remaining children to a temporary map so that we can find them by\n    // keys quickly. Implicit (null) keys get added to this set with their index\n    // instead.\n    const existingChildren = new Map();\n    let existingChild = currentFirstChild;\n\n    while (existingChild !== null) {\n      if (existingChild.key !== null) {\n        existingChildren.set(existingChild.key, existingChild);\n      } else {\n        existingChildren.set(existingChild.index, existingChild);\n      }\n\n      existingChild = existingChild.sibling;\n    }\n\n    return existingChildren;\n  }\n\n  function useFiber(fiber, pendingProps) {\n    // We currently set sibling to null and index to 0 here because it is easy\n    // to forget to do before returning it. E.g. for the single child case.\n    const clone = createWorkInProgress(fiber, pendingProps);\n    clone.index = 0;\n    clone.sibling = null;\n    return clone;\n  }\n\n  function placeChild(newFiber, lastPlacedIndex, newIndex) {\n    newFiber.index = newIndex;\n\n    if (!shouldTrackSideEffects) {\n      // During hydration, the useId algorithm needs to know which fibers are\n      // part of a list of children (arrays, iterators).\n      newFiber.flags |= Forked;\n      return lastPlacedIndex;\n    }\n\n    const current = newFiber.alternate;\n\n    if (current !== null) {\n      const oldIndex = current.index;\n\n      if (oldIndex < lastPlacedIndex) {\n        // This is a move.\n        newFiber.flags |= Placement;\n        return lastPlacedIndex;\n      } else {\n        // This item can stay in place.\n        return oldIndex;\n      }\n    } else {\n      // This is an insertion.\n      newFiber.flags |= Placement;\n      return lastPlacedIndex;\n    }\n  }\n\n  function placeSingleChild(newFiber) {\n    // This is simpler for the single child case. We only need to do a\n    // placement for inserting new children.\n    if (shouldTrackSideEffects && newFiber.alternate === null) {\n      newFiber.flags |= Placement;\n    }\n\n    return newFiber;\n  }\n\n  function updateTextNode(returnFiber, current, textContent, lanes) {\n    _s();\n\n    if (current === null || current.tag !== HostText) {\n      // Insert\n      const created = createFiberFromText(textContent, returnFiber.mode, lanes);\n      created.return = returnFiber;\n      return created;\n    } else {\n      // Update\n      const existing = useFiber(current, textContent);\n      existing.return = returnFiber;\n      return existing;\n    }\n  }\n\n  _s(updateTextNode, \"kiHzbwuEosy3to0T/G280Ayd51Y=\", false, function () {\n    return [useFiber];\n  });\n\n  function updateElement(returnFiber, current, element, lanes) {\n    _s2();\n\n    const elementType = element.type;\n\n    if (elementType === REACT_FRAGMENT_TYPE) {\n      return updateFragment(returnFiber, current, element.props.children, lanes, element.key);\n    }\n\n    if (current !== null) {\n      if (current.elementType === elementType || ( // Keep this check inline so it only runs on the false path:\n      __DEV__ ? isCompatibleFamilyForHotReloading(current, element) : false) || // Lazy types should reconcile their resolved type.\n      // We need to do this after the Hot Reloading check above,\n      // because hot reloading has different semantics than prod because\n      // it doesn't resuspend. So we can't let the call below suspend.\n      enableLazyElements && typeof elementType === 'object' && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current.type) {\n        // Move based on index\n        const existing = useFiber(current, element.props);\n        existing.ref = coerceRef(returnFiber, current, element);\n        existing.return = returnFiber;\n\n        if (__DEV__) {\n          existing._debugSource = element._source;\n          existing._debugOwner = element._owner;\n        }\n\n        return existing;\n      }\n    } // Insert\n\n\n    const created = createFiberFromElement(element, returnFiber.mode, lanes);\n    created.ref = coerceRef(returnFiber, current, element);\n    created.return = returnFiber;\n    return created;\n  }\n\n  _s2(updateElement, \"kiHzbwuEosy3to0T/G280Ayd51Y=\", false, function () {\n    return [useFiber];\n  });\n\n  function updatePortal(returnFiber, current, portal, lanes) {\n    _s3();\n\n    if (current === null || current.tag !== HostPortal || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) {\n      // Insert\n      const created = createFiberFromPortal(portal, returnFiber.mode, lanes);\n      created.return = returnFiber;\n      return created;\n    } else {\n      // Update\n      const existing = useFiber(current, portal.children || []);\n      existing.return = returnFiber;\n      return existing;\n    }\n  }\n\n  _s3(updatePortal, \"kiHzbwuEosy3to0T/G280Ayd51Y=\", false, function () {\n    return [useFiber];\n  });\n\n  function updateFragment(returnFiber, current, fragment, lanes, key) {\n    _s4();\n\n    if (current === null || current.tag !== Fragment) {\n      // Insert\n      const created = createFiberFromFragment(fragment, returnFiber.mode, lanes, key);\n      created.return = returnFiber;\n      return created;\n    } else {\n      // Update\n      const existing = useFiber(current, fragment);\n      existing.return = returnFiber;\n      return existing;\n    }\n  }\n\n  _s4(updateFragment, \"kiHzbwuEosy3to0T/G280Ayd51Y=\", false, function () {\n    return [useFiber];\n  });\n\n  function createChild(returnFiber, newChild, lanes) {\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      // Text nodes don't have keys. If the previous node is implicitly keyed\n      // we can continue to replace it without aborting even if it is not a text\n      // node.\n      const created = createFiberFromText('' + newChild, returnFiber.mode, lanes);\n      created.return = returnFiber;\n      return created;\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          {\n            const created = createFiberFromElement(newChild, returnFiber.mode, lanes);\n            created.ref = coerceRef(returnFiber, null, newChild);\n            created.return = returnFiber;\n            return created;\n          }\n\n        case REACT_PORTAL_TYPE:\n          {\n            const created = createFiberFromPortal(newChild, returnFiber.mode, lanes);\n            created.return = returnFiber;\n            return created;\n          }\n\n        case REACT_LAZY_TYPE:\n          {\n            if (enableLazyElements) {\n              const payload = newChild._payload;\n              const init = newChild._init;\n              return createChild(returnFiber, init(payload), lanes);\n            }\n          }\n      }\n\n      if (isArray(newChild) || getIteratorFn(newChild)) {\n        const created = createFiberFromFragment(newChild, returnFiber.mode, lanes, null);\n        created.return = returnFiber;\n        return created;\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    if (__DEV__) {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType(returnFiber);\n      }\n    }\n\n    return null;\n  }\n\n  function updateSlot(returnFiber, oldFiber, newChild, lanes) {\n    // Update the fiber if the keys match, otherwise return null.\n    const key = oldFiber !== null ? oldFiber.key : null;\n\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      // Text nodes don't have keys. If the previous node is implicitly keyed\n      // we can continue to replace it without aborting even if it is not a text\n      // node.\n      if (key !== null) {\n        return null;\n      }\n\n      return updateTextNode(returnFiber, oldFiber, '' + newChild, lanes);\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          {\n            if (newChild.key === key) {\n              return updateElement(returnFiber, oldFiber, newChild, lanes);\n            } else {\n              return null;\n            }\n          }\n\n        case REACT_PORTAL_TYPE:\n          {\n            if (newChild.key === key) {\n              return updatePortal(returnFiber, oldFiber, newChild, lanes);\n            } else {\n              return null;\n            }\n          }\n\n        case REACT_LAZY_TYPE:\n          {\n            if (enableLazyElements) {\n              const payload = newChild._payload;\n              const init = newChild._init;\n              return updateSlot(returnFiber, oldFiber, init(payload), lanes);\n            }\n          }\n      }\n\n      if (isArray(newChild) || getIteratorFn(newChild)) {\n        if (key !== null) {\n          return null;\n        }\n\n        return updateFragment(returnFiber, oldFiber, newChild, lanes, null);\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    if (__DEV__) {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType(returnFiber);\n      }\n    }\n\n    return null;\n  }\n\n  function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      // Text nodes don't have keys, so we neither have to check the old nor\n      // new node for the key. If both are text nodes, they match.\n      const matchedFiber = existingChildren.get(newIdx) || null;\n      return updateTextNode(returnFiber, matchedFiber, '' + newChild, lanes);\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          {\n            const matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n            return updateElement(returnFiber, matchedFiber, newChild, lanes);\n          }\n\n        case REACT_PORTAL_TYPE:\n          {\n            const matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n            return updatePortal(returnFiber, matchedFiber, newChild, lanes);\n          }\n\n        case REACT_LAZY_TYPE:\n          if (enableLazyElements) {\n            const payload = newChild._payload;\n            const init = newChild._init;\n            return updateFromMap(existingChildren, returnFiber, newIdx, init(payload), lanes);\n          }\n\n      }\n\n      if (isArray(newChild) || getIteratorFn(newChild)) {\n        const matchedFiber = existingChildren.get(newIdx) || null;\n        return updateFragment(returnFiber, matchedFiber, newChild, lanes, null);\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    if (__DEV__) {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType(returnFiber);\n      }\n    }\n\n    return null;\n  }\n  /**\n   * Warns if there is a duplicate or missing key\n   */\n\n\n  function warnOnInvalidKey(child, knownKeys, returnFiber) {\n    if (__DEV__) {\n      if (typeof child !== 'object' || child === null) {\n        return knownKeys;\n      }\n\n      switch (child.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n        case REACT_PORTAL_TYPE:\n          warnForMissingKey(child, returnFiber);\n          const key = child.key;\n\n          if (typeof key !== 'string') {\n            break;\n          }\n\n          if (knownKeys === null) {\n            knownKeys = new Set();\n            knownKeys.add(key);\n            break;\n          }\n\n          if (!knownKeys.has(key)) {\n            knownKeys.add(key);\n            break;\n          }\n\n          console.error('Encountered two children with the same key, `%s`. ' + 'Keys should be unique so that components maintain their identity ' + 'across updates. Non-unique keys may cause children to be ' + 'duplicated and/or omitted â€” the behavior is unsupported and ' + 'could change in a future version.', key);\n          break;\n\n        case REACT_LAZY_TYPE:\n          if (enableLazyElements) {\n            const payload = child._payload;\n            const init = child._init;\n            warnOnInvalidKey(init(payload), knownKeys, returnFiber);\n            break;\n          }\n\n        // We intentionally fallthrough here if enableLazyElements is not on.\n        // eslint-disable-next-lined no-fallthrough\n\n        default:\n          break;\n      }\n    }\n\n    return knownKeys;\n  }\n\n  function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {\n    // This algorithm can't optimize by searching from both ends since we\n    // don't have backpointers on fibers. I'm trying to see how far we can get\n    // with that model. If it ends up not being worth the tradeoffs, we can\n    // add it later.\n    // Even with a two ended optimization, we'd want to optimize for the case\n    // where there are few changes and brute force the comparison instead of\n    // going for the Map. It'd like to explore hitting that path first in\n    // forward-only mode and only go for the Map once we notice that we need\n    // lots of look ahead. This doesn't handle reversal as well as two ended\n    // search but that's unusual. Besides, for the two ended optimization to\n    // work on Iterables, we'd need to copy the whole set.\n    // In this first iteration, we'll just live with hitting the bad case\n    // (adding everything to a Map) in for every insert/move.\n    // If you change this code, also update reconcileChildrenIterator() which\n    // uses the same algorithm.\n    if (__DEV__) {\n      // First, validate keys.\n      let knownKeys = null;\n\n      for (let i = 0; i < newChildren.length; i++) {\n        const child = newChildren[i];\n        knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);\n      }\n    }\n\n    let resultingFirstChild = null;\n    let previousNewFiber = null;\n    let oldFiber = currentFirstChild;\n    let lastPlacedIndex = 0;\n    let newIdx = 0;\n    let nextOldFiber = null;\n\n    for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {\n      if (oldFiber.index > newIdx) {\n        nextOldFiber = oldFiber;\n        oldFiber = null;\n      } else {\n        nextOldFiber = oldFiber.sibling;\n      }\n\n      const newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);\n\n      if (newFiber === null) {\n        // TODO: This breaks on empty slots like null children. That's\n        // unfortunate because it triggers the slow path all the time. We need\n        // a better way to communicate whether this was a miss or null,\n        // boolean, undefined, etc.\n        if (oldFiber === null) {\n          oldFiber = nextOldFiber;\n        }\n\n        break;\n      }\n\n      if (shouldTrackSideEffects) {\n        if (oldFiber && newFiber.alternate === null) {\n          // We matched the slot, but we didn't reuse the existing fiber, so we\n          // need to delete the existing child.\n          deleteChild(returnFiber, oldFiber);\n        }\n      }\n\n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n\n      if (previousNewFiber === null) {\n        // TODO: Move out of the loop. This only happens for the first run.\n        resultingFirstChild = newFiber;\n      } else {\n        // TODO: Defer siblings if we're not at the right index for this slot.\n        // I.e. if we had null values before, then we want to defer this\n        // for each null value. However, we also don't want to call updateSlot\n        // with the previous one.\n        previousNewFiber.sibling = newFiber;\n      }\n\n      previousNewFiber = newFiber;\n      oldFiber = nextOldFiber;\n    }\n\n    if (newIdx === newChildren.length) {\n      // We've reached the end of the new children. We can delete the rest.\n      deleteRemainingChildren(returnFiber, oldFiber);\n\n      if (getIsHydrating()) {\n        const numberOfForks = newIdx;\n        pushTreeFork(returnFiber, numberOfForks);\n      }\n\n      return resultingFirstChild;\n    }\n\n    if (oldFiber === null) {\n      // If we don't have any more existing children we can choose a fast path\n      // since the rest will all be insertions.\n      for (; newIdx < newChildren.length; newIdx++) {\n        const newFiber = createChild(returnFiber, newChildren[newIdx], lanes);\n\n        if (newFiber === null) {\n          continue;\n        }\n\n        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n\n        if (previousNewFiber === null) {\n          // TODO: Move out of the loop. This only happens for the first run.\n          resultingFirstChild = newFiber;\n        } else {\n          previousNewFiber.sibling = newFiber;\n        }\n\n        previousNewFiber = newFiber;\n      }\n\n      if (getIsHydrating()) {\n        const numberOfForks = newIdx;\n        pushTreeFork(returnFiber, numberOfForks);\n      }\n\n      return resultingFirstChild;\n    } // Add all children to a key map for quick lookups.\n\n\n    const existingChildren = mapRemainingChildren(returnFiber, oldFiber); // Keep scanning and use the map to restore deleted items as moves.\n\n    for (; newIdx < newChildren.length; newIdx++) {\n      const newFiber = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], lanes);\n\n      if (newFiber !== null) {\n        if (shouldTrackSideEffects) {\n          if (newFiber.alternate !== null) {\n            // The new fiber is a work in progress, but if there exists a\n            // current, that means that we reused the fiber. We need to delete\n            // it from the child list so that we don't add it to the deletion\n            // list.\n            existingChildren.delete(newFiber.key === null ? newIdx : newFiber.key);\n          }\n        }\n\n        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n\n        if (previousNewFiber === null) {\n          resultingFirstChild = newFiber;\n        } else {\n          previousNewFiber.sibling = newFiber;\n        }\n\n        previousNewFiber = newFiber;\n      }\n    }\n\n    if (shouldTrackSideEffects) {\n      // Any existing children that weren't consumed above were deleted. We need\n      // to add them to the deletion list.\n      existingChildren.forEach(child => deleteChild(returnFiber, child));\n    }\n\n    if (getIsHydrating()) {\n      const numberOfForks = newIdx;\n      pushTreeFork(returnFiber, numberOfForks);\n    }\n\n    return resultingFirstChild;\n  }\n\n  function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, lanes) {\n    // This is the same implementation as reconcileChildrenArray(),\n    // but using the iterator instead.\n    const iteratorFn = getIteratorFn(newChildrenIterable);\n\n    if (typeof iteratorFn !== 'function') {\n      throw new Error('An object is not an iterable. This error is likely caused by a bug in ' + 'React. Please file an issue.');\n    }\n\n    if (__DEV__) {\n      // We don't support rendering Generators because it's a mutation.\n      // See https://github.com/facebook/react/issues/12995\n      if (typeof Symbol === 'function' && // $FlowFixMe Flow doesn't know about toStringTag\n      newChildrenIterable[Symbol.toStringTag] === 'Generator') {\n        if (!didWarnAboutGenerators) {\n          console.error('Using Generators as children is unsupported and will likely yield ' + 'unexpected results because enumerating a generator mutates it. ' + 'You may convert it to an array with `Array.from()` or the ' + '`[...spread]` operator before rendering. Keep in mind ' + 'you might need to polyfill these features for older browsers.');\n        }\n\n        didWarnAboutGenerators = true;\n      } // Warn about using Maps as children\n\n\n      if (newChildrenIterable.entries === iteratorFn) {\n        if (!didWarnAboutMaps) {\n          console.error('Using Maps as children is not supported. ' + 'Use an array of keyed ReactElements instead.');\n        }\n\n        didWarnAboutMaps = true;\n      } // First, validate keys.\n      // We'll get a different iterator later for the main pass.\n\n\n      const newChildren = iteratorFn.call(newChildrenIterable);\n\n      if (newChildren) {\n        let knownKeys = null;\n        let step = newChildren.next();\n\n        for (; !step.done; step = newChildren.next()) {\n          const child = step.value;\n          knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);\n        }\n      }\n    }\n\n    const newChildren = iteratorFn.call(newChildrenIterable);\n\n    if (newChildren == null) {\n      throw new Error('An iterable object provided no iterator.');\n    }\n\n    let resultingFirstChild = null;\n    let previousNewFiber = null;\n    let oldFiber = currentFirstChild;\n    let lastPlacedIndex = 0;\n    let newIdx = 0;\n    let nextOldFiber = null;\n    let step = newChildren.next();\n\n    for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {\n      if (oldFiber.index > newIdx) {\n        nextOldFiber = oldFiber;\n        oldFiber = null;\n      } else {\n        nextOldFiber = oldFiber.sibling;\n      }\n\n      const newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);\n\n      if (newFiber === null) {\n        // TODO: This breaks on empty slots like null children. That's\n        // unfortunate because it triggers the slow path all the time. We need\n        // a better way to communicate whether this was a miss or null,\n        // boolean, undefined, etc.\n        if (oldFiber === null) {\n          oldFiber = nextOldFiber;\n        }\n\n        break;\n      }\n\n      if (shouldTrackSideEffects) {\n        if (oldFiber && newFiber.alternate === null) {\n          // We matched the slot, but we didn't reuse the existing fiber, so we\n          // need to delete the existing child.\n          deleteChild(returnFiber, oldFiber);\n        }\n      }\n\n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n\n      if (previousNewFiber === null) {\n        // TODO: Move out of the loop. This only happens for the first run.\n        resultingFirstChild = newFiber;\n      } else {\n        // TODO: Defer siblings if we're not at the right index for this slot.\n        // I.e. if we had null values before, then we want to defer this\n        // for each null value. However, we also don't want to call updateSlot\n        // with the previous one.\n        previousNewFiber.sibling = newFiber;\n      }\n\n      previousNewFiber = newFiber;\n      oldFiber = nextOldFiber;\n    }\n\n    if (step.done) {\n      // We've reached the end of the new children. We can delete the rest.\n      deleteRemainingChildren(returnFiber, oldFiber);\n\n      if (getIsHydrating()) {\n        const numberOfForks = newIdx;\n        pushTreeFork(returnFiber, numberOfForks);\n      }\n\n      return resultingFirstChild;\n    }\n\n    if (oldFiber === null) {\n      // If we don't have any more existing children we can choose a fast path\n      // since the rest will all be insertions.\n      for (; !step.done; newIdx++, step = newChildren.next()) {\n        const newFiber = createChild(returnFiber, step.value, lanes);\n\n        if (newFiber === null) {\n          continue;\n        }\n\n        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n\n        if (previousNewFiber === null) {\n          // TODO: Move out of the loop. This only happens for the first run.\n          resultingFirstChild = newFiber;\n        } else {\n          previousNewFiber.sibling = newFiber;\n        }\n\n        previousNewFiber = newFiber;\n      }\n\n      if (getIsHydrating()) {\n        const numberOfForks = newIdx;\n        pushTreeFork(returnFiber, numberOfForks);\n      }\n\n      return resultingFirstChild;\n    } // Add all children to a key map for quick lookups.\n\n\n    const existingChildren = mapRemainingChildren(returnFiber, oldFiber); // Keep scanning and use the map to restore deleted items as moves.\n\n    for (; !step.done; newIdx++, step = newChildren.next()) {\n      const newFiber = updateFromMap(existingChildren, returnFiber, newIdx, step.value, lanes);\n\n      if (newFiber !== null) {\n        if (shouldTrackSideEffects) {\n          if (newFiber.alternate !== null) {\n            // The new fiber is a work in progress, but if there exists a\n            // current, that means that we reused the fiber. We need to delete\n            // it from the child list so that we don't add it to the deletion\n            // list.\n            existingChildren.delete(newFiber.key === null ? newIdx : newFiber.key);\n          }\n        }\n\n        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n\n        if (previousNewFiber === null) {\n          resultingFirstChild = newFiber;\n        } else {\n          previousNewFiber.sibling = newFiber;\n        }\n\n        previousNewFiber = newFiber;\n      }\n    }\n\n    if (shouldTrackSideEffects) {\n      // Any existing children that weren't consumed above were deleted. We need\n      // to add them to the deletion list.\n      existingChildren.forEach(child => deleteChild(returnFiber, child));\n    }\n\n    if (getIsHydrating()) {\n      const numberOfForks = newIdx;\n      pushTreeFork(returnFiber, numberOfForks);\n    }\n\n    return resultingFirstChild;\n  }\n\n  function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, lanes) {\n    _s5();\n\n    // There's no need to check for keys on text nodes since we don't have a\n    // way to define them.\n    if (currentFirstChild !== null && currentFirstChild.tag === HostText) {\n      // We already have an existing node so let's just update it and delete\n      // the rest.\n      deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n      const existing = useFiber(currentFirstChild, textContent);\n      existing.return = returnFiber;\n      return existing;\n    } // The existing first child is not a text node so we need to create one\n    // and delete the existing ones.\n\n\n    deleteRemainingChildren(returnFiber, currentFirstChild);\n    const created = createFiberFromText(textContent, returnFiber.mode, lanes);\n    created.return = returnFiber;\n    return created;\n  }\n\n  _s5(reconcileSingleTextNode, \"kiHzbwuEosy3to0T/G280Ayd51Y=\", false, function () {\n    return [useFiber];\n  });\n\n  function reconcileSingleElement(returnFiber, currentFirstChild, element, lanes) {\n    _s6();\n\n    const key = element.key;\n    let child = currentFirstChild;\n\n    while (child !== null) {\n      // TODO: If key === null and child.key === null, then this only applies to\n      // the first item in the list.\n      if (child.key === key) {\n        const elementType = element.type;\n\n        if (elementType === REACT_FRAGMENT_TYPE) {\n          if (child.tag === Fragment) {\n            deleteRemainingChildren(returnFiber, child.sibling);\n            const existing = useFiber(child, element.props.children);\n            existing.return = returnFiber;\n\n            if (__DEV__) {\n              existing._debugSource = element._source;\n              existing._debugOwner = element._owner;\n            }\n\n            return existing;\n          }\n        } else {\n          if (child.elementType === elementType || ( // Keep this check inline so it only runs on the false path:\n          __DEV__ ? isCompatibleFamilyForHotReloading(child, element) : false) || // Lazy types should reconcile their resolved type.\n          // We need to do this after the Hot Reloading check above,\n          // because hot reloading has different semantics than prod because\n          // it doesn't resuspend. So we can't let the call below suspend.\n          enableLazyElements && typeof elementType === 'object' && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === child.type) {\n            deleteRemainingChildren(returnFiber, child.sibling);\n            const existing = useFiber(child, element.props);\n            existing.ref = coerceRef(returnFiber, child, element);\n            existing.return = returnFiber;\n\n            if (__DEV__) {\n              existing._debugSource = element._source;\n              existing._debugOwner = element._owner;\n            }\n\n            return existing;\n          }\n        } // Didn't match.\n\n\n        deleteRemainingChildren(returnFiber, child);\n        break;\n      } else {\n        deleteChild(returnFiber, child);\n      }\n\n      child = child.sibling;\n    }\n\n    if (element.type === REACT_FRAGMENT_TYPE) {\n      const created = createFiberFromFragment(element.props.children, returnFiber.mode, lanes, element.key);\n      created.return = returnFiber;\n      return created;\n    } else {\n      const created = createFiberFromElement(element, returnFiber.mode, lanes);\n      created.ref = coerceRef(returnFiber, currentFirstChild, element);\n      created.return = returnFiber;\n      return created;\n    }\n  }\n\n  _s6(reconcileSingleElement, \"YD9wqb/AD6BbMBjrepuEiWevtjU=\", false, function () {\n    return [useFiber, useFiber];\n  });\n\n  function reconcileSinglePortal(returnFiber, currentFirstChild, portal, lanes) {\n    _s7();\n\n    const key = portal.key;\n    let child = currentFirstChild;\n\n    while (child !== null) {\n      // TODO: If key === null and child.key === null, then this only applies to\n      // the first item in the list.\n      if (child.key === key) {\n        if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {\n          deleteRemainingChildren(returnFiber, child.sibling);\n          const existing = useFiber(child, portal.children || []);\n          existing.return = returnFiber;\n          return existing;\n        } else {\n          deleteRemainingChildren(returnFiber, child);\n          break;\n        }\n      } else {\n        deleteChild(returnFiber, child);\n      }\n\n      child = child.sibling;\n    }\n\n    const created = createFiberFromPortal(portal, returnFiber.mode, lanes);\n    created.return = returnFiber;\n    return created;\n  } // This API will tag the children with the side-effect of the reconciliation\n  // itself. They will be added to the side-effect list as we pass through the\n  // children and the parent.\n\n\n  _s7(reconcileSinglePortal, \"kiHzbwuEosy3to0T/G280Ayd51Y=\", false, function () {\n    return [useFiber];\n  });\n\n  function reconcileChildFibers(returnFiber, currentFirstChild, newChild, lanes) {\n    // This function is not recursive.\n    // If the top level item is an array, we treat it as a set of children,\n    // not as a fragment. Nested arrays on the other hand will be treated as\n    // fragment nodes. Recursion happens at the normal flow.\n    // Handle top level unkeyed fragments as if they were arrays.\n    // This leads to an ambiguity between <>{[...]}</> and <>...</>.\n    // We treat the ambiguous cases above the same.\n    const isUnkeyedTopLevelFragment = typeof newChild === 'object' && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null;\n\n    if (isUnkeyedTopLevelFragment) {\n      newChild = newChild.props.children;\n    } // Handle object types\n\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, lanes));\n\n        case REACT_PORTAL_TYPE:\n          return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, lanes));\n\n        case REACT_LAZY_TYPE:\n          if (enableLazyElements) {\n            const payload = newChild._payload;\n            const init = newChild._init; // TODO: This function is supposed to be non-recursive.\n\n            return reconcileChildFibers(returnFiber, currentFirstChild, init(payload), lanes);\n          }\n\n      }\n\n      if (isArray(newChild)) {\n        return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes);\n      }\n\n      if (getIteratorFn(newChild)) {\n        return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, lanes);\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, '' + newChild, lanes));\n    }\n\n    if (__DEV__) {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType(returnFiber);\n      }\n    } // Remaining cases are all treated as empty.\n\n\n    return deleteRemainingChildren(returnFiber, currentFirstChild);\n  }\n\n  return reconcileChildFibers;\n}\n\n_c = ChildReconciler;\nexport const reconcileChildFibers = ChildReconciler(true);\nexport const mountChildFibers = ChildReconciler(false);\nexport function cloneChildFibers(current, workInProgress) {\n  if (current !== null && workInProgress.child !== current.child) {\n    throw new Error('Resuming work not yet implemented.');\n  }\n\n  if (workInProgress.child === null) {\n    return;\n  }\n\n  let currentChild = workInProgress.child;\n  let newChild = createWorkInProgress(currentChild, currentChild.pendingProps);\n  workInProgress.child = newChild;\n  newChild.return = workInProgress;\n\n  while (currentChild.sibling !== null) {\n    currentChild = currentChild.sibling;\n    newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps);\n    newChild.return = workInProgress;\n  }\n\n  newChild.sibling = null;\n} // Reset a workInProgress child set to prepare it for a second pass.\n\nexport function resetChildFibers(workInProgress, lanes) {\n  let child = workInProgress.child;\n\n  while (child !== null) {\n    resetWorkInProgress(child, lanes);\n    child = child.sibling;\n  }\n}\n\nvar _c;\n\n$RefreshReg$(_c, \"ChildReconciler\");","map":{"version":3,"sources":["/Users/zhangshuo/git/react-source-test/src/react/packages/react-reconciler/src/ReactChildFiber.new.js"],"names":["getComponentNameFromFiber","Placement","ChildDeletion","Forked","getIteratorFn","REACT_ELEMENT_TYPE","REACT_FRAGMENT_TYPE","REACT_PORTAL_TYPE","REACT_LAZY_TYPE","ClassComponent","HostText","HostPortal","Fragment","isArray","warnAboutStringRefs","enableLazyElements","checkPropStringCoercion","createWorkInProgress","resetWorkInProgress","createFiberFromElement","createFiberFromFragment","createFiberFromText","createFiberFromPortal","emptyRefsObject","isCompatibleFamilyForHotReloading","StrictLegacyMode","getIsHydrating","pushTreeFork","didWarnAboutMaps","didWarnAboutGenerators","didWarnAboutStringRefs","ownerHasKeyUseWarning","ownerHasFunctionTypeWarning","warnForMissingKey","child","returnFiber","__DEV__","_store","validated","key","Error","componentName","console","error","coerceRef","current","element","mixedRef","ref","mode","_owner","_self","stateNode","owner","inst","ownerFiber","tag","resolvedInst","stringRef","_stringRef","value","refs","throwOnInvalidObjectType","newChild","childString","Object","prototype","toString","call","keys","join","warnOnFunctionType","resolveLazy","lazyType","payload","_payload","init","_init","ChildReconciler","shouldTrackSideEffects","deleteChild","childToDelete","deletions","flags","push","deleteRemainingChildren","currentFirstChild","sibling","mapRemainingChildren","existingChildren","Map","existingChild","set","index","useFiber","fiber","pendingProps","clone","placeChild","newFiber","lastPlacedIndex","newIndex","alternate","oldIndex","placeSingleChild","updateTextNode","textContent","lanes","created","return","existing","updateElement","elementType","type","updateFragment","props","children","$$typeof","_debugSource","_source","_debugOwner","updatePortal","portal","containerInfo","implementation","fragment","createChild","updateSlot","oldFiber","updateFromMap","newIdx","matchedFiber","get","warnOnInvalidKey","knownKeys","Set","add","has","reconcileChildrenArray","newChildren","i","length","resultingFirstChild","previousNewFiber","nextOldFiber","numberOfForks","delete","forEach","reconcileChildrenIterator","newChildrenIterable","iteratorFn","Symbol","toStringTag","entries","step","next","done","reconcileSingleTextNode","reconcileSingleElement","reconcileSinglePortal","reconcileChildFibers","isUnkeyedTopLevelFragment","mountChildFibers","cloneChildFibers","workInProgress","currentChild","resetChildFibers"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {ReactElement} from 'shared/ReactElementType';\nimport type {ReactPortal} from 'shared/ReactTypes';\nimport type {Fiber} from './ReactInternalTypes';\nimport type {Lanes} from './ReactFiberLane.new';\n\nimport getComponentNameFromFiber from 'react-reconciler/src/getComponentNameFromFiber';\nimport {Placement, ChildDeletion, Forked} from './ReactFiberFlags';\nimport {\n  getIteratorFn,\n  REACT_ELEMENT_TYPE,\n  REACT_FRAGMENT_TYPE,\n  REACT_PORTAL_TYPE,\n  REACT_LAZY_TYPE,\n} from 'shared/ReactSymbols';\nimport {ClassComponent, HostText, HostPortal, Fragment} from './ReactWorkTags';\nimport isArray from 'shared/isArray';\nimport {\n  warnAboutStringRefs,\n  enableLazyElements,\n} from 'shared/ReactFeatureFlags';\nimport {checkPropStringCoercion} from 'shared/CheckStringCoercion';\n\nimport {\n  createWorkInProgress,\n  resetWorkInProgress,\n  createFiberFromElement,\n  createFiberFromFragment,\n  createFiberFromText,\n  createFiberFromPortal,\n} from './ReactFiber.new';\nimport {emptyRefsObject} from './ReactFiberClassComponent.new';\nimport {isCompatibleFamilyForHotReloading} from './ReactFiberHotReloading.new';\nimport {StrictLegacyMode} from './ReactTypeOfMode';\nimport {getIsHydrating} from './ReactFiberHydrationContext.new';\nimport {pushTreeFork} from './ReactFiberTreeContext.new';\n\nlet didWarnAboutMaps;\nlet didWarnAboutGenerators;\nlet didWarnAboutStringRefs;\nlet ownerHasKeyUseWarning;\nlet ownerHasFunctionTypeWarning;\nlet warnForMissingKey = (child: mixed, returnFiber: Fiber) => {};\n\nif (__DEV__) {\n  didWarnAboutMaps = false;\n  didWarnAboutGenerators = false;\n  didWarnAboutStringRefs = {};\n\n  /**\n   * Warn if there's no key explicitly set on dynamic arrays of children or\n   * object keys are not valid. This allows us to keep track of children between\n   * updates.\n   */\n  ownerHasKeyUseWarning = {};\n  ownerHasFunctionTypeWarning = {};\n\n  warnForMissingKey = (child: mixed, returnFiber: Fiber) => {\n    if (child === null || typeof child !== 'object') {\n      return;\n    }\n    if (!child._store || child._store.validated || child.key != null) {\n      return;\n    }\n\n    if (typeof child._store !== 'object') {\n      throw new Error(\n        'React Component in warnForMissingKey should have a _store. ' +\n          'This error is likely caused by a bug in React. Please file an issue.',\n      );\n    }\n\n    child._store.validated = true;\n\n    const componentName = getComponentNameFromFiber(returnFiber) || 'Component';\n\n    if (ownerHasKeyUseWarning[componentName]) {\n      return;\n    }\n    ownerHasKeyUseWarning[componentName] = true;\n\n    console.error(\n      'Each child in a list should have a unique ' +\n        '\"key\" prop. See https://reactjs.org/link/warning-keys for ' +\n        'more information.',\n    );\n  };\n}\n\nfunction coerceRef(\n  returnFiber: Fiber,\n  current: Fiber | null,\n  element: ReactElement,\n) {\n  const mixedRef = element.ref;\n  if (\n    mixedRef !== null &&\n    typeof mixedRef !== 'function' &&\n    typeof mixedRef !== 'object'\n  ) {\n    if (__DEV__) {\n      // TODO: Clean this up once we turn on the string ref warning for\n      // everyone, because the strict mode case will no longer be relevant\n      if (\n        (returnFiber.mode & StrictLegacyMode || warnAboutStringRefs) &&\n        // We warn in ReactElement.js if owner and self are equal for string refs\n        // because these cannot be automatically converted to an arrow function\n        // using a codemod. Therefore, we don't have to warn about string refs again.\n        !(\n          element._owner &&\n          element._self &&\n          element._owner.stateNode !== element._self\n        )\n      ) {\n        const componentName =\n          getComponentNameFromFiber(returnFiber) || 'Component';\n        if (!didWarnAboutStringRefs[componentName]) {\n          if (warnAboutStringRefs) {\n            console.error(\n              'Component \"%s\" contains the string ref \"%s\". Support for string refs ' +\n                'will be removed in a future major release. We recommend using ' +\n                'useRef() or createRef() instead. ' +\n                'Learn more about using refs safely here: ' +\n                'https://reactjs.org/link/strict-mode-string-ref',\n              componentName,\n              mixedRef,\n            );\n          } else {\n            console.error(\n              'A string ref, \"%s\", has been found within a strict mode tree. ' +\n                'String refs are a source of potential bugs and should be avoided. ' +\n                'We recommend using useRef() or createRef() instead. ' +\n                'Learn more about using refs safely here: ' +\n                'https://reactjs.org/link/strict-mode-string-ref',\n              mixedRef,\n            );\n          }\n          didWarnAboutStringRefs[componentName] = true;\n        }\n      }\n    }\n\n    if (element._owner) {\n      const owner: ?Fiber = (element._owner: any);\n      let inst;\n      if (owner) {\n        const ownerFiber = ((owner: any): Fiber);\n\n        if (ownerFiber.tag !== ClassComponent) {\n          throw new Error(\n            'Function components cannot have string refs. ' +\n              'We recommend using useRef() instead. ' +\n              'Learn more about using refs safely here: ' +\n              'https://reactjs.org/link/strict-mode-string-ref',\n          );\n        }\n\n        inst = ownerFiber.stateNode;\n      }\n\n      if (!inst) {\n        throw new Error(\n          `Missing owner for string ref ${mixedRef}. This error is likely caused by a ` +\n            'bug in React. Please file an issue.',\n        );\n      }\n      // Assigning this to a const so Flow knows it won't change in the closure\n      const resolvedInst = inst;\n\n      if (__DEV__) {\n        checkPropStringCoercion(mixedRef, 'ref');\n      }\n      const stringRef = '' + mixedRef;\n      // Check if previous string ref matches new string ref\n      if (\n        current !== null &&\n        current.ref !== null &&\n        typeof current.ref === 'function' &&\n        current.ref._stringRef === stringRef\n      ) {\n        return current.ref;\n      }\n      const ref = function(value) {\n        let refs = resolvedInst.refs;\n        if (refs === emptyRefsObject) {\n          // This is a lazy pooled frozen object, so we need to initialize.\n          refs = resolvedInst.refs = {};\n        }\n        if (value === null) {\n          delete refs[stringRef];\n        } else {\n          refs[stringRef] = value;\n        }\n      };\n      ref._stringRef = stringRef;\n      return ref;\n    } else {\n      if (typeof mixedRef !== 'string') {\n        throw new Error(\n          'Expected ref to be a function, a string, an object returned by React.createRef(), or null.',\n        );\n      }\n\n      if (!element._owner) {\n        throw new Error(\n          `Element ref was specified as a string (${mixedRef}) but no owner was set. This could happen for one of` +\n            ' the following reasons:\\n' +\n            '1. You may be adding a ref to a function component\\n' +\n            \"2. You may be adding a ref to a component that was not created inside a component's render method\\n\" +\n            '3. You have multiple copies of React loaded\\n' +\n            'See https://reactjs.org/link/refs-must-have-owner for more information.',\n        );\n      }\n    }\n  }\n  return mixedRef;\n}\n\nfunction throwOnInvalidObjectType(returnFiber: Fiber, newChild: Object) {\n  const childString = Object.prototype.toString.call(newChild);\n\n  throw new Error(\n    `Objects are not valid as a React child (found: ${\n      childString === '[object Object]'\n        ? 'object with keys {' + Object.keys(newChild).join(', ') + '}'\n        : childString\n    }). ` +\n      'If you meant to render a collection of children, use an array ' +\n      'instead.',\n  );\n}\n\nfunction warnOnFunctionType(returnFiber: Fiber) {\n  if (__DEV__) {\n    const componentName = getComponentNameFromFiber(returnFiber) || 'Component';\n\n    if (ownerHasFunctionTypeWarning[componentName]) {\n      return;\n    }\n    ownerHasFunctionTypeWarning[componentName] = true;\n\n    console.error(\n      'Functions are not valid as a React child. This may happen if ' +\n        'you return a Component instead of <Component /> from render. ' +\n        'Or maybe you meant to call this function rather than return it.',\n    );\n  }\n}\n\nfunction resolveLazy(lazyType) {\n  const payload = lazyType._payload;\n  const init = lazyType._init;\n  return init(payload);\n}\n\n// This wrapper function exists because I expect to clone the code in each path\n// to be able to optimize each path individually by branching early. This needs\n// a compiler or we can do it manually. Helpers that don't need this branching\n// live outside of this function.\nfunction ChildReconciler(shouldTrackSideEffects) {\n  function deleteChild(returnFiber: Fiber, childToDelete: Fiber): void {\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return;\n    }\n    const deletions = returnFiber.deletions;\n    if (deletions === null) {\n      returnFiber.deletions = [childToDelete];\n      returnFiber.flags |= ChildDeletion;\n    } else {\n      deletions.push(childToDelete);\n    }\n  }\n\n  function deleteRemainingChildren(\n    returnFiber: Fiber,\n    currentFirstChild: Fiber | null,\n  ): null {\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return null;\n    }\n\n    // TODO: For the shouldClone case, this could be micro-optimized a bit by\n    // assuming that after the first child we've already added everything.\n    let childToDelete = currentFirstChild;\n    while (childToDelete !== null) {\n      deleteChild(returnFiber, childToDelete);\n      childToDelete = childToDelete.sibling;\n    }\n    return null;\n  }\n\n  function mapRemainingChildren(\n    returnFiber: Fiber,\n    currentFirstChild: Fiber,\n  ): Map<string | number, Fiber> {\n    // Add the remaining children to a temporary map so that we can find them by\n    // keys quickly. Implicit (null) keys get added to this set with their index\n    // instead.\n    const existingChildren: Map<string | number, Fiber> = new Map();\n\n    let existingChild = currentFirstChild;\n    while (existingChild !== null) {\n      if (existingChild.key !== null) {\n        existingChildren.set(existingChild.key, existingChild);\n      } else {\n        existingChildren.set(existingChild.index, existingChild);\n      }\n      existingChild = existingChild.sibling;\n    }\n    return existingChildren;\n  }\n\n  function useFiber(fiber: Fiber, pendingProps: mixed): Fiber {\n    // We currently set sibling to null and index to 0 here because it is easy\n    // to forget to do before returning it. E.g. for the single child case.\n    const clone = createWorkInProgress(fiber, pendingProps);\n    clone.index = 0;\n    clone.sibling = null;\n    return clone;\n  }\n\n  function placeChild(\n    newFiber: Fiber,\n    lastPlacedIndex: number,\n    newIndex: number,\n  ): number {\n    newFiber.index = newIndex;\n    if (!shouldTrackSideEffects) {\n      // During hydration, the useId algorithm needs to know which fibers are\n      // part of a list of children (arrays, iterators).\n      newFiber.flags |= Forked;\n      return lastPlacedIndex;\n    }\n    const current = newFiber.alternate;\n    if (current !== null) {\n      const oldIndex = current.index;\n      if (oldIndex < lastPlacedIndex) {\n        // This is a move.\n        newFiber.flags |= Placement;\n        return lastPlacedIndex;\n      } else {\n        // This item can stay in place.\n        return oldIndex;\n      }\n    } else {\n      // This is an insertion.\n      newFiber.flags |= Placement;\n      return lastPlacedIndex;\n    }\n  }\n\n  function placeSingleChild(newFiber: Fiber): Fiber {\n    // This is simpler for the single child case. We only need to do a\n    // placement for inserting new children.\n    if (shouldTrackSideEffects && newFiber.alternate === null) {\n      newFiber.flags |= Placement;\n    }\n    return newFiber;\n  }\n\n  function updateTextNode(\n    returnFiber: Fiber,\n    current: Fiber | null,\n    textContent: string,\n    lanes: Lanes,\n  ) {\n    if (current === null || current.tag !== HostText) {\n      // Insert\n      const created = createFiberFromText(textContent, returnFiber.mode, lanes);\n      created.return = returnFiber;\n      return created;\n    } else {\n      // Update\n      const existing = useFiber(current, textContent);\n      existing.return = returnFiber;\n      return existing;\n    }\n  }\n\n  function updateElement(\n    returnFiber: Fiber,\n    current: Fiber | null,\n    element: ReactElement,\n    lanes: Lanes,\n  ): Fiber {\n    const elementType = element.type;\n    if (elementType === REACT_FRAGMENT_TYPE) {\n      return updateFragment(\n        returnFiber,\n        current,\n        element.props.children,\n        lanes,\n        element.key,\n      );\n    }\n    if (current !== null) {\n      if (\n        current.elementType === elementType ||\n        // Keep this check inline so it only runs on the false path:\n        (__DEV__\n          ? isCompatibleFamilyForHotReloading(current, element)\n          : false) ||\n        // Lazy types should reconcile their resolved type.\n        // We need to do this after the Hot Reloading check above,\n        // because hot reloading has different semantics than prod because\n        // it doesn't resuspend. So we can't let the call below suspend.\n        (enableLazyElements &&\n          typeof elementType === 'object' &&\n          elementType !== null &&\n          elementType.$$typeof === REACT_LAZY_TYPE &&\n          resolveLazy(elementType) === current.type)\n      ) {\n        // Move based on index\n        const existing = useFiber(current, element.props);\n        existing.ref = coerceRef(returnFiber, current, element);\n        existing.return = returnFiber;\n        if (__DEV__) {\n          existing._debugSource = element._source;\n          existing._debugOwner = element._owner;\n        }\n        return existing;\n      }\n    }\n    // Insert\n    const created = createFiberFromElement(element, returnFiber.mode, lanes);\n    created.ref = coerceRef(returnFiber, current, element);\n    created.return = returnFiber;\n    return created;\n  }\n\n  function updatePortal(\n    returnFiber: Fiber,\n    current: Fiber | null,\n    portal: ReactPortal,\n    lanes: Lanes,\n  ): Fiber {\n    if (\n      current === null ||\n      current.tag !== HostPortal ||\n      current.stateNode.containerInfo !== portal.containerInfo ||\n      current.stateNode.implementation !== portal.implementation\n    ) {\n      // Insert\n      const created = createFiberFromPortal(portal, returnFiber.mode, lanes);\n      created.return = returnFiber;\n      return created;\n    } else {\n      // Update\n      const existing = useFiber(current, portal.children || []);\n      existing.return = returnFiber;\n      return existing;\n    }\n  }\n\n  function updateFragment(\n    returnFiber: Fiber,\n    current: Fiber | null,\n    fragment: Iterable<*>,\n    lanes: Lanes,\n    key: null | string,\n  ): Fiber {\n    if (current === null || current.tag !== Fragment) {\n      // Insert\n      const created = createFiberFromFragment(\n        fragment,\n        returnFiber.mode,\n        lanes,\n        key,\n      );\n      created.return = returnFiber;\n      return created;\n    } else {\n      // Update\n      const existing = useFiber(current, fragment);\n      existing.return = returnFiber;\n      return existing;\n    }\n  }\n\n  function createChild(\n    returnFiber: Fiber,\n    newChild: any,\n    lanes: Lanes,\n  ): Fiber | null {\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      // Text nodes don't have keys. If the previous node is implicitly keyed\n      // we can continue to replace it without aborting even if it is not a text\n      // node.\n      const created = createFiberFromText(\n        '' + newChild,\n        returnFiber.mode,\n        lanes,\n      );\n      created.return = returnFiber;\n      return created;\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE: {\n          const created = createFiberFromElement(\n            newChild,\n            returnFiber.mode,\n            lanes,\n          );\n          created.ref = coerceRef(returnFiber, null, newChild);\n          created.return = returnFiber;\n          return created;\n        }\n        case REACT_PORTAL_TYPE: {\n          const created = createFiberFromPortal(\n            newChild,\n            returnFiber.mode,\n            lanes,\n          );\n          created.return = returnFiber;\n          return created;\n        }\n        case REACT_LAZY_TYPE: {\n          if (enableLazyElements) {\n            const payload = newChild._payload;\n            const init = newChild._init;\n            return createChild(returnFiber, init(payload), lanes);\n          }\n        }\n      }\n\n      if (isArray(newChild) || getIteratorFn(newChild)) {\n        const created = createFiberFromFragment(\n          newChild,\n          returnFiber.mode,\n          lanes,\n          null,\n        );\n        created.return = returnFiber;\n        return created;\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    if (__DEV__) {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType(returnFiber);\n      }\n    }\n\n    return null;\n  }\n\n  function updateSlot(\n    returnFiber: Fiber,\n    oldFiber: Fiber | null,\n    newChild: any,\n    lanes: Lanes,\n  ): Fiber | null {\n    // Update the fiber if the keys match, otherwise return null.\n\n    const key = oldFiber !== null ? oldFiber.key : null;\n\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      // Text nodes don't have keys. If the previous node is implicitly keyed\n      // we can continue to replace it without aborting even if it is not a text\n      // node.\n      if (key !== null) {\n        return null;\n      }\n      return updateTextNode(returnFiber, oldFiber, '' + newChild, lanes);\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE: {\n          if (newChild.key === key) {\n            return updateElement(returnFiber, oldFiber, newChild, lanes);\n          } else {\n            return null;\n          }\n        }\n        case REACT_PORTAL_TYPE: {\n          if (newChild.key === key) {\n            return updatePortal(returnFiber, oldFiber, newChild, lanes);\n          } else {\n            return null;\n          }\n        }\n        case REACT_LAZY_TYPE: {\n          if (enableLazyElements) {\n            const payload = newChild._payload;\n            const init = newChild._init;\n            return updateSlot(returnFiber, oldFiber, init(payload), lanes);\n          }\n        }\n      }\n\n      if (isArray(newChild) || getIteratorFn(newChild)) {\n        if (key !== null) {\n          return null;\n        }\n\n        return updateFragment(returnFiber, oldFiber, newChild, lanes, null);\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    if (__DEV__) {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType(returnFiber);\n      }\n    }\n\n    return null;\n  }\n\n  function updateFromMap(\n    existingChildren: Map<string | number, Fiber>,\n    returnFiber: Fiber,\n    newIdx: number,\n    newChild: any,\n    lanes: Lanes,\n  ): Fiber | null {\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      // Text nodes don't have keys, so we neither have to check the old nor\n      // new node for the key. If both are text nodes, they match.\n      const matchedFiber = existingChildren.get(newIdx) || null;\n      return updateTextNode(returnFiber, matchedFiber, '' + newChild, lanes);\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE: {\n          const matchedFiber =\n            existingChildren.get(\n              newChild.key === null ? newIdx : newChild.key,\n            ) || null;\n          return updateElement(returnFiber, matchedFiber, newChild, lanes);\n        }\n        case REACT_PORTAL_TYPE: {\n          const matchedFiber =\n            existingChildren.get(\n              newChild.key === null ? newIdx : newChild.key,\n            ) || null;\n          return updatePortal(returnFiber, matchedFiber, newChild, lanes);\n        }\n        case REACT_LAZY_TYPE:\n          if (enableLazyElements) {\n            const payload = newChild._payload;\n            const init = newChild._init;\n            return updateFromMap(\n              existingChildren,\n              returnFiber,\n              newIdx,\n              init(payload),\n              lanes,\n            );\n          }\n      }\n\n      if (isArray(newChild) || getIteratorFn(newChild)) {\n        const matchedFiber = existingChildren.get(newIdx) || null;\n        return updateFragment(returnFiber, matchedFiber, newChild, lanes, null);\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    if (__DEV__) {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType(returnFiber);\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Warns if there is a duplicate or missing key\n   */\n  function warnOnInvalidKey(\n    child: mixed,\n    knownKeys: Set<string> | null,\n    returnFiber: Fiber,\n  ): Set<string> | null {\n    if (__DEV__) {\n      if (typeof child !== 'object' || child === null) {\n        return knownKeys;\n      }\n      switch (child.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n        case REACT_PORTAL_TYPE:\n          warnForMissingKey(child, returnFiber);\n          const key = child.key;\n          if (typeof key !== 'string') {\n            break;\n          }\n          if (knownKeys === null) {\n            knownKeys = new Set();\n            knownKeys.add(key);\n            break;\n          }\n          if (!knownKeys.has(key)) {\n            knownKeys.add(key);\n            break;\n          }\n          console.error(\n            'Encountered two children with the same key, `%s`. ' +\n              'Keys should be unique so that components maintain their identity ' +\n              'across updates. Non-unique keys may cause children to be ' +\n              'duplicated and/or omitted â€” the behavior is unsupported and ' +\n              'could change in a future version.',\n            key,\n          );\n          break;\n        case REACT_LAZY_TYPE:\n          if (enableLazyElements) {\n            const payload = child._payload;\n            const init = (child._init: any);\n            warnOnInvalidKey(init(payload), knownKeys, returnFiber);\n            break;\n          }\n        // We intentionally fallthrough here if enableLazyElements is not on.\n        // eslint-disable-next-lined no-fallthrough\n        default:\n          break;\n      }\n    }\n    return knownKeys;\n  }\n\n  function reconcileChildrenArray(\n    returnFiber: Fiber,\n    currentFirstChild: Fiber | null,\n    newChildren: Array<*>,\n    lanes: Lanes,\n  ): Fiber | null {\n    // This algorithm can't optimize by searching from both ends since we\n    // don't have backpointers on fibers. I'm trying to see how far we can get\n    // with that model. If it ends up not being worth the tradeoffs, we can\n    // add it later.\n\n    // Even with a two ended optimization, we'd want to optimize for the case\n    // where there are few changes and brute force the comparison instead of\n    // going for the Map. It'd like to explore hitting that path first in\n    // forward-only mode and only go for the Map once we notice that we need\n    // lots of look ahead. This doesn't handle reversal as well as two ended\n    // search but that's unusual. Besides, for the two ended optimization to\n    // work on Iterables, we'd need to copy the whole set.\n\n    // In this first iteration, we'll just live with hitting the bad case\n    // (adding everything to a Map) in for every insert/move.\n\n    // If you change this code, also update reconcileChildrenIterator() which\n    // uses the same algorithm.\n\n    if (__DEV__) {\n      // First, validate keys.\n      let knownKeys = null;\n      for (let i = 0; i < newChildren.length; i++) {\n        const child = newChildren[i];\n        knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);\n      }\n    }\n\n    let resultingFirstChild: Fiber | null = null;\n    let previousNewFiber: Fiber | null = null;\n\n    let oldFiber = currentFirstChild;\n    let lastPlacedIndex = 0;\n    let newIdx = 0;\n    let nextOldFiber = null;\n    for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {\n      if (oldFiber.index > newIdx) {\n        nextOldFiber = oldFiber;\n        oldFiber = null;\n      } else {\n        nextOldFiber = oldFiber.sibling;\n      }\n      const newFiber = updateSlot(\n        returnFiber,\n        oldFiber,\n        newChildren[newIdx],\n        lanes,\n      );\n      if (newFiber === null) {\n        // TODO: This breaks on empty slots like null children. That's\n        // unfortunate because it triggers the slow path all the time. We need\n        // a better way to communicate whether this was a miss or null,\n        // boolean, undefined, etc.\n        if (oldFiber === null) {\n          oldFiber = nextOldFiber;\n        }\n        break;\n      }\n      if (shouldTrackSideEffects) {\n        if (oldFiber && newFiber.alternate === null) {\n          // We matched the slot, but we didn't reuse the existing fiber, so we\n          // need to delete the existing child.\n          deleteChild(returnFiber, oldFiber);\n        }\n      }\n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n      if (previousNewFiber === null) {\n        // TODO: Move out of the loop. This only happens for the first run.\n        resultingFirstChild = newFiber;\n      } else {\n        // TODO: Defer siblings if we're not at the right index for this slot.\n        // I.e. if we had null values before, then we want to defer this\n        // for each null value. However, we also don't want to call updateSlot\n        // with the previous one.\n        previousNewFiber.sibling = newFiber;\n      }\n      previousNewFiber = newFiber;\n      oldFiber = nextOldFiber;\n    }\n\n    if (newIdx === newChildren.length) {\n      // We've reached the end of the new children. We can delete the rest.\n      deleteRemainingChildren(returnFiber, oldFiber);\n      if (getIsHydrating()) {\n        const numberOfForks = newIdx;\n        pushTreeFork(returnFiber, numberOfForks);\n      }\n      return resultingFirstChild;\n    }\n\n    if (oldFiber === null) {\n      // If we don't have any more existing children we can choose a fast path\n      // since the rest will all be insertions.\n      for (; newIdx < newChildren.length; newIdx++) {\n        const newFiber = createChild(returnFiber, newChildren[newIdx], lanes);\n        if (newFiber === null) {\n          continue;\n        }\n        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          // TODO: Move out of the loop. This only happens for the first run.\n          resultingFirstChild = newFiber;\n        } else {\n          previousNewFiber.sibling = newFiber;\n        }\n        previousNewFiber = newFiber;\n      }\n      if (getIsHydrating()) {\n        const numberOfForks = newIdx;\n        pushTreeFork(returnFiber, numberOfForks);\n      }\n      return resultingFirstChild;\n    }\n\n    // Add all children to a key map for quick lookups.\n    const existingChildren = mapRemainingChildren(returnFiber, oldFiber);\n\n    // Keep scanning and use the map to restore deleted items as moves.\n    for (; newIdx < newChildren.length; newIdx++) {\n      const newFiber = updateFromMap(\n        existingChildren,\n        returnFiber,\n        newIdx,\n        newChildren[newIdx],\n        lanes,\n      );\n      if (newFiber !== null) {\n        if (shouldTrackSideEffects) {\n          if (newFiber.alternate !== null) {\n            // The new fiber is a work in progress, but if there exists a\n            // current, that means that we reused the fiber. We need to delete\n            // it from the child list so that we don't add it to the deletion\n            // list.\n            existingChildren.delete(\n              newFiber.key === null ? newIdx : newFiber.key,\n            );\n          }\n        }\n        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          resultingFirstChild = newFiber;\n        } else {\n          previousNewFiber.sibling = newFiber;\n        }\n        previousNewFiber = newFiber;\n      }\n    }\n\n    if (shouldTrackSideEffects) {\n      // Any existing children that weren't consumed above were deleted. We need\n      // to add them to the deletion list.\n      existingChildren.forEach(child => deleteChild(returnFiber, child));\n    }\n\n    if (getIsHydrating()) {\n      const numberOfForks = newIdx;\n      pushTreeFork(returnFiber, numberOfForks);\n    }\n    return resultingFirstChild;\n  }\n\n  function reconcileChildrenIterator(\n    returnFiber: Fiber,\n    currentFirstChild: Fiber | null,\n    newChildrenIterable: Iterable<*>,\n    lanes: Lanes,\n  ): Fiber | null {\n    // This is the same implementation as reconcileChildrenArray(),\n    // but using the iterator instead.\n\n    const iteratorFn = getIteratorFn(newChildrenIterable);\n\n    if (typeof iteratorFn !== 'function') {\n      throw new Error(\n        'An object is not an iterable. This error is likely caused by a bug in ' +\n          'React. Please file an issue.',\n      );\n    }\n\n    if (__DEV__) {\n      // We don't support rendering Generators because it's a mutation.\n      // See https://github.com/facebook/react/issues/12995\n      if (\n        typeof Symbol === 'function' &&\n        // $FlowFixMe Flow doesn't know about toStringTag\n        newChildrenIterable[Symbol.toStringTag] === 'Generator'\n      ) {\n        if (!didWarnAboutGenerators) {\n          console.error(\n            'Using Generators as children is unsupported and will likely yield ' +\n              'unexpected results because enumerating a generator mutates it. ' +\n              'You may convert it to an array with `Array.from()` or the ' +\n              '`[...spread]` operator before rendering. Keep in mind ' +\n              'you might need to polyfill these features for older browsers.',\n          );\n        }\n        didWarnAboutGenerators = true;\n      }\n\n      // Warn about using Maps as children\n      if ((newChildrenIterable: any).entries === iteratorFn) {\n        if (!didWarnAboutMaps) {\n          console.error(\n            'Using Maps as children is not supported. ' +\n              'Use an array of keyed ReactElements instead.',\n          );\n        }\n        didWarnAboutMaps = true;\n      }\n\n      // First, validate keys.\n      // We'll get a different iterator later for the main pass.\n      const newChildren = iteratorFn.call(newChildrenIterable);\n      if (newChildren) {\n        let knownKeys = null;\n        let step = newChildren.next();\n        for (; !step.done; step = newChildren.next()) {\n          const child = step.value;\n          knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);\n        }\n      }\n    }\n\n    const newChildren = iteratorFn.call(newChildrenIterable);\n\n    if (newChildren == null) {\n      throw new Error('An iterable object provided no iterator.');\n    }\n\n    let resultingFirstChild: Fiber | null = null;\n    let previousNewFiber: Fiber | null = null;\n\n    let oldFiber = currentFirstChild;\n    let lastPlacedIndex = 0;\n    let newIdx = 0;\n    let nextOldFiber = null;\n\n    let step = newChildren.next();\n    for (\n      ;\n      oldFiber !== null && !step.done;\n      newIdx++, step = newChildren.next()\n    ) {\n      if (oldFiber.index > newIdx) {\n        nextOldFiber = oldFiber;\n        oldFiber = null;\n      } else {\n        nextOldFiber = oldFiber.sibling;\n      }\n      const newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);\n      if (newFiber === null) {\n        // TODO: This breaks on empty slots like null children. That's\n        // unfortunate because it triggers the slow path all the time. We need\n        // a better way to communicate whether this was a miss or null,\n        // boolean, undefined, etc.\n        if (oldFiber === null) {\n          oldFiber = nextOldFiber;\n        }\n        break;\n      }\n      if (shouldTrackSideEffects) {\n        if (oldFiber && newFiber.alternate === null) {\n          // We matched the slot, but we didn't reuse the existing fiber, so we\n          // need to delete the existing child.\n          deleteChild(returnFiber, oldFiber);\n        }\n      }\n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n      if (previousNewFiber === null) {\n        // TODO: Move out of the loop. This only happens for the first run.\n        resultingFirstChild = newFiber;\n      } else {\n        // TODO: Defer siblings if we're not at the right index for this slot.\n        // I.e. if we had null values before, then we want to defer this\n        // for each null value. However, we also don't want to call updateSlot\n        // with the previous one.\n        previousNewFiber.sibling = newFiber;\n      }\n      previousNewFiber = newFiber;\n      oldFiber = nextOldFiber;\n    }\n\n    if (step.done) {\n      // We've reached the end of the new children. We can delete the rest.\n      deleteRemainingChildren(returnFiber, oldFiber);\n      if (getIsHydrating()) {\n        const numberOfForks = newIdx;\n        pushTreeFork(returnFiber, numberOfForks);\n      }\n      return resultingFirstChild;\n    }\n\n    if (oldFiber === null) {\n      // If we don't have any more existing children we can choose a fast path\n      // since the rest will all be insertions.\n      for (; !step.done; newIdx++, step = newChildren.next()) {\n        const newFiber = createChild(returnFiber, step.value, lanes);\n        if (newFiber === null) {\n          continue;\n        }\n        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          // TODO: Move out of the loop. This only happens for the first run.\n          resultingFirstChild = newFiber;\n        } else {\n          previousNewFiber.sibling = newFiber;\n        }\n        previousNewFiber = newFiber;\n      }\n      if (getIsHydrating()) {\n        const numberOfForks = newIdx;\n        pushTreeFork(returnFiber, numberOfForks);\n      }\n      return resultingFirstChild;\n    }\n\n    // Add all children to a key map for quick lookups.\n    const existingChildren = mapRemainingChildren(returnFiber, oldFiber);\n\n    // Keep scanning and use the map to restore deleted items as moves.\n    for (; !step.done; newIdx++, step = newChildren.next()) {\n      const newFiber = updateFromMap(\n        existingChildren,\n        returnFiber,\n        newIdx,\n        step.value,\n        lanes,\n      );\n      if (newFiber !== null) {\n        if (shouldTrackSideEffects) {\n          if (newFiber.alternate !== null) {\n            // The new fiber is a work in progress, but if there exists a\n            // current, that means that we reused the fiber. We need to delete\n            // it from the child list so that we don't add it to the deletion\n            // list.\n            existingChildren.delete(\n              newFiber.key === null ? newIdx : newFiber.key,\n            );\n          }\n        }\n        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          resultingFirstChild = newFiber;\n        } else {\n          previousNewFiber.sibling = newFiber;\n        }\n        previousNewFiber = newFiber;\n      }\n    }\n\n    if (shouldTrackSideEffects) {\n      // Any existing children that weren't consumed above were deleted. We need\n      // to add them to the deletion list.\n      existingChildren.forEach(child => deleteChild(returnFiber, child));\n    }\n\n    if (getIsHydrating()) {\n      const numberOfForks = newIdx;\n      pushTreeFork(returnFiber, numberOfForks);\n    }\n    return resultingFirstChild;\n  }\n\n  function reconcileSingleTextNode(\n    returnFiber: Fiber,\n    currentFirstChild: Fiber | null,\n    textContent: string,\n    lanes: Lanes,\n  ): Fiber {\n    // There's no need to check for keys on text nodes since we don't have a\n    // way to define them.\n    if (currentFirstChild !== null && currentFirstChild.tag === HostText) {\n      // We already have an existing node so let's just update it and delete\n      // the rest.\n      deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n      const existing = useFiber(currentFirstChild, textContent);\n      existing.return = returnFiber;\n      return existing;\n    }\n    // The existing first child is not a text node so we need to create one\n    // and delete the existing ones.\n    deleteRemainingChildren(returnFiber, currentFirstChild);\n    const created = createFiberFromText(textContent, returnFiber.mode, lanes);\n    created.return = returnFiber;\n    return created;\n  }\n\n  function reconcileSingleElement(\n    returnFiber: Fiber,\n    currentFirstChild: Fiber | null,\n    element: ReactElement,\n    lanes: Lanes,\n  ): Fiber {\n    const key = element.key;\n    let child = currentFirstChild;\n    while (child !== null) {\n      // TODO: If key === null and child.key === null, then this only applies to\n      // the first item in the list.\n      if (child.key === key) {\n        const elementType = element.type;\n        if (elementType === REACT_FRAGMENT_TYPE) {\n          if (child.tag === Fragment) {\n            deleteRemainingChildren(returnFiber, child.sibling);\n            const existing = useFiber(child, element.props.children);\n            existing.return = returnFiber;\n            if (__DEV__) {\n              existing._debugSource = element._source;\n              existing._debugOwner = element._owner;\n            }\n            return existing;\n          }\n        } else {\n          if (\n            child.elementType === elementType ||\n            // Keep this check inline so it only runs on the false path:\n            (__DEV__\n              ? isCompatibleFamilyForHotReloading(child, element)\n              : false) ||\n            // Lazy types should reconcile their resolved type.\n            // We need to do this after the Hot Reloading check above,\n            // because hot reloading has different semantics than prod because\n            // it doesn't resuspend. So we can't let the call below suspend.\n            (enableLazyElements &&\n              typeof elementType === 'object' &&\n              elementType !== null &&\n              elementType.$$typeof === REACT_LAZY_TYPE &&\n              resolveLazy(elementType) === child.type)\n          ) {\n            deleteRemainingChildren(returnFiber, child.sibling);\n            const existing = useFiber(child, element.props);\n            existing.ref = coerceRef(returnFiber, child, element);\n            existing.return = returnFiber;\n            if (__DEV__) {\n              existing._debugSource = element._source;\n              existing._debugOwner = element._owner;\n            }\n            return existing;\n          }\n        }\n        // Didn't match.\n        deleteRemainingChildren(returnFiber, child);\n        break;\n      } else {\n        deleteChild(returnFiber, child);\n      }\n      child = child.sibling;\n    }\n\n    if (element.type === REACT_FRAGMENT_TYPE) {\n      const created = createFiberFromFragment(\n        element.props.children,\n        returnFiber.mode,\n        lanes,\n        element.key,\n      );\n      created.return = returnFiber;\n      return created;\n    } else {\n      const created = createFiberFromElement(element, returnFiber.mode, lanes);\n      created.ref = coerceRef(returnFiber, currentFirstChild, element);\n      created.return = returnFiber;\n      return created;\n    }\n  }\n\n  function reconcileSinglePortal(\n    returnFiber: Fiber,\n    currentFirstChild: Fiber | null,\n    portal: ReactPortal,\n    lanes: Lanes,\n  ): Fiber {\n    const key = portal.key;\n    let child = currentFirstChild;\n    while (child !== null) {\n      // TODO: If key === null and child.key === null, then this only applies to\n      // the first item in the list.\n      if (child.key === key) {\n        if (\n          child.tag === HostPortal &&\n          child.stateNode.containerInfo === portal.containerInfo &&\n          child.stateNode.implementation === portal.implementation\n        ) {\n          deleteRemainingChildren(returnFiber, child.sibling);\n          const existing = useFiber(child, portal.children || []);\n          existing.return = returnFiber;\n          return existing;\n        } else {\n          deleteRemainingChildren(returnFiber, child);\n          break;\n        }\n      } else {\n        deleteChild(returnFiber, child);\n      }\n      child = child.sibling;\n    }\n\n    const created = createFiberFromPortal(portal, returnFiber.mode, lanes);\n    created.return = returnFiber;\n    return created;\n  }\n\n  // This API will tag the children with the side-effect of the reconciliation\n  // itself. They will be added to the side-effect list as we pass through the\n  // children and the parent.\n  function reconcileChildFibers(\n    returnFiber: Fiber,\n    currentFirstChild: Fiber | null,\n    newChild: any,\n    lanes: Lanes,\n  ): Fiber | null {\n    // This function is not recursive.\n    // If the top level item is an array, we treat it as a set of children,\n    // not as a fragment. Nested arrays on the other hand will be treated as\n    // fragment nodes. Recursion happens at the normal flow.\n\n    // Handle top level unkeyed fragments as if they were arrays.\n    // This leads to an ambiguity between <>{[...]}</> and <>...</>.\n    // We treat the ambiguous cases above the same.\n    const isUnkeyedTopLevelFragment =\n      typeof newChild === 'object' &&\n      newChild !== null &&\n      newChild.type === REACT_FRAGMENT_TYPE &&\n      newChild.key === null;\n    if (isUnkeyedTopLevelFragment) {\n      newChild = newChild.props.children;\n    }\n\n    // Handle object types\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          return placeSingleChild(\n            reconcileSingleElement(\n              returnFiber,\n              currentFirstChild,\n              newChild,\n              lanes,\n            ),\n          );\n        case REACT_PORTAL_TYPE:\n          return placeSingleChild(\n            reconcileSinglePortal(\n              returnFiber,\n              currentFirstChild,\n              newChild,\n              lanes,\n            ),\n          );\n        case REACT_LAZY_TYPE:\n          if (enableLazyElements) {\n            const payload = newChild._payload;\n            const init = newChild._init;\n            // TODO: This function is supposed to be non-recursive.\n            return reconcileChildFibers(\n              returnFiber,\n              currentFirstChild,\n              init(payload),\n              lanes,\n            );\n          }\n      }\n\n      if (isArray(newChild)) {\n        return reconcileChildrenArray(\n          returnFiber,\n          currentFirstChild,\n          newChild,\n          lanes,\n        );\n      }\n\n      if (getIteratorFn(newChild)) {\n        return reconcileChildrenIterator(\n          returnFiber,\n          currentFirstChild,\n          newChild,\n          lanes,\n        );\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      return placeSingleChild(\n        reconcileSingleTextNode(\n          returnFiber,\n          currentFirstChild,\n          '' + newChild,\n          lanes,\n        ),\n      );\n    }\n\n    if (__DEV__) {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType(returnFiber);\n      }\n    }\n\n    // Remaining cases are all treated as empty.\n    return deleteRemainingChildren(returnFiber, currentFirstChild);\n  }\n\n  return reconcileChildFibers;\n}\n\nexport const reconcileChildFibers = ChildReconciler(true);\nexport const mountChildFibers = ChildReconciler(false);\n\nexport function cloneChildFibers(\n  current: Fiber | null,\n  workInProgress: Fiber,\n): void {\n  if (current !== null && workInProgress.child !== current.child) {\n    throw new Error('Resuming work not yet implemented.');\n  }\n\n  if (workInProgress.child === null) {\n    return;\n  }\n\n  let currentChild = workInProgress.child;\n  let newChild = createWorkInProgress(currentChild, currentChild.pendingProps);\n  workInProgress.child = newChild;\n\n  newChild.return = workInProgress;\n  while (currentChild.sibling !== null) {\n    currentChild = currentChild.sibling;\n    newChild = newChild.sibling = createWorkInProgress(\n      currentChild,\n      currentChild.pendingProps,\n    );\n    newChild.return = workInProgress;\n  }\n  newChild.sibling = null;\n}\n\n// Reset a workInProgress child set to prepare it for a second pass.\nexport function resetChildFibers(workInProgress: Fiber, lanes: Lanes): void {\n  let child = workInProgress.child;\n  while (child !== null) {\n    resetWorkInProgress(child, lanes);\n    child = child.sibling;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}