{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport getNodeForCharacterOffset from './getNodeForCharacterOffset';\nimport { TEXT_NODE } from '../shared/HTMLNodeType';\n/**\n * @param {DOMElement} outerNode\n * @return {?object}\n */\n\nexport function getOffsets(outerNode) {\n  const {\n    ownerDocument\n  } = outerNode;\n  const win = ownerDocument && ownerDocument.defaultView || window;\n  const selection = win.getSelection && win.getSelection();\n\n  if (!selection || selection.rangeCount === 0) {\n    return null;\n  }\n\n  const {\n    anchorNode,\n    anchorOffset,\n    focusNode,\n    focusOffset\n  } = selection; // In Firefox, anchorNode and focusNode can be \"anonymous divs\", e.g. the\n  // up/down buttons on an <input type=\"number\">. Anonymous divs do not seem to\n  // expose properties, triggering a \"Permission denied error\" if any of its\n  // properties are accessed. The only seemingly possible way to avoid erroring\n  // is to access a property that typically works for non-anonymous divs and\n  // catch any error that may otherwise arise. See\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427\n\n  try {\n    /* eslint-disable no-unused-expressions */\n    anchorNode.nodeType;\n    focusNode.nodeType;\n    /* eslint-enable no-unused-expressions */\n  } catch (e) {\n    return null;\n  }\n\n  return getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset);\n}\n/**\n * Returns {start, end} where `start` is the character/codepoint index of\n * (anchorNode, anchorOffset) within the textContent of `outerNode`, and\n * `end` is the index of (focusNode, focusOffset).\n *\n * Returns null if you pass in garbage input but we should probably just crash.\n *\n * Exported only for testing.\n */\n\nexport function getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset) {\n  let length = 0;\n  let start = -1;\n  let end = -1;\n  let indexWithinAnchor = 0;\n  let indexWithinFocus = 0;\n  let node = outerNode;\n  let parentNode = null;\n\n  outer: while (true) {\n    let next = null;\n\n    while (true) {\n      if (node === anchorNode && (anchorOffset === 0 || node.nodeType === TEXT_NODE)) {\n        start = length + anchorOffset;\n      }\n\n      if (node === focusNode && (focusOffset === 0 || node.nodeType === TEXT_NODE)) {\n        end = length + focusOffset;\n      }\n\n      if (node.nodeType === TEXT_NODE) {\n        length += node.nodeValue.length;\n      }\n\n      if ((next = node.firstChild) === null) {\n        break;\n      } // Moving from `node` to its first child `next`.\n\n\n      parentNode = node;\n      node = next;\n    }\n\n    while (true) {\n      if (node === outerNode) {\n        // If `outerNode` has children, this is always the second time visiting\n        // it. If it has no children, this is still the first loop, and the only\n        // valid selection is anchorNode and focusNode both equal to this node\n        // and both offsets 0, in which case we will have handled above.\n        break outer;\n      }\n\n      if (parentNode === anchorNode && ++indexWithinAnchor === anchorOffset) {\n        start = length;\n      }\n\n      if (parentNode === focusNode && ++indexWithinFocus === focusOffset) {\n        end = length;\n      }\n\n      if ((next = node.nextSibling) !== null) {\n        break;\n      }\n\n      node = parentNode;\n      parentNode = node.parentNode;\n    } // Moving from `node` to its next sibling `next`.\n\n\n    node = next;\n  }\n\n  if (start === -1 || end === -1) {\n    // This should never happen. (Would happen if the anchor/focus nodes aren't\n    // actually inside the passed-in node.)\n    return null;\n  }\n\n  return {\n    start: start,\n    end: end\n  };\n}\n/**\n * In modern non-IE browsers, we can support both forward and backward\n * selections.\n *\n * Note: IE10+ supports the Selection object, but it does not support\n * the `extend` method, which means that even in modern IE, it's not possible\n * to programmatically create a backward selection. Thus, for all IE\n * versions, we use the old IE API to create our selections.\n *\n * @param {DOMElement|DOMTextNode} node\n * @param {object} offsets\n */\n\nexport function setOffsets(node, offsets) {\n  const doc = node.ownerDocument || document;\n  const win = doc && doc.defaultView || window; // Edge fails with \"Object expected\" in some scenarios.\n  // (For instance: TinyMCE editor used in a list component that supports pasting to add more,\n  // fails when pasting 100+ items)\n\n  if (!win.getSelection) {\n    return;\n  }\n\n  const selection = win.getSelection();\n  const length = node.textContent.length;\n  let start = Math.min(offsets.start, length);\n  let end = offsets.end === undefined ? start : Math.min(offsets.end, length); // IE 11 uses modern selection, but doesn't support the extend method.\n  // Flip backward selections, so we can set with a single range.\n\n  if (!selection.extend && start > end) {\n    const temp = end;\n    end = start;\n    start = temp;\n  }\n\n  const startMarker = getNodeForCharacterOffset(node, start);\n  const endMarker = getNodeForCharacterOffset(node, end);\n\n  if (startMarker && endMarker) {\n    if (selection.rangeCount === 1 && selection.anchorNode === startMarker.node && selection.anchorOffset === startMarker.offset && selection.focusNode === endMarker.node && selection.focusOffset === endMarker.offset) {\n      return;\n    }\n\n    const range = doc.createRange();\n    range.setStart(startMarker.node, startMarker.offset);\n    selection.removeAllRanges();\n\n    if (start > end) {\n      selection.addRange(range);\n      selection.extend(endMarker.node, endMarker.offset);\n    } else {\n      range.setEnd(endMarker.node, endMarker.offset);\n      selection.addRange(range);\n    }\n  }\n}","map":{"version":3,"sources":["/Users/zhangshuo/git/react-source-test/src/react/packages/react-dom/src/client/ReactDOMSelection.js"],"names":["getNodeForCharacterOffset","TEXT_NODE","getOffsets","outerNode","ownerDocument","win","defaultView","window","selection","getSelection","rangeCount","anchorNode","anchorOffset","focusNode","focusOffset","nodeType","e","getModernOffsetsFromPoints","length","start","end","indexWithinAnchor","indexWithinFocus","node","parentNode","outer","next","nodeValue","firstChild","nextSibling","setOffsets","offsets","doc","document","textContent","Math","min","undefined","extend","temp","startMarker","endMarker","offset","range","createRange","setStart","removeAllRanges","addRange","setEnd"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport getNodeForCharacterOffset from './getNodeForCharacterOffset';\nimport {TEXT_NODE} from '../shared/HTMLNodeType';\n\n/**\n * @param {DOMElement} outerNode\n * @return {?object}\n */\nexport function getOffsets(outerNode) {\n  const {ownerDocument} = outerNode;\n  const win = (ownerDocument && ownerDocument.defaultView) || window;\n  const selection = win.getSelection && win.getSelection();\n\n  if (!selection || selection.rangeCount === 0) {\n    return null;\n  }\n\n  const {anchorNode, anchorOffset, focusNode, focusOffset} = selection;\n\n  // In Firefox, anchorNode and focusNode can be \"anonymous divs\", e.g. the\n  // up/down buttons on an <input type=\"number\">. Anonymous divs do not seem to\n  // expose properties, triggering a \"Permission denied error\" if any of its\n  // properties are accessed. The only seemingly possible way to avoid erroring\n  // is to access a property that typically works for non-anonymous divs and\n  // catch any error that may otherwise arise. See\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427\n  try {\n    /* eslint-disable no-unused-expressions */\n    anchorNode.nodeType;\n    focusNode.nodeType;\n    /* eslint-enable no-unused-expressions */\n  } catch (e) {\n    return null;\n  }\n\n  return getModernOffsetsFromPoints(\n    outerNode,\n    anchorNode,\n    anchorOffset,\n    focusNode,\n    focusOffset,\n  );\n}\n\n/**\n * Returns {start, end} where `start` is the character/codepoint index of\n * (anchorNode, anchorOffset) within the textContent of `outerNode`, and\n * `end` is the index of (focusNode, focusOffset).\n *\n * Returns null if you pass in garbage input but we should probably just crash.\n *\n * Exported only for testing.\n */\nexport function getModernOffsetsFromPoints(\n  outerNode,\n  anchorNode,\n  anchorOffset,\n  focusNode,\n  focusOffset,\n) {\n  let length = 0;\n  let start = -1;\n  let end = -1;\n  let indexWithinAnchor = 0;\n  let indexWithinFocus = 0;\n  let node = outerNode;\n  let parentNode = null;\n\n  outer: while (true) {\n    let next = null;\n\n    while (true) {\n      if (\n        node === anchorNode &&\n        (anchorOffset === 0 || node.nodeType === TEXT_NODE)\n      ) {\n        start = length + anchorOffset;\n      }\n      if (\n        node === focusNode &&\n        (focusOffset === 0 || node.nodeType === TEXT_NODE)\n      ) {\n        end = length + focusOffset;\n      }\n\n      if (node.nodeType === TEXT_NODE) {\n        length += node.nodeValue.length;\n      }\n\n      if ((next = node.firstChild) === null) {\n        break;\n      }\n      // Moving from `node` to its first child `next`.\n      parentNode = node;\n      node = next;\n    }\n\n    while (true) {\n      if (node === outerNode) {\n        // If `outerNode` has children, this is always the second time visiting\n        // it. If it has no children, this is still the first loop, and the only\n        // valid selection is anchorNode and focusNode both equal to this node\n        // and both offsets 0, in which case we will have handled above.\n        break outer;\n      }\n      if (parentNode === anchorNode && ++indexWithinAnchor === anchorOffset) {\n        start = length;\n      }\n      if (parentNode === focusNode && ++indexWithinFocus === focusOffset) {\n        end = length;\n      }\n      if ((next = node.nextSibling) !== null) {\n        break;\n      }\n      node = parentNode;\n      parentNode = node.parentNode;\n    }\n\n    // Moving from `node` to its next sibling `next`.\n    node = next;\n  }\n\n  if (start === -1 || end === -1) {\n    // This should never happen. (Would happen if the anchor/focus nodes aren't\n    // actually inside the passed-in node.)\n    return null;\n  }\n\n  return {\n    start: start,\n    end: end,\n  };\n}\n\n/**\n * In modern non-IE browsers, we can support both forward and backward\n * selections.\n *\n * Note: IE10+ supports the Selection object, but it does not support\n * the `extend` method, which means that even in modern IE, it's not possible\n * to programmatically create a backward selection. Thus, for all IE\n * versions, we use the old IE API to create our selections.\n *\n * @param {DOMElement|DOMTextNode} node\n * @param {object} offsets\n */\nexport function setOffsets(node, offsets) {\n  const doc = node.ownerDocument || document;\n  const win = (doc && doc.defaultView) || window;\n\n  // Edge fails with \"Object expected\" in some scenarios.\n  // (For instance: TinyMCE editor used in a list component that supports pasting to add more,\n  // fails when pasting 100+ items)\n  if (!win.getSelection) {\n    return;\n  }\n\n  const selection = win.getSelection();\n  const length = node.textContent.length;\n  let start = Math.min(offsets.start, length);\n  let end = offsets.end === undefined ? start : Math.min(offsets.end, length);\n\n  // IE 11 uses modern selection, but doesn't support the extend method.\n  // Flip backward selections, so we can set with a single range.\n  if (!selection.extend && start > end) {\n    const temp = end;\n    end = start;\n    start = temp;\n  }\n\n  const startMarker = getNodeForCharacterOffset(node, start);\n  const endMarker = getNodeForCharacterOffset(node, end);\n\n  if (startMarker && endMarker) {\n    if (\n      selection.rangeCount === 1 &&\n      selection.anchorNode === startMarker.node &&\n      selection.anchorOffset === startMarker.offset &&\n      selection.focusNode === endMarker.node &&\n      selection.focusOffset === endMarker.offset\n    ) {\n      return;\n    }\n    const range = doc.createRange();\n    range.setStart(startMarker.node, startMarker.offset);\n    selection.removeAllRanges();\n\n    if (start > end) {\n      selection.addRange(range);\n      selection.extend(endMarker.node, endMarker.offset);\n    } else {\n      range.setEnd(endMarker.node, endMarker.offset);\n      selection.addRange(range);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}