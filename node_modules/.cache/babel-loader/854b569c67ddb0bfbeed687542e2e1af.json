{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { allNativeEvents } from '../events/EventRegistry';\nimport { getEventHandlerListeners, setEventHandlerListeners, doesTargetHaveEventHandle, addEventHandleToTarget } from './ReactDOMComponentTree';\nimport { ELEMENT_NODE } from '../shared/HTMLNodeType';\nimport { listenToNativeEventForNonManagedEventTarget } from '../events/DOMPluginEventSystem';\nimport { enableScopeAPI, enableCreateEventHandleAPI } from 'shared/ReactFeatureFlags';\n\nfunction isValidEventTarget(target) {\n  return typeof target.addEventListener === 'function';\n}\n\nfunction isReactScope(target) {\n  return typeof target.getChildContextValues === 'function';\n}\n\nfunction createEventHandleListener(type, isCapturePhaseListener, callback) {\n  return {\n    callback,\n    capture: isCapturePhaseListener,\n    type\n  };\n}\n\nfunction registerReactDOMEvent(target, domEventName, isCapturePhaseListener) {\n  if (target.nodeType === ELEMENT_NODE) {// Do nothing. We already attached all root listeners.\n  } else if (enableScopeAPI && isReactScope(target)) {// Do nothing. We already attached all root listeners.\n  } else if (isValidEventTarget(target)) {\n    const eventTarget = target; // These are valid event targets, but they are also\n    // non-managed React nodes.\n\n    listenToNativeEventForNonManagedEventTarget(domEventName, isCapturePhaseListener, eventTarget);\n  } else {\n    throw new Error('ReactDOM.createEventHandle: setter called on an invalid ' + 'target. Provide a valid EventTarget or an element managed by React.');\n  }\n}\n\nexport function createEventHandle(type, options) {\n  if (enableCreateEventHandleAPI) {\n    const domEventName = type; // We cannot support arbitrary native events with eager root listeners\n    // because the eager strategy relies on knowing the whole list ahead of time.\n    // If we wanted to support this, we'd have to add code to keep track\n    // (or search) for all portal and root containers, and lazily add listeners\n    // to them whenever we see a previously unknown event. This seems like a lot\n    // of complexity for something we don't even have a particular use case for.\n    // Unfortunately, the downside of this invariant is that *removing* a native\n    // event from the list of known events has now become a breaking change for\n    // any code relying on the createEventHandle API.\n\n    if (!allNativeEvents.has(domEventName)) {\n      throw new Error(`Cannot call unstable_createEventHandle with \"${domEventName}\", as it is not an event known to React.`);\n    }\n\n    let isCapturePhaseListener = false;\n\n    if (options != null) {\n      const optionsCapture = options.capture;\n\n      if (typeof optionsCapture === 'boolean') {\n        isCapturePhaseListener = optionsCapture;\n      }\n    }\n\n    const eventHandle = (target, callback) => {\n      if (typeof callback !== 'function') {\n        throw new Error('ReactDOM.createEventHandle: setter called with an invalid ' + 'callback. The callback must be a function.');\n      }\n\n      if (!doesTargetHaveEventHandle(target, eventHandle)) {\n        addEventHandleToTarget(target, eventHandle);\n        registerReactDOMEvent(target, domEventName, isCapturePhaseListener);\n      }\n\n      const listener = createEventHandleListener(domEventName, isCapturePhaseListener, callback);\n      let targetListeners = getEventHandlerListeners(target);\n\n      if (targetListeners === null) {\n        targetListeners = new Set();\n        setEventHandlerListeners(target, targetListeners);\n      }\n\n      targetListeners.add(listener);\n      return () => {\n        targetListeners.delete(listener);\n      };\n    };\n\n    return eventHandle;\n  }\n\n  return null;\n}","map":{"version":3,"sources":["/Users/zhangshuo/git/my-app/src/react/packages/react-dom/src/client/ReactDOMEventHandle.js"],"names":["allNativeEvents","getEventHandlerListeners","setEventHandlerListeners","doesTargetHaveEventHandle","addEventHandleToTarget","ELEMENT_NODE","listenToNativeEventForNonManagedEventTarget","enableScopeAPI","enableCreateEventHandleAPI","isValidEventTarget","target","addEventListener","isReactScope","getChildContextValues","createEventHandleListener","type","isCapturePhaseListener","callback","capture","registerReactDOMEvent","domEventName","nodeType","eventTarget","Error","createEventHandle","options","has","optionsCapture","eventHandle","listener","targetListeners","Set","add","delete"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {DOMEventName} from '../events/DOMEventNames';\nimport type {ReactScopeInstance} from 'shared/ReactTypes';\nimport type {\n  ReactDOMEventHandle,\n  ReactDOMEventHandleListener,\n} from '../shared/ReactDOMTypes';\n\nimport {allNativeEvents} from '../events/EventRegistry';\nimport {\n  getEventHandlerListeners,\n  setEventHandlerListeners,\n  doesTargetHaveEventHandle,\n  addEventHandleToTarget,\n} from './ReactDOMComponentTree';\nimport {ELEMENT_NODE} from '../shared/HTMLNodeType';\nimport {listenToNativeEventForNonManagedEventTarget} from '../events/DOMPluginEventSystem';\n\nimport {\n  enableScopeAPI,\n  enableCreateEventHandleAPI,\n} from 'shared/ReactFeatureFlags';\n\ntype EventHandleOptions = {|\n  capture?: boolean,\n|};\n\nfunction isValidEventTarget(target: EventTarget | ReactScopeInstance): boolean {\n  return typeof (target: Object).addEventListener === 'function';\n}\n\nfunction isReactScope(target: EventTarget | ReactScopeInstance): boolean {\n  return typeof (target: Object).getChildContextValues === 'function';\n}\n\nfunction createEventHandleListener(\n  type: DOMEventName,\n  isCapturePhaseListener: boolean,\n  callback: (SyntheticEvent<EventTarget>) => void,\n): ReactDOMEventHandleListener {\n  return {\n    callback,\n    capture: isCapturePhaseListener,\n    type,\n  };\n}\n\nfunction registerReactDOMEvent(\n  target: EventTarget | ReactScopeInstance,\n  domEventName: DOMEventName,\n  isCapturePhaseListener: boolean,\n): void {\n  if ((target: any).nodeType === ELEMENT_NODE) {\n    // Do nothing. We already attached all root listeners.\n  } else if (enableScopeAPI && isReactScope(target)) {\n    // Do nothing. We already attached all root listeners.\n  } else if (isValidEventTarget(target)) {\n    const eventTarget = ((target: any): EventTarget);\n    // These are valid event targets, but they are also\n    // non-managed React nodes.\n    listenToNativeEventForNonManagedEventTarget(\n      domEventName,\n      isCapturePhaseListener,\n      eventTarget,\n    );\n  } else {\n    throw new Error(\n      'ReactDOM.createEventHandle: setter called on an invalid ' +\n        'target. Provide a valid EventTarget or an element managed by React.',\n    );\n  }\n}\n\nexport function createEventHandle(\n  type: string,\n  options?: EventHandleOptions,\n): ReactDOMEventHandle {\n  if (enableCreateEventHandleAPI) {\n    const domEventName = ((type: any): DOMEventName);\n\n    // We cannot support arbitrary native events with eager root listeners\n    // because the eager strategy relies on knowing the whole list ahead of time.\n    // If we wanted to support this, we'd have to add code to keep track\n    // (or search) for all portal and root containers, and lazily add listeners\n    // to them whenever we see a previously unknown event. This seems like a lot\n    // of complexity for something we don't even have a particular use case for.\n    // Unfortunately, the downside of this invariant is that *removing* a native\n    // event from the list of known events has now become a breaking change for\n    // any code relying on the createEventHandle API.\n    if (!allNativeEvents.has(domEventName)) {\n      throw new Error(\n        `Cannot call unstable_createEventHandle with \"${domEventName}\", as it is not an event known to React.`,\n      );\n    }\n\n    let isCapturePhaseListener = false;\n    if (options != null) {\n      const optionsCapture = options.capture;\n      if (typeof optionsCapture === 'boolean') {\n        isCapturePhaseListener = optionsCapture;\n      }\n    }\n\n    const eventHandle = (\n      target: EventTarget | ReactScopeInstance,\n      callback: (SyntheticEvent<EventTarget>) => void,\n    ) => {\n      if (typeof callback !== 'function') {\n        throw new Error(\n          'ReactDOM.createEventHandle: setter called with an invalid ' +\n            'callback. The callback must be a function.',\n        );\n      }\n\n      if (!doesTargetHaveEventHandle(target, eventHandle)) {\n        addEventHandleToTarget(target, eventHandle);\n        registerReactDOMEvent(target, domEventName, isCapturePhaseListener);\n      }\n      const listener = createEventHandleListener(\n        domEventName,\n        isCapturePhaseListener,\n        callback,\n      );\n      let targetListeners = getEventHandlerListeners(target);\n      if (targetListeners === null) {\n        targetListeners = new Set();\n        setEventHandlerListeners(target, targetListeners);\n      }\n      targetListeners.add(listener);\n      return () => {\n        ((targetListeners: any): Set<ReactDOMEventHandleListener>).delete(\n          listener,\n        );\n      };\n    };\n\n    return eventHandle;\n  }\n  return (null: any);\n}\n"]},"metadata":{},"sourceType":"module"}