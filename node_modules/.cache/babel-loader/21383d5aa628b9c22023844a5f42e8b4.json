{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { enableComponentStackLocations, disableNativeComponentFrames } from 'shared/ReactFeatureFlags';\nimport { REACT_SUSPENSE_TYPE, REACT_SUSPENSE_LIST_TYPE, REACT_FORWARD_REF_TYPE, REACT_MEMO_TYPE, REACT_LAZY_TYPE } from 'shared/ReactSymbols';\nimport { disableLogs, reenableLogs } from 'shared/ConsolePatchingDev';\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nconst {\n  ReactCurrentDispatcher\n} = ReactSharedInternals;\nlet prefix;\nexport function describeBuiltInComponentFrame(name, source, ownerFn) {\n  if (enableComponentStackLocations) {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        const match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  } else {\n    let ownerName = null;\n\n    if (__DEV__ && ownerFn) {\n      ownerName = ownerFn.displayName || ownerFn.name || null;\n    }\n\n    return describeComponentFrame(name, source, ownerName);\n  }\n}\nlet reentry = false;\nlet componentFrameCache;\n\nif (__DEV__) {\n  const PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n\nexport function describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if (disableNativeComponentFrames || !fn || reentry) {\n    return '';\n  }\n\n  if (__DEV__) {\n    const frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  let control;\n  reentry = true;\n  const previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  let previousDispatcher;\n\n  if (__DEV__) {\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n\n  try {\n    // This should throw.\n    if (construct) {\n      // Something should be setting the props in the constructor.\n      const Fake = function () {\n        throw Error();\n      }; // $FlowFixMe\n\n\n      Object.defineProperty(Fake.prototype, 'props', {\n        set: function () {\n          // We use a throwing setter instead of frozen or non-writable props\n          // because that won't throw in a non-strict mode function.\n          throw Error();\n        }\n      });\n\n      if (typeof Reflect === 'object' && Reflect.construct) {\n        // We construct a different control for this case to include any extra\n        // frames added by the construct call.\n        try {\n          Reflect.construct(Fake, []);\n        } catch (x) {\n          control = x;\n        }\n\n        Reflect.construct(fn, [], Fake);\n      } else {\n        try {\n          Fake.call();\n        } catch (x) {\n          control = x;\n        }\n\n        fn.call(Fake.prototype);\n      }\n    } else {\n      try {\n        throw Error();\n      } catch (x) {\n        control = x;\n      }\n\n      fn();\n    }\n  } catch (sample) {\n    // This is inlined manually because closure doesn't do it for us.\n    if (sample && control && typeof sample.stack === 'string') {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      const sampleLines = sample.stack.split('\\n');\n      const controlLines = control.stack.split('\\n');\n      let s = sampleLines.length - 1;\n      let c = controlLines.length - 1;\n\n      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n        // We expect at least one stack frame to be shared.\n        // Typically this will be the root most one. However, stack frames may be\n        // cut off due to maximum stack limits. In this case, one maybe cut off\n        // earlier than the other. We assume that the sample is longer or the same\n        // and there for cut off earlier. So we should find the root most frame in\n        // the sample somewhere in the control.\n        c--;\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                let frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n                if (fn.displayName && frame.includes('<anonymous>')) {\n                  frame = frame.replace('<anonymous>', fn.displayName);\n                }\n\n                if (__DEV__) {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, frame);\n                  }\n                } // Return the line we found.\n\n\n                return frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    if (__DEV__) {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  const name = fn ? fn.displayName || fn.name : '';\n  const syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  if (__DEV__) {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nconst BEFORE_SLASH_RE = /^(.*)[\\\\\\/]/;\n\nfunction describeComponentFrame(name, source, ownerName) {\n  let sourceInfo = '';\n\n  if (__DEV__ && source) {\n    const path = source.fileName;\n    let fileName = path.replace(BEFORE_SLASH_RE, ''); // In DEV, include code for a common special case:\n    // prefer \"folder/index.js\" instead of just \"index.js\".\n\n    if (/^index\\./.test(fileName)) {\n      const match = path.match(BEFORE_SLASH_RE);\n\n      if (match) {\n        const pathBeforeSlash = match[1];\n\n        if (pathBeforeSlash) {\n          const folderName = pathBeforeSlash.replace(BEFORE_SLASH_RE, '');\n          fileName = folderName + '/' + fileName;\n        }\n      }\n    }\n\n    sourceInfo = ' (at ' + fileName + ':' + source.lineNumber + ')';\n  } else if (ownerName) {\n    sourceInfo = ' (created by ' + ownerName + ')';\n  }\n\n  return '\\n    in ' + (name || 'Unknown') + sourceInfo;\n}\n\nexport function describeClassComponentFrame(ctor, source, ownerFn) {\n  if (enableComponentStackLocations) {\n    return describeNativeComponentFrame(ctor, true);\n  } else {\n    return describeFunctionComponentFrame(ctor, source, ownerFn);\n  }\n}\nexport function describeFunctionComponentFrame(fn, source, ownerFn) {\n  if (enableComponentStackLocations) {\n    return describeNativeComponentFrame(fn, false);\n  } else {\n    if (!fn) {\n      return '';\n    }\n\n    const name = fn.displayName || fn.name || null;\n    let ownerName = null;\n\n    if (__DEV__ && ownerFn) {\n      ownerName = ownerFn.displayName || ownerFn.name || null;\n    }\n\n    return describeComponentFrame(name, source, ownerName);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  const prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nexport function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n  if (!__DEV__) {\n    return '';\n  }\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    if (enableComponentStackLocations) {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    } else {\n      return describeFunctionComponentFrame(type, source, ownerFn);\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type, source, ownerFn);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense', source, ownerFn);\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList', source, ownerFn);\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render, source, ownerFn);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          const lazyComponent = type;\n          const payload = lazyComponent._payload;\n          const init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}","map":{"version":3,"sources":["/Users/zhangshuo/git/react-source-test/src/react/packages/shared/ReactComponentStackFrame.js"],"names":["enableComponentStackLocations","disableNativeComponentFrames","REACT_SUSPENSE_TYPE","REACT_SUSPENSE_LIST_TYPE","REACT_FORWARD_REF_TYPE","REACT_MEMO_TYPE","REACT_LAZY_TYPE","disableLogs","reenableLogs","ReactSharedInternals","ReactCurrentDispatcher","prefix","describeBuiltInComponentFrame","name","source","ownerFn","undefined","Error","x","match","stack","trim","ownerName","__DEV__","displayName","describeComponentFrame","reentry","componentFrameCache","PossiblyWeakMap","WeakMap","Map","describeNativeComponentFrame","fn","construct","frame","get","control","previousPrepareStackTrace","prepareStackTrace","previousDispatcher","current","Fake","Object","defineProperty","prototype","set","Reflect","call","sample","sampleLines","split","controlLines","s","length","c","replace","includes","syntheticFrame","BEFORE_SLASH_RE","sourceInfo","path","fileName","test","pathBeforeSlash","folderName","lineNumber","describeClassComponentFrame","ctor","describeFunctionComponentFrame","shouldConstruct","Component","isReactComponent","describeUnknownElementTypeFrameInDEV","type","$$typeof","render","lazyComponent","payload","_payload","init","_init"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Source} from 'shared/ReactElementType';\nimport type {LazyComponent} from 'react/src/ReactLazy';\n\nimport {\n  enableComponentStackLocations,\n  disableNativeComponentFrames,\n} from 'shared/ReactFeatureFlags';\n\nimport {\n  REACT_SUSPENSE_TYPE,\n  REACT_SUSPENSE_LIST_TYPE,\n  REACT_FORWARD_REF_TYPE,\n  REACT_MEMO_TYPE,\n  REACT_LAZY_TYPE,\n} from 'shared/ReactSymbols';\n\nimport {disableLogs, reenableLogs} from 'shared/ConsolePatchingDev';\n\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\n\nconst {ReactCurrentDispatcher} = ReactSharedInternals;\n\nlet prefix;\nexport function describeBuiltInComponentFrame(\n  name: string,\n  source: void | null | Source,\n  ownerFn: void | null | Function,\n): string {\n  if (enableComponentStackLocations) {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        const match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = (match && match[1]) || '';\n      }\n    }\n    // We use the prefix to ensure our stacks line up with native stack frames.\n    return '\\n' + prefix + name;\n  } else {\n    let ownerName = null;\n    if (__DEV__ && ownerFn) {\n      ownerName = ownerFn.displayName || ownerFn.name || null;\n    }\n    return describeComponentFrame(name, source, ownerName);\n  }\n}\n\nlet reentry = false;\nlet componentFrameCache;\nif (__DEV__) {\n  const PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n\nexport function describeNativeComponentFrame(\n  fn: Function,\n  construct: boolean,\n): string {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if (disableNativeComponentFrames || !fn || reentry) {\n    return '';\n  }\n\n  if (__DEV__) {\n    const frame = componentFrameCache.get(fn);\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  let control;\n\n  reentry = true;\n  const previousPrepareStackTrace = Error.prepareStackTrace;\n  // $FlowFixMe It does accept undefined.\n  Error.prepareStackTrace = undefined;\n  let previousDispatcher;\n  if (__DEV__) {\n    previousDispatcher = ReactCurrentDispatcher.current;\n    // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n  try {\n    // This should throw.\n    if (construct) {\n      // Something should be setting the props in the constructor.\n      const Fake = function() {\n        throw Error();\n      };\n      // $FlowFixMe\n      Object.defineProperty(Fake.prototype, 'props', {\n        set: function() {\n          // We use a throwing setter instead of frozen or non-writable props\n          // because that won't throw in a non-strict mode function.\n          throw Error();\n        },\n      });\n      if (typeof Reflect === 'object' && Reflect.construct) {\n        // We construct a different control for this case to include any extra\n        // frames added by the construct call.\n        try {\n          Reflect.construct(Fake, []);\n        } catch (x) {\n          control = x;\n        }\n        Reflect.construct(fn, [], Fake);\n      } else {\n        try {\n          Fake.call();\n        } catch (x) {\n          control = x;\n        }\n        fn.call(Fake.prototype);\n      }\n    } else {\n      try {\n        throw Error();\n      } catch (x) {\n        control = x;\n      }\n      fn();\n    }\n  } catch (sample) {\n    // This is inlined manually because closure doesn't do it for us.\n    if (sample && control && typeof sample.stack === 'string') {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      const sampleLines = sample.stack.split('\\n');\n      const controlLines = control.stack.split('\\n');\n      let s = sampleLines.length - 1;\n      let c = controlLines.length - 1;\n      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n        // We expect at least one stack frame to be shared.\n        // Typically this will be the root most one. However, stack frames may be\n        // cut off due to maximum stack limits. In this case, one maybe cut off\n        // earlier than the other. We assume that the sample is longer or the same\n        // and there for cut off earlier. So we should find the root most frame in\n        // the sample somewhere in the control.\n        c--;\n      }\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--;\n              // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                let frame = '\\n' + sampleLines[s].replace(' at new ', ' at ');\n\n                // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n                if (fn.displayName && frame.includes('<anonymous>')) {\n                  frame = frame.replace('<anonymous>', fn.displayName);\n                }\n\n                if (__DEV__) {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, frame);\n                  }\n                }\n                // Return the line we found.\n                return frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n    if (__DEV__) {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  }\n  // Fallback to just using the name if we couldn't make it throw.\n  const name = fn ? fn.displayName || fn.name : '';\n  const syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n  if (__DEV__) {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n  return syntheticFrame;\n}\n\nconst BEFORE_SLASH_RE = /^(.*)[\\\\\\/]/;\n\nfunction describeComponentFrame(\n  name: null | string,\n  source: void | null | Source,\n  ownerName: null | string,\n) {\n  let sourceInfo = '';\n  if (__DEV__ && source) {\n    const path = source.fileName;\n    let fileName = path.replace(BEFORE_SLASH_RE, '');\n    // In DEV, include code for a common special case:\n    // prefer \"folder/index.js\" instead of just \"index.js\".\n    if (/^index\\./.test(fileName)) {\n      const match = path.match(BEFORE_SLASH_RE);\n      if (match) {\n        const pathBeforeSlash = match[1];\n        if (pathBeforeSlash) {\n          const folderName = pathBeforeSlash.replace(BEFORE_SLASH_RE, '');\n          fileName = folderName + '/' + fileName;\n        }\n      }\n    }\n    sourceInfo = ' (at ' + fileName + ':' + source.lineNumber + ')';\n  } else if (ownerName) {\n    sourceInfo = ' (created by ' + ownerName + ')';\n  }\n  return '\\n    in ' + (name || 'Unknown') + sourceInfo;\n}\n\nexport function describeClassComponentFrame(\n  ctor: Function,\n  source: void | null | Source,\n  ownerFn: void | null | Function,\n): string {\n  if (enableComponentStackLocations) {\n    return describeNativeComponentFrame(ctor, true);\n  } else {\n    return describeFunctionComponentFrame(ctor, source, ownerFn);\n  }\n}\n\nexport function describeFunctionComponentFrame(\n  fn: Function,\n  source: void | null | Source,\n  ownerFn: void | null | Function,\n): string {\n  if (enableComponentStackLocations) {\n    return describeNativeComponentFrame(fn, false);\n  } else {\n    if (!fn) {\n      return '';\n    }\n    const name = fn.displayName || fn.name || null;\n    let ownerName = null;\n    if (__DEV__ && ownerFn) {\n      ownerName = ownerFn.displayName || ownerFn.name || null;\n    }\n    return describeComponentFrame(name, source, ownerName);\n  }\n}\n\nfunction shouldConstruct(Component: Function) {\n  const prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nexport function describeUnknownElementTypeFrameInDEV(\n  type: any,\n  source: void | null | Source,\n  ownerFn: void | null | Function,\n): string {\n  if (!__DEV__) {\n    return '';\n  }\n  if (type == null) {\n    return '';\n  }\n  if (typeof type === 'function') {\n    if (enableComponentStackLocations) {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    } else {\n      return describeFunctionComponentFrame(type, source, ownerFn);\n    }\n  }\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type, source, ownerFn);\n  }\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense', source, ownerFn);\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList', source, ownerFn);\n  }\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render, source, ownerFn);\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n      case REACT_LAZY_TYPE: {\n        const lazyComponent: LazyComponent<any, any> = (type: any);\n        const payload = lazyComponent._payload;\n        const init = lazyComponent._init;\n        try {\n          // Lazy may contain any component type so we recursively resolve it.\n          return describeUnknownElementTypeFrameInDEV(\n            init(payload),\n            source,\n            ownerFn,\n          );\n        } catch (x) {}\n      }\n    }\n  }\n  return '';\n}\n"]},"metadata":{},"sourceType":"module"}