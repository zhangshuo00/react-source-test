{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { findCurrentHostFiber, findCurrentHostFiberWithNoPortals } from './ReactFiberTreeReflection';\nimport { get as getInstance } from 'shared/ReactInstanceMap';\nimport { HostComponent, ClassComponent, HostRoot, SuspenseComponent } from './ReactWorkTags';\nimport getComponentNameFromFiber from 'react-reconciler/src/getComponentNameFromFiber';\nimport isArray from 'shared/isArray';\nimport { enableSchedulingProfiler } from 'shared/ReactFeatureFlags';\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nimport { getPublicInstance } from './ReactFiberHostConfig';\nimport { findCurrentUnmaskedContext, processChildContext, emptyContextObject, isContextProvider as isLegacyContextProvider } from './ReactFiberContext.new';\nimport { createFiberRoot } from './ReactFiberRoot.new';\nimport { injectInternals, onScheduleRoot } from './ReactFiberDevToolsHook.new';\nimport { requestEventTime, requestUpdateLane, scheduleUpdateOnFiber, flushRoot, batchedUpdates, flushSync, isAlreadyRendering, flushControlled, deferredUpdates, discreteUpdates, flushPassiveEffects } from './ReactFiberWorkLoop.new';\nimport { createUpdate, enqueueUpdate, entangleTransitions } from './ReactUpdateQueue.new';\nimport { isRendering as ReactCurrentFiberIsRendering, current as ReactCurrentFiberCurrent, resetCurrentFiber as resetCurrentDebugFiberInDEV, setCurrentFiber as setCurrentDebugFiberInDEV } from './ReactCurrentFiber';\nimport { StrictLegacyMode } from './ReactTypeOfMode';\nimport { SyncLane, SelectiveHydrationLane, NoTimestamp, getHighestPriorityPendingLanes, higherPriorityLane } from './ReactFiberLane.new';\nimport { getCurrentUpdatePriority, runWithPriority } from './ReactEventPriorities.new';\nimport { scheduleRefresh, scheduleRoot, setRefreshHandler, findHostInstancesForRefresh } from './ReactFiberHotReloading.new';\nimport { markRenderScheduled } from './SchedulingProfiler';\nimport ReactVersion from 'shared/ReactVersion';\nexport { registerMutableSourceForHydration } from './ReactMutableSource.new';\nexport { createPortal } from './ReactPortal';\nexport { createComponentSelector, createHasPseudoClassSelector, createRoleSelector, createTestNameSelector, createTextSelector, getFindAllNodesFailureDescription, findAllNodes, findBoundingRects, focusWithin, observeVisibleRects } from './ReactTestSelectors';\nlet didWarnAboutNestedUpdates;\nlet didWarnAboutFindNodeInStrictMode;\n\nif (__DEV__) {\n  didWarnAboutNestedUpdates = false;\n  didWarnAboutFindNodeInStrictMode = {};\n}\n\nfunction getContextForSubtree(parentComponent) {\n  if (!parentComponent) {\n    return emptyContextObject;\n  }\n\n  const fiber = getInstance(parentComponent);\n  const parentContext = findCurrentUnmaskedContext(fiber);\n\n  if (fiber.tag === ClassComponent) {\n    const Component = fiber.type;\n\n    if (isLegacyContextProvider(Component)) {\n      return processChildContext(fiber, Component, parentContext);\n    }\n  }\n\n  return parentContext;\n}\n\nfunction findHostInstance(component) {\n  const fiber = getInstance(component);\n\n  if (fiber === undefined) {\n    if (typeof component.render === 'function') {\n      throw new Error('Unable to find node on an unmounted component.');\n    } else {\n      const keys = Object.keys(component).join(',');\n      throw new Error(`Argument appears to not be a ReactComponent. Keys: ${keys}`);\n    }\n  }\n\n  const hostFiber = findCurrentHostFiber(fiber);\n\n  if (hostFiber === null) {\n    return null;\n  }\n\n  return hostFiber.stateNode;\n}\n\nfunction findHostInstanceWithWarning(component, methodName) {\n  if (__DEV__) {\n    const fiber = getInstance(component);\n\n    if (fiber === undefined) {\n      if (typeof component.render === 'function') {\n        throw new Error('Unable to find node on an unmounted component.');\n      } else {\n        const keys = Object.keys(component).join(',');\n        throw new Error(`Argument appears to not be a ReactComponent. Keys: ${keys}`);\n      }\n    }\n\n    const hostFiber = findCurrentHostFiber(fiber);\n\n    if (hostFiber === null) {\n      return null;\n    }\n\n    if (hostFiber.mode & StrictLegacyMode) {\n      const componentName = getComponentNameFromFiber(fiber) || 'Component';\n\n      if (!didWarnAboutFindNodeInStrictMode[componentName]) {\n        didWarnAboutFindNodeInStrictMode[componentName] = true;\n        const previousFiber = ReactCurrentFiberCurrent;\n\n        try {\n          setCurrentDebugFiberInDEV(hostFiber);\n\n          if (fiber.mode & StrictLegacyMode) {\n            console.error('%s is deprecated in StrictMode. ' + '%s was passed an instance of %s which is inside StrictMode. ' + 'Instead, add a ref directly to the element you want to reference. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-find-node', methodName, methodName, componentName);\n          } else {\n            console.error('%s is deprecated in StrictMode. ' + '%s was passed an instance of %s which renders StrictMode children. ' + 'Instead, add a ref directly to the element you want to reference. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-find-node', methodName, methodName, componentName);\n          }\n        } finally {\n          // Ideally this should reset to previous but this shouldn't be called in\n          // render and there's another warning for that anyway.\n          if (previousFiber) {\n            setCurrentDebugFiberInDEV(previousFiber);\n          } else {\n            resetCurrentDebugFiberInDEV();\n          }\n        }\n      }\n    }\n\n    return hostFiber.stateNode;\n  }\n\n  return findHostInstance(component);\n}\n\nexport function createContainer(containerInfo, tag, hydrate, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride) {\n  return createFiberRoot(containerInfo, tag, hydrate, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride);\n}\nexport function updateContainer(element, container, parentComponent, callback) {\n  if (__DEV__) {\n    onScheduleRoot(container, element);\n  }\n\n  const current = container.current;\n  const eventTime = requestEventTime();\n  const lane = requestUpdateLane(current);\n\n  if (enableSchedulingProfiler) {\n    markRenderScheduled(lane);\n  }\n\n  const context = getContextForSubtree(parentComponent);\n\n  if (container.context === null) {\n    container.context = context;\n  } else {\n    container.pendingContext = context;\n  }\n\n  if (__DEV__) {\n    if (ReactCurrentFiberIsRendering && ReactCurrentFiberCurrent !== null && !didWarnAboutNestedUpdates) {\n      didWarnAboutNestedUpdates = true;\n      console.error('Render methods should be a pure function of props and state; ' + 'triggering nested component updates from render is not allowed. ' + 'If necessary, trigger nested updates in componentDidUpdate.\\n\\n' + 'Check the render method of %s.', getComponentNameFromFiber(ReactCurrentFiberCurrent) || 'Unknown');\n    }\n  }\n\n  const update = createUpdate(eventTime, lane); // Caution: React DevTools currently depends on this property\n  // being called \"element\".\n\n  update.payload = {\n    element\n  };\n  callback = callback === undefined ? null : callback;\n\n  if (callback !== null) {\n    if (__DEV__) {\n      if (typeof callback !== 'function') {\n        console.error('render(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callback);\n      }\n    }\n\n    update.callback = callback;\n  }\n\n  enqueueUpdate(current, update, lane);\n  const root = scheduleUpdateOnFiber(current, lane, eventTime);\n\n  if (root !== null) {\n    entangleTransitions(root, current, lane);\n  }\n\n  return lane;\n}\nexport { batchedUpdates, deferredUpdates, discreteUpdates, flushControlled, flushSync, isAlreadyRendering, flushPassiveEffects };\nexport function getPublicRootInstance(container) {\n  const containerFiber = container.current;\n\n  if (!containerFiber.child) {\n    return null;\n  }\n\n  switch (containerFiber.child.tag) {\n    case HostComponent:\n      return getPublicInstance(containerFiber.child.stateNode);\n\n    default:\n      return containerFiber.child.stateNode;\n  }\n}\nexport function attemptSynchronousHydration(fiber) {\n  switch (fiber.tag) {\n    case HostRoot:\n      const root = fiber.stateNode;\n\n      if (root.isDehydrated) {\n        // Flush the first scheduled \"update\".\n        const lanes = getHighestPriorityPendingLanes(root);\n        flushRoot(root, lanes);\n      }\n\n      break;\n\n    case SuspenseComponent:\n      const eventTime = requestEventTime();\n      flushSync(() => scheduleUpdateOnFiber(fiber, SyncLane, eventTime)); // If we're still blocked after this, we need to increase\n      // the priority of any promises resolving within this\n      // boundary so that they next attempt also has higher pri.\n\n      const retryLane = SyncLane;\n      markRetryLaneIfNotHydrated(fiber, retryLane);\n      break;\n  }\n}\n\nfunction markRetryLaneImpl(fiber, retryLane) {\n  const suspenseState = fiber.memoizedState;\n\n  if (suspenseState !== null && suspenseState.dehydrated !== null) {\n    suspenseState.retryLane = higherPriorityLane(suspenseState.retryLane, retryLane);\n  }\n} // Increases the priority of thenables when they resolve within this boundary.\n\n\nfunction markRetryLaneIfNotHydrated(fiber, retryLane) {\n  markRetryLaneImpl(fiber, retryLane);\n  const alternate = fiber.alternate;\n\n  if (alternate) {\n    markRetryLaneImpl(alternate, retryLane);\n  }\n}\n\nexport function attemptDiscreteHydration(fiber) {\n  if (fiber.tag !== SuspenseComponent) {\n    // We ignore HostRoots here because we can't increase\n    // their priority and they should not suspend on I/O,\n    // since you have to wrap anything that might suspend in\n    // Suspense.\n    return;\n  }\n\n  const eventTime = requestEventTime();\n  const lane = SyncLane;\n  scheduleUpdateOnFiber(fiber, lane, eventTime);\n  markRetryLaneIfNotHydrated(fiber, lane);\n}\nexport function attemptContinuousHydration(fiber) {\n  if (fiber.tag !== SuspenseComponent) {\n    // We ignore HostRoots here because we can't increase\n    // their priority and they should not suspend on I/O,\n    // since you have to wrap anything that might suspend in\n    // Suspense.\n    return;\n  }\n\n  const eventTime = requestEventTime();\n  const lane = SelectiveHydrationLane;\n  scheduleUpdateOnFiber(fiber, lane, eventTime);\n  markRetryLaneIfNotHydrated(fiber, lane);\n}\nexport function attemptHydrationAtCurrentPriority(fiber) {\n  if (fiber.tag !== SuspenseComponent) {\n    // We ignore HostRoots here because we can't increase\n    // their priority other than synchronously flush it.\n    return;\n  }\n\n  const eventTime = requestEventTime();\n  const lane = requestUpdateLane(fiber);\n  scheduleUpdateOnFiber(fiber, lane, eventTime);\n  markRetryLaneIfNotHydrated(fiber, lane);\n}\nexport { getCurrentUpdatePriority, runWithPriority };\nexport { findHostInstance };\nexport { findHostInstanceWithWarning };\nexport function findHostInstanceWithNoPortals(fiber) {\n  const hostFiber = findCurrentHostFiberWithNoPortals(fiber);\n\n  if (hostFiber === null) {\n    return null;\n  }\n\n  return hostFiber.stateNode;\n}\n\nlet shouldErrorImpl = fiber => null;\n\nexport function shouldError(fiber) {\n  return shouldErrorImpl(fiber);\n}\n\nlet shouldSuspendImpl = fiber => false;\n\nexport function shouldSuspend(fiber) {\n  return shouldSuspendImpl(fiber);\n}\nlet overrideHookState = null;\nlet overrideHookStateDeletePath = null;\nlet overrideHookStateRenamePath = null;\nlet overrideProps = null;\nlet overridePropsDeletePath = null;\nlet overridePropsRenamePath = null;\nlet scheduleUpdate = null;\nlet setErrorHandler = null;\nlet setSuspenseHandler = null;\n\nif (__DEV__) {\n  const copyWithDeleteImpl = (obj, path, index) => {\n    const key = path[index];\n    const updated = isArray(obj) ? obj.slice() : { ...obj\n    };\n\n    if (index + 1 === path.length) {\n      if (isArray(updated)) {\n        updated.splice(key, 1);\n      } else {\n        delete updated[key];\n      }\n\n      return updated;\n    } // $FlowFixMe number or string is fine here\n\n\n    updated[key] = copyWithDeleteImpl(obj[key], path, index + 1);\n    return updated;\n  };\n\n  const copyWithDelete = (obj, path) => {\n    return copyWithDeleteImpl(obj, path, 0);\n  };\n\n  const copyWithRenameImpl = (obj, oldPath, newPath, index) => {\n    const oldKey = oldPath[index];\n    const updated = isArray(obj) ? obj.slice() : { ...obj\n    };\n\n    if (index + 1 === oldPath.length) {\n      const newKey = newPath[index]; // $FlowFixMe number or string is fine here\n\n      updated[newKey] = updated[oldKey];\n\n      if (isArray(updated)) {\n        updated.splice(oldKey, 1);\n      } else {\n        delete updated[oldKey];\n      }\n    } else {\n      // $FlowFixMe number or string is fine here\n      updated[oldKey] = copyWithRenameImpl( // $FlowFixMe number or string is fine here\n      obj[oldKey], oldPath, newPath, index + 1);\n    }\n\n    return updated;\n  };\n\n  const copyWithRename = (obj, oldPath, newPath) => {\n    if (oldPath.length !== newPath.length) {\n      console.warn('copyWithRename() expects paths of the same length');\n      return;\n    } else {\n      for (let i = 0; i < newPath.length - 1; i++) {\n        if (oldPath[i] !== newPath[i]) {\n          console.warn('copyWithRename() expects paths to be the same except for the deepest key');\n          return;\n        }\n      }\n    }\n\n    return copyWithRenameImpl(obj, oldPath, newPath, 0);\n  };\n\n  const copyWithSetImpl = (obj, path, index, value) => {\n    if (index >= path.length) {\n      return value;\n    }\n\n    const key = path[index];\n    const updated = isArray(obj) ? obj.slice() : { ...obj\n    }; // $FlowFixMe number or string is fine here\n\n    updated[key] = copyWithSetImpl(obj[key], path, index + 1, value);\n    return updated;\n  };\n\n  const copyWithSet = (obj, path, value) => {\n    return copyWithSetImpl(obj, path, 0, value);\n  };\n\n  const findHook = (fiber, id) => {\n    // For now, the \"id\" of stateful hooks is just the stateful hook index.\n    // This may change in the future with e.g. nested hooks.\n    let currentHook = fiber.memoizedState;\n\n    while (currentHook !== null && id > 0) {\n      currentHook = currentHook.next;\n      id--;\n    }\n\n    return currentHook;\n  }; // Support DevTools editable values for useState and useReducer.\n\n\n  overrideHookState = (fiber, id, path, value) => {\n    const hook = findHook(fiber, id);\n\n    if (hook !== null) {\n      const newState = copyWithSet(hook.memoizedState, path, value);\n      hook.memoizedState = newState;\n      hook.baseState = newState; // We aren't actually adding an update to the queue,\n      // because there is no update we can add for useReducer hooks that won't trigger an error.\n      // (There's no appropriate action type for DevTools overrides.)\n      // As a result though, React will see the scheduled update as a noop and bailout.\n      // Shallow cloning props works as a workaround for now to bypass the bailout check.\n\n      fiber.memoizedProps = { ...fiber.memoizedProps\n      };\n      scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\n    }\n  };\n\n  overrideHookStateDeletePath = (fiber, id, path) => {\n    const hook = findHook(fiber, id);\n\n    if (hook !== null) {\n      const newState = copyWithDelete(hook.memoizedState, path);\n      hook.memoizedState = newState;\n      hook.baseState = newState; // We aren't actually adding an update to the queue,\n      // because there is no update we can add for useReducer hooks that won't trigger an error.\n      // (There's no appropriate action type for DevTools overrides.)\n      // As a result though, React will see the scheduled update as a noop and bailout.\n      // Shallow cloning props works as a workaround for now to bypass the bailout check.\n\n      fiber.memoizedProps = { ...fiber.memoizedProps\n      };\n      scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\n    }\n  };\n\n  overrideHookStateRenamePath = (fiber, id, oldPath, newPath) => {\n    const hook = findHook(fiber, id);\n\n    if (hook !== null) {\n      const newState = copyWithRename(hook.memoizedState, oldPath, newPath);\n      hook.memoizedState = newState;\n      hook.baseState = newState; // We aren't actually adding an update to the queue,\n      // because there is no update we can add for useReducer hooks that won't trigger an error.\n      // (There's no appropriate action type for DevTools overrides.)\n      // As a result though, React will see the scheduled update as a noop and bailout.\n      // Shallow cloning props works as a workaround for now to bypass the bailout check.\n\n      fiber.memoizedProps = { ...fiber.memoizedProps\n      };\n      scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\n    }\n  }; // Support DevTools props for function components, forwardRef, memo, host components, etc.\n\n\n  overrideProps = (fiber, path, value) => {\n    fiber.pendingProps = copyWithSet(fiber.memoizedProps, path, value);\n\n    if (fiber.alternate) {\n      fiber.alternate.pendingProps = fiber.pendingProps;\n    }\n\n    scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\n  };\n\n  overridePropsDeletePath = (fiber, path) => {\n    fiber.pendingProps = copyWithDelete(fiber.memoizedProps, path);\n\n    if (fiber.alternate) {\n      fiber.alternate.pendingProps = fiber.pendingProps;\n    }\n\n    scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\n  };\n\n  overridePropsRenamePath = (fiber, oldPath, newPath) => {\n    fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);\n\n    if (fiber.alternate) {\n      fiber.alternate.pendingProps = fiber.pendingProps;\n    }\n\n    scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\n  };\n\n  scheduleUpdate = fiber => {\n    scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\n  };\n\n  setErrorHandler = newShouldErrorImpl => {\n    shouldErrorImpl = newShouldErrorImpl;\n  };\n\n  setSuspenseHandler = newShouldSuspendImpl => {\n    shouldSuspendImpl = newShouldSuspendImpl;\n  };\n}\n\nfunction findHostInstanceByFiber(fiber) {\n  const hostFiber = findCurrentHostFiber(fiber);\n\n  if (hostFiber === null) {\n    return null;\n  }\n\n  return hostFiber.stateNode;\n}\n\nfunction emptyFindFiberByHostInstance(instance) {\n  return null;\n}\n\nfunction getCurrentFiberForDevTools() {\n  return ReactCurrentFiberCurrent;\n}\n\nexport function injectIntoDevTools(devToolsConfig) {\n  const {\n    findFiberByHostInstance\n  } = devToolsConfig;\n  const {\n    ReactCurrentDispatcher\n  } = ReactSharedInternals;\n  return injectInternals({\n    bundleType: devToolsConfig.bundleType,\n    version: devToolsConfig.version,\n    rendererPackageName: devToolsConfig.rendererPackageName,\n    rendererConfig: devToolsConfig.rendererConfig,\n    overrideHookState,\n    overrideHookStateDeletePath,\n    overrideHookStateRenamePath,\n    overrideProps,\n    overridePropsDeletePath,\n    overridePropsRenamePath,\n    setErrorHandler,\n    setSuspenseHandler,\n    scheduleUpdate,\n    currentDispatcherRef: ReactCurrentDispatcher,\n    findHostInstanceByFiber,\n    findFiberByHostInstance: findFiberByHostInstance || emptyFindFiberByHostInstance,\n    // React Refresh\n    findHostInstancesForRefresh: __DEV__ ? findHostInstancesForRefresh : null,\n    scheduleRefresh: __DEV__ ? scheduleRefresh : null,\n    scheduleRoot: __DEV__ ? scheduleRoot : null,\n    setRefreshHandler: __DEV__ ? setRefreshHandler : null,\n    // Enables DevTools to append owner stacks to error messages in DEV mode.\n    getCurrentFiber: __DEV__ ? getCurrentFiberForDevTools : null,\n    // Enables DevTools to detect reconciler version rather than renderer version\n    // which may not match for third party renderers.\n    reconcilerVersion: ReactVersion\n  });\n}","map":{"version":3,"sources":["/Users/zhangshuo/git/my-app/src/react/packages/react-reconciler/src/ReactFiberReconciler.new.js"],"names":["findCurrentHostFiber","findCurrentHostFiberWithNoPortals","get","getInstance","HostComponent","ClassComponent","HostRoot","SuspenseComponent","getComponentNameFromFiber","isArray","enableSchedulingProfiler","ReactSharedInternals","getPublicInstance","findCurrentUnmaskedContext","processChildContext","emptyContextObject","isContextProvider","isLegacyContextProvider","createFiberRoot","injectInternals","onScheduleRoot","requestEventTime","requestUpdateLane","scheduleUpdateOnFiber","flushRoot","batchedUpdates","flushSync","isAlreadyRendering","flushControlled","deferredUpdates","discreteUpdates","flushPassiveEffects","createUpdate","enqueueUpdate","entangleTransitions","isRendering","ReactCurrentFiberIsRendering","current","ReactCurrentFiberCurrent","resetCurrentFiber","resetCurrentDebugFiberInDEV","setCurrentFiber","setCurrentDebugFiberInDEV","StrictLegacyMode","SyncLane","SelectiveHydrationLane","NoTimestamp","getHighestPriorityPendingLanes","higherPriorityLane","getCurrentUpdatePriority","runWithPriority","scheduleRefresh","scheduleRoot","setRefreshHandler","findHostInstancesForRefresh","markRenderScheduled","ReactVersion","registerMutableSourceForHydration","createPortal","createComponentSelector","createHasPseudoClassSelector","createRoleSelector","createTestNameSelector","createTextSelector","getFindAllNodesFailureDescription","findAllNodes","findBoundingRects","focusWithin","observeVisibleRects","didWarnAboutNestedUpdates","didWarnAboutFindNodeInStrictMode","__DEV__","getContextForSubtree","parentComponent","fiber","parentContext","tag","Component","type","findHostInstance","component","undefined","render","Error","keys","Object","join","hostFiber","stateNode","findHostInstanceWithWarning","methodName","mode","componentName","previousFiber","console","error","createContainer","containerInfo","hydrate","hydrationCallbacks","isStrictMode","concurrentUpdatesByDefaultOverride","updateContainer","element","container","callback","eventTime","lane","context","pendingContext","update","payload","root","getPublicRootInstance","containerFiber","child","attemptSynchronousHydration","isDehydrated","lanes","retryLane","markRetryLaneIfNotHydrated","markRetryLaneImpl","suspenseState","memoizedState","dehydrated","alternate","attemptDiscreteHydration","attemptContinuousHydration","attemptHydrationAtCurrentPriority","findHostInstanceWithNoPortals","shouldErrorImpl","shouldError","shouldSuspendImpl","shouldSuspend","overrideHookState","overrideHookStateDeletePath","overrideHookStateRenamePath","overrideProps","overridePropsDeletePath","overridePropsRenamePath","scheduleUpdate","setErrorHandler","setSuspenseHandler","copyWithDeleteImpl","obj","path","index","key","updated","slice","length","splice","copyWithDelete","copyWithRenameImpl","oldPath","newPath","oldKey","newKey","copyWithRename","warn","i","copyWithSetImpl","value","copyWithSet","findHook","id","currentHook","next","hook","newState","baseState","memoizedProps","pendingProps","newShouldErrorImpl","newShouldSuspendImpl","findHostInstanceByFiber","emptyFindFiberByHostInstance","instance","getCurrentFiberForDevTools","injectIntoDevTools","devToolsConfig","findFiberByHostInstance","ReactCurrentDispatcher","bundleType","version","rendererPackageName","rendererConfig","currentDispatcherRef","getCurrentFiber","reconcilerVersion"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAgBA,SACEA,oBADF,EAEEC,iCAFF,QAGO,4BAHP;AAIA,SAAQC,GAAG,IAAIC,WAAf,QAAiC,yBAAjC;AACA,SACEC,aADF,EAEEC,cAFF,EAGEC,QAHF,EAIEC,iBAJF,QAKO,iBALP;AAMA,OAAOC,yBAAP,MAAsC,gDAAtC;AACA,OAAOC,OAAP,MAAoB,gBAApB;AACA,SAAQC,wBAAR,QAAuC,0BAAvC;AACA,OAAOC,oBAAP,MAAiC,6BAAjC;AACA,SAAQC,iBAAR,QAAgC,wBAAhC;AACA,SACEC,0BADF,EAEEC,mBAFF,EAGEC,kBAHF,EAIEC,iBAAiB,IAAIC,uBAJvB,QAKO,yBALP;AAMA,SAAQC,eAAR,QAA8B,sBAA9B;AACA,SAAQC,eAAR,EAAyBC,cAAzB,QAA8C,8BAA9C;AACA,SACEC,gBADF,EAEEC,iBAFF,EAGEC,qBAHF,EAIEC,SAJF,EAKEC,cALF,EAMEC,SANF,EAOEC,kBAPF,EAQEC,eARF,EASEC,eATF,EAUEC,eAVF,EAWEC,mBAXF,QAYO,0BAZP;AAaA,SACEC,YADF,EAEEC,aAFF,EAGEC,mBAHF,QAIO,wBAJP;AAKA,SACEC,WAAW,IAAIC,4BADjB,EAEEC,OAAO,IAAIC,wBAFb,EAGEC,iBAAiB,IAAIC,2BAHvB,EAIEC,eAAe,IAAIC,yBAJrB,QAKO,qBALP;AAMA,SAAQC,gBAAR,QAA+B,mBAA/B;AACA,SACEC,QADF,EAEEC,sBAFF,EAGEC,WAHF,EAIEC,8BAJF,EAKEC,kBALF,QAMO,sBANP;AAOA,SACEC,wBADF,EAEEC,eAFF,QAGO,4BAHP;AAIA,SACEC,eADF,EAEEC,YAFF,EAGEC,iBAHF,EAIEC,2BAJF,QAKO,8BALP;AAMA,SAAQC,mBAAR,QAAkC,sBAAlC;AACA,OAAOC,YAAP,MAAyB,qBAAzB;AACA,SAAQC,iCAAR,QAAgD,0BAAhD;AACA,SAAQC,YAAR,QAA2B,eAA3B;AACA,SACEC,uBADF,EAEEC,4BAFF,EAGEC,kBAHF,EAIEC,sBAJF,EAKEC,kBALF,EAMEC,iCANF,EAOEC,YAPF,EAQEC,iBARF,EASEC,WATF,EAUEC,mBAVF,QAWO,sBAXP;AA6BA,IAAIC,yBAAJ;AACA,IAAIC,gCAAJ;;AAEA,IAAIC,OAAJ,EAAa;AACXF,EAAAA,yBAAyB,GAAG,KAA5B;AACAC,EAAAA,gCAAgC,GAAG,EAAnC;AACD;;AAED,SAASE,oBAAT,CACEC,eADF,EAEU;AACR,MAAI,CAACA,eAAL,EAAsB;AACpB,WAAO1D,kBAAP;AACD;;AAED,QAAM2D,KAAK,GAAGvE,WAAW,CAACsE,eAAD,CAAzB;AACA,QAAME,aAAa,GAAG9D,0BAA0B,CAAC6D,KAAD,CAAhD;;AAEA,MAAIA,KAAK,CAACE,GAAN,KAAcvE,cAAlB,EAAkC;AAChC,UAAMwE,SAAS,GAAGH,KAAK,CAACI,IAAxB;;AACA,QAAI7D,uBAAuB,CAAC4D,SAAD,CAA3B,EAAwC;AACtC,aAAO/D,mBAAmB,CAAC4D,KAAD,EAAQG,SAAR,EAAmBF,aAAnB,CAA1B;AACD;AACF;;AAED,SAAOA,aAAP;AACD;;AAED,SAASI,gBAAT,CAA0BC,SAA1B,EAAoE;AAClE,QAAMN,KAAK,GAAGvE,WAAW,CAAC6E,SAAD,CAAzB;;AACA,MAAIN,KAAK,KAAKO,SAAd,EAAyB;AACvB,QAAI,OAAOD,SAAS,CAACE,MAAjB,KAA4B,UAAhC,EAA4C;AAC1C,YAAM,IAAIC,KAAJ,CAAU,gDAAV,CAAN;AACD,KAFD,MAEO;AACL,YAAMC,IAAI,GAAGC,MAAM,CAACD,IAAP,CAAYJ,SAAZ,EAAuBM,IAAvB,CAA4B,GAA5B,CAAb;AACA,YAAM,IAAIH,KAAJ,CACH,sDAAqDC,IAAK,EADvD,CAAN;AAGD;AACF;;AACD,QAAMG,SAAS,GAAGvF,oBAAoB,CAAC0E,KAAD,CAAtC;;AACA,MAAIa,SAAS,KAAK,IAAlB,EAAwB;AACtB,WAAO,IAAP;AACD;;AACD,SAAOA,SAAS,CAACC,SAAjB;AACD;;AAED,SAASC,2BAAT,CACET,SADF,EAEEU,UAFF,EAGyB;AACvB,MAAInB,OAAJ,EAAa;AACX,UAAMG,KAAK,GAAGvE,WAAW,CAAC6E,SAAD,CAAzB;;AACA,QAAIN,KAAK,KAAKO,SAAd,EAAyB;AACvB,UAAI,OAAOD,SAAS,CAACE,MAAjB,KAA4B,UAAhC,EAA4C;AAC1C,cAAM,IAAIC,KAAJ,CAAU,gDAAV,CAAN;AACD,OAFD,MAEO;AACL,cAAMC,IAAI,GAAGC,MAAM,CAACD,IAAP,CAAYJ,SAAZ,EAAuBM,IAAvB,CAA4B,GAA5B,CAAb;AACA,cAAM,IAAIH,KAAJ,CACH,sDAAqDC,IAAK,EADvD,CAAN;AAGD;AACF;;AACD,UAAMG,SAAS,GAAGvF,oBAAoB,CAAC0E,KAAD,CAAtC;;AACA,QAAIa,SAAS,KAAK,IAAlB,EAAwB;AACtB,aAAO,IAAP;AACD;;AACD,QAAIA,SAAS,CAACI,IAAV,GAAiBhD,gBAArB,EAAuC;AACrC,YAAMiD,aAAa,GAAGpF,yBAAyB,CAACkE,KAAD,CAAzB,IAAoC,WAA1D;;AACA,UAAI,CAACJ,gCAAgC,CAACsB,aAAD,CAArC,EAAsD;AACpDtB,QAAAA,gCAAgC,CAACsB,aAAD,CAAhC,GAAkD,IAAlD;AAEA,cAAMC,aAAa,GAAGvD,wBAAtB;;AACA,YAAI;AACFI,UAAAA,yBAAyB,CAAC6C,SAAD,CAAzB;;AACA,cAAIb,KAAK,CAACiB,IAAN,GAAahD,gBAAjB,EAAmC;AACjCmD,YAAAA,OAAO,CAACC,KAAR,CACE,qCACE,8DADF,GAEE,oEAFF,GAGE,2CAHF,GAIE,gDALJ,EAMEL,UANF,EAOEA,UAPF,EAQEE,aARF;AAUD,WAXD,MAWO;AACLE,YAAAA,OAAO,CAACC,KAAR,CACE,qCACE,qEADF,GAEE,oEAFF,GAGE,2CAHF,GAIE,gDALJ,EAMEL,UANF,EAOEA,UAPF,EAQEE,aARF;AAUD;AACF,SAzBD,SAyBU;AACR;AACA;AACA,cAAIC,aAAJ,EAAmB;AACjBnD,YAAAA,yBAAyB,CAACmD,aAAD,CAAzB;AACD,WAFD,MAEO;AACLrD,YAAAA,2BAA2B;AAC5B;AACF;AACF;AACF;;AACD,WAAO+C,SAAS,CAACC,SAAjB;AACD;;AACD,SAAOT,gBAAgB,CAACC,SAAD,CAAvB;AACD;;AAED,OAAO,SAASgB,eAAT,CACLC,aADK,EAELrB,GAFK,EAGLsB,OAHK,EAILC,kBAJK,EAKLC,YALK,EAMLC,kCANK,EAOO;AACZ,SAAOnF,eAAe,CACpB+E,aADoB,EAEpBrB,GAFoB,EAGpBsB,OAHoB,EAIpBC,kBAJoB,EAKpBC,YALoB,EAMpBC,kCANoB,CAAtB;AAQD;AAED,OAAO,SAASC,eAAT,CACLC,OADK,EAELC,SAFK,EAGL/B,eAHK,EAILgC,QAJK,EAKC;AACN,MAAIlC,OAAJ,EAAa;AACXnD,IAAAA,cAAc,CAACoF,SAAD,EAAYD,OAAZ,CAAd;AACD;;AACD,QAAMlE,OAAO,GAAGmE,SAAS,CAACnE,OAA1B;AACA,QAAMqE,SAAS,GAAGrF,gBAAgB,EAAlC;AACA,QAAMsF,IAAI,GAAGrF,iBAAiB,CAACe,OAAD,CAA9B;;AAEA,MAAI3B,wBAAJ,EAA8B;AAC5B6C,IAAAA,mBAAmB,CAACoD,IAAD,CAAnB;AACD;;AAED,QAAMC,OAAO,GAAGpC,oBAAoB,CAACC,eAAD,CAApC;;AACA,MAAI+B,SAAS,CAACI,OAAV,KAAsB,IAA1B,EAAgC;AAC9BJ,IAAAA,SAAS,CAACI,OAAV,GAAoBA,OAApB;AACD,GAFD,MAEO;AACLJ,IAAAA,SAAS,CAACK,cAAV,GAA2BD,OAA3B;AACD;;AAED,MAAIrC,OAAJ,EAAa;AACX,QACEnC,4BAA4B,IAC5BE,wBAAwB,KAAK,IAD7B,IAEA,CAAC+B,yBAHH,EAIE;AACAA,MAAAA,yBAAyB,GAAG,IAA5B;AACAyB,MAAAA,OAAO,CAACC,KAAR,CACE,kEACE,kEADF,GAEE,iEAFF,GAGE,gCAJJ,EAKEvF,yBAAyB,CAAC8B,wBAAD,CAAzB,IAAuD,SALzD;AAOD;AACF;;AAED,QAAMwE,MAAM,GAAG9E,YAAY,CAAC0E,SAAD,EAAYC,IAAZ,CAA3B,CApCM,CAqCN;AACA;;AACAG,EAAAA,MAAM,CAACC,OAAP,GAAiB;AAACR,IAAAA;AAAD,GAAjB;AAEAE,EAAAA,QAAQ,GAAGA,QAAQ,KAAKxB,SAAb,GAAyB,IAAzB,GAAgCwB,QAA3C;;AACA,MAAIA,QAAQ,KAAK,IAAjB,EAAuB;AACrB,QAAIlC,OAAJ,EAAa;AACX,UAAI,OAAOkC,QAAP,KAAoB,UAAxB,EAAoC;AAClCX,QAAAA,OAAO,CAACC,KAAR,CACE,yEACE,iCAFJ,EAGEU,QAHF;AAKD;AACF;;AACDK,IAAAA,MAAM,CAACL,QAAP,GAAkBA,QAAlB;AACD;;AAEDxE,EAAAA,aAAa,CAACI,OAAD,EAAUyE,MAAV,EAAkBH,IAAlB,CAAb;AACA,QAAMK,IAAI,GAAGzF,qBAAqB,CAACc,OAAD,EAAUsE,IAAV,EAAgBD,SAAhB,CAAlC;;AACA,MAAIM,IAAI,KAAK,IAAb,EAAmB;AACjB9E,IAAAA,mBAAmB,CAAC8E,IAAD,EAAO3E,OAAP,EAAgBsE,IAAhB,CAAnB;AACD;;AAED,SAAOA,IAAP;AACD;AAED,SACElF,cADF,EAEEI,eAFF,EAGEC,eAHF,EAIEF,eAJF,EAKEF,SALF,EAMEC,kBANF,EAOEI,mBAPF;AAUA,OAAO,SAASkF,qBAAT,CACLT,SADK,EAE8C;AACnD,QAAMU,cAAc,GAAGV,SAAS,CAACnE,OAAjC;;AACA,MAAI,CAAC6E,cAAc,CAACC,KAApB,EAA2B;AACzB,WAAO,IAAP;AACD;;AACD,UAAQD,cAAc,CAACC,KAAf,CAAqBvC,GAA7B;AACE,SAAKxE,aAAL;AACE,aAAOQ,iBAAiB,CAACsG,cAAc,CAACC,KAAf,CAAqB3B,SAAtB,CAAxB;;AACF;AACE,aAAO0B,cAAc,CAACC,KAAf,CAAqB3B,SAA5B;AAJJ;AAMD;AAED,OAAO,SAAS4B,2BAAT,CAAqC1C,KAArC,EAAyD;AAC9D,UAAQA,KAAK,CAACE,GAAd;AACE,SAAKtE,QAAL;AACE,YAAM0G,IAAe,GAAGtC,KAAK,CAACc,SAA9B;;AACA,UAAIwB,IAAI,CAACK,YAAT,EAAuB;AACrB;AACA,cAAMC,KAAK,GAAGvE,8BAA8B,CAACiE,IAAD,CAA5C;AACAxF,QAAAA,SAAS,CAACwF,IAAD,EAAOM,KAAP,CAAT;AACD;;AACD;;AACF,SAAK/G,iBAAL;AACE,YAAMmG,SAAS,GAAGrF,gBAAgB,EAAlC;AACAK,MAAAA,SAAS,CAAC,MAAMH,qBAAqB,CAACmD,KAAD,EAAQ9B,QAAR,EAAkB8D,SAAlB,CAA5B,CAAT,CAFF,CAGE;AACA;AACA;;AACA,YAAMa,SAAS,GAAG3E,QAAlB;AACA4E,MAAAA,0BAA0B,CAAC9C,KAAD,EAAQ6C,SAAR,CAA1B;AACA;AAjBJ;AAmBD;;AAED,SAASE,iBAAT,CAA2B/C,KAA3B,EAAyC6C,SAAzC,EAA0D;AACxD,QAAMG,aAAmC,GAAGhD,KAAK,CAACiD,aAAlD;;AACA,MAAID,aAAa,KAAK,IAAlB,IAA0BA,aAAa,CAACE,UAAd,KAA6B,IAA3D,EAAiE;AAC/DF,IAAAA,aAAa,CAACH,SAAd,GAA0BvE,kBAAkB,CAC1C0E,aAAa,CAACH,SAD4B,EAE1CA,SAF0C,CAA5C;AAID;AACF,C,CAED;;;AACA,SAASC,0BAAT,CAAoC9C,KAApC,EAAkD6C,SAAlD,EAAmE;AACjEE,EAAAA,iBAAiB,CAAC/C,KAAD,EAAQ6C,SAAR,CAAjB;AACA,QAAMM,SAAS,GAAGnD,KAAK,CAACmD,SAAxB;;AACA,MAAIA,SAAJ,EAAe;AACbJ,IAAAA,iBAAiB,CAACI,SAAD,EAAYN,SAAZ,CAAjB;AACD;AACF;;AAED,OAAO,SAASO,wBAAT,CAAkCpD,KAAlC,EAAsD;AAC3D,MAAIA,KAAK,CAACE,GAAN,KAAcrE,iBAAlB,EAAqC;AACnC;AACA;AACA;AACA;AACA;AACD;;AACD,QAAMmG,SAAS,GAAGrF,gBAAgB,EAAlC;AACA,QAAMsF,IAAI,GAAG/D,QAAb;AACArB,EAAAA,qBAAqB,CAACmD,KAAD,EAAQiC,IAAR,EAAcD,SAAd,CAArB;AACAc,EAAAA,0BAA0B,CAAC9C,KAAD,EAAQiC,IAAR,CAA1B;AACD;AAED,OAAO,SAASoB,0BAAT,CAAoCrD,KAApC,EAAwD;AAC7D,MAAIA,KAAK,CAACE,GAAN,KAAcrE,iBAAlB,EAAqC;AACnC;AACA;AACA;AACA;AACA;AACD;;AACD,QAAMmG,SAAS,GAAGrF,gBAAgB,EAAlC;AACA,QAAMsF,IAAI,GAAG9D,sBAAb;AACAtB,EAAAA,qBAAqB,CAACmD,KAAD,EAAQiC,IAAR,EAAcD,SAAd,CAArB;AACAc,EAAAA,0BAA0B,CAAC9C,KAAD,EAAQiC,IAAR,CAA1B;AACD;AAED,OAAO,SAASqB,iCAAT,CAA2CtD,KAA3C,EAA+D;AACpE,MAAIA,KAAK,CAACE,GAAN,KAAcrE,iBAAlB,EAAqC;AACnC;AACA;AACA;AACD;;AACD,QAAMmG,SAAS,GAAGrF,gBAAgB,EAAlC;AACA,QAAMsF,IAAI,GAAGrF,iBAAiB,CAACoD,KAAD,CAA9B;AACAnD,EAAAA,qBAAqB,CAACmD,KAAD,EAAQiC,IAAR,EAAcD,SAAd,CAArB;AACAc,EAAAA,0BAA0B,CAAC9C,KAAD,EAAQiC,IAAR,CAA1B;AACD;AAED,SAAQ1D,wBAAR,EAAkCC,eAAlC;AAEA,SAAQ6B,gBAAR;AAEA,SAAQU,2BAAR;AAEA,OAAO,SAASwC,6BAAT,CACLvD,KADK,EAEkB;AACvB,QAAMa,SAAS,GAAGtF,iCAAiC,CAACyE,KAAD,CAAnD;;AACA,MAAIa,SAAS,KAAK,IAAlB,EAAwB;AACtB,WAAO,IAAP;AACD;;AACD,SAAOA,SAAS,CAACC,SAAjB;AACD;;AAED,IAAI0C,eAAe,GAAGxD,KAAK,IAAI,IAA/B;;AAEA,OAAO,SAASyD,WAAT,CAAqBzD,KAArB,EAA6C;AAClD,SAAOwD,eAAe,CAACxD,KAAD,CAAtB;AACD;;AAED,IAAI0D,iBAAiB,GAAG1D,KAAK,IAAI,KAAjC;;AAEA,OAAO,SAAS2D,aAAT,CAAuB3D,KAAvB,EAA8C;AACnD,SAAO0D,iBAAiB,CAAC1D,KAAD,CAAxB;AACD;AAED,IAAI4D,iBAAiB,GAAG,IAAxB;AACA,IAAIC,2BAA2B,GAAG,IAAlC;AACA,IAAIC,2BAA2B,GAAG,IAAlC;AACA,IAAIC,aAAa,GAAG,IAApB;AACA,IAAIC,uBAAuB,GAAG,IAA9B;AACA,IAAIC,uBAAuB,GAAG,IAA9B;AACA,IAAIC,cAAc,GAAG,IAArB;AACA,IAAIC,eAAe,GAAG,IAAtB;AACA,IAAIC,kBAAkB,GAAG,IAAzB;;AAEA,IAAIvE,OAAJ,EAAa;AACX,QAAMwE,kBAAkB,GAAG,CACzBC,GADyB,EAEzBC,IAFyB,EAGzBC,KAHyB,KAItB;AACH,UAAMC,GAAG,GAAGF,IAAI,CAACC,KAAD,CAAhB;AACA,UAAME,OAAO,GAAG3I,OAAO,CAACuI,GAAD,CAAP,GAAeA,GAAG,CAACK,KAAJ,EAAf,GAA6B,EAAC,GAAGL;AAAJ,KAA7C;;AACA,QAAIE,KAAK,GAAG,CAAR,KAAcD,IAAI,CAACK,MAAvB,EAA+B;AAC7B,UAAI7I,OAAO,CAAC2I,OAAD,CAAX,EAAsB;AACpBA,QAAAA,OAAO,CAACG,MAAR,CAAiBJ,GAAjB,EAAqC,CAArC;AACD,OAFD,MAEO;AACL,eAAOC,OAAO,CAACD,GAAD,CAAd;AACD;;AACD,aAAOC,OAAP;AACD,KAVE,CAWH;;;AACAA,IAAAA,OAAO,CAACD,GAAD,CAAP,GAAeJ,kBAAkB,CAACC,GAAG,CAACG,GAAD,CAAJ,EAAWF,IAAX,EAAiBC,KAAK,GAAG,CAAzB,CAAjC;AACA,WAAOE,OAAP;AACD,GAlBD;;AAoBA,QAAMI,cAAc,GAAG,CACrBR,GADqB,EAErBC,IAFqB,KAGG;AACxB,WAAOF,kBAAkB,CAACC,GAAD,EAAMC,IAAN,EAAY,CAAZ,CAAzB;AACD,GALD;;AAOA,QAAMQ,kBAAkB,GAAG,CACzBT,GADyB,EAEzBU,OAFyB,EAGzBC,OAHyB,EAIzBT,KAJyB,KAKtB;AACH,UAAMU,MAAM,GAAGF,OAAO,CAACR,KAAD,CAAtB;AACA,UAAME,OAAO,GAAG3I,OAAO,CAACuI,GAAD,CAAP,GAAeA,GAAG,CAACK,KAAJ,EAAf,GAA6B,EAAC,GAAGL;AAAJ,KAA7C;;AACA,QAAIE,KAAK,GAAG,CAAR,KAAcQ,OAAO,CAACJ,MAA1B,EAAkC;AAChC,YAAMO,MAAM,GAAGF,OAAO,CAACT,KAAD,CAAtB,CADgC,CAEhC;;AACAE,MAAAA,OAAO,CAACS,MAAD,CAAP,GAAkBT,OAAO,CAACQ,MAAD,CAAzB;;AACA,UAAInJ,OAAO,CAAC2I,OAAD,CAAX,EAAsB;AACpBA,QAAAA,OAAO,CAACG,MAAR,CAAiBK,MAAjB,EAAwC,CAAxC;AACD,OAFD,MAEO;AACL,eAAOR,OAAO,CAACQ,MAAD,CAAd;AACD;AACF,KATD,MASO;AACL;AACAR,MAAAA,OAAO,CAACQ,MAAD,CAAP,GAAkBH,kBAAkB,EAClC;AACAT,MAAAA,GAAG,CAACY,MAAD,CAF+B,EAGlCF,OAHkC,EAIlCC,OAJkC,EAKlCT,KAAK,GAAG,CAL0B,CAApC;AAOD;;AACD,WAAOE,OAAP;AACD,GA5BD;;AA8BA,QAAMU,cAAc,GAAG,CACrBd,GADqB,EAErBU,OAFqB,EAGrBC,OAHqB,KAIG;AACxB,QAAID,OAAO,CAACJ,MAAR,KAAmBK,OAAO,CAACL,MAA/B,EAAuC;AACrCxD,MAAAA,OAAO,CAACiE,IAAR,CAAa,mDAAb;AACA;AACD,KAHD,MAGO;AACL,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,OAAO,CAACL,MAAR,GAAiB,CAArC,EAAwCU,CAAC,EAAzC,EAA6C;AAC3C,YAAIN,OAAO,CAACM,CAAD,CAAP,KAAeL,OAAO,CAACK,CAAD,CAA1B,EAA+B;AAC7BlE,UAAAA,OAAO,CAACiE,IAAR,CACE,0EADF;AAGA;AACD;AACF;AACF;;AACD,WAAON,kBAAkB,CAACT,GAAD,EAAMU,OAAN,EAAeC,OAAf,EAAwB,CAAxB,CAAzB;AACD,GAnBD;;AAqBA,QAAMM,eAAe,GAAG,CACtBjB,GADsB,EAEtBC,IAFsB,EAGtBC,KAHsB,EAItBgB,KAJsB,KAKnB;AACH,QAAIhB,KAAK,IAAID,IAAI,CAACK,MAAlB,EAA0B;AACxB,aAAOY,KAAP;AACD;;AACD,UAAMf,GAAG,GAAGF,IAAI,CAACC,KAAD,CAAhB;AACA,UAAME,OAAO,GAAG3I,OAAO,CAACuI,GAAD,CAAP,GAAeA,GAAG,CAACK,KAAJ,EAAf,GAA6B,EAAC,GAAGL;AAAJ,KAA7C,CALG,CAMH;;AACAI,IAAAA,OAAO,CAACD,GAAD,CAAP,GAAec,eAAe,CAACjB,GAAG,CAACG,GAAD,CAAJ,EAAWF,IAAX,EAAiBC,KAAK,GAAG,CAAzB,EAA4BgB,KAA5B,CAA9B;AACA,WAAOd,OAAP;AACD,GAdD;;AAgBA,QAAMe,WAAW,GAAG,CAClBnB,GADkB,EAElBC,IAFkB,EAGlBiB,KAHkB,KAIM;AACxB,WAAOD,eAAe,CAACjB,GAAD,EAAMC,IAAN,EAAY,CAAZ,EAAeiB,KAAf,CAAtB;AACD,GAND;;AAQA,QAAME,QAAQ,GAAG,CAAC1F,KAAD,EAAe2F,EAAf,KAA8B;AAC7C;AACA;AACA,QAAIC,WAAW,GAAG5F,KAAK,CAACiD,aAAxB;;AACA,WAAO2C,WAAW,KAAK,IAAhB,IAAwBD,EAAE,GAAG,CAApC,EAAuC;AACrCC,MAAAA,WAAW,GAAGA,WAAW,CAACC,IAA1B;AACAF,MAAAA,EAAE;AACH;;AACD,WAAOC,WAAP;AACD,GATD,CAvGW,CAkHX;;;AACAhC,EAAAA,iBAAiB,GAAG,CAClB5D,KADkB,EAElB2F,EAFkB,EAGlBpB,IAHkB,EAIlBiB,KAJkB,KAKf;AACH,UAAMM,IAAI,GAAGJ,QAAQ,CAAC1F,KAAD,EAAQ2F,EAAR,CAArB;;AACA,QAAIG,IAAI,KAAK,IAAb,EAAmB;AACjB,YAAMC,QAAQ,GAAGN,WAAW,CAACK,IAAI,CAAC7C,aAAN,EAAqBsB,IAArB,EAA2BiB,KAA3B,CAA5B;AACAM,MAAAA,IAAI,CAAC7C,aAAL,GAAqB8C,QAArB;AACAD,MAAAA,IAAI,CAACE,SAAL,GAAiBD,QAAjB,CAHiB,CAKjB;AACA;AACA;AACA;AACA;;AACA/F,MAAAA,KAAK,CAACiG,aAAN,GAAsB,EAAC,GAAGjG,KAAK,CAACiG;AAAV,OAAtB;AAEApJ,MAAAA,qBAAqB,CAACmD,KAAD,EAAQ9B,QAAR,EAAkBE,WAAlB,CAArB;AACD;AACF,GArBD;;AAsBAyF,EAAAA,2BAA2B,GAAG,CAC5B7D,KAD4B,EAE5B2F,EAF4B,EAG5BpB,IAH4B,KAIzB;AACH,UAAMuB,IAAI,GAAGJ,QAAQ,CAAC1F,KAAD,EAAQ2F,EAAR,CAArB;;AACA,QAAIG,IAAI,KAAK,IAAb,EAAmB;AACjB,YAAMC,QAAQ,GAAGjB,cAAc,CAACgB,IAAI,CAAC7C,aAAN,EAAqBsB,IAArB,CAA/B;AACAuB,MAAAA,IAAI,CAAC7C,aAAL,GAAqB8C,QAArB;AACAD,MAAAA,IAAI,CAACE,SAAL,GAAiBD,QAAjB,CAHiB,CAKjB;AACA;AACA;AACA;AACA;;AACA/F,MAAAA,KAAK,CAACiG,aAAN,GAAsB,EAAC,GAAGjG,KAAK,CAACiG;AAAV,OAAtB;AAEApJ,MAAAA,qBAAqB,CAACmD,KAAD,EAAQ9B,QAAR,EAAkBE,WAAlB,CAArB;AACD;AACF,GApBD;;AAqBA0F,EAAAA,2BAA2B,GAAG,CAC5B9D,KAD4B,EAE5B2F,EAF4B,EAG5BX,OAH4B,EAI5BC,OAJ4B,KAKzB;AACH,UAAMa,IAAI,GAAGJ,QAAQ,CAAC1F,KAAD,EAAQ2F,EAAR,CAArB;;AACA,QAAIG,IAAI,KAAK,IAAb,EAAmB;AACjB,YAAMC,QAAQ,GAAGX,cAAc,CAACU,IAAI,CAAC7C,aAAN,EAAqB+B,OAArB,EAA8BC,OAA9B,CAA/B;AACAa,MAAAA,IAAI,CAAC7C,aAAL,GAAqB8C,QAArB;AACAD,MAAAA,IAAI,CAACE,SAAL,GAAiBD,QAAjB,CAHiB,CAKjB;AACA;AACA;AACA;AACA;;AACA/F,MAAAA,KAAK,CAACiG,aAAN,GAAsB,EAAC,GAAGjG,KAAK,CAACiG;AAAV,OAAtB;AAEApJ,MAAAA,qBAAqB,CAACmD,KAAD,EAAQ9B,QAAR,EAAkBE,WAAlB,CAArB;AACD;AACF,GArBD,CA9JW,CAqLX;;;AACA2F,EAAAA,aAAa,GAAG,CAAC/D,KAAD,EAAeuE,IAAf,EAA6CiB,KAA7C,KAA4D;AAC1ExF,IAAAA,KAAK,CAACkG,YAAN,GAAqBT,WAAW,CAACzF,KAAK,CAACiG,aAAP,EAAsB1B,IAAtB,EAA4BiB,KAA5B,CAAhC;;AACA,QAAIxF,KAAK,CAACmD,SAAV,EAAqB;AACnBnD,MAAAA,KAAK,CAACmD,SAAN,CAAgB+C,YAAhB,GAA+BlG,KAAK,CAACkG,YAArC;AACD;;AACDrJ,IAAAA,qBAAqB,CAACmD,KAAD,EAAQ9B,QAAR,EAAkBE,WAAlB,CAArB;AACD,GAND;;AAOA4F,EAAAA,uBAAuB,GAAG,CAAChE,KAAD,EAAeuE,IAAf,KAAgD;AACxEvE,IAAAA,KAAK,CAACkG,YAAN,GAAqBpB,cAAc,CAAC9E,KAAK,CAACiG,aAAP,EAAsB1B,IAAtB,CAAnC;;AACA,QAAIvE,KAAK,CAACmD,SAAV,EAAqB;AACnBnD,MAAAA,KAAK,CAACmD,SAAN,CAAgB+C,YAAhB,GAA+BlG,KAAK,CAACkG,YAArC;AACD;;AACDrJ,IAAAA,qBAAqB,CAACmD,KAAD,EAAQ9B,QAAR,EAAkBE,WAAlB,CAArB;AACD,GAND;;AAOA6F,EAAAA,uBAAuB,GAAG,CACxBjE,KADwB,EAExBgF,OAFwB,EAGxBC,OAHwB,KAIrB;AACHjF,IAAAA,KAAK,CAACkG,YAAN,GAAqBd,cAAc,CAACpF,KAAK,CAACiG,aAAP,EAAsBjB,OAAtB,EAA+BC,OAA/B,CAAnC;;AACA,QAAIjF,KAAK,CAACmD,SAAV,EAAqB;AACnBnD,MAAAA,KAAK,CAACmD,SAAN,CAAgB+C,YAAhB,GAA+BlG,KAAK,CAACkG,YAArC;AACD;;AACDrJ,IAAAA,qBAAqB,CAACmD,KAAD,EAAQ9B,QAAR,EAAkBE,WAAlB,CAArB;AACD,GAVD;;AAYA8F,EAAAA,cAAc,GAAIlE,KAAD,IAAkB;AACjCnD,IAAAA,qBAAqB,CAACmD,KAAD,EAAQ9B,QAAR,EAAkBE,WAAlB,CAArB;AACD,GAFD;;AAIA+F,EAAAA,eAAe,GAAIgC,kBAAD,IAA2C;AAC3D3C,IAAAA,eAAe,GAAG2C,kBAAlB;AACD,GAFD;;AAIA/B,EAAAA,kBAAkB,GAAIgC,oBAAD,IAA4C;AAC/D1C,IAAAA,iBAAiB,GAAG0C,oBAApB;AACD,GAFD;AAGD;;AAED,SAASC,uBAAT,CAAiCrG,KAAjC,EAA+E;AAC7E,QAAMa,SAAS,GAAGvF,oBAAoB,CAAC0E,KAAD,CAAtC;;AACA,MAAIa,SAAS,KAAK,IAAlB,EAAwB;AACtB,WAAO,IAAP;AACD;;AACD,SAAOA,SAAS,CAACC,SAAjB;AACD;;AAED,SAASwF,4BAAT,CACEC,QADF,EAEgB;AACd,SAAO,IAAP;AACD;;AAED,SAASC,0BAAT,GAAsC;AACpC,SAAO5I,wBAAP;AACD;;AAED,OAAO,SAAS6I,kBAAT,CAA4BC,cAA5B,EAAqE;AAC1E,QAAM;AAACC,IAAAA;AAAD,MAA4BD,cAAlC;AACA,QAAM;AAACE,IAAAA;AAAD,MAA2B3K,oBAAjC;AAEA,SAAOQ,eAAe,CAAC;AACrBoK,IAAAA,UAAU,EAAEH,cAAc,CAACG,UADN;AAErBC,IAAAA,OAAO,EAAEJ,cAAc,CAACI,OAFH;AAGrBC,IAAAA,mBAAmB,EAAEL,cAAc,CAACK,mBAHf;AAIrBC,IAAAA,cAAc,EAAEN,cAAc,CAACM,cAJV;AAKrBpD,IAAAA,iBALqB;AAMrBC,IAAAA,2BANqB;AAOrBC,IAAAA,2BAPqB;AAQrBC,IAAAA,aARqB;AASrBC,IAAAA,uBATqB;AAUrBC,IAAAA,uBAVqB;AAWrBE,IAAAA,eAXqB;AAYrBC,IAAAA,kBAZqB;AAarBF,IAAAA,cAbqB;AAcrB+C,IAAAA,oBAAoB,EAAEL,sBAdD;AAerBP,IAAAA,uBAfqB;AAgBrBM,IAAAA,uBAAuB,EACrBA,uBAAuB,IAAIL,4BAjBR;AAkBrB;AACA1H,IAAAA,2BAA2B,EAAEiB,OAAO,GAAGjB,2BAAH,GAAiC,IAnBhD;AAoBrBH,IAAAA,eAAe,EAAEoB,OAAO,GAAGpB,eAAH,GAAqB,IApBxB;AAqBrBC,IAAAA,YAAY,EAAEmB,OAAO,GAAGnB,YAAH,GAAkB,IArBlB;AAsBrBC,IAAAA,iBAAiB,EAAEkB,OAAO,GAAGlB,iBAAH,GAAuB,IAtB5B;AAuBrB;AACAuI,IAAAA,eAAe,EAAErH,OAAO,GAAG2G,0BAAH,GAAgC,IAxBnC;AAyBrB;AACA;AACAW,IAAAA,iBAAiB,EAAErI;AA3BE,GAAD,CAAtB;AA6BD","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Fiber, SuspenseHydrationCallbacks} from './ReactInternalTypes';\nimport type {FiberRoot} from './ReactInternalTypes';\nimport type {RootTag} from './ReactRootTags';\nimport type {\n  Instance,\n  TextInstance,\n  Container,\n  PublicInstance,\n} from './ReactFiberHostConfig';\nimport type {RendererInspectionConfig} from './ReactFiberHostConfig';\nimport type {ReactNodeList} from 'shared/ReactTypes';\nimport type {Lane} from './ReactFiberLane.new';\nimport type {SuspenseState} from './ReactFiberSuspenseComponent.new';\n\nimport {\n  findCurrentHostFiber,\n  findCurrentHostFiberWithNoPortals,\n} from './ReactFiberTreeReflection';\nimport {get as getInstance} from 'shared/ReactInstanceMap';\nimport {\n  HostComponent,\n  ClassComponent,\n  HostRoot,\n  SuspenseComponent,\n} from './ReactWorkTags';\nimport getComponentNameFromFiber from 'react-reconciler/src/getComponentNameFromFiber';\nimport isArray from 'shared/isArray';\nimport {enableSchedulingProfiler} from 'shared/ReactFeatureFlags';\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nimport {getPublicInstance} from './ReactFiberHostConfig';\nimport {\n  findCurrentUnmaskedContext,\n  processChildContext,\n  emptyContextObject,\n  isContextProvider as isLegacyContextProvider,\n} from './ReactFiberContext.new';\nimport {createFiberRoot} from './ReactFiberRoot.new';\nimport {injectInternals, onScheduleRoot} from './ReactFiberDevToolsHook.new';\nimport {\n  requestEventTime,\n  requestUpdateLane,\n  scheduleUpdateOnFiber,\n  flushRoot,\n  batchedUpdates,\n  flushSync,\n  isAlreadyRendering,\n  flushControlled,\n  deferredUpdates,\n  discreteUpdates,\n  flushPassiveEffects,\n} from './ReactFiberWorkLoop.new';\nimport {\n  createUpdate,\n  enqueueUpdate,\n  entangleTransitions,\n} from './ReactUpdateQueue.new';\nimport {\n  isRendering as ReactCurrentFiberIsRendering,\n  current as ReactCurrentFiberCurrent,\n  resetCurrentFiber as resetCurrentDebugFiberInDEV,\n  setCurrentFiber as setCurrentDebugFiberInDEV,\n} from './ReactCurrentFiber';\nimport {StrictLegacyMode} from './ReactTypeOfMode';\nimport {\n  SyncLane,\n  SelectiveHydrationLane,\n  NoTimestamp,\n  getHighestPriorityPendingLanes,\n  higherPriorityLane,\n} from './ReactFiberLane.new';\nimport {\n  getCurrentUpdatePriority,\n  runWithPriority,\n} from './ReactEventPriorities.new';\nimport {\n  scheduleRefresh,\n  scheduleRoot,\n  setRefreshHandler,\n  findHostInstancesForRefresh,\n} from './ReactFiberHotReloading.new';\nimport {markRenderScheduled} from './SchedulingProfiler';\nimport ReactVersion from 'shared/ReactVersion';\nexport {registerMutableSourceForHydration} from './ReactMutableSource.new';\nexport {createPortal} from './ReactPortal';\nexport {\n  createComponentSelector,\n  createHasPseudoClassSelector,\n  createRoleSelector,\n  createTestNameSelector,\n  createTextSelector,\n  getFindAllNodesFailureDescription,\n  findAllNodes,\n  findBoundingRects,\n  focusWithin,\n  observeVisibleRects,\n} from './ReactTestSelectors';\n\ntype OpaqueRoot = FiberRoot;\n\n// 0 is PROD, 1 is DEV.\n// Might add PROFILE later.\ntype BundleType = 0 | 1;\n\ntype DevToolsConfig = {|\n  bundleType: BundleType,\n  version: string,\n  rendererPackageName: string,\n  // Note: this actually *does* depend on Fiber internal fields.\n  // Used by \"inspect clicked DOM element\" in React DevTools.\n  findFiberByHostInstance?: (instance: Instance | TextInstance) => Fiber | null,\n  rendererConfig?: RendererInspectionConfig,\n|};\n\nlet didWarnAboutNestedUpdates;\nlet didWarnAboutFindNodeInStrictMode;\n\nif (__DEV__) {\n  didWarnAboutNestedUpdates = false;\n  didWarnAboutFindNodeInStrictMode = {};\n}\n\nfunction getContextForSubtree(\n  parentComponent: ?React$Component<any, any>,\n): Object {\n  if (!parentComponent) {\n    return emptyContextObject;\n  }\n\n  const fiber = getInstance(parentComponent);\n  const parentContext = findCurrentUnmaskedContext(fiber);\n\n  if (fiber.tag === ClassComponent) {\n    const Component = fiber.type;\n    if (isLegacyContextProvider(Component)) {\n      return processChildContext(fiber, Component, parentContext);\n    }\n  }\n\n  return parentContext;\n}\n\nfunction findHostInstance(component: Object): PublicInstance | null {\n  const fiber = getInstance(component);\n  if (fiber === undefined) {\n    if (typeof component.render === 'function') {\n      throw new Error('Unable to find node on an unmounted component.');\n    } else {\n      const keys = Object.keys(component).join(',');\n      throw new Error(\n        `Argument appears to not be a ReactComponent. Keys: ${keys}`,\n      );\n    }\n  }\n  const hostFiber = findCurrentHostFiber(fiber);\n  if (hostFiber === null) {\n    return null;\n  }\n  return hostFiber.stateNode;\n}\n\nfunction findHostInstanceWithWarning(\n  component: Object,\n  methodName: string,\n): PublicInstance | null {\n  if (__DEV__) {\n    const fiber = getInstance(component);\n    if (fiber === undefined) {\n      if (typeof component.render === 'function') {\n        throw new Error('Unable to find node on an unmounted component.');\n      } else {\n        const keys = Object.keys(component).join(',');\n        throw new Error(\n          `Argument appears to not be a ReactComponent. Keys: ${keys}`,\n        );\n      }\n    }\n    const hostFiber = findCurrentHostFiber(fiber);\n    if (hostFiber === null) {\n      return null;\n    }\n    if (hostFiber.mode & StrictLegacyMode) {\n      const componentName = getComponentNameFromFiber(fiber) || 'Component';\n      if (!didWarnAboutFindNodeInStrictMode[componentName]) {\n        didWarnAboutFindNodeInStrictMode[componentName] = true;\n\n        const previousFiber = ReactCurrentFiberCurrent;\n        try {\n          setCurrentDebugFiberInDEV(hostFiber);\n          if (fiber.mode & StrictLegacyMode) {\n            console.error(\n              '%s is deprecated in StrictMode. ' +\n                '%s was passed an instance of %s which is inside StrictMode. ' +\n                'Instead, add a ref directly to the element you want to reference. ' +\n                'Learn more about using refs safely here: ' +\n                'https://reactjs.org/link/strict-mode-find-node',\n              methodName,\n              methodName,\n              componentName,\n            );\n          } else {\n            console.error(\n              '%s is deprecated in StrictMode. ' +\n                '%s was passed an instance of %s which renders StrictMode children. ' +\n                'Instead, add a ref directly to the element you want to reference. ' +\n                'Learn more about using refs safely here: ' +\n                'https://reactjs.org/link/strict-mode-find-node',\n              methodName,\n              methodName,\n              componentName,\n            );\n          }\n        } finally {\n          // Ideally this should reset to previous but this shouldn't be called in\n          // render and there's another warning for that anyway.\n          if (previousFiber) {\n            setCurrentDebugFiberInDEV(previousFiber);\n          } else {\n            resetCurrentDebugFiberInDEV();\n          }\n        }\n      }\n    }\n    return hostFiber.stateNode;\n  }\n  return findHostInstance(component);\n}\n\nexport function createContainer(\n  containerInfo: Container,\n  tag: RootTag,\n  hydrate: boolean,\n  hydrationCallbacks: null | SuspenseHydrationCallbacks,\n  isStrictMode: boolean,\n  concurrentUpdatesByDefaultOverride: null | boolean,\n): OpaqueRoot {\n  return createFiberRoot(\n    containerInfo,\n    tag,\n    hydrate,\n    hydrationCallbacks,\n    isStrictMode,\n    concurrentUpdatesByDefaultOverride,\n  );\n}\n\nexport function updateContainer(\n  element: ReactNodeList,\n  container: OpaqueRoot,\n  parentComponent: ?React$Component<any, any>,\n  callback: ?Function,\n): Lane {\n  if (__DEV__) {\n    onScheduleRoot(container, element);\n  }\n  const current = container.current;\n  const eventTime = requestEventTime();\n  const lane = requestUpdateLane(current);\n\n  if (enableSchedulingProfiler) {\n    markRenderScheduled(lane);\n  }\n\n  const context = getContextForSubtree(parentComponent);\n  if (container.context === null) {\n    container.context = context;\n  } else {\n    container.pendingContext = context;\n  }\n\n  if (__DEV__) {\n    if (\n      ReactCurrentFiberIsRendering &&\n      ReactCurrentFiberCurrent !== null &&\n      !didWarnAboutNestedUpdates\n    ) {\n      didWarnAboutNestedUpdates = true;\n      console.error(\n        'Render methods should be a pure function of props and state; ' +\n          'triggering nested component updates from render is not allowed. ' +\n          'If necessary, trigger nested updates in componentDidUpdate.\\n\\n' +\n          'Check the render method of %s.',\n        getComponentNameFromFiber(ReactCurrentFiberCurrent) || 'Unknown',\n      );\n    }\n  }\n\n  const update = createUpdate(eventTime, lane);\n  // Caution: React DevTools currently depends on this property\n  // being called \"element\".\n  update.payload = {element};\n\n  callback = callback === undefined ? null : callback;\n  if (callback !== null) {\n    if (__DEV__) {\n      if (typeof callback !== 'function') {\n        console.error(\n          'render(...): Expected the last optional `callback` argument to be a ' +\n            'function. Instead received: %s.',\n          callback,\n        );\n      }\n    }\n    update.callback = callback;\n  }\n\n  enqueueUpdate(current, update, lane);\n  const root = scheduleUpdateOnFiber(current, lane, eventTime);\n  if (root !== null) {\n    entangleTransitions(root, current, lane);\n  }\n\n  return lane;\n}\n\nexport {\n  batchedUpdates,\n  deferredUpdates,\n  discreteUpdates,\n  flushControlled,\n  flushSync,\n  isAlreadyRendering,\n  flushPassiveEffects,\n};\n\nexport function getPublicRootInstance(\n  container: OpaqueRoot,\n): React$Component<any, any> | PublicInstance | null {\n  const containerFiber = container.current;\n  if (!containerFiber.child) {\n    return null;\n  }\n  switch (containerFiber.child.tag) {\n    case HostComponent:\n      return getPublicInstance(containerFiber.child.stateNode);\n    default:\n      return containerFiber.child.stateNode;\n  }\n}\n\nexport function attemptSynchronousHydration(fiber: Fiber): void {\n  switch (fiber.tag) {\n    case HostRoot:\n      const root: FiberRoot = fiber.stateNode;\n      if (root.isDehydrated) {\n        // Flush the first scheduled \"update\".\n        const lanes = getHighestPriorityPendingLanes(root);\n        flushRoot(root, lanes);\n      }\n      break;\n    case SuspenseComponent:\n      const eventTime = requestEventTime();\n      flushSync(() => scheduleUpdateOnFiber(fiber, SyncLane, eventTime));\n      // If we're still blocked after this, we need to increase\n      // the priority of any promises resolving within this\n      // boundary so that they next attempt also has higher pri.\n      const retryLane = SyncLane;\n      markRetryLaneIfNotHydrated(fiber, retryLane);\n      break;\n  }\n}\n\nfunction markRetryLaneImpl(fiber: Fiber, retryLane: Lane) {\n  const suspenseState: null | SuspenseState = fiber.memoizedState;\n  if (suspenseState !== null && suspenseState.dehydrated !== null) {\n    suspenseState.retryLane = higherPriorityLane(\n      suspenseState.retryLane,\n      retryLane,\n    );\n  }\n}\n\n// Increases the priority of thenables when they resolve within this boundary.\nfunction markRetryLaneIfNotHydrated(fiber: Fiber, retryLane: Lane) {\n  markRetryLaneImpl(fiber, retryLane);\n  const alternate = fiber.alternate;\n  if (alternate) {\n    markRetryLaneImpl(alternate, retryLane);\n  }\n}\n\nexport function attemptDiscreteHydration(fiber: Fiber): void {\n  if (fiber.tag !== SuspenseComponent) {\n    // We ignore HostRoots here because we can't increase\n    // their priority and they should not suspend on I/O,\n    // since you have to wrap anything that might suspend in\n    // Suspense.\n    return;\n  }\n  const eventTime = requestEventTime();\n  const lane = SyncLane;\n  scheduleUpdateOnFiber(fiber, lane, eventTime);\n  markRetryLaneIfNotHydrated(fiber, lane);\n}\n\nexport function attemptContinuousHydration(fiber: Fiber): void {\n  if (fiber.tag !== SuspenseComponent) {\n    // We ignore HostRoots here because we can't increase\n    // their priority and they should not suspend on I/O,\n    // since you have to wrap anything that might suspend in\n    // Suspense.\n    return;\n  }\n  const eventTime = requestEventTime();\n  const lane = SelectiveHydrationLane;\n  scheduleUpdateOnFiber(fiber, lane, eventTime);\n  markRetryLaneIfNotHydrated(fiber, lane);\n}\n\nexport function attemptHydrationAtCurrentPriority(fiber: Fiber): void {\n  if (fiber.tag !== SuspenseComponent) {\n    // We ignore HostRoots here because we can't increase\n    // their priority other than synchronously flush it.\n    return;\n  }\n  const eventTime = requestEventTime();\n  const lane = requestUpdateLane(fiber);\n  scheduleUpdateOnFiber(fiber, lane, eventTime);\n  markRetryLaneIfNotHydrated(fiber, lane);\n}\n\nexport {getCurrentUpdatePriority, runWithPriority};\n\nexport {findHostInstance};\n\nexport {findHostInstanceWithWarning};\n\nexport function findHostInstanceWithNoPortals(\n  fiber: Fiber,\n): PublicInstance | null {\n  const hostFiber = findCurrentHostFiberWithNoPortals(fiber);\n  if (hostFiber === null) {\n    return null;\n  }\n  return hostFiber.stateNode;\n}\n\nlet shouldErrorImpl = fiber => null;\n\nexport function shouldError(fiber: Fiber): ?boolean {\n  return shouldErrorImpl(fiber);\n}\n\nlet shouldSuspendImpl = fiber => false;\n\nexport function shouldSuspend(fiber: Fiber): boolean {\n  return shouldSuspendImpl(fiber);\n}\n\nlet overrideHookState = null;\nlet overrideHookStateDeletePath = null;\nlet overrideHookStateRenamePath = null;\nlet overrideProps = null;\nlet overridePropsDeletePath = null;\nlet overridePropsRenamePath = null;\nlet scheduleUpdate = null;\nlet setErrorHandler = null;\nlet setSuspenseHandler = null;\n\nif (__DEV__) {\n  const copyWithDeleteImpl = (\n    obj: Object | Array<any>,\n    path: Array<string | number>,\n    index: number,\n  ) => {\n    const key = path[index];\n    const updated = isArray(obj) ? obj.slice() : {...obj};\n    if (index + 1 === path.length) {\n      if (isArray(updated)) {\n        updated.splice(((key: any): number), 1);\n      } else {\n        delete updated[key];\n      }\n      return updated;\n    }\n    // $FlowFixMe number or string is fine here\n    updated[key] = copyWithDeleteImpl(obj[key], path, index + 1);\n    return updated;\n  };\n\n  const copyWithDelete = (\n    obj: Object | Array<any>,\n    path: Array<string | number>,\n  ): Object | Array<any> => {\n    return copyWithDeleteImpl(obj, path, 0);\n  };\n\n  const copyWithRenameImpl = (\n    obj: Object | Array<any>,\n    oldPath: Array<string | number>,\n    newPath: Array<string | number>,\n    index: number,\n  ) => {\n    const oldKey = oldPath[index];\n    const updated = isArray(obj) ? obj.slice() : {...obj};\n    if (index + 1 === oldPath.length) {\n      const newKey = newPath[index];\n      // $FlowFixMe number or string is fine here\n      updated[newKey] = updated[oldKey];\n      if (isArray(updated)) {\n        updated.splice(((oldKey: any): number), 1);\n      } else {\n        delete updated[oldKey];\n      }\n    } else {\n      // $FlowFixMe number or string is fine here\n      updated[oldKey] = copyWithRenameImpl(\n        // $FlowFixMe number or string is fine here\n        obj[oldKey],\n        oldPath,\n        newPath,\n        index + 1,\n      );\n    }\n    return updated;\n  };\n\n  const copyWithRename = (\n    obj: Object | Array<any>,\n    oldPath: Array<string | number>,\n    newPath: Array<string | number>,\n  ): Object | Array<any> => {\n    if (oldPath.length !== newPath.length) {\n      console.warn('copyWithRename() expects paths of the same length');\n      return;\n    } else {\n      for (let i = 0; i < newPath.length - 1; i++) {\n        if (oldPath[i] !== newPath[i]) {\n          console.warn(\n            'copyWithRename() expects paths to be the same except for the deepest key',\n          );\n          return;\n        }\n      }\n    }\n    return copyWithRenameImpl(obj, oldPath, newPath, 0);\n  };\n\n  const copyWithSetImpl = (\n    obj: Object | Array<any>,\n    path: Array<string | number>,\n    index: number,\n    value: any,\n  ) => {\n    if (index >= path.length) {\n      return value;\n    }\n    const key = path[index];\n    const updated = isArray(obj) ? obj.slice() : {...obj};\n    // $FlowFixMe number or string is fine here\n    updated[key] = copyWithSetImpl(obj[key], path, index + 1, value);\n    return updated;\n  };\n\n  const copyWithSet = (\n    obj: Object | Array<any>,\n    path: Array<string | number>,\n    value: any,\n  ): Object | Array<any> => {\n    return copyWithSetImpl(obj, path, 0, value);\n  };\n\n  const findHook = (fiber: Fiber, id: number) => {\n    // For now, the \"id\" of stateful hooks is just the stateful hook index.\n    // This may change in the future with e.g. nested hooks.\n    let currentHook = fiber.memoizedState;\n    while (currentHook !== null && id > 0) {\n      currentHook = currentHook.next;\n      id--;\n    }\n    return currentHook;\n  };\n\n  // Support DevTools editable values for useState and useReducer.\n  overrideHookState = (\n    fiber: Fiber,\n    id: number,\n    path: Array<string | number>,\n    value: any,\n  ) => {\n    const hook = findHook(fiber, id);\n    if (hook !== null) {\n      const newState = copyWithSet(hook.memoizedState, path, value);\n      hook.memoizedState = newState;\n      hook.baseState = newState;\n\n      // We aren't actually adding an update to the queue,\n      // because there is no update we can add for useReducer hooks that won't trigger an error.\n      // (There's no appropriate action type for DevTools overrides.)\n      // As a result though, React will see the scheduled update as a noop and bailout.\n      // Shallow cloning props works as a workaround for now to bypass the bailout check.\n      fiber.memoizedProps = {...fiber.memoizedProps};\n\n      scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\n    }\n  };\n  overrideHookStateDeletePath = (\n    fiber: Fiber,\n    id: number,\n    path: Array<string | number>,\n  ) => {\n    const hook = findHook(fiber, id);\n    if (hook !== null) {\n      const newState = copyWithDelete(hook.memoizedState, path);\n      hook.memoizedState = newState;\n      hook.baseState = newState;\n\n      // We aren't actually adding an update to the queue,\n      // because there is no update we can add for useReducer hooks that won't trigger an error.\n      // (There's no appropriate action type for DevTools overrides.)\n      // As a result though, React will see the scheduled update as a noop and bailout.\n      // Shallow cloning props works as a workaround for now to bypass the bailout check.\n      fiber.memoizedProps = {...fiber.memoizedProps};\n\n      scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\n    }\n  };\n  overrideHookStateRenamePath = (\n    fiber: Fiber,\n    id: number,\n    oldPath: Array<string | number>,\n    newPath: Array<string | number>,\n  ) => {\n    const hook = findHook(fiber, id);\n    if (hook !== null) {\n      const newState = copyWithRename(hook.memoizedState, oldPath, newPath);\n      hook.memoizedState = newState;\n      hook.baseState = newState;\n\n      // We aren't actually adding an update to the queue,\n      // because there is no update we can add for useReducer hooks that won't trigger an error.\n      // (There's no appropriate action type for DevTools overrides.)\n      // As a result though, React will see the scheduled update as a noop and bailout.\n      // Shallow cloning props works as a workaround for now to bypass the bailout check.\n      fiber.memoizedProps = {...fiber.memoizedProps};\n\n      scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\n    }\n  };\n\n  // Support DevTools props for function components, forwardRef, memo, host components, etc.\n  overrideProps = (fiber: Fiber, path: Array<string | number>, value: any) => {\n    fiber.pendingProps = copyWithSet(fiber.memoizedProps, path, value);\n    if (fiber.alternate) {\n      fiber.alternate.pendingProps = fiber.pendingProps;\n    }\n    scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\n  };\n  overridePropsDeletePath = (fiber: Fiber, path: Array<string | number>) => {\n    fiber.pendingProps = copyWithDelete(fiber.memoizedProps, path);\n    if (fiber.alternate) {\n      fiber.alternate.pendingProps = fiber.pendingProps;\n    }\n    scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\n  };\n  overridePropsRenamePath = (\n    fiber: Fiber,\n    oldPath: Array<string | number>,\n    newPath: Array<string | number>,\n  ) => {\n    fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);\n    if (fiber.alternate) {\n      fiber.alternate.pendingProps = fiber.pendingProps;\n    }\n    scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\n  };\n\n  scheduleUpdate = (fiber: Fiber) => {\n    scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\n  };\n\n  setErrorHandler = (newShouldErrorImpl: Fiber => ?boolean) => {\n    shouldErrorImpl = newShouldErrorImpl;\n  };\n\n  setSuspenseHandler = (newShouldSuspendImpl: Fiber => boolean) => {\n    shouldSuspendImpl = newShouldSuspendImpl;\n  };\n}\n\nfunction findHostInstanceByFiber(fiber: Fiber): Instance | TextInstance | null {\n  const hostFiber = findCurrentHostFiber(fiber);\n  if (hostFiber === null) {\n    return null;\n  }\n  return hostFiber.stateNode;\n}\n\nfunction emptyFindFiberByHostInstance(\n  instance: Instance | TextInstance,\n): Fiber | null {\n  return null;\n}\n\nfunction getCurrentFiberForDevTools() {\n  return ReactCurrentFiberCurrent;\n}\n\nexport function injectIntoDevTools(devToolsConfig: DevToolsConfig): boolean {\n  const {findFiberByHostInstance} = devToolsConfig;\n  const {ReactCurrentDispatcher} = ReactSharedInternals;\n\n  return injectInternals({\n    bundleType: devToolsConfig.bundleType,\n    version: devToolsConfig.version,\n    rendererPackageName: devToolsConfig.rendererPackageName,\n    rendererConfig: devToolsConfig.rendererConfig,\n    overrideHookState,\n    overrideHookStateDeletePath,\n    overrideHookStateRenamePath,\n    overrideProps,\n    overridePropsDeletePath,\n    overridePropsRenamePath,\n    setErrorHandler,\n    setSuspenseHandler,\n    scheduleUpdate,\n    currentDispatcherRef: ReactCurrentDispatcher,\n    findHostInstanceByFiber,\n    findFiberByHostInstance:\n      findFiberByHostInstance || emptyFindFiberByHostInstance,\n    // React Refresh\n    findHostInstancesForRefresh: __DEV__ ? findHostInstancesForRefresh : null,\n    scheduleRefresh: __DEV__ ? scheduleRefresh : null,\n    scheduleRoot: __DEV__ ? scheduleRoot : null,\n    setRefreshHandler: __DEV__ ? setRefreshHandler : null,\n    // Enables DevTools to append owner stacks to error messages in DEV mode.\n    getCurrentFiber: __DEV__ ? getCurrentFiberForDevTools : null,\n    // Enables DevTools to detect reconciler version rather than renderer version\n    // which may not match for third party renderers.\n    reconcilerVersion: ReactVersion,\n  });\n}\n"]},"metadata":{},"sourceType":"module"}