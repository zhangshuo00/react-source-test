{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n// TODO: Ideally these types would be opaque but that doesn't work well with\n// our reconciler fork infra, since these leak into non-reconciler packages.\nimport { enableSchedulingProfiler, enableUpdaterTracking, allowConcurrentByDefault } from 'shared/ReactFeatureFlags';\nimport { isDevToolsPresent } from './ReactFiberDevToolsHook.old';\nimport { ConcurrentUpdatesByDefaultMode, NoMode } from './ReactTypeOfMode';\nimport { clz32 } from './clz32'; // Lane values below should be kept in sync with getLabelForLane(), used by react-devtools-timeline.\n// If those values are changed that package should be rebuilt and redeployed.\n\nexport const TotalLanes = 31;\nexport const NoLanes =\n/*                        */\n0b0000000000000000000000000000000;\nexport const NoLane =\n/*                          */\n0b0000000000000000000000000000000;\nexport const SyncLane =\n/*                        */\n0b0000000000000000000000000000001;\nexport const InputContinuousHydrationLane =\n/*    */\n0b0000000000000000000000000000010;\nexport const InputContinuousLane =\n/*            */\n0b0000000000000000000000000000100;\nexport const DefaultHydrationLane =\n/*            */\n0b0000000000000000000000000001000;\nexport const DefaultLane =\n/*                    */\n0b0000000000000000000000000010000;\nconst TransitionHydrationLane =\n/*                */\n0b0000000000000000000000000100000;\nconst TransitionLanes =\n/*                       */\n0b0000000001111111111111111000000;\nconst TransitionLane1 =\n/*                        */\n0b0000000000000000000000001000000;\nconst TransitionLane2 =\n/*                        */\n0b0000000000000000000000010000000;\nconst TransitionLane3 =\n/*                        */\n0b0000000000000000000000100000000;\nconst TransitionLane4 =\n/*                        */\n0b0000000000000000000001000000000;\nconst TransitionLane5 =\n/*                        */\n0b0000000000000000000010000000000;\nconst TransitionLane6 =\n/*                        */\n0b0000000000000000000100000000000;\nconst TransitionLane7 =\n/*                        */\n0b0000000000000000001000000000000;\nconst TransitionLane8 =\n/*                        */\n0b0000000000000000010000000000000;\nconst TransitionLane9 =\n/*                        */\n0b0000000000000000100000000000000;\nconst TransitionLane10 =\n/*                       */\n0b0000000000000001000000000000000;\nconst TransitionLane11 =\n/*                       */\n0b0000000000000010000000000000000;\nconst TransitionLane12 =\n/*                       */\n0b0000000000000100000000000000000;\nconst TransitionLane13 =\n/*                       */\n0b0000000000001000000000000000000;\nconst TransitionLane14 =\n/*                       */\n0b0000000000010000000000000000000;\nconst TransitionLane15 =\n/*                       */\n0b0000000000100000000000000000000;\nconst TransitionLane16 =\n/*                       */\n0b0000000001000000000000000000000;\nconst RetryLanes =\n/*                            */\n0b0000111110000000000000000000000;\nconst RetryLane1 =\n/*                             */\n0b0000000010000000000000000000000;\nconst RetryLane2 =\n/*                             */\n0b0000000100000000000000000000000;\nconst RetryLane3 =\n/*                             */\n0b0000001000000000000000000000000;\nconst RetryLane4 =\n/*                             */\n0b0000010000000000000000000000000;\nconst RetryLane5 =\n/*                             */\n0b0000100000000000000000000000000;\nexport const SomeRetryLane = RetryLane1;\nexport const SelectiveHydrationLane =\n/*          */\n0b0001000000000000000000000000000;\nconst NonIdleLanes =\n/*                                 */\n0b0001111111111111111111111111111;\nexport const IdleHydrationLane =\n/*               */\n0b0010000000000000000000000000000;\nexport const IdleLane =\n/*                       */\n0b0100000000000000000000000000000;\nexport const OffscreenLane =\n/*                   */\n0b1000000000000000000000000000000; // This function is used for the experimental timeline (react-devtools-timeline)\n// It should be kept in sync with the Lanes values above.\n\nexport function getLabelForLane(lane) {\n  if (enableSchedulingProfiler) {\n    if (lane & SyncLane) {\n      return 'Sync';\n    }\n\n    if (lane & InputContinuousHydrationLane) {\n      return 'InputContinuousHydration';\n    }\n\n    if (lane & InputContinuousLane) {\n      return 'InputContinuous';\n    }\n\n    if (lane & DefaultHydrationLane) {\n      return 'DefaultHydration';\n    }\n\n    if (lane & DefaultLane) {\n      return 'Default';\n    }\n\n    if (lane & TransitionHydrationLane) {\n      return 'TransitionHydration';\n    }\n\n    if (lane & TransitionLanes) {\n      return 'Transition';\n    }\n\n    if (lane & RetryLanes) {\n      return 'Retry';\n    }\n\n    if (lane & SelectiveHydrationLane) {\n      return 'SelectiveHydration';\n    }\n\n    if (lane & IdleHydrationLane) {\n      return 'IdleHydration';\n    }\n\n    if (lane & IdleLane) {\n      return 'Idle';\n    }\n\n    if (lane & OffscreenLane) {\n      return 'Offscreen';\n    }\n  }\n}\nexport const NoTimestamp = -1;\nlet nextTransitionLane = TransitionLane1;\nlet nextRetryLane = RetryLane1;\n\nfunction getHighestPriorityLanes(lanes) {\n  switch (getHighestPriorityLane(lanes)) {\n    case SyncLane:\n      return SyncLane;\n\n    case InputContinuousHydrationLane:\n      return InputContinuousHydrationLane;\n\n    case InputContinuousLane:\n      return InputContinuousLane;\n\n    case DefaultHydrationLane:\n      return DefaultHydrationLane;\n\n    case DefaultLane:\n      return DefaultLane;\n\n    case TransitionHydrationLane:\n      return TransitionHydrationLane;\n\n    case TransitionLane1:\n    case TransitionLane2:\n    case TransitionLane3:\n    case TransitionLane4:\n    case TransitionLane5:\n    case TransitionLane6:\n    case TransitionLane7:\n    case TransitionLane8:\n    case TransitionLane9:\n    case TransitionLane10:\n    case TransitionLane11:\n    case TransitionLane12:\n    case TransitionLane13:\n    case TransitionLane14:\n    case TransitionLane15:\n    case TransitionLane16:\n      return lanes & TransitionLanes;\n\n    case RetryLane1:\n    case RetryLane2:\n    case RetryLane3:\n    case RetryLane4:\n    case RetryLane5:\n      return lanes & RetryLanes;\n\n    case SelectiveHydrationLane:\n      return SelectiveHydrationLane;\n\n    case IdleHydrationLane:\n      return IdleHydrationLane;\n\n    case IdleLane:\n      return IdleLane;\n\n    case OffscreenLane:\n      return OffscreenLane;\n\n    default:\n      if (__DEV__) {\n        console.error('Should have found matching lanes. This is a bug in React.');\n      } // This shouldn't be reachable, but as a fallback, return the entire bitmask.\n\n\n      return lanes;\n  }\n}\n\nexport function getNextLanes(root, wipLanes) {\n  // Early bailout if there's no pending work left.\n  const pendingLanes = root.pendingLanes;\n\n  if (pendingLanes === NoLanes) {\n    return NoLanes;\n  }\n\n  let nextLanes = NoLanes;\n  const suspendedLanes = root.suspendedLanes;\n  const pingedLanes = root.pingedLanes; // Do not work on any idle work until all the non-idle work has finished,\n  // even if the work is suspended.\n\n  const nonIdlePendingLanes = pendingLanes & NonIdleLanes;\n\n  if (nonIdlePendingLanes !== NoLanes) {\n    const nonIdleUnblockedLanes = nonIdlePendingLanes & ~suspendedLanes;\n\n    if (nonIdleUnblockedLanes !== NoLanes) {\n      nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);\n    } else {\n      const nonIdlePingedLanes = nonIdlePendingLanes & pingedLanes;\n\n      if (nonIdlePingedLanes !== NoLanes) {\n        nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);\n      }\n    }\n  } else {\n    // The only remaining work is Idle.\n    const unblockedLanes = pendingLanes & ~suspendedLanes;\n\n    if (unblockedLanes !== NoLanes) {\n      nextLanes = getHighestPriorityLanes(unblockedLanes);\n    } else {\n      if (pingedLanes !== NoLanes) {\n        nextLanes = getHighestPriorityLanes(pingedLanes);\n      }\n    }\n  }\n\n  if (nextLanes === NoLanes) {\n    // This should only be reachable if we're suspended\n    // TODO: Consider warning in this path if a fallback timer is not scheduled.\n    return NoLanes;\n  } // If we're already in the middle of a render, switching lanes will interrupt\n  // it and we'll lose our progress. We should only do this if the new lanes are\n  // higher priority.\n\n\n  if (wipLanes !== NoLanes && wipLanes !== nextLanes && // If we already suspended with a delay, then interrupting is fine. Don't\n  // bother waiting until the root is complete.\n  (wipLanes & suspendedLanes) === NoLanes) {\n    const nextLane = getHighestPriorityLane(nextLanes);\n    const wipLane = getHighestPriorityLane(wipLanes);\n\n    if ( // Tests whether the next lane is equal or lower priority than the wip\n    // one. This works because the bits decrease in priority as you go left.\n    nextLane >= wipLane || // Default priority updates should not interrupt transition updates. The\n    // only difference between default updates and transition updates is that\n    // default updates do not support refresh transitions.\n    nextLane === DefaultLane && (wipLane & TransitionLanes) !== NoLanes) {\n      // Keep working on the existing in-progress tree. Do not interrupt.\n      return wipLanes;\n    }\n  }\n\n  if (allowConcurrentByDefault && (root.current.mode & ConcurrentUpdatesByDefaultMode) !== NoMode) {// Do nothing, use the lanes as they were assigned.\n  } else if ((nextLanes & InputContinuousLane) !== NoLanes) {\n    // When updates are sync by default, we entangle continuous priority updates\n    // and default updates, so they render in the same batch. The only reason\n    // they use separate lanes is because continuous updates should interrupt\n    // transitions, but default updates should not.\n    nextLanes |= pendingLanes & DefaultLane;\n  } // Check for entangled lanes and add them to the batch.\n  //\n  // A lane is said to be entangled with another when it's not allowed to render\n  // in a batch that does not also include the other lane. Typically we do this\n  // when multiple updates have the same source, and we only want to respond to\n  // the most recent event from that source.\n  //\n  // Note that we apply entanglements *after* checking for partial work above.\n  // This means that if a lane is entangled during an interleaved event while\n  // it's already rendering, we won't interrupt it. This is intentional, since\n  // entanglement is usually \"best effort\": we'll try our best to render the\n  // lanes in the same batch, but it's not worth throwing out partially\n  // completed work in order to do it.\n  // TODO: Reconsider this. The counter-argument is that the partial work\n  // represents an intermediate state, which we don't want to show to the user.\n  // And by spending extra time finishing it, we're increasing the amount of\n  // time it takes to show the final state, which is what they are actually\n  // waiting for.\n  //\n  // For those exceptions where entanglement is semantically important, like\n  // useMutableSource, we should ensure that there is no partial work at the\n  // time we apply the entanglement.\n\n\n  const entangledLanes = root.entangledLanes;\n\n  if (entangledLanes !== NoLanes) {\n    const entanglements = root.entanglements;\n    let lanes = nextLanes & entangledLanes;\n\n    while (lanes > 0) {\n      const index = pickArbitraryLaneIndex(lanes);\n      const lane = 1 << index;\n      nextLanes |= entanglements[index];\n      lanes &= ~lane;\n    }\n  }\n\n  return nextLanes;\n}\nexport function getMostRecentEventTime(root, lanes) {\n  const eventTimes = root.eventTimes;\n  let mostRecentEventTime = NoTimestamp;\n\n  while (lanes > 0) {\n    const index = pickArbitraryLaneIndex(lanes);\n    const lane = 1 << index;\n    const eventTime = eventTimes[index];\n\n    if (eventTime > mostRecentEventTime) {\n      mostRecentEventTime = eventTime;\n    }\n\n    lanes &= ~lane;\n  }\n\n  return mostRecentEventTime;\n}\n\nfunction computeExpirationTime(lane, currentTime) {\n  switch (lane) {\n    case SyncLane:\n    case InputContinuousHydrationLane:\n    case InputContinuousLane:\n      // User interactions should expire slightly more quickly.\n      //\n      // NOTE: This is set to the corresponding constant as in Scheduler.js.\n      // When we made it larger, a product metric in www regressed, suggesting\n      // there's a user interaction that's being starved by a series of\n      // synchronous updates. If that theory is correct, the proper solution is\n      // to fix the starvation. However, this scenario supports the idea that\n      // expiration times are an important safeguard when starvation\n      // does happen.\n      return currentTime + 250;\n\n    case DefaultHydrationLane:\n    case DefaultLane:\n    case TransitionHydrationLane:\n    case TransitionLane1:\n    case TransitionLane2:\n    case TransitionLane3:\n    case TransitionLane4:\n    case TransitionLane5:\n    case TransitionLane6:\n    case TransitionLane7:\n    case TransitionLane8:\n    case TransitionLane9:\n    case TransitionLane10:\n    case TransitionLane11:\n    case TransitionLane12:\n    case TransitionLane13:\n    case TransitionLane14:\n    case TransitionLane15:\n    case TransitionLane16:\n      return currentTime + 5000;\n\n    case RetryLane1:\n    case RetryLane2:\n    case RetryLane3:\n    case RetryLane4:\n    case RetryLane5:\n      // TODO: Retries should be allowed to expire if they are CPU bound for\n      // too long, but when I made this change it caused a spike in browser\n      // crashes. There must be some other underlying bug; not super urgent but\n      // ideally should figure out why and fix it. Unfortunately we don't have\n      // a repro for the crashes, only detected via production metrics.\n      return NoTimestamp;\n\n    case SelectiveHydrationLane:\n    case IdleHydrationLane:\n    case IdleLane:\n    case OffscreenLane:\n      // Anything idle priority or lower should never expire.\n      return NoTimestamp;\n\n    default:\n      if (__DEV__) {\n        console.error('Should have found matching lanes. This is a bug in React.');\n      }\n\n      return NoTimestamp;\n  }\n}\n\nexport function markStarvedLanesAsExpired(root, currentTime) {\n  // TODO: This gets called every time we yield. We can optimize by storing\n  // the earliest expiration time on the root. Then use that to quickly bail out\n  // of this function.\n  const pendingLanes = root.pendingLanes;\n  const suspendedLanes = root.suspendedLanes;\n  const pingedLanes = root.pingedLanes;\n  const expirationTimes = root.expirationTimes; // Iterate through the pending lanes and check if we've reached their\n  // expiration time. If so, we'll assume the update is being starved and mark\n  // it as expired to force it to finish.\n\n  let lanes = pendingLanes;\n\n  while (lanes > 0) {\n    const index = pickArbitraryLaneIndex(lanes);\n    const lane = 1 << index;\n    const expirationTime = expirationTimes[index];\n\n    if (expirationTime === NoTimestamp) {\n      // Found a pending lane with no expiration time. If it's not suspended, or\n      // if it's pinged, assume it's CPU-bound. Compute a new expiration time\n      // using the current time.\n      if ((lane & suspendedLanes) === NoLanes || (lane & pingedLanes) !== NoLanes) {\n        // Assumes timestamps are monotonically increasing.\n        expirationTimes[index] = computeExpirationTime(lane, currentTime);\n      }\n    } else if (expirationTime <= currentTime) {\n      // This lane expired\n      root.expiredLanes |= lane;\n    }\n\n    lanes &= ~lane;\n  }\n} // This returns the highest priority pending lanes regardless of whether they\n// are suspended.\n\nexport function getHighestPriorityPendingLanes(root) {\n  return getHighestPriorityLanes(root.pendingLanes);\n}\nexport function getLanesToRetrySynchronouslyOnError(root) {\n  const everythingButOffscreen = root.pendingLanes & ~OffscreenLane;\n\n  if (everythingButOffscreen !== NoLanes) {\n    return everythingButOffscreen;\n  }\n\n  if (everythingButOffscreen & OffscreenLane) {\n    return OffscreenLane;\n  }\n\n  return NoLanes;\n}\nexport function includesNonIdleWork(lanes) {\n  return (lanes & NonIdleLanes) !== NoLanes;\n}\nexport function includesOnlyRetries(lanes) {\n  return (lanes & RetryLanes) === lanes;\n}\nexport function includesOnlyTransitions(lanes) {\n  return (lanes & TransitionLanes) === lanes;\n}\nexport function includesBlockingLane(root, lanes) {\n  if (allowConcurrentByDefault && (root.current.mode & ConcurrentUpdatesByDefaultMode) !== NoMode) {\n    // Concurrent updates by default always use time slicing.\n    return false;\n  }\n\n  const SyncDefaultLanes = InputContinuousHydrationLane | InputContinuousLane | DefaultHydrationLane | DefaultLane;\n  return (lanes & SyncDefaultLanes) !== NoLanes;\n}\nexport function includesExpiredLane(root, lanes) {\n  // This is a separate check from includesBlockingLane because a lane can\n  // expire after a render has already started.\n  return (lanes & root.expiredLanes) !== NoLanes;\n}\nexport function isTransitionLane(lane) {\n  return (lane & TransitionLanes) !== 0;\n}\nexport function claimNextTransitionLane() {\n  // Cycle through the lanes, assigning each new transition to the next lane.\n  // In most cases, this means every transition gets its own lane, until we\n  // run out of lanes and cycle back to the beginning.\n  const lane = nextTransitionLane;\n  nextTransitionLane <<= 1;\n\n  if ((nextTransitionLane & TransitionLanes) === 0) {\n    nextTransitionLane = TransitionLane1;\n  }\n\n  return lane;\n}\nexport function claimNextRetryLane() {\n  const lane = nextRetryLane;\n  nextRetryLane <<= 1;\n\n  if ((nextRetryLane & RetryLanes) === 0) {\n    nextRetryLane = RetryLane1;\n  }\n\n  return lane;\n}\nexport function getHighestPriorityLane(lanes) {\n  return lanes & -lanes;\n}\nexport function pickArbitraryLane(lanes) {\n  // This wrapper function gets inlined. Only exists so to communicate that it\n  // doesn't matter which bit is selected; you can pick any bit without\n  // affecting the algorithms where its used. Here I'm using\n  // getHighestPriorityLane because it requires the fewest operations.\n  return getHighestPriorityLane(lanes);\n}\n\nfunction pickArbitraryLaneIndex(lanes) {\n  return 31 - clz32(lanes);\n}\n\nfunction laneToIndex(lane) {\n  return pickArbitraryLaneIndex(lane);\n}\n\nexport function includesSomeLane(a, b) {\n  return (a & b) !== NoLanes;\n}\nexport function isSubsetOfLanes(set, subset) {\n  return (set & subset) === subset;\n}\nexport function mergeLanes(a, b) {\n  return a | b;\n}\nexport function removeLanes(set, subset) {\n  return set & ~subset;\n}\nexport function intersectLanes(a, b) {\n  return a & b;\n} // Seems redundant, but it changes the type from a single lane (used for\n// updates) to a group of lanes (used for flushing work).\n\nexport function laneToLanes(lane) {\n  return lane;\n}\nexport function higherPriorityLane(a, b) {\n  // This works because the bit ranges decrease in priority as you go left.\n  return a !== NoLane && a < b ? a : b;\n}\nexport function createLaneMap(initial) {\n  // Intentionally pushing one by one.\n  // https://v8.dev/blog/elements-kinds#avoid-creating-holes\n  const laneMap = [];\n\n  for (let i = 0; i < TotalLanes; i++) {\n    laneMap.push(initial);\n  }\n\n  return laneMap;\n}\nexport function markRootUpdated(root, updateLane, eventTime) {\n  root.pendingLanes |= updateLane; // If there are any suspended transitions, it's possible this new update\n  // could unblock them. Clear the suspended lanes so that we can try rendering\n  // them again.\n  //\n  // TODO: We really only need to unsuspend only lanes that are in the\n  // `subtreeLanes` of the updated fiber, or the update lanes of the return\n  // path. This would exclude suspended updates in an unrelated sibling tree,\n  // since there's no way for this update to unblock it.\n  //\n  // We don't do this if the incoming update is idle, because we never process\n  // idle updates until after all the regular updates have finished; there's no\n  // way it could unblock a transition.\n\n  if (updateLane !== IdleLane) {\n    root.suspendedLanes = NoLanes;\n    root.pingedLanes = NoLanes;\n  }\n\n  const eventTimes = root.eventTimes;\n  const index = laneToIndex(updateLane); // We can always overwrite an existing timestamp because we prefer the most\n  // recent event, and we assume time is monotonically increasing.\n\n  eventTimes[index] = eventTime;\n}\nexport function markRootSuspended(root, suspendedLanes) {\n  root.suspendedLanes |= suspendedLanes;\n  root.pingedLanes &= ~suspendedLanes; // The suspended lanes are no longer CPU-bound. Clear their expiration times.\n\n  const expirationTimes = root.expirationTimes;\n  let lanes = suspendedLanes;\n\n  while (lanes > 0) {\n    const index = pickArbitraryLaneIndex(lanes);\n    const lane = 1 << index;\n    expirationTimes[index] = NoTimestamp;\n    lanes &= ~lane;\n  }\n}\nexport function markRootPinged(root, pingedLanes, eventTime) {\n  root.pingedLanes |= root.suspendedLanes & pingedLanes;\n}\nexport function markRootMutableRead(root, updateLane) {\n  root.mutableReadLanes |= updateLane & root.pendingLanes;\n}\nexport function markRootFinished(root, remainingLanes) {\n  const noLongerPendingLanes = root.pendingLanes & ~remainingLanes;\n  root.pendingLanes = remainingLanes; // Let's try everything again\n\n  root.suspendedLanes = 0;\n  root.pingedLanes = 0;\n  root.expiredLanes &= remainingLanes;\n  root.mutableReadLanes &= remainingLanes;\n  root.entangledLanes &= remainingLanes;\n  const entanglements = root.entanglements;\n  const eventTimes = root.eventTimes;\n  const expirationTimes = root.expirationTimes; // Clear the lanes that no longer have pending work\n\n  let lanes = noLongerPendingLanes;\n\n  while (lanes > 0) {\n    const index = pickArbitraryLaneIndex(lanes);\n    const lane = 1 << index;\n    entanglements[index] = NoLanes;\n    eventTimes[index] = NoTimestamp;\n    expirationTimes[index] = NoTimestamp;\n    lanes &= ~lane;\n  }\n}\nexport function markRootEntangled(root, entangledLanes) {\n  // In addition to entangling each of the given lanes with each other, we also\n  // have to consider _transitive_ entanglements. For each lane that is already\n  // entangled with *any* of the given lanes, that lane is now transitively\n  // entangled with *all* the given lanes.\n  //\n  // Translated: If C is entangled with A, then entangling A with B also\n  // entangles C with B.\n  //\n  // If this is hard to grasp, it might help to intentionally break this\n  // function and look at the tests that fail in ReactTransition-test.js. Try\n  // commenting out one of the conditions below.\n  const rootEntangledLanes = root.entangledLanes |= entangledLanes;\n  const entanglements = root.entanglements;\n  let lanes = rootEntangledLanes;\n\n  while (lanes) {\n    const index = pickArbitraryLaneIndex(lanes);\n    const lane = 1 << index;\n\n    if ( // Is this one of the newly entangled lanes?\n    lane & entangledLanes | // Is this lane transitively entangled with the newly entangled lanes?\n    entanglements[index] & entangledLanes) {\n      entanglements[index] |= entangledLanes;\n    }\n\n    lanes &= ~lane;\n  }\n}\nexport function getBumpedLaneForHydration(root, renderLanes) {\n  const renderLane = getHighestPriorityLane(renderLanes);\n  let lane;\n\n  switch (renderLane) {\n    case InputContinuousLane:\n      lane = InputContinuousHydrationLane;\n      break;\n\n    case DefaultLane:\n      lane = DefaultHydrationLane;\n      break;\n\n    case TransitionLane1:\n    case TransitionLane2:\n    case TransitionLane3:\n    case TransitionLane4:\n    case TransitionLane5:\n    case TransitionLane6:\n    case TransitionLane7:\n    case TransitionLane8:\n    case TransitionLane9:\n    case TransitionLane10:\n    case TransitionLane11:\n    case TransitionLane12:\n    case TransitionLane13:\n    case TransitionLane14:\n    case TransitionLane15:\n    case TransitionLane16:\n    case RetryLane1:\n    case RetryLane2:\n    case RetryLane3:\n    case RetryLane4:\n    case RetryLane5:\n      lane = TransitionHydrationLane;\n      break;\n\n    case IdleLane:\n      lane = IdleHydrationLane;\n      break;\n\n    default:\n      // Everything else is already either a hydration lane, or shouldn't\n      // be retried at a hydration lane.\n      lane = NoLane;\n      break;\n  } // Check if the lane we chose is suspended. If so, that indicates that we\n  // already attempted and failed to hydrate at that level. Also check if we're\n  // already rendering that lane, which is rare but could happen.\n\n\n  if ((lane & (root.suspendedLanes | renderLanes)) !== NoLane) {\n    // Give up trying to hydrate and fall back to client render.\n    return NoLane;\n  }\n\n  return lane;\n}\nexport function addFiberToLanesMap(root, fiber, lanes) {\n  if (!enableUpdaterTracking) {\n    return;\n  }\n\n  if (!isDevToolsPresent) {\n    return;\n  }\n\n  const pendingUpdatersLaneMap = root.pendingUpdatersLaneMap;\n\n  while (lanes > 0) {\n    const index = laneToIndex(lanes);\n    const lane = 1 << index;\n    const updaters = pendingUpdatersLaneMap[index];\n    updaters.add(fiber);\n    lanes &= ~lane;\n  }\n}\nexport function movePendingFibersToMemoized(root, lanes) {\n  if (!enableUpdaterTracking) {\n    return;\n  }\n\n  if (!isDevToolsPresent) {\n    return;\n  }\n\n  const pendingUpdatersLaneMap = root.pendingUpdatersLaneMap;\n  const memoizedUpdaters = root.memoizedUpdaters;\n\n  while (lanes > 0) {\n    const index = laneToIndex(lanes);\n    const lane = 1 << index;\n    const updaters = pendingUpdatersLaneMap[index];\n\n    if (updaters.size > 0) {\n      updaters.forEach(fiber => {\n        const alternate = fiber.alternate;\n\n        if (alternate === null || !memoizedUpdaters.has(alternate)) {\n          memoizedUpdaters.add(fiber);\n        }\n      });\n      updaters.clear();\n    }\n\n    lanes &= ~lane;\n  }\n}","map":{"version":3,"sources":["/Users/zhangshuo/git/react-source-test/src/react/packages/react-reconciler/src/ReactFiberLane.old.js"],"names":["enableSchedulingProfiler","enableUpdaterTracking","allowConcurrentByDefault","isDevToolsPresent","ConcurrentUpdatesByDefaultMode","NoMode","clz32","TotalLanes","NoLanes","NoLane","SyncLane","InputContinuousHydrationLane","InputContinuousLane","DefaultHydrationLane","DefaultLane","TransitionHydrationLane","TransitionLanes","TransitionLane1","TransitionLane2","TransitionLane3","TransitionLane4","TransitionLane5","TransitionLane6","TransitionLane7","TransitionLane8","TransitionLane9","TransitionLane10","TransitionLane11","TransitionLane12","TransitionLane13","TransitionLane14","TransitionLane15","TransitionLane16","RetryLanes","RetryLane1","RetryLane2","RetryLane3","RetryLane4","RetryLane5","SomeRetryLane","SelectiveHydrationLane","NonIdleLanes","IdleHydrationLane","IdleLane","OffscreenLane","getLabelForLane","lane","NoTimestamp","nextTransitionLane","nextRetryLane","getHighestPriorityLanes","lanes","getHighestPriorityLane","__DEV__","console","error","getNextLanes","root","wipLanes","pendingLanes","nextLanes","suspendedLanes","pingedLanes","nonIdlePendingLanes","nonIdleUnblockedLanes","nonIdlePingedLanes","unblockedLanes","nextLane","wipLane","current","mode","entangledLanes","entanglements","index","pickArbitraryLaneIndex","getMostRecentEventTime","eventTimes","mostRecentEventTime","eventTime","computeExpirationTime","currentTime","markStarvedLanesAsExpired","expirationTimes","expirationTime","expiredLanes","getHighestPriorityPendingLanes","getLanesToRetrySynchronouslyOnError","everythingButOffscreen","includesNonIdleWork","includesOnlyRetries","includesOnlyTransitions","includesBlockingLane","SyncDefaultLanes","includesExpiredLane","isTransitionLane","claimNextTransitionLane","claimNextRetryLane","pickArbitraryLane","laneToIndex","includesSomeLane","a","b","isSubsetOfLanes","set","subset","mergeLanes","removeLanes","intersectLanes","laneToLanes","higherPriorityLane","createLaneMap","initial","laneMap","i","push","markRootUpdated","updateLane","markRootSuspended","markRootPinged","markRootMutableRead","mutableReadLanes","markRootFinished","remainingLanes","noLongerPendingLanes","markRootEntangled","rootEntangledLanes","getBumpedLaneForHydration","renderLanes","renderLane","addFiberToLanesMap","fiber","pendingUpdatersLaneMap","updaters","add","movePendingFibersToMemoized","memoizedUpdaters","size","forEach","alternate","has","clear"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {FiberRoot} from './ReactInternalTypes';\n\n// TODO: Ideally these types would be opaque but that doesn't work well with\n// our reconciler fork infra, since these leak into non-reconciler packages.\n\nexport type Lanes = number;\nexport type Lane = number;\nexport type LaneMap<T> = Array<T>;\n\nimport {\n  enableSchedulingProfiler,\n  enableUpdaterTracking,\n  allowConcurrentByDefault,\n} from 'shared/ReactFeatureFlags';\nimport {isDevToolsPresent} from './ReactFiberDevToolsHook.old';\nimport {ConcurrentUpdatesByDefaultMode, NoMode} from './ReactTypeOfMode';\nimport {clz32} from './clz32';\n\n// Lane values below should be kept in sync with getLabelForLane(), used by react-devtools-timeline.\n// If those values are changed that package should be rebuilt and redeployed.\n\nexport const TotalLanes = 31;\n\nexport const NoLanes: Lanes = /*                        */ 0b0000000000000000000000000000000;\nexport const NoLane: Lane = /*                          */ 0b0000000000000000000000000000000;\n\nexport const SyncLane: Lane = /*                        */ 0b0000000000000000000000000000001;\n\nexport const InputContinuousHydrationLane: Lane = /*    */ 0b0000000000000000000000000000010;\nexport const InputContinuousLane: Lanes = /*            */ 0b0000000000000000000000000000100;\n\nexport const DefaultHydrationLane: Lane = /*            */ 0b0000000000000000000000000001000;\nexport const DefaultLane: Lanes = /*                    */ 0b0000000000000000000000000010000;\n\nconst TransitionHydrationLane: Lane = /*                */ 0b0000000000000000000000000100000;\nconst TransitionLanes: Lanes = /*                       */ 0b0000000001111111111111111000000;\nconst TransitionLane1: Lane = /*                        */ 0b0000000000000000000000001000000;\nconst TransitionLane2: Lane = /*                        */ 0b0000000000000000000000010000000;\nconst TransitionLane3: Lane = /*                        */ 0b0000000000000000000000100000000;\nconst TransitionLane4: Lane = /*                        */ 0b0000000000000000000001000000000;\nconst TransitionLane5: Lane = /*                        */ 0b0000000000000000000010000000000;\nconst TransitionLane6: Lane = /*                        */ 0b0000000000000000000100000000000;\nconst TransitionLane7: Lane = /*                        */ 0b0000000000000000001000000000000;\nconst TransitionLane8: Lane = /*                        */ 0b0000000000000000010000000000000;\nconst TransitionLane9: Lane = /*                        */ 0b0000000000000000100000000000000;\nconst TransitionLane10: Lane = /*                       */ 0b0000000000000001000000000000000;\nconst TransitionLane11: Lane = /*                       */ 0b0000000000000010000000000000000;\nconst TransitionLane12: Lane = /*                       */ 0b0000000000000100000000000000000;\nconst TransitionLane13: Lane = /*                       */ 0b0000000000001000000000000000000;\nconst TransitionLane14: Lane = /*                       */ 0b0000000000010000000000000000000;\nconst TransitionLane15: Lane = /*                       */ 0b0000000000100000000000000000000;\nconst TransitionLane16: Lane = /*                       */ 0b0000000001000000000000000000000;\n\nconst RetryLanes: Lanes = /*                            */ 0b0000111110000000000000000000000;\nconst RetryLane1: Lane = /*                             */ 0b0000000010000000000000000000000;\nconst RetryLane2: Lane = /*                             */ 0b0000000100000000000000000000000;\nconst RetryLane3: Lane = /*                             */ 0b0000001000000000000000000000000;\nconst RetryLane4: Lane = /*                             */ 0b0000010000000000000000000000000;\nconst RetryLane5: Lane = /*                             */ 0b0000100000000000000000000000000;\n\nexport const SomeRetryLane: Lane = RetryLane1;\n\nexport const SelectiveHydrationLane: Lane = /*          */ 0b0001000000000000000000000000000;\n\nconst NonIdleLanes = /*                                 */ 0b0001111111111111111111111111111;\n\nexport const IdleHydrationLane: Lane = /*               */ 0b0010000000000000000000000000000;\nexport const IdleLane: Lanes = /*                       */ 0b0100000000000000000000000000000;\n\nexport const OffscreenLane: Lane = /*                   */ 0b1000000000000000000000000000000;\n\n// This function is used for the experimental timeline (react-devtools-timeline)\n// It should be kept in sync with the Lanes values above.\nexport function getLabelForLane(lane: Lane): string | void {\n  if (enableSchedulingProfiler) {\n    if (lane & SyncLane) {\n      return 'Sync';\n    }\n    if (lane & InputContinuousHydrationLane) {\n      return 'InputContinuousHydration';\n    }\n    if (lane & InputContinuousLane) {\n      return 'InputContinuous';\n    }\n    if (lane & DefaultHydrationLane) {\n      return 'DefaultHydration';\n    }\n    if (lane & DefaultLane) {\n      return 'Default';\n    }\n    if (lane & TransitionHydrationLane) {\n      return 'TransitionHydration';\n    }\n    if (lane & TransitionLanes) {\n      return 'Transition';\n    }\n    if (lane & RetryLanes) {\n      return 'Retry';\n    }\n    if (lane & SelectiveHydrationLane) {\n      return 'SelectiveHydration';\n    }\n    if (lane & IdleHydrationLane) {\n      return 'IdleHydration';\n    }\n    if (lane & IdleLane) {\n      return 'Idle';\n    }\n    if (lane & OffscreenLane) {\n      return 'Offscreen';\n    }\n  }\n}\n\nexport const NoTimestamp = -1;\n\nlet nextTransitionLane: Lane = TransitionLane1;\nlet nextRetryLane: Lane = RetryLane1;\n\nfunction getHighestPriorityLanes(lanes: Lanes | Lane): Lanes {\n  switch (getHighestPriorityLane(lanes)) {\n    case SyncLane:\n      return SyncLane;\n    case InputContinuousHydrationLane:\n      return InputContinuousHydrationLane;\n    case InputContinuousLane:\n      return InputContinuousLane;\n    case DefaultHydrationLane:\n      return DefaultHydrationLane;\n    case DefaultLane:\n      return DefaultLane;\n    case TransitionHydrationLane:\n      return TransitionHydrationLane;\n    case TransitionLane1:\n    case TransitionLane2:\n    case TransitionLane3:\n    case TransitionLane4:\n    case TransitionLane5:\n    case TransitionLane6:\n    case TransitionLane7:\n    case TransitionLane8:\n    case TransitionLane9:\n    case TransitionLane10:\n    case TransitionLane11:\n    case TransitionLane12:\n    case TransitionLane13:\n    case TransitionLane14:\n    case TransitionLane15:\n    case TransitionLane16:\n      return lanes & TransitionLanes;\n    case RetryLane1:\n    case RetryLane2:\n    case RetryLane3:\n    case RetryLane4:\n    case RetryLane5:\n      return lanes & RetryLanes;\n    case SelectiveHydrationLane:\n      return SelectiveHydrationLane;\n    case IdleHydrationLane:\n      return IdleHydrationLane;\n    case IdleLane:\n      return IdleLane;\n    case OffscreenLane:\n      return OffscreenLane;\n    default:\n      if (__DEV__) {\n        console.error(\n          'Should have found matching lanes. This is a bug in React.',\n        );\n      }\n      // This shouldn't be reachable, but as a fallback, return the entire bitmask.\n      return lanes;\n  }\n}\n\nexport function getNextLanes(root: FiberRoot, wipLanes: Lanes): Lanes {\n  // Early bailout if there's no pending work left.\n  const pendingLanes = root.pendingLanes;\n  if (pendingLanes === NoLanes) {\n    return NoLanes;\n  }\n\n  let nextLanes = NoLanes;\n\n  const suspendedLanes = root.suspendedLanes;\n  const pingedLanes = root.pingedLanes;\n\n  // Do not work on any idle work until all the non-idle work has finished,\n  // even if the work is suspended.\n  const nonIdlePendingLanes = pendingLanes & NonIdleLanes;\n  if (nonIdlePendingLanes !== NoLanes) {\n    const nonIdleUnblockedLanes = nonIdlePendingLanes & ~suspendedLanes;\n    if (nonIdleUnblockedLanes !== NoLanes) {\n      nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);\n    } else {\n      const nonIdlePingedLanes = nonIdlePendingLanes & pingedLanes;\n      if (nonIdlePingedLanes !== NoLanes) {\n        nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);\n      }\n    }\n  } else {\n    // The only remaining work is Idle.\n    const unblockedLanes = pendingLanes & ~suspendedLanes;\n    if (unblockedLanes !== NoLanes) {\n      nextLanes = getHighestPriorityLanes(unblockedLanes);\n    } else {\n      if (pingedLanes !== NoLanes) {\n        nextLanes = getHighestPriorityLanes(pingedLanes);\n      }\n    }\n  }\n\n  if (nextLanes === NoLanes) {\n    // This should only be reachable if we're suspended\n    // TODO: Consider warning in this path if a fallback timer is not scheduled.\n    return NoLanes;\n  }\n\n  // If we're already in the middle of a render, switching lanes will interrupt\n  // it and we'll lose our progress. We should only do this if the new lanes are\n  // higher priority.\n  if (\n    wipLanes !== NoLanes &&\n    wipLanes !== nextLanes &&\n    // If we already suspended with a delay, then interrupting is fine. Don't\n    // bother waiting until the root is complete.\n    (wipLanes & suspendedLanes) === NoLanes\n  ) {\n    const nextLane = getHighestPriorityLane(nextLanes);\n    const wipLane = getHighestPriorityLane(wipLanes);\n    if (\n      // Tests whether the next lane is equal or lower priority than the wip\n      // one. This works because the bits decrease in priority as you go left.\n      nextLane >= wipLane ||\n      // Default priority updates should not interrupt transition updates. The\n      // only difference between default updates and transition updates is that\n      // default updates do not support refresh transitions.\n      (nextLane === DefaultLane && (wipLane & TransitionLanes) !== NoLanes)\n    ) {\n      // Keep working on the existing in-progress tree. Do not interrupt.\n      return wipLanes;\n    }\n  }\n\n  if (\n    allowConcurrentByDefault &&\n    (root.current.mode & ConcurrentUpdatesByDefaultMode) !== NoMode\n  ) {\n    // Do nothing, use the lanes as they were assigned.\n  } else if ((nextLanes & InputContinuousLane) !== NoLanes) {\n    // When updates are sync by default, we entangle continuous priority updates\n    // and default updates, so they render in the same batch. The only reason\n    // they use separate lanes is because continuous updates should interrupt\n    // transitions, but default updates should not.\n    nextLanes |= pendingLanes & DefaultLane;\n  }\n\n  // Check for entangled lanes and add them to the batch.\n  //\n  // A lane is said to be entangled with another when it's not allowed to render\n  // in a batch that does not also include the other lane. Typically we do this\n  // when multiple updates have the same source, and we only want to respond to\n  // the most recent event from that source.\n  //\n  // Note that we apply entanglements *after* checking for partial work above.\n  // This means that if a lane is entangled during an interleaved event while\n  // it's already rendering, we won't interrupt it. This is intentional, since\n  // entanglement is usually \"best effort\": we'll try our best to render the\n  // lanes in the same batch, but it's not worth throwing out partially\n  // completed work in order to do it.\n  // TODO: Reconsider this. The counter-argument is that the partial work\n  // represents an intermediate state, which we don't want to show to the user.\n  // And by spending extra time finishing it, we're increasing the amount of\n  // time it takes to show the final state, which is what they are actually\n  // waiting for.\n  //\n  // For those exceptions where entanglement is semantically important, like\n  // useMutableSource, we should ensure that there is no partial work at the\n  // time we apply the entanglement.\n  const entangledLanes = root.entangledLanes;\n  if (entangledLanes !== NoLanes) {\n    const entanglements = root.entanglements;\n    let lanes = nextLanes & entangledLanes;\n    while (lanes > 0) {\n      const index = pickArbitraryLaneIndex(lanes);\n      const lane = 1 << index;\n\n      nextLanes |= entanglements[index];\n\n      lanes &= ~lane;\n    }\n  }\n\n  return nextLanes;\n}\n\nexport function getMostRecentEventTime(root: FiberRoot, lanes: Lanes): number {\n  const eventTimes = root.eventTimes;\n\n  let mostRecentEventTime = NoTimestamp;\n  while (lanes > 0) {\n    const index = pickArbitraryLaneIndex(lanes);\n    const lane = 1 << index;\n\n    const eventTime = eventTimes[index];\n    if (eventTime > mostRecentEventTime) {\n      mostRecentEventTime = eventTime;\n    }\n\n    lanes &= ~lane;\n  }\n\n  return mostRecentEventTime;\n}\n\nfunction computeExpirationTime(lane: Lane, currentTime: number) {\n  switch (lane) {\n    case SyncLane:\n    case InputContinuousHydrationLane:\n    case InputContinuousLane:\n      // User interactions should expire slightly more quickly.\n      //\n      // NOTE: This is set to the corresponding constant as in Scheduler.js.\n      // When we made it larger, a product metric in www regressed, suggesting\n      // there's a user interaction that's being starved by a series of\n      // synchronous updates. If that theory is correct, the proper solution is\n      // to fix the starvation. However, this scenario supports the idea that\n      // expiration times are an important safeguard when starvation\n      // does happen.\n      return currentTime + 250;\n    case DefaultHydrationLane:\n    case DefaultLane:\n    case TransitionHydrationLane:\n    case TransitionLane1:\n    case TransitionLane2:\n    case TransitionLane3:\n    case TransitionLane4:\n    case TransitionLane5:\n    case TransitionLane6:\n    case TransitionLane7:\n    case TransitionLane8:\n    case TransitionLane9:\n    case TransitionLane10:\n    case TransitionLane11:\n    case TransitionLane12:\n    case TransitionLane13:\n    case TransitionLane14:\n    case TransitionLane15:\n    case TransitionLane16:\n      return currentTime + 5000;\n    case RetryLane1:\n    case RetryLane2:\n    case RetryLane3:\n    case RetryLane4:\n    case RetryLane5:\n      // TODO: Retries should be allowed to expire if they are CPU bound for\n      // too long, but when I made this change it caused a spike in browser\n      // crashes. There must be some other underlying bug; not super urgent but\n      // ideally should figure out why and fix it. Unfortunately we don't have\n      // a repro for the crashes, only detected via production metrics.\n      return NoTimestamp;\n    case SelectiveHydrationLane:\n    case IdleHydrationLane:\n    case IdleLane:\n    case OffscreenLane:\n      // Anything idle priority or lower should never expire.\n      return NoTimestamp;\n    default:\n      if (__DEV__) {\n        console.error(\n          'Should have found matching lanes. This is a bug in React.',\n        );\n      }\n      return NoTimestamp;\n  }\n}\n\nexport function markStarvedLanesAsExpired(\n  root: FiberRoot,\n  currentTime: number,\n): void {\n  // TODO: This gets called every time we yield. We can optimize by storing\n  // the earliest expiration time on the root. Then use that to quickly bail out\n  // of this function.\n\n  const pendingLanes = root.pendingLanes;\n  const suspendedLanes = root.suspendedLanes;\n  const pingedLanes = root.pingedLanes;\n  const expirationTimes = root.expirationTimes;\n\n  // Iterate through the pending lanes and check if we've reached their\n  // expiration time. If so, we'll assume the update is being starved and mark\n  // it as expired to force it to finish.\n  let lanes = pendingLanes;\n  while (lanes > 0) {\n    const index = pickArbitraryLaneIndex(lanes);\n    const lane = 1 << index;\n\n    const expirationTime = expirationTimes[index];\n    if (expirationTime === NoTimestamp) {\n      // Found a pending lane with no expiration time. If it's not suspended, or\n      // if it's pinged, assume it's CPU-bound. Compute a new expiration time\n      // using the current time.\n      if (\n        (lane & suspendedLanes) === NoLanes ||\n        (lane & pingedLanes) !== NoLanes\n      ) {\n        // Assumes timestamps are monotonically increasing.\n        expirationTimes[index] = computeExpirationTime(lane, currentTime);\n      }\n    } else if (expirationTime <= currentTime) {\n      // This lane expired\n      root.expiredLanes |= lane;\n    }\n\n    lanes &= ~lane;\n  }\n}\n\n// This returns the highest priority pending lanes regardless of whether they\n// are suspended.\nexport function getHighestPriorityPendingLanes(root: FiberRoot) {\n  return getHighestPriorityLanes(root.pendingLanes);\n}\n\nexport function getLanesToRetrySynchronouslyOnError(root: FiberRoot): Lanes {\n  const everythingButOffscreen = root.pendingLanes & ~OffscreenLane;\n  if (everythingButOffscreen !== NoLanes) {\n    return everythingButOffscreen;\n  }\n  if (everythingButOffscreen & OffscreenLane) {\n    return OffscreenLane;\n  }\n  return NoLanes;\n}\n\nexport function includesNonIdleWork(lanes: Lanes) {\n  return (lanes & NonIdleLanes) !== NoLanes;\n}\nexport function includesOnlyRetries(lanes: Lanes) {\n  return (lanes & RetryLanes) === lanes;\n}\nexport function includesOnlyTransitions(lanes: Lanes) {\n  return (lanes & TransitionLanes) === lanes;\n}\n\nexport function includesBlockingLane(root: FiberRoot, lanes: Lanes) {\n  if (\n    allowConcurrentByDefault &&\n    (root.current.mode & ConcurrentUpdatesByDefaultMode) !== NoMode\n  ) {\n    // Concurrent updates by default always use time slicing.\n    return false;\n  }\n  const SyncDefaultLanes =\n    InputContinuousHydrationLane |\n    InputContinuousLane |\n    DefaultHydrationLane |\n    DefaultLane;\n  return (lanes & SyncDefaultLanes) !== NoLanes;\n}\n\nexport function includesExpiredLane(root: FiberRoot, lanes: Lanes) {\n  // This is a separate check from includesBlockingLane because a lane can\n  // expire after a render has already started.\n  return (lanes & root.expiredLanes) !== NoLanes;\n}\n\nexport function isTransitionLane(lane: Lane) {\n  return (lane & TransitionLanes) !== 0;\n}\n\nexport function claimNextTransitionLane(): Lane {\n  // Cycle through the lanes, assigning each new transition to the next lane.\n  // In most cases, this means every transition gets its own lane, until we\n  // run out of lanes and cycle back to the beginning.\n  const lane = nextTransitionLane;\n  nextTransitionLane <<= 1;\n  if ((nextTransitionLane & TransitionLanes) === 0) {\n    nextTransitionLane = TransitionLane1;\n  }\n  return lane;\n}\n\nexport function claimNextRetryLane(): Lane {\n  const lane = nextRetryLane;\n  nextRetryLane <<= 1;\n  if ((nextRetryLane & RetryLanes) === 0) {\n    nextRetryLane = RetryLane1;\n  }\n  return lane;\n}\n\nexport function getHighestPriorityLane(lanes: Lanes): Lane {\n  return lanes & -lanes;\n}\n\nexport function pickArbitraryLane(lanes: Lanes): Lane {\n  // This wrapper function gets inlined. Only exists so to communicate that it\n  // doesn't matter which bit is selected; you can pick any bit without\n  // affecting the algorithms where its used. Here I'm using\n  // getHighestPriorityLane because it requires the fewest operations.\n  return getHighestPriorityLane(lanes);\n}\n\nfunction pickArbitraryLaneIndex(lanes: Lanes) {\n  return 31 - clz32(lanes);\n}\n\nfunction laneToIndex(lane: Lane) {\n  return pickArbitraryLaneIndex(lane);\n}\n\nexport function includesSomeLane(a: Lanes | Lane, b: Lanes | Lane) {\n  return (a & b) !== NoLanes;\n}\n\nexport function isSubsetOfLanes(set: Lanes, subset: Lanes | Lane) {\n  return (set & subset) === subset;\n}\n\nexport function mergeLanes(a: Lanes | Lane, b: Lanes | Lane): Lanes {\n  return a | b;\n}\n\nexport function removeLanes(set: Lanes, subset: Lanes | Lane): Lanes {\n  return set & ~subset;\n}\n\nexport function intersectLanes(a: Lanes | Lane, b: Lanes | Lane): Lanes {\n  return a & b;\n}\n\n// Seems redundant, but it changes the type from a single lane (used for\n// updates) to a group of lanes (used for flushing work).\nexport function laneToLanes(lane: Lane): Lanes {\n  return lane;\n}\n\nexport function higherPriorityLane(a: Lane, b: Lane) {\n  // This works because the bit ranges decrease in priority as you go left.\n  return a !== NoLane && a < b ? a : b;\n}\n\nexport function createLaneMap<T>(initial: T): LaneMap<T> {\n  // Intentionally pushing one by one.\n  // https://v8.dev/blog/elements-kinds#avoid-creating-holes\n  const laneMap = [];\n  for (let i = 0; i < TotalLanes; i++) {\n    laneMap.push(initial);\n  }\n  return laneMap;\n}\n\nexport function markRootUpdated(\n  root: FiberRoot,\n  updateLane: Lane,\n  eventTime: number,\n) {\n  root.pendingLanes |= updateLane;\n\n  // If there are any suspended transitions, it's possible this new update\n  // could unblock them. Clear the suspended lanes so that we can try rendering\n  // them again.\n  //\n  // TODO: We really only need to unsuspend only lanes that are in the\n  // `subtreeLanes` of the updated fiber, or the update lanes of the return\n  // path. This would exclude suspended updates in an unrelated sibling tree,\n  // since there's no way for this update to unblock it.\n  //\n  // We don't do this if the incoming update is idle, because we never process\n  // idle updates until after all the regular updates have finished; there's no\n  // way it could unblock a transition.\n  if (updateLane !== IdleLane) {\n    root.suspendedLanes = NoLanes;\n    root.pingedLanes = NoLanes;\n  }\n\n  const eventTimes = root.eventTimes;\n  const index = laneToIndex(updateLane);\n  // We can always overwrite an existing timestamp because we prefer the most\n  // recent event, and we assume time is monotonically increasing.\n  eventTimes[index] = eventTime;\n}\n\nexport function markRootSuspended(root: FiberRoot, suspendedLanes: Lanes) {\n  root.suspendedLanes |= suspendedLanes;\n  root.pingedLanes &= ~suspendedLanes;\n\n  // The suspended lanes are no longer CPU-bound. Clear their expiration times.\n  const expirationTimes = root.expirationTimes;\n  let lanes = suspendedLanes;\n  while (lanes > 0) {\n    const index = pickArbitraryLaneIndex(lanes);\n    const lane = 1 << index;\n\n    expirationTimes[index] = NoTimestamp;\n\n    lanes &= ~lane;\n  }\n}\n\nexport function markRootPinged(\n  root: FiberRoot,\n  pingedLanes: Lanes,\n  eventTime: number,\n) {\n  root.pingedLanes |= root.suspendedLanes & pingedLanes;\n}\n\nexport function markRootMutableRead(root: FiberRoot, updateLane: Lane) {\n  root.mutableReadLanes |= updateLane & root.pendingLanes;\n}\n\nexport function markRootFinished(root: FiberRoot, remainingLanes: Lanes) {\n  const noLongerPendingLanes = root.pendingLanes & ~remainingLanes;\n\n  root.pendingLanes = remainingLanes;\n\n  // Let's try everything again\n  root.suspendedLanes = 0;\n  root.pingedLanes = 0;\n\n  root.expiredLanes &= remainingLanes;\n  root.mutableReadLanes &= remainingLanes;\n\n  root.entangledLanes &= remainingLanes;\n\n  const entanglements = root.entanglements;\n  const eventTimes = root.eventTimes;\n  const expirationTimes = root.expirationTimes;\n\n  // Clear the lanes that no longer have pending work\n  let lanes = noLongerPendingLanes;\n  while (lanes > 0) {\n    const index = pickArbitraryLaneIndex(lanes);\n    const lane = 1 << index;\n\n    entanglements[index] = NoLanes;\n    eventTimes[index] = NoTimestamp;\n    expirationTimes[index] = NoTimestamp;\n\n    lanes &= ~lane;\n  }\n}\n\nexport function markRootEntangled(root: FiberRoot, entangledLanes: Lanes) {\n  // In addition to entangling each of the given lanes with each other, we also\n  // have to consider _transitive_ entanglements. For each lane that is already\n  // entangled with *any* of the given lanes, that lane is now transitively\n  // entangled with *all* the given lanes.\n  //\n  // Translated: If C is entangled with A, then entangling A with B also\n  // entangles C with B.\n  //\n  // If this is hard to grasp, it might help to intentionally break this\n  // function and look at the tests that fail in ReactTransition-test.js. Try\n  // commenting out one of the conditions below.\n\n  const rootEntangledLanes = (root.entangledLanes |= entangledLanes);\n  const entanglements = root.entanglements;\n  let lanes = rootEntangledLanes;\n  while (lanes) {\n    const index = pickArbitraryLaneIndex(lanes);\n    const lane = 1 << index;\n    if (\n      // Is this one of the newly entangled lanes?\n      (lane & entangledLanes) |\n      // Is this lane transitively entangled with the newly entangled lanes?\n      (entanglements[index] & entangledLanes)\n    ) {\n      entanglements[index] |= entangledLanes;\n    }\n    lanes &= ~lane;\n  }\n}\n\nexport function getBumpedLaneForHydration(\n  root: FiberRoot,\n  renderLanes: Lanes,\n): Lane {\n  const renderLane = getHighestPriorityLane(renderLanes);\n\n  let lane;\n  switch (renderLane) {\n    case InputContinuousLane:\n      lane = InputContinuousHydrationLane;\n      break;\n    case DefaultLane:\n      lane = DefaultHydrationLane;\n      break;\n    case TransitionLane1:\n    case TransitionLane2:\n    case TransitionLane3:\n    case TransitionLane4:\n    case TransitionLane5:\n    case TransitionLane6:\n    case TransitionLane7:\n    case TransitionLane8:\n    case TransitionLane9:\n    case TransitionLane10:\n    case TransitionLane11:\n    case TransitionLane12:\n    case TransitionLane13:\n    case TransitionLane14:\n    case TransitionLane15:\n    case TransitionLane16:\n    case RetryLane1:\n    case RetryLane2:\n    case RetryLane3:\n    case RetryLane4:\n    case RetryLane5:\n      lane = TransitionHydrationLane;\n      break;\n    case IdleLane:\n      lane = IdleHydrationLane;\n      break;\n    default:\n      // Everything else is already either a hydration lane, or shouldn't\n      // be retried at a hydration lane.\n      lane = NoLane;\n      break;\n  }\n\n  // Check if the lane we chose is suspended. If so, that indicates that we\n  // already attempted and failed to hydrate at that level. Also check if we're\n  // already rendering that lane, which is rare but could happen.\n  if ((lane & (root.suspendedLanes | renderLanes)) !== NoLane) {\n    // Give up trying to hydrate and fall back to client render.\n    return NoLane;\n  }\n\n  return lane;\n}\n\nexport function addFiberToLanesMap(\n  root: FiberRoot,\n  fiber: Fiber,\n  lanes: Lanes | Lane,\n) {\n  if (!enableUpdaterTracking) {\n    return;\n  }\n  if (!isDevToolsPresent) {\n    return;\n  }\n  const pendingUpdatersLaneMap = root.pendingUpdatersLaneMap;\n  while (lanes > 0) {\n    const index = laneToIndex(lanes);\n    const lane = 1 << index;\n\n    const updaters = pendingUpdatersLaneMap[index];\n    updaters.add(fiber);\n\n    lanes &= ~lane;\n  }\n}\n\nexport function movePendingFibersToMemoized(root: FiberRoot, lanes: Lanes) {\n  if (!enableUpdaterTracking) {\n    return;\n  }\n  if (!isDevToolsPresent) {\n    return;\n  }\n  const pendingUpdatersLaneMap = root.pendingUpdatersLaneMap;\n  const memoizedUpdaters = root.memoizedUpdaters;\n  while (lanes > 0) {\n    const index = laneToIndex(lanes);\n    const lane = 1 << index;\n\n    const updaters = pendingUpdatersLaneMap[index];\n    if (updaters.size > 0) {\n      updaters.forEach(fiber => {\n        const alternate = fiber.alternate;\n        if (alternate === null || !memoizedUpdaters.has(alternate)) {\n          memoizedUpdaters.add(fiber);\n        }\n      });\n      updaters.clear();\n    }\n\n    lanes &= ~lane;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}