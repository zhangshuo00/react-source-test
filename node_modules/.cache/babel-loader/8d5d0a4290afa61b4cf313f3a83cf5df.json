{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { getChildHostContext, getRootHostContext } from './ReactFiberHostConfig';\nimport { createCursor, push, pop } from './ReactFiberStack.new';\nconst NO_CONTEXT = {};\nconst contextStackCursor = createCursor(NO_CONTEXT);\nconst contextFiberStackCursor = createCursor(NO_CONTEXT);\nconst rootInstanceStackCursor = createCursor(NO_CONTEXT);\n\nfunction requiredContext(c) {\n  if (c === NO_CONTEXT) {\n    throw new Error('Expected host context to exist. This error is likely caused by a bug ' + 'in React. Please file an issue.');\n  }\n\n  return c;\n}\n\nfunction getRootHostContainer() {\n  const rootInstance = requiredContext(rootInstanceStackCursor.current);\n  return rootInstance;\n}\n\nfunction pushHostContainer(fiber, nextRootInstance) {\n  // Push current root instance onto the stack;\n  // This allows us to reset root when portals are popped.\n  push(rootInstanceStackCursor, nextRootInstance, fiber); // Track the context and the Fiber that provided it.\n  // This enables us to pop only Fibers that provide unique contexts.\n\n  push(contextFiberStackCursor, fiber, fiber); // Finally, we need to push the host context to the stack.\n  // However, we can't just call getRootHostContext() and push it because\n  // we'd have a different number of entries on the stack depending on\n  // whether getRootHostContext() throws somewhere in renderer code or not.\n  // So we push an empty value first. This lets us safely unwind on errors.\n\n  push(contextStackCursor, NO_CONTEXT, fiber);\n  const nextRootContext = getRootHostContext(nextRootInstance); // Now that we know this function doesn't throw, replace it.\n\n  pop(contextStackCursor, fiber);\n  push(contextStackCursor, nextRootContext, fiber);\n}\n\nfunction popHostContainer(fiber) {\n  pop(contextStackCursor, fiber);\n  pop(contextFiberStackCursor, fiber);\n  pop(rootInstanceStackCursor, fiber);\n}\n\nfunction getHostContext() {\n  const context = requiredContext(contextStackCursor.current);\n  return context;\n}\n\nfunction pushHostContext(fiber) {\n  const rootInstance = requiredContext(rootInstanceStackCursor.current);\n  const context = requiredContext(contextStackCursor.current);\n  const nextContext = getChildHostContext(context, fiber.type, rootInstance); // Don't push this Fiber's context unless it's unique.\n\n  if (context === nextContext) {\n    return;\n  } // Track the context and the Fiber that provided it.\n  // This enables us to pop only Fibers that provide unique contexts.\n\n\n  push(contextFiberStackCursor, fiber, fiber);\n  push(contextStackCursor, nextContext, fiber);\n}\n\nfunction popHostContext(fiber) {\n  // Do not pop unless this Fiber provided the current context.\n  // pushHostContext() only pushes Fibers that provide unique contexts.\n  if (contextFiberStackCursor.current !== fiber) {\n    return;\n  }\n\n  pop(contextStackCursor, fiber);\n  pop(contextFiberStackCursor, fiber);\n}\n\nexport { getHostContext, getRootHostContainer, popHostContainer, popHostContext, pushHostContainer, pushHostContext };","map":{"version":3,"sources":["/Users/zhangshuo/git/react-source-test/src/react/packages/react-reconciler/src/ReactFiberHostContext.new.js"],"names":["getChildHostContext","getRootHostContext","createCursor","push","pop","NO_CONTEXT","contextStackCursor","contextFiberStackCursor","rootInstanceStackCursor","requiredContext","c","Error","getRootHostContainer","rootInstance","current","pushHostContainer","fiber","nextRootInstance","nextRootContext","popHostContainer","getHostContext","context","pushHostContext","nextContext","type","popHostContext"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA,SAAQA,mBAAR,EAA6BC,kBAA7B,QAAsD,wBAAtD;AACA,SAAQC,YAAR,EAAsBC,IAAtB,EAA4BC,GAA5B,QAAsC,uBAAtC;AAGA,MAAMC,UAAsB,GAAI,EAAhC;AAEA,MAAMC,kBAAyD,GAAGJ,YAAY,CAC5EG,UAD4E,CAA9E;AAGA,MAAME,uBAAwD,GAAGL,YAAY,CAC3EG,UAD2E,CAA7E;AAGA,MAAMG,uBAEL,GAAGN,YAAY,CAACG,UAAD,CAFhB;;AAIA,SAASI,eAAT,CAAgCC,CAAhC,EAA8D;AAC5D,MAAIA,CAAC,KAAKL,UAAV,EAAsB;AACpB,UAAM,IAAIM,KAAJ,CACJ,0EACE,iCAFE,CAAN;AAID;;AAED,SAAQD,CAAR;AACD;;AAED,SAASE,oBAAT,GAA2C;AACzC,QAAMC,YAAY,GAAGJ,eAAe,CAACD,uBAAuB,CAACM,OAAzB,CAApC;AACA,SAAOD,YAAP;AACD;;AAED,SAASE,iBAAT,CAA2BC,KAA3B,EAAyCC,gBAAzC,EAAsE;AACpE;AACA;AACAd,EAAAA,IAAI,CAACK,uBAAD,EAA0BS,gBAA1B,EAA4CD,KAA5C,CAAJ,CAHoE,CAIpE;AACA;;AACAb,EAAAA,IAAI,CAACI,uBAAD,EAA0BS,KAA1B,EAAiCA,KAAjC,CAAJ,CANoE,CAQpE;AACA;AACA;AACA;AACA;;AACAb,EAAAA,IAAI,CAACG,kBAAD,EAAqBD,UAArB,EAAiCW,KAAjC,CAAJ;AACA,QAAME,eAAe,GAAGjB,kBAAkB,CAACgB,gBAAD,CAA1C,CAdoE,CAepE;;AACAb,EAAAA,GAAG,CAACE,kBAAD,EAAqBU,KAArB,CAAH;AACAb,EAAAA,IAAI,CAACG,kBAAD,EAAqBY,eAArB,EAAsCF,KAAtC,CAAJ;AACD;;AAED,SAASG,gBAAT,CAA0BH,KAA1B,EAAwC;AACtCZ,EAAAA,GAAG,CAACE,kBAAD,EAAqBU,KAArB,CAAH;AACAZ,EAAAA,GAAG,CAACG,uBAAD,EAA0BS,KAA1B,CAAH;AACAZ,EAAAA,GAAG,CAACI,uBAAD,EAA0BQ,KAA1B,CAAH;AACD;;AAED,SAASI,cAAT,GAAuC;AACrC,QAAMC,OAAO,GAAGZ,eAAe,CAACH,kBAAkB,CAACQ,OAApB,CAA/B;AACA,SAAOO,OAAP;AACD;;AAED,SAASC,eAAT,CAAyBN,KAAzB,EAA6C;AAC3C,QAAMH,YAAuB,GAAGJ,eAAe,CAC7CD,uBAAuB,CAACM,OADqB,CAA/C;AAGA,QAAMO,OAAoB,GAAGZ,eAAe,CAACH,kBAAkB,CAACQ,OAApB,CAA5C;AACA,QAAMS,WAAW,GAAGvB,mBAAmB,CAACqB,OAAD,EAAUL,KAAK,CAACQ,IAAhB,EAAsBX,YAAtB,CAAvC,CAL2C,CAO3C;;AACA,MAAIQ,OAAO,KAAKE,WAAhB,EAA6B;AAC3B;AACD,GAV0C,CAY3C;AACA;;;AACApB,EAAAA,IAAI,CAACI,uBAAD,EAA0BS,KAA1B,EAAiCA,KAAjC,CAAJ;AACAb,EAAAA,IAAI,CAACG,kBAAD,EAAqBiB,WAArB,EAAkCP,KAAlC,CAAJ;AACD;;AAED,SAASS,cAAT,CAAwBT,KAAxB,EAA4C;AAC1C;AACA;AACA,MAAIT,uBAAuB,CAACO,OAAxB,KAAoCE,KAAxC,EAA+C;AAC7C;AACD;;AAEDZ,EAAAA,GAAG,CAACE,kBAAD,EAAqBU,KAArB,CAAH;AACAZ,EAAAA,GAAG,CAACG,uBAAD,EAA0BS,KAA1B,CAAH;AACD;;AAED,SACEI,cADF,EAEER,oBAFF,EAGEO,gBAHF,EAIEM,cAJF,EAKEV,iBALF,EAMEO,eANF","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Fiber} from './ReactInternalTypes';\nimport type {StackCursor} from './ReactFiberStack.new';\nimport type {Container, HostContext} from './ReactFiberHostConfig';\n\nimport {getChildHostContext, getRootHostContext} from './ReactFiberHostConfig';\nimport {createCursor, push, pop} from './ReactFiberStack.new';\n\ndeclare class NoContextT {}\nconst NO_CONTEXT: NoContextT = ({}: any);\n\nconst contextStackCursor: StackCursor<HostContext | NoContextT> = createCursor(\n  NO_CONTEXT,\n);\nconst contextFiberStackCursor: StackCursor<Fiber | NoContextT> = createCursor(\n  NO_CONTEXT,\n);\nconst rootInstanceStackCursor: StackCursor<\n  Container | NoContextT,\n> = createCursor(NO_CONTEXT);\n\nfunction requiredContext<Value>(c: Value | NoContextT): Value {\n  if (c === NO_CONTEXT) {\n    throw new Error(\n      'Expected host context to exist. This error is likely caused by a bug ' +\n        'in React. Please file an issue.',\n    );\n  }\n\n  return (c: any);\n}\n\nfunction getRootHostContainer(): Container {\n  const rootInstance = requiredContext(rootInstanceStackCursor.current);\n  return rootInstance;\n}\n\nfunction pushHostContainer(fiber: Fiber, nextRootInstance: Container) {\n  // Push current root instance onto the stack;\n  // This allows us to reset root when portals are popped.\n  push(rootInstanceStackCursor, nextRootInstance, fiber);\n  // Track the context and the Fiber that provided it.\n  // This enables us to pop only Fibers that provide unique contexts.\n  push(contextFiberStackCursor, fiber, fiber);\n\n  // Finally, we need to push the host context to the stack.\n  // However, we can't just call getRootHostContext() and push it because\n  // we'd have a different number of entries on the stack depending on\n  // whether getRootHostContext() throws somewhere in renderer code or not.\n  // So we push an empty value first. This lets us safely unwind on errors.\n  push(contextStackCursor, NO_CONTEXT, fiber);\n  const nextRootContext = getRootHostContext(nextRootInstance);\n  // Now that we know this function doesn't throw, replace it.\n  pop(contextStackCursor, fiber);\n  push(contextStackCursor, nextRootContext, fiber);\n}\n\nfunction popHostContainer(fiber: Fiber) {\n  pop(contextStackCursor, fiber);\n  pop(contextFiberStackCursor, fiber);\n  pop(rootInstanceStackCursor, fiber);\n}\n\nfunction getHostContext(): HostContext {\n  const context = requiredContext(contextStackCursor.current);\n  return context;\n}\n\nfunction pushHostContext(fiber: Fiber): void {\n  const rootInstance: Container = requiredContext(\n    rootInstanceStackCursor.current,\n  );\n  const context: HostContext = requiredContext(contextStackCursor.current);\n  const nextContext = getChildHostContext(context, fiber.type, rootInstance);\n\n  // Don't push this Fiber's context unless it's unique.\n  if (context === nextContext) {\n    return;\n  }\n\n  // Track the context and the Fiber that provided it.\n  // This enables us to pop only Fibers that provide unique contexts.\n  push(contextFiberStackCursor, fiber, fiber);\n  push(contextStackCursor, nextContext, fiber);\n}\n\nfunction popHostContext(fiber: Fiber): void {\n  // Do not pop unless this Fiber provided the current context.\n  // pushHostContext() only pushes Fibers that provide unique contexts.\n  if (contextFiberStackCursor.current !== fiber) {\n    return;\n  }\n\n  pop(contextStackCursor, fiber);\n  pop(contextFiberStackCursor, fiber);\n}\n\nexport {\n  getHostContext,\n  getRootHostContainer,\n  popHostContainer,\n  popHostContext,\n  pushHostContainer,\n  pushHostContext,\n};\n"]},"metadata":{},"sourceType":"module"}