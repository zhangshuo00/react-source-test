{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { DiscreteEventPriority, getCurrentUpdatePriority, setCurrentUpdatePriority } from './ReactEventPriorities.new';\nimport { ImmediatePriority, scheduleCallback } from './Scheduler';\nlet syncQueue = null;\nlet includesLegacySyncCallbacks = false;\nlet isFlushingSyncQueue = false;\nexport function scheduleSyncCallback(callback) {\n  // Push this callback into an internal queue. We'll flush these either in\n  // the next tick, or earlier if something calls `flushSyncCallbackQueue`.\n  if (syncQueue === null) {\n    syncQueue = [callback];\n  } else {\n    // Push onto existing queue. Don't need to schedule a callback because\n    // we already scheduled one when we created the queue.\n    syncQueue.push(callback);\n  }\n}\nexport function scheduleLegacySyncCallback(callback) {\n  includesLegacySyncCallbacks = true;\n  scheduleSyncCallback(callback);\n}\nexport function flushSyncCallbacksOnlyInLegacyMode() {\n  // Only flushes the queue if there's a legacy sync callback scheduled.\n  // TODO: There's only a single type of callback: performSyncOnWorkOnRoot. So\n  // it might make more sense for the queue to be a list of roots instead of a\n  // list of generic callbacks. Then we can have two: one for legacy roots, one\n  // for concurrent roots. And this method would only flush the legacy ones.\n  if (includesLegacySyncCallbacks) {\n    flushSyncCallbacks();\n  }\n}\nexport function flushSyncCallbacks() {\n  if (!isFlushingSyncQueue && syncQueue !== null) {\n    // Prevent re-entrance.\n    isFlushingSyncQueue = true;\n    let i = 0;\n    const previousUpdatePriority = getCurrentUpdatePriority();\n\n    try {\n      const isSync = true;\n      const queue = syncQueue; // TODO: Is this necessary anymore? The only user code that runs in this\n      // queue is in the render or commit phases.\n\n      setCurrentUpdatePriority(DiscreteEventPriority);\n\n      for (; i < queue.length; i++) {\n        let callback = queue[i];\n\n        do {\n          callback = callback(isSync);\n        } while (callback !== null);\n      }\n\n      syncQueue = null;\n      includesLegacySyncCallbacks = false;\n    } catch (error) {\n      // If something throws, leave the remaining callbacks on the queue.\n      if (syncQueue !== null) {\n        syncQueue = syncQueue.slice(i + 1);\n      } // Resume flushing in the next tick\n\n\n      scheduleCallback(ImmediatePriority, flushSyncCallbacks);\n      throw error;\n    } finally {\n      setCurrentUpdatePriority(previousUpdatePriority);\n      isFlushingSyncQueue = false;\n    }\n  }\n\n  return null;\n}","map":{"version":3,"sources":["/Users/zhangshuo/git/react-source-test/src/react/packages/react-reconciler/src/ReactFiberSyncTaskQueue.new.js"],"names":["DiscreteEventPriority","getCurrentUpdatePriority","setCurrentUpdatePriority","ImmediatePriority","scheduleCallback","syncQueue","includesLegacySyncCallbacks","isFlushingSyncQueue","scheduleSyncCallback","callback","push","scheduleLegacySyncCallback","flushSyncCallbacksOnlyInLegacyMode","flushSyncCallbacks","i","previousUpdatePriority","isSync","queue","length","error","slice"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA,SACEA,qBADF,EAEEC,wBAFF,EAGEC,wBAHF,QAIO,4BAJP;AAKA,SAAQC,iBAAR,EAA2BC,gBAA3B,QAAkD,aAAlD;AAEA,IAAIC,SAA0C,GAAG,IAAjD;AACA,IAAIC,2BAAoC,GAAG,KAA3C;AACA,IAAIC,mBAA4B,GAAG,KAAnC;AAEA,OAAO,SAASC,oBAAT,CAA8BC,QAA9B,EAA2D;AAChE;AACA;AACA,MAAIJ,SAAS,KAAK,IAAlB,EAAwB;AACtBA,IAAAA,SAAS,GAAG,CAACI,QAAD,CAAZ;AACD,GAFD,MAEO;AACL;AACA;AACAJ,IAAAA,SAAS,CAACK,IAAV,CAAeD,QAAf;AACD;AACF;AAED,OAAO,SAASE,0BAAT,CAAoCF,QAApC,EAAiE;AACtEH,EAAAA,2BAA2B,GAAG,IAA9B;AACAE,EAAAA,oBAAoB,CAACC,QAAD,CAApB;AACD;AAED,OAAO,SAASG,kCAAT,GAA8C;AACnD;AACA;AACA;AACA;AACA;AACA,MAAIN,2BAAJ,EAAiC;AAC/BO,IAAAA,kBAAkB;AACnB;AACF;AAED,OAAO,SAASA,kBAAT,GAA8B;AACnC,MAAI,CAACN,mBAAD,IAAwBF,SAAS,KAAK,IAA1C,EAAgD;AAC9C;AACAE,IAAAA,mBAAmB,GAAG,IAAtB;AACA,QAAIO,CAAC,GAAG,CAAR;AACA,UAAMC,sBAAsB,GAAGd,wBAAwB,EAAvD;;AACA,QAAI;AACF,YAAMe,MAAM,GAAG,IAAf;AACA,YAAMC,KAAK,GAAGZ,SAAd,CAFE,CAGF;AACA;;AACAH,MAAAA,wBAAwB,CAACF,qBAAD,CAAxB;;AACA,aAAOc,CAAC,GAAGG,KAAK,CAACC,MAAjB,EAAyBJ,CAAC,EAA1B,EAA8B;AAC5B,YAAIL,QAAQ,GAAGQ,KAAK,CAACH,CAAD,CAApB;;AACA,WAAG;AACDL,UAAAA,QAAQ,GAAGA,QAAQ,CAACO,MAAD,CAAnB;AACD,SAFD,QAESP,QAAQ,KAAK,IAFtB;AAGD;;AACDJ,MAAAA,SAAS,GAAG,IAAZ;AACAC,MAAAA,2BAA2B,GAAG,KAA9B;AACD,KAdD,CAcE,OAAOa,KAAP,EAAc;AACd;AACA,UAAId,SAAS,KAAK,IAAlB,EAAwB;AACtBA,QAAAA,SAAS,GAAGA,SAAS,CAACe,KAAV,CAAgBN,CAAC,GAAG,CAApB,CAAZ;AACD,OAJa,CAKd;;;AACAV,MAAAA,gBAAgB,CAACD,iBAAD,EAAoBU,kBAApB,CAAhB;AACA,YAAMM,KAAN;AACD,KAtBD,SAsBU;AACRjB,MAAAA,wBAAwB,CAACa,sBAAD,CAAxB;AACAR,MAAAA,mBAAmB,GAAG,KAAtB;AACD;AACF;;AACD,SAAO,IAAP;AACD","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {SchedulerCallback} from './Scheduler';\n\nimport {\n  DiscreteEventPriority,\n  getCurrentUpdatePriority,\n  setCurrentUpdatePriority,\n} from './ReactEventPriorities.new';\nimport {ImmediatePriority, scheduleCallback} from './Scheduler';\n\nlet syncQueue: Array<SchedulerCallback> | null = null;\nlet includesLegacySyncCallbacks: boolean = false;\nlet isFlushingSyncQueue: boolean = false;\n\nexport function scheduleSyncCallback(callback: SchedulerCallback) {\n  // Push this callback into an internal queue. We'll flush these either in\n  // the next tick, or earlier if something calls `flushSyncCallbackQueue`.\n  if (syncQueue === null) {\n    syncQueue = [callback];\n  } else {\n    // Push onto existing queue. Don't need to schedule a callback because\n    // we already scheduled one when we created the queue.\n    syncQueue.push(callback);\n  }\n}\n\nexport function scheduleLegacySyncCallback(callback: SchedulerCallback) {\n  includesLegacySyncCallbacks = true;\n  scheduleSyncCallback(callback);\n}\n\nexport function flushSyncCallbacksOnlyInLegacyMode() {\n  // Only flushes the queue if there's a legacy sync callback scheduled.\n  // TODO: There's only a single type of callback: performSyncOnWorkOnRoot. So\n  // it might make more sense for the queue to be a list of roots instead of a\n  // list of generic callbacks. Then we can have two: one for legacy roots, one\n  // for concurrent roots. And this method would only flush the legacy ones.\n  if (includesLegacySyncCallbacks) {\n    flushSyncCallbacks();\n  }\n}\n\nexport function flushSyncCallbacks() {\n  if (!isFlushingSyncQueue && syncQueue !== null) {\n    // Prevent re-entrance.\n    isFlushingSyncQueue = true;\n    let i = 0;\n    const previousUpdatePriority = getCurrentUpdatePriority();\n    try {\n      const isSync = true;\n      const queue = syncQueue;\n      // TODO: Is this necessary anymore? The only user code that runs in this\n      // queue is in the render or commit phases.\n      setCurrentUpdatePriority(DiscreteEventPriority);\n      for (; i < queue.length; i++) {\n        let callback = queue[i];\n        do {\n          callback = callback(isSync);\n        } while (callback !== null);\n      }\n      syncQueue = null;\n      includesLegacySyncCallbacks = false;\n    } catch (error) {\n      // If something throws, leave the remaining callbacks on the queue.\n      if (syncQueue !== null) {\n        syncQueue = syncQueue.slice(i + 1);\n      }\n      // Resume flushing in the next tick\n      scheduleCallback(ImmediatePriority, flushSyncCallbacks);\n      throw error;\n    } finally {\n      setCurrentUpdatePriority(previousUpdatePriority);\n      isFlushingSyncQueue = false;\n    }\n  }\n  return null;\n}\n"]},"metadata":{},"sourceType":"module"}