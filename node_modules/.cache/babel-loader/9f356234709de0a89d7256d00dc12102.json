{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { enableProfilerCommitHooks, enableProfilerNestedUpdatePhase, enableProfilerTimer } from 'shared/ReactFeatureFlags';\nimport { HostRoot, Profiler } from './ReactWorkTags'; // Intentionally not named imports because Rollup would use dynamic dispatch for\n// CommonJS interop named imports.\n\nimport * as Scheduler from 'scheduler';\nconst {\n  unstable_now: now\n} = Scheduler;\nlet commitTime = 0;\nlet layoutEffectStartTime = -1;\nlet profilerStartTime = -1;\nlet passiveEffectStartTime = -1;\n/**\n * Tracks whether the current update was a nested/cascading update (scheduled from a layout effect).\n *\n * The overall sequence is:\n *   1. render\n *   2. commit (and call `onRender`, `onCommit`)\n *   3. check for nested updates\n *   4. flush passive effects (and call `onPostCommit`)\n *\n * Nested updates are identified in step 3 above,\n * but step 4 still applies to the work that was just committed.\n * We use two flags to track nested updates then:\n * one tracks whether the upcoming update is a nested update,\n * and the other tracks whether the current update was a nested update.\n * The first value gets synced to the second at the start of the render phase.\n */\n\nlet currentUpdateIsNested = false;\nlet nestedUpdateScheduled = false;\n\nfunction isCurrentUpdateNested() {\n  return currentUpdateIsNested;\n}\n\nfunction markNestedUpdateScheduled() {\n  if (enableProfilerNestedUpdatePhase) {\n    nestedUpdateScheduled = true;\n  }\n}\n\nfunction resetNestedUpdateFlag() {\n  if (enableProfilerNestedUpdatePhase) {\n    currentUpdateIsNested = false;\n    nestedUpdateScheduled = false;\n  }\n}\n\nfunction syncNestedUpdateFlag() {\n  if (enableProfilerNestedUpdatePhase) {\n    currentUpdateIsNested = nestedUpdateScheduled;\n    nestedUpdateScheduled = false;\n  }\n}\n\nfunction getCommitTime() {\n  return commitTime;\n}\n\nfunction recordCommitTime() {\n  if (!enableProfilerTimer) {\n    return;\n  }\n\n  commitTime = now();\n}\n\nfunction startProfilerTimer(fiber) {\n  if (!enableProfilerTimer) {\n    return;\n  }\n\n  profilerStartTime = now();\n\n  if (fiber.actualStartTime < 0) {\n    fiber.actualStartTime = now();\n  }\n}\n\nfunction stopProfilerTimerIfRunning(fiber) {\n  if (!enableProfilerTimer) {\n    return;\n  }\n\n  profilerStartTime = -1;\n}\n\nfunction stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {\n  if (!enableProfilerTimer) {\n    return;\n  }\n\n  if (profilerStartTime >= 0) {\n    const elapsedTime = now() - profilerStartTime;\n    fiber.actualDuration += elapsedTime;\n\n    if (overrideBaseTime) {\n      fiber.selfBaseDuration = elapsedTime;\n    }\n\n    profilerStartTime = -1;\n  }\n}\n\nfunction recordLayoutEffectDuration(fiber) {\n  if (!enableProfilerTimer || !enableProfilerCommitHooks) {\n    return;\n  }\n\n  if (layoutEffectStartTime >= 0) {\n    const elapsedTime = now() - layoutEffectStartTime;\n    layoutEffectStartTime = -1; // Store duration on the next nearest Profiler ancestor\n    // Or the root (for the DevTools Profiler to read)\n\n    let parentFiber = fiber.return;\n\n    while (parentFiber !== null) {\n      switch (parentFiber.tag) {\n        case HostRoot:\n          const root = parentFiber.stateNode;\n          root.effectDuration += elapsedTime;\n          return;\n\n        case Profiler:\n          const parentStateNode = parentFiber.stateNode;\n          parentStateNode.effectDuration += elapsedTime;\n          return;\n      }\n\n      parentFiber = parentFiber.return;\n    }\n  }\n}\n\nfunction recordPassiveEffectDuration(fiber) {\n  if (!enableProfilerTimer || !enableProfilerCommitHooks) {\n    return;\n  }\n\n  if (passiveEffectStartTime >= 0) {\n    const elapsedTime = now() - passiveEffectStartTime;\n    passiveEffectStartTime = -1; // Store duration on the next nearest Profiler ancestor\n    // Or the root (for the DevTools Profiler to read)\n\n    let parentFiber = fiber.return;\n\n    while (parentFiber !== null) {\n      switch (parentFiber.tag) {\n        case HostRoot:\n          const root = parentFiber.stateNode;\n\n          if (root !== null) {\n            root.passiveEffectDuration += elapsedTime;\n          }\n\n          return;\n\n        case Profiler:\n          const parentStateNode = parentFiber.stateNode;\n\n          if (parentStateNode !== null) {\n            // Detached fibers have their state node cleared out.\n            // In this case, the return pointer is also cleared out,\n            // so we won't be able to report the time spent in this Profiler's subtree.\n            parentStateNode.passiveEffectDuration += elapsedTime;\n          }\n\n          return;\n      }\n\n      parentFiber = parentFiber.return;\n    }\n  }\n}\n\nfunction startLayoutEffectTimer() {\n  if (!enableProfilerTimer || !enableProfilerCommitHooks) {\n    return;\n  }\n\n  layoutEffectStartTime = now();\n}\n\nfunction startPassiveEffectTimer() {\n  if (!enableProfilerTimer || !enableProfilerCommitHooks) {\n    return;\n  }\n\n  passiveEffectStartTime = now();\n}\n\nfunction transferActualDuration(fiber) {\n  // Transfer time spent rendering these children so we don't lose it\n  // after we rerender. This is used as a helper in special cases\n  // where we should count the work of multiple passes.\n  let child = fiber.child;\n\n  while (child) {\n    fiber.actualDuration += child.actualDuration;\n    child = child.sibling;\n  }\n}\n\nexport { getCommitTime, isCurrentUpdateNested, markNestedUpdateScheduled, recordCommitTime, recordLayoutEffectDuration, recordPassiveEffectDuration, resetNestedUpdateFlag, startLayoutEffectTimer, startPassiveEffectTimer, startProfilerTimer, stopProfilerTimerIfRunning, stopProfilerTimerIfRunningAndRecordDelta, syncNestedUpdateFlag, transferActualDuration };","map":{"version":3,"sources":["/Users/zhangshuo/git/my-app/src/react/packages/react-reconciler/src/ReactProfilerTimer.new.js"],"names":["enableProfilerCommitHooks","enableProfilerNestedUpdatePhase","enableProfilerTimer","HostRoot","Profiler","Scheduler","unstable_now","now","commitTime","layoutEffectStartTime","profilerStartTime","passiveEffectStartTime","currentUpdateIsNested","nestedUpdateScheduled","isCurrentUpdateNested","markNestedUpdateScheduled","resetNestedUpdateFlag","syncNestedUpdateFlag","getCommitTime","recordCommitTime","startProfilerTimer","fiber","actualStartTime","stopProfilerTimerIfRunning","stopProfilerTimerIfRunningAndRecordDelta","overrideBaseTime","elapsedTime","actualDuration","selfBaseDuration","recordLayoutEffectDuration","parentFiber","return","tag","root","stateNode","effectDuration","parentStateNode","recordPassiveEffectDuration","passiveEffectDuration","startLayoutEffectTimer","startPassiveEffectTimer","transferActualDuration","child","sibling"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Fiber} from './ReactInternalTypes';\n\nimport {\n  enableProfilerCommitHooks,\n  enableProfilerNestedUpdatePhase,\n  enableProfilerTimer,\n} from 'shared/ReactFeatureFlags';\nimport {HostRoot, Profiler} from './ReactWorkTags';\n\n// Intentionally not named imports because Rollup would use dynamic dispatch for\n// CommonJS interop named imports.\nimport * as Scheduler from 'scheduler';\n\nconst {unstable_now: now} = Scheduler;\n\nexport type ProfilerTimer = {\n  getCommitTime(): number,\n  isCurrentUpdateNested(): boolean,\n  markNestedUpdateScheduled(): void,\n  recordCommitTime(): void,\n  startProfilerTimer(fiber: Fiber): void,\n  stopProfilerTimerIfRunning(fiber: Fiber): void,\n  stopProfilerTimerIfRunningAndRecordDelta(fiber: Fiber): void,\n  syncNestedUpdateFlag(): void,\n  ...\n};\n\nlet commitTime: number = 0;\nlet layoutEffectStartTime: number = -1;\nlet profilerStartTime: number = -1;\nlet passiveEffectStartTime: number = -1;\n\n/**\n * Tracks whether the current update was a nested/cascading update (scheduled from a layout effect).\n *\n * The overall sequence is:\n *   1. render\n *   2. commit (and call `onRender`, `onCommit`)\n *   3. check for nested updates\n *   4. flush passive effects (and call `onPostCommit`)\n *\n * Nested updates are identified in step 3 above,\n * but step 4 still applies to the work that was just committed.\n * We use two flags to track nested updates then:\n * one tracks whether the upcoming update is a nested update,\n * and the other tracks whether the current update was a nested update.\n * The first value gets synced to the second at the start of the render phase.\n */\nlet currentUpdateIsNested: boolean = false;\nlet nestedUpdateScheduled: boolean = false;\n\nfunction isCurrentUpdateNested(): boolean {\n  return currentUpdateIsNested;\n}\n\nfunction markNestedUpdateScheduled(): void {\n  if (enableProfilerNestedUpdatePhase) {\n    nestedUpdateScheduled = true;\n  }\n}\n\nfunction resetNestedUpdateFlag(): void {\n  if (enableProfilerNestedUpdatePhase) {\n    currentUpdateIsNested = false;\n    nestedUpdateScheduled = false;\n  }\n}\n\nfunction syncNestedUpdateFlag(): void {\n  if (enableProfilerNestedUpdatePhase) {\n    currentUpdateIsNested = nestedUpdateScheduled;\n    nestedUpdateScheduled = false;\n  }\n}\n\nfunction getCommitTime(): number {\n  return commitTime;\n}\n\nfunction recordCommitTime(): void {\n  if (!enableProfilerTimer) {\n    return;\n  }\n  commitTime = now();\n}\n\nfunction startProfilerTimer(fiber: Fiber): void {\n  if (!enableProfilerTimer) {\n    return;\n  }\n\n  profilerStartTime = now();\n\n  if (((fiber.actualStartTime: any): number) < 0) {\n    fiber.actualStartTime = now();\n  }\n}\n\nfunction stopProfilerTimerIfRunning(fiber: Fiber): void {\n  if (!enableProfilerTimer) {\n    return;\n  }\n  profilerStartTime = -1;\n}\n\nfunction stopProfilerTimerIfRunningAndRecordDelta(\n  fiber: Fiber,\n  overrideBaseTime: boolean,\n): void {\n  if (!enableProfilerTimer) {\n    return;\n  }\n\n  if (profilerStartTime >= 0) {\n    const elapsedTime = now() - profilerStartTime;\n    fiber.actualDuration += elapsedTime;\n    if (overrideBaseTime) {\n      fiber.selfBaseDuration = elapsedTime;\n    }\n    profilerStartTime = -1;\n  }\n}\n\nfunction recordLayoutEffectDuration(fiber: Fiber): void {\n  if (!enableProfilerTimer || !enableProfilerCommitHooks) {\n    return;\n  }\n\n  if (layoutEffectStartTime >= 0) {\n    const elapsedTime = now() - layoutEffectStartTime;\n\n    layoutEffectStartTime = -1;\n\n    // Store duration on the next nearest Profiler ancestor\n    // Or the root (for the DevTools Profiler to read)\n    let parentFiber = fiber.return;\n    while (parentFiber !== null) {\n      switch (parentFiber.tag) {\n        case HostRoot:\n          const root = parentFiber.stateNode;\n          root.effectDuration += elapsedTime;\n          return;\n        case Profiler:\n          const parentStateNode = parentFiber.stateNode;\n          parentStateNode.effectDuration += elapsedTime;\n          return;\n      }\n      parentFiber = parentFiber.return;\n    }\n  }\n}\n\nfunction recordPassiveEffectDuration(fiber: Fiber): void {\n  if (!enableProfilerTimer || !enableProfilerCommitHooks) {\n    return;\n  }\n\n  if (passiveEffectStartTime >= 0) {\n    const elapsedTime = now() - passiveEffectStartTime;\n\n    passiveEffectStartTime = -1;\n\n    // Store duration on the next nearest Profiler ancestor\n    // Or the root (for the DevTools Profiler to read)\n    let parentFiber = fiber.return;\n    while (parentFiber !== null) {\n      switch (parentFiber.tag) {\n        case HostRoot:\n          const root = parentFiber.stateNode;\n          if (root !== null) {\n            root.passiveEffectDuration += elapsedTime;\n          }\n          return;\n        case Profiler:\n          const parentStateNode = parentFiber.stateNode;\n          if (parentStateNode !== null) {\n            // Detached fibers have their state node cleared out.\n            // In this case, the return pointer is also cleared out,\n            // so we won't be able to report the time spent in this Profiler's subtree.\n            parentStateNode.passiveEffectDuration += elapsedTime;\n          }\n          return;\n      }\n      parentFiber = parentFiber.return;\n    }\n  }\n}\n\nfunction startLayoutEffectTimer(): void {\n  if (!enableProfilerTimer || !enableProfilerCommitHooks) {\n    return;\n  }\n  layoutEffectStartTime = now();\n}\n\nfunction startPassiveEffectTimer(): void {\n  if (!enableProfilerTimer || !enableProfilerCommitHooks) {\n    return;\n  }\n  passiveEffectStartTime = now();\n}\n\nfunction transferActualDuration(fiber: Fiber): void {\n  // Transfer time spent rendering these children so we don't lose it\n  // after we rerender. This is used as a helper in special cases\n  // where we should count the work of multiple passes.\n  let child = fiber.child;\n  while (child) {\n    fiber.actualDuration += child.actualDuration;\n    child = child.sibling;\n  }\n}\n\nexport {\n  getCommitTime,\n  isCurrentUpdateNested,\n  markNestedUpdateScheduled,\n  recordCommitTime,\n  recordLayoutEffectDuration,\n  recordPassiveEffectDuration,\n  resetNestedUpdateFlag,\n  startLayoutEffectTimer,\n  startPassiveEffectTimer,\n  startProfilerTimer,\n  stopProfilerTimerIfRunning,\n  stopProfilerTimerIfRunningAndRecordDelta,\n  syncNestedUpdateFlag,\n  transferActualDuration,\n};\n"]},"metadata":{},"sourceType":"module"}