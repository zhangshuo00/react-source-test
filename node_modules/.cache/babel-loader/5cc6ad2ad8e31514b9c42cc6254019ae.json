{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { canUseDOM } from 'shared/ExecutionEnvironment';\nimport { SyntheticEvent } from '../../events/SyntheticEvent';\nimport isTextInputElement from '../isTextInputElement';\nimport shallowEqual from 'shared/shallowEqual';\nimport { registerTwoPhaseEvent } from '../EventRegistry';\nimport getActiveElement from '../../client/getActiveElement';\nimport { getNodeFromInstance } from '../../client/ReactDOMComponentTree';\nimport { hasSelectionCapabilities } from '../../client/ReactInputSelection';\nimport { DOCUMENT_NODE } from '../../shared/HTMLNodeType';\nimport { accumulateTwoPhaseListeners } from '../DOMPluginEventSystem';\nconst skipSelectionChangeEvent = canUseDOM && 'documentMode' in document && document.documentMode <= 11;\n\nfunction registerEvents() {\n  registerTwoPhaseEvent('onSelect', ['focusout', 'contextmenu', 'dragend', 'focusin', 'keydown', 'keyup', 'mousedown', 'mouseup', 'selectionchange']);\n}\n\nlet activeElement = null;\nlet activeElementInst = null;\nlet lastSelection = null;\nlet mouseDown = false;\n/**\n * Get an object which is a unique representation of the current selection.\n *\n * The return value will not be consistent across nodes or browsers, but\n * two identical selections on the same node will return identical objects.\n */\n\nfunction getSelection(node) {\n  if ('selectionStart' in node && hasSelectionCapabilities(node)) {\n    return {\n      start: node.selectionStart,\n      end: node.selectionEnd\n    };\n  } else {\n    const win = node.ownerDocument && node.ownerDocument.defaultView || window;\n    const selection = win.getSelection();\n    return {\n      anchorNode: selection.anchorNode,\n      anchorOffset: selection.anchorOffset,\n      focusNode: selection.focusNode,\n      focusOffset: selection.focusOffset\n    };\n  }\n}\n/**\n * Get document associated with the event target.\n */\n\n\nfunction getEventTargetDocument(eventTarget) {\n  return eventTarget.window === eventTarget ? eventTarget.document : eventTarget.nodeType === DOCUMENT_NODE ? eventTarget : eventTarget.ownerDocument;\n}\n/**\n * Poll selection to see whether it's changed.\n *\n * @param {object} nativeEvent\n * @param {object} nativeEventTarget\n * @return {?SyntheticEvent}\n */\n\n\nfunction constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {\n  // Ensure we have the right element, and that the user is not dragging a\n  // selection (this matches native `select` event behavior). In HTML5, select\n  // fires only on input and textarea thus if there's no focused element we\n  // won't dispatch.\n  const doc = getEventTargetDocument(nativeEventTarget);\n\n  if (mouseDown || activeElement == null || activeElement !== getActiveElement(doc)) {\n    return;\n  } // Only fire when selection has actually changed.\n\n\n  const currentSelection = getSelection(activeElement);\n\n  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {\n    lastSelection = currentSelection;\n    const listeners = accumulateTwoPhaseListeners(activeElementInst, 'onSelect');\n\n    if (listeners.length > 0) {\n      const event = new SyntheticEvent('onSelect', 'select', null, nativeEvent, nativeEventTarget);\n      dispatchQueue.push({\n        event,\n        listeners\n      });\n      event.target = activeElement;\n    }\n  }\n}\n/**\n * This plugin creates an `onSelect` event that normalizes select events\n * across form elements.\n *\n * Supported elements are:\n * - input (see `isTextInputElement`)\n * - textarea\n * - contentEditable\n *\n * This differs from native browser implementations in the following ways:\n * - Fires on contentEditable fields as well as inputs.\n * - Fires for collapsed selection.\n * - Fires after user input.\n */\n\n\nfunction extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {\n  const targetNode = targetInst ? getNodeFromInstance(targetInst) : window;\n\n  switch (domEventName) {\n    // Track the input node that has focus.\n    case 'focusin':\n      if (isTextInputElement(targetNode) || targetNode.contentEditable === 'true') {\n        activeElement = targetNode;\n        activeElementInst = targetInst;\n        lastSelection = null;\n      }\n\n      break;\n\n    case 'focusout':\n      activeElement = null;\n      activeElementInst = null;\n      lastSelection = null;\n      break;\n    // Don't fire the event while the user is dragging. This matches the\n    // semantics of the native select event.\n\n    case 'mousedown':\n      mouseDown = true;\n      break;\n\n    case 'contextmenu':\n    case 'mouseup':\n    case 'dragend':\n      mouseDown = false;\n      constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);\n      break;\n    // Chrome and IE fire non-standard event when selection is changed (and\n    // sometimes when it hasn't). IE's event fires out of order with respect\n    // to key and input events on deletion, so we discard it.\n    //\n    // Firefox doesn't support selectionchange, so check selection status\n    // after each key entry. The selection changes after keydown and before\n    // keyup, but we check on keydown as well in the case of holding down a\n    // key, when multiple keydown events are fired but only one keyup is.\n    // This is also our approach for IE handling, for the reason above.\n\n    case 'selectionchange':\n      if (skipSelectionChangeEvent) {\n        break;\n      }\n\n    // falls through\n\n    case 'keydown':\n    case 'keyup':\n      constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);\n  }\n}\n\nexport { registerEvents, extractEvents };","map":{"version":3,"sources":["/Users/zhangshuo/git/react-source-test/src/react/packages/react-dom/src/events/plugins/SelectEventPlugin.js"],"names":["canUseDOM","SyntheticEvent","isTextInputElement","shallowEqual","registerTwoPhaseEvent","getActiveElement","getNodeFromInstance","hasSelectionCapabilities","DOCUMENT_NODE","accumulateTwoPhaseListeners","skipSelectionChangeEvent","document","documentMode","registerEvents","activeElement","activeElementInst","lastSelection","mouseDown","getSelection","node","start","selectionStart","end","selectionEnd","win","ownerDocument","defaultView","window","selection","anchorNode","anchorOffset","focusNode","focusOffset","getEventTargetDocument","eventTarget","nodeType","constructSelectEvent","dispatchQueue","nativeEvent","nativeEventTarget","doc","currentSelection","listeners","length","event","push","target","extractEvents","domEventName","targetInst","eventSystemFlags","targetContainer","targetNode","contentEditable"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {AnyNativeEvent} from '../PluginModuleType';\nimport type {DOMEventName} from '../DOMEventNames';\nimport type {DispatchQueue} from '../DOMPluginEventSystem';\nimport type {EventSystemFlags} from '../EventSystemFlags';\n\nimport {canUseDOM} from 'shared/ExecutionEnvironment';\nimport {SyntheticEvent} from '../../events/SyntheticEvent';\nimport isTextInputElement from '../isTextInputElement';\nimport shallowEqual from 'shared/shallowEqual';\n\nimport {registerTwoPhaseEvent} from '../EventRegistry';\nimport getActiveElement from '../../client/getActiveElement';\nimport {getNodeFromInstance} from '../../client/ReactDOMComponentTree';\nimport {hasSelectionCapabilities} from '../../client/ReactInputSelection';\nimport {DOCUMENT_NODE} from '../../shared/HTMLNodeType';\nimport {accumulateTwoPhaseListeners} from '../DOMPluginEventSystem';\n\nconst skipSelectionChangeEvent =\n  canUseDOM && 'documentMode' in document && document.documentMode <= 11;\n\nfunction registerEvents() {\n  registerTwoPhaseEvent('onSelect', [\n    'focusout',\n    'contextmenu',\n    'dragend',\n    'focusin',\n    'keydown',\n    'keyup',\n    'mousedown',\n    'mouseup',\n    'selectionchange',\n  ]);\n}\n\nlet activeElement = null;\nlet activeElementInst = null;\nlet lastSelection = null;\nlet mouseDown = false;\n\n/**\n * Get an object which is a unique representation of the current selection.\n *\n * The return value will not be consistent across nodes or browsers, but\n * two identical selections on the same node will return identical objects.\n */\nfunction getSelection(node: any) {\n  if ('selectionStart' in node && hasSelectionCapabilities(node)) {\n    return {\n      start: node.selectionStart,\n      end: node.selectionEnd,\n    };\n  } else {\n    const win =\n      (node.ownerDocument && node.ownerDocument.defaultView) || window;\n    const selection = win.getSelection();\n    return {\n      anchorNode: selection.anchorNode,\n      anchorOffset: selection.anchorOffset,\n      focusNode: selection.focusNode,\n      focusOffset: selection.focusOffset,\n    };\n  }\n}\n\n/**\n * Get document associated with the event target.\n */\nfunction getEventTargetDocument(eventTarget: any) {\n  return eventTarget.window === eventTarget\n    ? eventTarget.document\n    : eventTarget.nodeType === DOCUMENT_NODE\n    ? eventTarget\n    : eventTarget.ownerDocument;\n}\n\n/**\n * Poll selection to see whether it's changed.\n *\n * @param {object} nativeEvent\n * @param {object} nativeEventTarget\n * @return {?SyntheticEvent}\n */\nfunction constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {\n  // Ensure we have the right element, and that the user is not dragging a\n  // selection (this matches native `select` event behavior). In HTML5, select\n  // fires only on input and textarea thus if there's no focused element we\n  // won't dispatch.\n  const doc = getEventTargetDocument(nativeEventTarget);\n\n  if (\n    mouseDown ||\n    activeElement == null ||\n    activeElement !== getActiveElement(doc)\n  ) {\n    return;\n  }\n\n  // Only fire when selection has actually changed.\n  const currentSelection = getSelection(activeElement);\n  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {\n    lastSelection = currentSelection;\n\n    const listeners = accumulateTwoPhaseListeners(\n      activeElementInst,\n      'onSelect',\n    );\n    if (listeners.length > 0) {\n      const event = new SyntheticEvent(\n        'onSelect',\n        'select',\n        null,\n        nativeEvent,\n        nativeEventTarget,\n      );\n      dispatchQueue.push({event, listeners});\n      event.target = activeElement;\n    }\n  }\n}\n\n/**\n * This plugin creates an `onSelect` event that normalizes select events\n * across form elements.\n *\n * Supported elements are:\n * - input (see `isTextInputElement`)\n * - textarea\n * - contentEditable\n *\n * This differs from native browser implementations in the following ways:\n * - Fires on contentEditable fields as well as inputs.\n * - Fires for collapsed selection.\n * - Fires after user input.\n */\nfunction extractEvents(\n  dispatchQueue: DispatchQueue,\n  domEventName: DOMEventName,\n  targetInst: null | Fiber,\n  nativeEvent: AnyNativeEvent,\n  nativeEventTarget: null | EventTarget,\n  eventSystemFlags: EventSystemFlags,\n  targetContainer: EventTarget,\n) {\n  const targetNode = targetInst ? getNodeFromInstance(targetInst) : window;\n\n  switch (domEventName) {\n    // Track the input node that has focus.\n    case 'focusin':\n      if (\n        isTextInputElement((targetNode: any)) ||\n        targetNode.contentEditable === 'true'\n      ) {\n        activeElement = targetNode;\n        activeElementInst = targetInst;\n        lastSelection = null;\n      }\n      break;\n    case 'focusout':\n      activeElement = null;\n      activeElementInst = null;\n      lastSelection = null;\n      break;\n    // Don't fire the event while the user is dragging. This matches the\n    // semantics of the native select event.\n    case 'mousedown':\n      mouseDown = true;\n      break;\n    case 'contextmenu':\n    case 'mouseup':\n    case 'dragend':\n      mouseDown = false;\n      constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);\n      break;\n    // Chrome and IE fire non-standard event when selection is changed (and\n    // sometimes when it hasn't). IE's event fires out of order with respect\n    // to key and input events on deletion, so we discard it.\n    //\n    // Firefox doesn't support selectionchange, so check selection status\n    // after each key entry. The selection changes after keydown and before\n    // keyup, but we check on keydown as well in the case of holding down a\n    // key, when multiple keydown events are fired but only one keyup is.\n    // This is also our approach for IE handling, for the reason above.\n    case 'selectionchange':\n      if (skipSelectionChangeEvent) {\n        break;\n      }\n    // falls through\n    case 'keydown':\n    case 'keyup':\n      constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);\n  }\n}\n\nexport {registerEvents, extractEvents};\n"]},"metadata":{},"sourceType":"module"}