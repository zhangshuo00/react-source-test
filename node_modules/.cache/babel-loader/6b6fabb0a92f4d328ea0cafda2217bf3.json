{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { SHOULD_NOT_DEFER_CLICK_FOR_FB_SUPPORT_MODE, IS_LEGACY_FB_SUPPORT_MODE, SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS } from './EventSystemFlags';\nimport { allNativeEvents } from './EventRegistry';\nimport { IS_CAPTURE_PHASE, IS_EVENT_HANDLE_NON_MANAGED_NODE, IS_NON_DELEGATED } from './EventSystemFlags';\nimport { HostRoot, HostPortal, HostComponent, HostText, ScopeComponent } from 'react-reconciler/src/ReactWorkTags';\nimport getEventTarget from './getEventTarget';\nimport { getClosestInstanceFromNode, getEventListenerSet, getEventHandlerListeners } from '../client/ReactDOMComponentTree';\nimport { COMMENT_NODE } from '../shared/HTMLNodeType';\nimport { batchedUpdates } from './ReactDOMUpdateBatching';\nimport getListener from './getListener';\nimport { passiveBrowserEventsSupported } from './checkPassiveEvents';\nimport { enableLegacyFBSupport, enableCreateEventHandleAPI, enableScopeAPI } from 'shared/ReactFeatureFlags';\nimport { invokeGuardedCallbackAndCatchFirstError, rethrowCaughtError } from 'shared/ReactErrorUtils';\nimport { DOCUMENT_NODE } from '../shared/HTMLNodeType';\nimport { createEventListenerWrapperWithPriority } from './ReactDOMEventListener';\nimport { removeEventListener, addEventCaptureListener, addEventBubbleListener, addEventBubbleListenerWithPassiveFlag, addEventCaptureListenerWithPassiveFlag } from './EventListener';\nimport * as BeforeInputEventPlugin from './plugins/BeforeInputEventPlugin';\nimport * as ChangeEventPlugin from './plugins/ChangeEventPlugin';\nimport * as EnterLeaveEventPlugin from './plugins/EnterLeaveEventPlugin';\nimport * as SelectEventPlugin from './plugins/SelectEventPlugin';\nimport * as SimpleEventPlugin from './plugins/SimpleEventPlugin';\n// TODO: remove top-level side effect.\nSimpleEventPlugin.registerEvents();\nEnterLeaveEventPlugin.registerEvents();\nChangeEventPlugin.registerEvents();\nSelectEventPlugin.registerEvents();\nBeforeInputEventPlugin.registerEvents();\n\nfunction extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {\n  // TODO: we should remove the concept of a \"SimpleEventPlugin\".\n  // This is the basic functionality of the event system. All\n  // the other plugins are essentially polyfills. So the plugin\n  // should probably be inlined somewhere and have its logic\n  // be core the to event system. This would potentially allow\n  // us to ship builds of React without the polyfilled plugins below.\n  SimpleEventPlugin.extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer);\n  const shouldProcessPolyfillPlugins = (eventSystemFlags & SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS) === 0; // We don't process these events unless we are in the\n  // event's native \"bubble\" phase, which means that we're\n  // not in the capture phase. That's because we emulate\n  // the capture phase here still. This is a trade-off,\n  // because in an ideal world we would not emulate and use\n  // the phases properly, like we do with the SimpleEvent\n  // plugin. However, the plugins below either expect\n  // emulation (EnterLeave) or use state localized to that\n  // plugin (BeforeInput, Change, Select). The state in\n  // these modules complicates things, as you'll essentially\n  // get the case where the capture phase event might change\n  // state, only for the following bubble event to come in\n  // later and not trigger anything as the state now\n  // invalidates the heuristics of the event plugin. We\n  // could alter all these plugins to work in such ways, but\n  // that might cause other unknown side-effects that we\n  // can't foresee right now.\n\n  if (shouldProcessPolyfillPlugins) {\n    EnterLeaveEventPlugin.extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer);\n    ChangeEventPlugin.extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer);\n    SelectEventPlugin.extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer);\n    BeforeInputEventPlugin.extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer);\n  }\n} // List of events that need to be individually attached to media elements.\n\n\nexport const mediaEventTypes = ['abort', 'canplay', 'canplaythrough', 'durationchange', 'emptied', 'encrypted', 'ended', 'error', 'loadeddata', 'loadedmetadata', 'loadstart', 'pause', 'play', 'playing', 'progress', 'ratechange', 'resize', 'seeked', 'seeking', 'stalled', 'suspend', 'timeupdate', 'volumechange', 'waiting']; // We should not delegate these events to the container, but rather\n// set them on the actual target element itself. This is primarily\n// because these events do not consistently bubble in the DOM.\n\nexport const nonDelegatedEvents = new Set(['cancel', 'close', 'invalid', 'load', 'scroll', 'toggle', // In order to reduce bytes, we insert the above array of media events\n// into this Set. Note: the \"error\" event isn't an exclusive media event,\n// and can occur on other elements too. Rather than duplicate that event,\n// we just take it from the media events array.\n...mediaEventTypes]);\n\nfunction executeDispatch(event, listener, currentTarget) {\n  const type = event.type || 'unknown-event';\n  event.currentTarget = currentTarget;\n  invokeGuardedCallbackAndCatchFirstError(type, listener, undefined, event);\n  event.currentTarget = null;\n}\n\nfunction processDispatchQueueItemsInOrder(event, dispatchListeners, inCapturePhase) {\n  let previousInstance;\n\n  if (inCapturePhase) {\n    for (let i = dispatchListeners.length - 1; i >= 0; i--) {\n      const {\n        instance,\n        currentTarget,\n        listener\n      } = dispatchListeners[i];\n\n      if (instance !== previousInstance && event.isPropagationStopped()) {\n        return;\n      }\n\n      executeDispatch(event, listener, currentTarget);\n      previousInstance = instance;\n    }\n  } else {\n    for (let i = 0; i < dispatchListeners.length; i++) {\n      const {\n        instance,\n        currentTarget,\n        listener\n      } = dispatchListeners[i];\n\n      if (instance !== previousInstance && event.isPropagationStopped()) {\n        return;\n      }\n\n      executeDispatch(event, listener, currentTarget);\n      previousInstance = instance;\n    }\n  }\n}\n\nexport function processDispatchQueue(dispatchQueue, eventSystemFlags) {\n  const inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;\n\n  for (let i = 0; i < dispatchQueue.length; i++) {\n    const {\n      event,\n      listeners\n    } = dispatchQueue[i];\n    processDispatchQueueItemsInOrder(event, listeners, inCapturePhase); //  event system doesn't use pooling.\n  } // This would be a good time to rethrow if any of the event handlers threw.\n\n\n  rethrowCaughtError();\n}\n\nfunction dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {\n  const nativeEventTarget = getEventTarget(nativeEvent);\n  const dispatchQueue = [];\n  extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer);\n  processDispatchQueue(dispatchQueue, eventSystemFlags);\n}\n\nexport function listenToNonDelegatedEvent(domEventName, targetElement) {\n  if (__DEV__) {\n    if (!nonDelegatedEvents.has(domEventName)) {\n      console.error('Did not expect a listenToNonDelegatedEvent() call for \"%s\". ' + 'This is a bug in React. Please file an issue.', domEventName);\n    }\n  }\n\n  const isCapturePhaseListener = false;\n  const listenerSet = getEventListenerSet(targetElement);\n  const listenerSetKey = getListenerSetKey(domEventName, isCapturePhaseListener);\n\n  if (!listenerSet.has(listenerSetKey)) {\n    addTrappedEventListener(targetElement, domEventName, IS_NON_DELEGATED, isCapturePhaseListener);\n    listenerSet.add(listenerSetKey);\n  }\n}\nexport function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {\n  if (__DEV__) {\n    if (nonDelegatedEvents.has(domEventName) && !isCapturePhaseListener) {\n      console.error('Did not expect a listenToNativeEvent() call for \"%s\" in the bubble phase. ' + 'This is a bug in React. Please file an issue.', domEventName);\n    }\n  }\n\n  let eventSystemFlags = 0;\n\n  if (isCapturePhaseListener) {\n    eventSystemFlags |= IS_CAPTURE_PHASE;\n  }\n\n  addTrappedEventListener(target, domEventName, eventSystemFlags, isCapturePhaseListener);\n} // This is only used by createEventHandle when the\n// target is not a DOM element. E.g. window.\n\nexport function listenToNativeEventForNonManagedEventTarget(domEventName, isCapturePhaseListener, target) {\n  let eventSystemFlags = IS_EVENT_HANDLE_NON_MANAGED_NODE;\n  const listenerSet = getEventListenerSet(target);\n  const listenerSetKey = getListenerSetKey(domEventName, isCapturePhaseListener);\n\n  if (!listenerSet.has(listenerSetKey)) {\n    if (isCapturePhaseListener) {\n      eventSystemFlags |= IS_CAPTURE_PHASE;\n    }\n\n    addTrappedEventListener(target, domEventName, eventSystemFlags, isCapturePhaseListener);\n    listenerSet.add(listenerSetKey);\n  }\n}\nconst listeningMarker = '_reactListening' + Math.random().toString(36).slice(2);\nexport function listenToAllSupportedEvents(rootContainerElement) {\n  if (!rootContainerElement[listeningMarker]) {\n    rootContainerElement[listeningMarker] = true;\n    allNativeEvents.forEach(domEventName => {\n      // We handle selectionchange separately because it\n      // doesn't bubble and needs to be on the document.\n      if (domEventName !== 'selectionchange') {\n        if (!nonDelegatedEvents.has(domEventName)) {\n          listenToNativeEvent(domEventName, false, rootContainerElement);\n        }\n\n        listenToNativeEvent(domEventName, true, rootContainerElement);\n      }\n    });\n    const ownerDocument = rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;\n\n    if (ownerDocument !== null) {\n      // The selectionchange event also needs deduplication\n      // but it is attached to the document.\n      if (!ownerDocument[listeningMarker]) {\n        ownerDocument[listeningMarker] = true;\n        listenToNativeEvent('selectionchange', false, ownerDocument);\n      }\n    }\n  }\n}\n\nfunction addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener, isDeferredListenerForLegacyFBSupport) {\n  let listener = createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags); // If passive option is not supported, then the event will be\n  // active and not passive.\n\n  let isPassiveListener = undefined;\n\n  if (passiveBrowserEventsSupported) {\n    // Browsers introduced an intervention, making these events\n    // passive by default on document. React doesn't bind them\n    // to document anymore, but changing this now would undo\n    // the performance wins from the change. So we emulate\n    // the existing behavior manually on the roots now.\n    // https://github.com/facebook/react/issues/19651\n    if (domEventName === 'touchstart' || domEventName === 'touchmove' || domEventName === 'wheel') {\n      isPassiveListener = true;\n    }\n  }\n\n  targetContainer = enableLegacyFBSupport && isDeferredListenerForLegacyFBSupport ? targetContainer.ownerDocument : targetContainer;\n  let unsubscribeListener; // When legacyFBSupport is enabled, it's for when we\n  // want to add a one time event listener to a container.\n  // This should only be used with enableLegacyFBSupport\n  // due to requirement to provide compatibility with\n  // internal FB www event tooling. This works by removing\n  // the event listener as soon as it is invoked. We could\n  // also attempt to use the {once: true} param on\n  // addEventListener, but that requires support and some\n  // browsers do not support this today, and given this is\n  // to support legacy code patterns, it's likely they'll\n  // need support for such browsers.\n\n  if (enableLegacyFBSupport && isDeferredListenerForLegacyFBSupport) {\n    const originalListener = listener;\n\n    listener = function (...p) {\n      removeEventListener(targetContainer, domEventName, unsubscribeListener, isCapturePhaseListener);\n      return originalListener.apply(this, p);\n    };\n  } // TODO: There are too many combinations here. Consolidate them.\n\n\n  if (isCapturePhaseListener) {\n    if (isPassiveListener !== undefined) {\n      unsubscribeListener = addEventCaptureListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener);\n    } else {\n      unsubscribeListener = addEventCaptureListener(targetContainer, domEventName, listener);\n    }\n  } else {\n    if (isPassiveListener !== undefined) {\n      unsubscribeListener = addEventBubbleListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener);\n    } else {\n      unsubscribeListener = addEventBubbleListener(targetContainer, domEventName, listener);\n    }\n  }\n}\n\nfunction deferClickToDocumentForLegacyFBSupport(domEventName, targetContainer) {\n  // We defer all click events with legacy FB support mode on.\n  // This means we add a one time event listener to trigger\n  // after the FB delegated listeners fire.\n  const isDeferredListenerForLegacyFBSupport = true;\n  addTrappedEventListener(targetContainer, domEventName, IS_LEGACY_FB_SUPPORT_MODE, false, isDeferredListenerForLegacyFBSupport);\n}\n\nfunction isMatchingRootContainer(grandContainer, targetContainer) {\n  return grandContainer === targetContainer || grandContainer.nodeType === COMMENT_NODE && grandContainer.parentNode === targetContainer;\n}\n\nexport function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {\n  let ancestorInst = targetInst;\n\n  if ((eventSystemFlags & IS_EVENT_HANDLE_NON_MANAGED_NODE) === 0 && (eventSystemFlags & IS_NON_DELEGATED) === 0) {\n    const targetContainerNode = targetContainer; // If we are using the legacy FB support flag, we\n    // defer the event to the null with a one\n    // time event listener so we can defer the event.\n\n    if (enableLegacyFBSupport && // If our event flags match the required flags for entering\n    // FB legacy mode and we are processing the \"click\" event,\n    // then we can defer the event to the \"document\", to allow\n    // for legacy FB support, where the expected behavior was to\n    // match React < 16 behavior of delegated clicks to the doc.\n    domEventName === 'click' && (eventSystemFlags & SHOULD_NOT_DEFER_CLICK_FOR_FB_SUPPORT_MODE) === 0) {\n      deferClickToDocumentForLegacyFBSupport(domEventName, targetContainer);\n      return;\n    }\n\n    if (targetInst !== null) {\n      // The below logic attempts to work out if we need to change\n      // the target fiber to a different ancestor. We had similar logic\n      // in the legacy event system, except the big difference between\n      // systems is that the modern event system now has an event listener\n      // attached to each React Root and React Portal Root. Together,\n      // the DOM nodes representing these roots are the \"rootContainer\".\n      // To figure out which ancestor instance we should use, we traverse\n      // up the fiber tree from the target instance and attempt to find\n      // root boundaries that match that of our current \"rootContainer\".\n      // If we find that \"rootContainer\", we find the parent fiber\n      // sub-tree for that root and make that our ancestor instance.\n      let node = targetInst;\n\n      mainLoop: while (true) {\n        if (node === null) {\n          return;\n        }\n\n        const nodeTag = node.tag;\n\n        if (nodeTag === HostRoot || nodeTag === HostPortal) {\n          let container = node.stateNode.containerInfo;\n\n          if (isMatchingRootContainer(container, targetContainerNode)) {\n            break;\n          }\n\n          if (nodeTag === HostPortal) {\n            // The target is a portal, but it's not the rootContainer we're looking for.\n            // Normally portals handle their own events all the way down to the root.\n            // So we should be able to stop now. However, we don't know if this portal\n            // was part of *our* root.\n            let grandNode = node.return;\n\n            while (grandNode !== null) {\n              const grandTag = grandNode.tag;\n\n              if (grandTag === HostRoot || grandTag === HostPortal) {\n                const grandContainer = grandNode.stateNode.containerInfo;\n\n                if (isMatchingRootContainer(grandContainer, targetContainerNode)) {\n                  // This is the rootContainer we're looking for and we found it as\n                  // a parent of the Portal. That means we can ignore it because the\n                  // Portal will bubble through to us.\n                  return;\n                }\n              }\n\n              grandNode = grandNode.return;\n            }\n          } // Now we need to find it's corresponding host fiber in the other\n          // tree. To do this we can use getClosestInstanceFromNode, but we\n          // need to validate that the fiber is a host instance, otherwise\n          // we need to traverse up through the DOM till we find the correct\n          // node that is from the other tree.\n\n\n          while (container !== null) {\n            const parentNode = getClosestInstanceFromNode(container);\n\n            if (parentNode === null) {\n              return;\n            }\n\n            const parentTag = parentNode.tag;\n\n            if (parentTag === HostComponent || parentTag === HostText) {\n              node = ancestorInst = parentNode;\n              continue mainLoop;\n            }\n\n            container = container.parentNode;\n          }\n        }\n\n        node = node.return;\n      }\n    }\n  }\n\n  batchedUpdates(() => dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, ancestorInst, targetContainer));\n}\n\nfunction createDispatchListener(instance, listener, currentTarget) {\n  return {\n    instance,\n    listener,\n    currentTarget\n  };\n}\n\nexport function accumulateSinglePhaseListeners(targetFiber, reactName, nativeEventType, inCapturePhase, accumulateTargetOnly, nativeEvent) {\n  const captureName = reactName !== null ? reactName + 'Capture' : null;\n  const reactEventName = inCapturePhase ? captureName : reactName;\n  let listeners = [];\n  let instance = targetFiber;\n  let lastHostComponent = null; // Accumulate all instances and listeners via the target -> root path.\n\n  while (instance !== null) {\n    const {\n      stateNode,\n      tag\n    } = instance; // Handle listeners that are on HostComponents (i.e. <div>)\n\n    if (tag === HostComponent && stateNode !== null) {\n      lastHostComponent = stateNode; // createEventHandle listeners\n\n      if (enableCreateEventHandleAPI) {\n        const eventHandlerListeners = getEventHandlerListeners(lastHostComponent);\n\n        if (eventHandlerListeners !== null) {\n          eventHandlerListeners.forEach(entry => {\n            if (entry.type === nativeEventType && entry.capture === inCapturePhase) {\n              listeners.push(createDispatchListener(instance, entry.callback, lastHostComponent));\n            }\n          });\n        }\n      } // Standard React on* listeners, i.e. onClick or onClickCapture\n\n\n      if (reactEventName !== null) {\n        const listener = getListener(instance, reactEventName);\n\n        if (listener != null) {\n          listeners.push(createDispatchListener(instance, listener, lastHostComponent));\n        }\n      }\n    } else if (enableCreateEventHandleAPI && enableScopeAPI && tag === ScopeComponent && lastHostComponent !== null && stateNode !== null) {\n      // Scopes\n      const reactScopeInstance = stateNode;\n      const eventHandlerListeners = getEventHandlerListeners(reactScopeInstance);\n\n      if (eventHandlerListeners !== null) {\n        eventHandlerListeners.forEach(entry => {\n          if (entry.type === nativeEventType && entry.capture === inCapturePhase) {\n            listeners.push(createDispatchListener(instance, entry.callback, lastHostComponent));\n          }\n        });\n      }\n    } // If we are only accumulating events for the target, then we don't\n    // continue to propagate through the React fiber tree to find other\n    // listeners.\n\n\n    if (accumulateTargetOnly) {\n      break;\n    } // If we are processing the onBeforeBlur event, then we need to take\n    // into consideration that part of the React tree might have been hidden\n    // or deleted (as we're invoking this event during commit). We can find\n    // this out by checking if intercept fiber set on the event matches the\n    // current instance fiber. In which case, we should clear all existing\n    // listeners.\n\n\n    if (enableCreateEventHandleAPI && nativeEvent.type === 'beforeblur') {\n      // $FlowFixMe: internal field\n      const detachedInterceptFiber = nativeEvent._detachedInterceptFiber;\n\n      if (detachedInterceptFiber !== null && (detachedInterceptFiber === instance || detachedInterceptFiber === instance.alternate)) {\n        listeners = [];\n      }\n    }\n\n    instance = instance.return;\n  }\n\n  return listeners;\n} // We should only use this function for:\n// - BeforeInputEventPlugin\n// - ChangeEventPlugin\n// - SelectEventPlugin\n// This is because we only process these plugins\n// in the bubble phase, so we need to accumulate two\n// phase event listeners (via emulation).\n\nexport function accumulateTwoPhaseListeners(targetFiber, reactName) {\n  const captureName = reactName + 'Capture';\n  const listeners = [];\n  let instance = targetFiber; // Accumulate all instances and listeners via the target -> root path.\n\n  while (instance !== null) {\n    const {\n      stateNode,\n      tag\n    } = instance; // Handle listeners that are on HostComponents (i.e. <div>)\n\n    if (tag === HostComponent && stateNode !== null) {\n      const currentTarget = stateNode;\n      const captureListener = getListener(instance, captureName);\n\n      if (captureListener != null) {\n        listeners.unshift(createDispatchListener(instance, captureListener, currentTarget));\n      }\n\n      const bubbleListener = getListener(instance, reactName);\n\n      if (bubbleListener != null) {\n        listeners.push(createDispatchListener(instance, bubbleListener, currentTarget));\n      }\n    }\n\n    instance = instance.return;\n  }\n\n  return listeners;\n}\n\nfunction getParent(inst) {\n  if (inst === null) {\n    return null;\n  }\n\n  do {\n    inst = inst.return; // TODO: If this is a HostRoot we might want to bail out.\n    // That is depending on if we want nested subtrees (layers) to bubble\n    // events to their parent. We could also go through parentNode on the\n    // host node but that wouldn't work for React Native and doesn't let us\n    // do the portal feature.\n  } while (inst && inst.tag !== HostComponent);\n\n  if (inst) {\n    return inst;\n  }\n\n  return null;\n}\n/**\n * Return the lowest common ancestor of A and B, or null if they are in\n * different trees.\n */\n\n\nfunction getLowestCommonAncestor(instA, instB) {\n  let nodeA = instA;\n  let nodeB = instB;\n  let depthA = 0;\n\n  for (let tempA = nodeA; tempA; tempA = getParent(tempA)) {\n    depthA++;\n  }\n\n  let depthB = 0;\n\n  for (let tempB = nodeB; tempB; tempB = getParent(tempB)) {\n    depthB++;\n  } // If A is deeper, crawl up.\n\n\n  while (depthA - depthB > 0) {\n    nodeA = getParent(nodeA);\n    depthA--;\n  } // If B is deeper, crawl up.\n\n\n  while (depthB - depthA > 0) {\n    nodeB = getParent(nodeB);\n    depthB--;\n  } // Walk in lockstep until we find a match.\n\n\n  let depth = depthA;\n\n  while (depth--) {\n    if (nodeA === nodeB || nodeB !== null && nodeA === nodeB.alternate) {\n      return nodeA;\n    }\n\n    nodeA = getParent(nodeA);\n    nodeB = getParent(nodeB);\n  }\n\n  return null;\n}\n\nfunction accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {\n  const registrationName = event._reactName;\n  const listeners = [];\n  let instance = target;\n\n  while (instance !== null) {\n    if (instance === common) {\n      break;\n    }\n\n    const {\n      alternate,\n      stateNode,\n      tag\n    } = instance;\n\n    if (alternate !== null && alternate === common) {\n      break;\n    }\n\n    if (tag === HostComponent && stateNode !== null) {\n      const currentTarget = stateNode;\n\n      if (inCapturePhase) {\n        const captureListener = getListener(instance, registrationName);\n\n        if (captureListener != null) {\n          listeners.unshift(createDispatchListener(instance, captureListener, currentTarget));\n        }\n      } else if (!inCapturePhase) {\n        const bubbleListener = getListener(instance, registrationName);\n\n        if (bubbleListener != null) {\n          listeners.push(createDispatchListener(instance, bubbleListener, currentTarget));\n        }\n      }\n    }\n\n    instance = instance.return;\n  }\n\n  if (listeners.length !== 0) {\n    dispatchQueue.push({\n      event,\n      listeners\n    });\n  }\n} // We should only use this function for:\n// - EnterLeaveEventPlugin\n// This is because we only process this plugin\n// in the bubble phase, so we need to accumulate two\n// phase event listeners.\n\n\nexport function accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leaveEvent, enterEvent, from, to) {\n  const common = from && to ? getLowestCommonAncestor(from, to) : null;\n\n  if (from !== null) {\n    accumulateEnterLeaveListenersForEvent(dispatchQueue, leaveEvent, from, common, false);\n  }\n\n  if (to !== null && enterEvent !== null) {\n    accumulateEnterLeaveListenersForEvent(dispatchQueue, enterEvent, to, common, true);\n  }\n}\nexport function accumulateEventHandleNonManagedNodeListeners(reactEventType, currentTarget, inCapturePhase) {\n  const listeners = [];\n  const eventListeners = getEventHandlerListeners(currentTarget);\n\n  if (eventListeners !== null) {\n    eventListeners.forEach(entry => {\n      if (entry.type === reactEventType && entry.capture === inCapturePhase) {\n        listeners.push(createDispatchListener(null, entry.callback, currentTarget));\n      }\n    });\n  }\n\n  return listeners;\n}\nexport function getListenerSetKey(domEventName, capture) {\n  return `${domEventName}__${capture ? 'capture' : 'bubble'}`;\n}","map":{"version":3,"sources":["/Users/zhangshuo/git/react-source-test/src/react/packages/react-dom/src/events/DOMPluginEventSystem.js"],"names":["SHOULD_NOT_DEFER_CLICK_FOR_FB_SUPPORT_MODE","IS_LEGACY_FB_SUPPORT_MODE","SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS","allNativeEvents","IS_CAPTURE_PHASE","IS_EVENT_HANDLE_NON_MANAGED_NODE","IS_NON_DELEGATED","HostRoot","HostPortal","HostComponent","HostText","ScopeComponent","getEventTarget","getClosestInstanceFromNode","getEventListenerSet","getEventHandlerListeners","COMMENT_NODE","batchedUpdates","getListener","passiveBrowserEventsSupported","enableLegacyFBSupport","enableCreateEventHandleAPI","enableScopeAPI","invokeGuardedCallbackAndCatchFirstError","rethrowCaughtError","DOCUMENT_NODE","createEventListenerWrapperWithPriority","removeEventListener","addEventCaptureListener","addEventBubbleListener","addEventBubbleListenerWithPassiveFlag","addEventCaptureListenerWithPassiveFlag","BeforeInputEventPlugin","ChangeEventPlugin","EnterLeaveEventPlugin","SelectEventPlugin","SimpleEventPlugin","registerEvents","extractEvents","dispatchQueue","domEventName","targetInst","nativeEvent","nativeEventTarget","eventSystemFlags","targetContainer","shouldProcessPolyfillPlugins","mediaEventTypes","nonDelegatedEvents","Set","executeDispatch","event","listener","currentTarget","type","undefined","processDispatchQueueItemsInOrder","dispatchListeners","inCapturePhase","previousInstance","i","length","instance","isPropagationStopped","processDispatchQueue","listeners","dispatchEventsForPlugins","listenToNonDelegatedEvent","targetElement","__DEV__","has","console","error","isCapturePhaseListener","listenerSet","listenerSetKey","getListenerSetKey","addTrappedEventListener","add","listenToNativeEvent","target","listenToNativeEventForNonManagedEventTarget","listeningMarker","Math","random","toString","slice","listenToAllSupportedEvents","rootContainerElement","forEach","ownerDocument","nodeType","isDeferredListenerForLegacyFBSupport","isPassiveListener","unsubscribeListener","originalListener","p","apply","deferClickToDocumentForLegacyFBSupport","isMatchingRootContainer","grandContainer","parentNode","dispatchEventForPluginEventSystem","ancestorInst","targetContainerNode","node","mainLoop","nodeTag","tag","container","stateNode","containerInfo","grandNode","return","grandTag","parentTag","createDispatchListener","accumulateSinglePhaseListeners","targetFiber","reactName","nativeEventType","accumulateTargetOnly","captureName","reactEventName","lastHostComponent","eventHandlerListeners","entry","capture","push","callback","reactScopeInstance","detachedInterceptFiber","_detachedInterceptFiber","alternate","accumulateTwoPhaseListeners","captureListener","unshift","bubbleListener","getParent","inst","getLowestCommonAncestor","instA","instB","nodeA","nodeB","depthA","tempA","depthB","tempB","depth","accumulateEnterLeaveListenersForEvent","common","registrationName","_reactName","accumulateEnterLeaveTwoPhaseListeners","leaveEvent","enterEvent","from","to","accumulateEventHandleNonManagedNodeListeners","reactEventType","eventListeners"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA,SAEEA,0CAFF,EAGEC,yBAHF,EAIEC,yCAJF,QAKO,oBALP;AAaA,SAAQC,eAAR,QAA8B,iBAA9B;AACA,SACEC,gBADF,EAEEC,gCAFF,EAGEC,gBAHF,QAIO,oBAJP;AAMA,SACEC,QADF,EAEEC,UAFF,EAGEC,aAHF,EAIEC,QAJF,EAKEC,cALF,QAMO,oCANP;AAQA,OAAOC,cAAP,MAA2B,kBAA3B;AACA,SACEC,0BADF,EAEEC,mBAFF,EAGEC,wBAHF,QAIO,iCAJP;AAKA,SAAQC,YAAR,QAA2B,wBAA3B;AACA,SAAQC,cAAR,QAA6B,0BAA7B;AACA,OAAOC,WAAP,MAAwB,eAAxB;AACA,SAAQC,6BAAR,QAA4C,sBAA5C;AAEA,SACEC,qBADF,EAEEC,0BAFF,EAGEC,cAHF,QAIO,0BAJP;AAKA,SACEC,uCADF,EAEEC,kBAFF,QAGO,wBAHP;AAIA,SAAQC,aAAR,QAA4B,wBAA5B;AACA,SAAQC,sCAAR,QAAqD,yBAArD;AACA,SACEC,mBADF,EAEEC,uBAFF,EAGEC,sBAHF,EAIEC,qCAJF,EAKEC,sCALF,QAMO,iBANP;AAOA,OAAO,KAAKC,sBAAZ,MAAwC,kCAAxC;AACA,OAAO,KAAKC,iBAAZ,MAAmC,6BAAnC;AACA,OAAO,KAAKC,qBAAZ,MAAuC,iCAAvC;AACA,OAAO,KAAKC,iBAAZ,MAAmC,6BAAnC;AACA,OAAO,KAAKC,iBAAZ,MAAmC,6BAAnC;AAeA;AACAA,iBAAiB,CAACC,cAAlB;AACAH,qBAAqB,CAACG,cAAtB;AACAJ,iBAAiB,CAACI,cAAlB;AACAF,iBAAiB,CAACE,cAAlB;AACAL,sBAAsB,CAACK,cAAvB;;AAEA,SAASC,aAAT,CACEC,aADF,EAEEC,YAFF,EAGEC,UAHF,EAIEC,WAJF,EAKEC,iBALF,EAMEC,gBANF,EAOEC,eAPF,EAQE;AACA;AACA;AACA;AACA;AACA;AACA;AACAT,EAAAA,iBAAiB,CAACE,aAAlB,CACEC,aADF,EAEEC,YAFF,EAGEC,UAHF,EAIEC,WAJF,EAKEC,iBALF,EAMEC,gBANF,EAOEC,eAPF;AASA,QAAMC,4BAA4B,GAChC,CAACF,gBAAgB,GAAG1C,yCAApB,MAAmE,CADrE,CAhBA,CAkBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAI4C,4BAAJ,EAAkC;AAChCZ,IAAAA,qBAAqB,CAACI,aAAtB,CACEC,aADF,EAEEC,YAFF,EAGEC,UAHF,EAIEC,WAJF,EAKEC,iBALF,EAMEC,gBANF,EAOEC,eAPF;AASAZ,IAAAA,iBAAiB,CAACK,aAAlB,CACEC,aADF,EAEEC,YAFF,EAGEC,UAHF,EAIEC,WAJF,EAKEC,iBALF,EAMEC,gBANF,EAOEC,eAPF;AASAV,IAAAA,iBAAiB,CAACG,aAAlB,CACEC,aADF,EAEEC,YAFF,EAGEC,UAHF,EAIEC,WAJF,EAKEC,iBALF,EAMEC,gBANF,EAOEC,eAPF;AASAb,IAAAA,sBAAsB,CAACM,aAAvB,CACEC,aADF,EAEEC,YAFF,EAGEC,UAHF,EAIEC,WAJF,EAKEC,iBALF,EAMEC,gBANF,EAOEC,eAPF;AASD;AACF,C,CAED;;;AACA,OAAO,MAAME,eAAoC,GAAG,CAClD,OADkD,EAElD,SAFkD,EAGlD,gBAHkD,EAIlD,gBAJkD,EAKlD,SALkD,EAMlD,WANkD,EAOlD,OAPkD,EAQlD,OARkD,EASlD,YATkD,EAUlD,gBAVkD,EAWlD,WAXkD,EAYlD,OAZkD,EAalD,MAbkD,EAclD,SAdkD,EAelD,UAfkD,EAgBlD,YAhBkD,EAiBlD,QAjBkD,EAkBlD,QAlBkD,EAmBlD,SAnBkD,EAoBlD,SApBkD,EAqBlD,SArBkD,EAsBlD,YAtBkD,EAuBlD,cAvBkD,EAwBlD,SAxBkD,CAA7C,C,CA2BP;AACA;AACA;;AACA,OAAO,MAAMC,kBAAqC,GAAG,IAAIC,GAAJ,CAAQ,CAC3D,QAD2D,EAE3D,OAF2D,EAG3D,SAH2D,EAI3D,MAJ2D,EAK3D,QAL2D,EAM3D,QAN2D,EAO3D;AACA;AACA;AACA;AACA,GAAGF,eAXwD,CAAR,CAA9C;;AAcP,SAASG,eAAT,CACEC,KADF,EAEEC,QAFF,EAGEC,aAHF,EAIQ;AACN,QAAMC,IAAI,GAAGH,KAAK,CAACG,IAAN,IAAc,eAA3B;AACAH,EAAAA,KAAK,CAACE,aAAN,GAAsBA,aAAtB;AACA9B,EAAAA,uCAAuC,CAAC+B,IAAD,EAAOF,QAAP,EAAiBG,SAAjB,EAA4BJ,KAA5B,CAAvC;AACAA,EAAAA,KAAK,CAACE,aAAN,GAAsB,IAAtB;AACD;;AAED,SAASG,gCAAT,CACEL,KADF,EAEEM,iBAFF,EAGEC,cAHF,EAIQ;AACN,MAAIC,gBAAJ;;AACA,MAAID,cAAJ,EAAoB;AAClB,SAAK,IAAIE,CAAC,GAAGH,iBAAiB,CAACI,MAAlB,GAA2B,CAAxC,EAA2CD,CAAC,IAAI,CAAhD,EAAmDA,CAAC,EAApD,EAAwD;AACtD,YAAM;AAACE,QAAAA,QAAD;AAAWT,QAAAA,aAAX;AAA0BD,QAAAA;AAA1B,UAAsCK,iBAAiB,CAACG,CAAD,CAA7D;;AACA,UAAIE,QAAQ,KAAKH,gBAAb,IAAiCR,KAAK,CAACY,oBAAN,EAArC,EAAmE;AACjE;AACD;;AACDb,MAAAA,eAAe,CAACC,KAAD,EAAQC,QAAR,EAAkBC,aAAlB,CAAf;AACAM,MAAAA,gBAAgB,GAAGG,QAAnB;AACD;AACF,GATD,MASO;AACL,SAAK,IAAIF,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,iBAAiB,CAACI,MAAtC,EAA8CD,CAAC,EAA/C,EAAmD;AACjD,YAAM;AAACE,QAAAA,QAAD;AAAWT,QAAAA,aAAX;AAA0BD,QAAAA;AAA1B,UAAsCK,iBAAiB,CAACG,CAAD,CAA7D;;AACA,UAAIE,QAAQ,KAAKH,gBAAb,IAAiCR,KAAK,CAACY,oBAAN,EAArC,EAAmE;AACjE;AACD;;AACDb,MAAAA,eAAe,CAACC,KAAD,EAAQC,QAAR,EAAkBC,aAAlB,CAAf;AACAM,MAAAA,gBAAgB,GAAGG,QAAnB;AACD;AACF;AACF;;AAED,OAAO,SAASE,oBAAT,CACLzB,aADK,EAELK,gBAFK,EAGC;AACN,QAAMc,cAAc,GAAG,CAACd,gBAAgB,GAAGxC,gBAApB,MAA0C,CAAjE;;AACA,OAAK,IAAIwD,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGrB,aAAa,CAACsB,MAAlC,EAA0CD,CAAC,EAA3C,EAA+C;AAC7C,UAAM;AAACT,MAAAA,KAAD;AAAQc,MAAAA;AAAR,QAAqB1B,aAAa,CAACqB,CAAD,CAAxC;AACAJ,IAAAA,gCAAgC,CAACL,KAAD,EAAQc,SAAR,EAAmBP,cAAnB,CAAhC,CAF6C,CAG7C;AACD,GANK,CAON;;;AACAlC,EAAAA,kBAAkB;AACnB;;AAED,SAAS0C,wBAAT,CACE1B,YADF,EAEEI,gBAFF,EAGEF,WAHF,EAIED,UAJF,EAKEI,eALF,EAMQ;AACN,QAAMF,iBAAiB,GAAG/B,cAAc,CAAC8B,WAAD,CAAxC;AACA,QAAMH,aAA4B,GAAG,EAArC;AACAD,EAAAA,aAAa,CACXC,aADW,EAEXC,YAFW,EAGXC,UAHW,EAIXC,WAJW,EAKXC,iBALW,EAMXC,gBANW,EAOXC,eAPW,CAAb;AASAmB,EAAAA,oBAAoB,CAACzB,aAAD,EAAgBK,gBAAhB,CAApB;AACD;;AAED,OAAO,SAASuB,yBAAT,CACL3B,YADK,EAEL4B,aAFK,EAGC;AACN,MAAIC,OAAJ,EAAa;AACX,QAAI,CAACrB,kBAAkB,CAACsB,GAAnB,CAAuB9B,YAAvB,CAAL,EAA2C;AACzC+B,MAAAA,OAAO,CAACC,KAAR,CACE,iEACE,+CAFJ,EAGEhC,YAHF;AAKD;AACF;;AACD,QAAMiC,sBAAsB,GAAG,KAA/B;AACA,QAAMC,WAAW,GAAG5D,mBAAmB,CAACsD,aAAD,CAAvC;AACA,QAAMO,cAAc,GAAGC,iBAAiB,CACtCpC,YADsC,EAEtCiC,sBAFsC,CAAxC;;AAIA,MAAI,CAACC,WAAW,CAACJ,GAAZ,CAAgBK,cAAhB,CAAL,EAAsC;AACpCE,IAAAA,uBAAuB,CACrBT,aADqB,EAErB5B,YAFqB,EAGrBlC,gBAHqB,EAIrBmE,sBAJqB,CAAvB;AAMAC,IAAAA,WAAW,CAACI,GAAZ,CAAgBH,cAAhB;AACD;AACF;AAED,OAAO,SAASI,mBAAT,CACLvC,YADK,EAELiC,sBAFK,EAGLO,MAHK,EAIC;AACN,MAAIX,OAAJ,EAAa;AACX,QAAIrB,kBAAkB,CAACsB,GAAnB,CAAuB9B,YAAvB,KAAwC,CAACiC,sBAA7C,EAAqE;AACnEF,MAAAA,OAAO,CAACC,KAAR,CACE,+EACE,+CAFJ,EAGEhC,YAHF;AAKD;AACF;;AAED,MAAII,gBAAgB,GAAG,CAAvB;;AACA,MAAI6B,sBAAJ,EAA4B;AAC1B7B,IAAAA,gBAAgB,IAAIxC,gBAApB;AACD;;AACDyE,EAAAA,uBAAuB,CACrBG,MADqB,EAErBxC,YAFqB,EAGrBI,gBAHqB,EAIrB6B,sBAJqB,CAAvB;AAMD,C,CAED;AACA;;AACA,OAAO,SAASQ,2CAAT,CACLzC,YADK,EAELiC,sBAFK,EAGLO,MAHK,EAIC;AACN,MAAIpC,gBAAgB,GAAGvC,gCAAvB;AACA,QAAMqE,WAAW,GAAG5D,mBAAmB,CAACkE,MAAD,CAAvC;AACA,QAAML,cAAc,GAAGC,iBAAiB,CACtCpC,YADsC,EAEtCiC,sBAFsC,CAAxC;;AAIA,MAAI,CAACC,WAAW,CAACJ,GAAZ,CAAgBK,cAAhB,CAAL,EAAsC;AACpC,QAAIF,sBAAJ,EAA4B;AAC1B7B,MAAAA,gBAAgB,IAAIxC,gBAApB;AACD;;AACDyE,IAAAA,uBAAuB,CACrBG,MADqB,EAErBxC,YAFqB,EAGrBI,gBAHqB,EAIrB6B,sBAJqB,CAAvB;AAMAC,IAAAA,WAAW,CAACI,GAAZ,CAAgBH,cAAhB;AACD;AACF;AAED,MAAMO,eAAe,GACnB,oBACAC,IAAI,CAACC,MAAL,GACGC,QADH,CACY,EADZ,EAEGC,KAFH,CAES,CAFT,CAFF;AAMA,OAAO,SAASC,0BAAT,CAAoCC,oBAApC,EAAuE;AAC5E,MAAI,CAAEA,oBAAD,CAA4BN,eAA5B,CAAL,EAAmD;AAChDM,IAAAA,oBAAD,CAA4BN,eAA5B,IAA+C,IAA/C;AACA/E,IAAAA,eAAe,CAACsF,OAAhB,CAAwBjD,YAAY,IAAI;AACtC;AACA;AACA,UAAIA,YAAY,KAAK,iBAArB,EAAwC;AACtC,YAAI,CAACQ,kBAAkB,CAACsB,GAAnB,CAAuB9B,YAAvB,CAAL,EAA2C;AACzCuC,UAAAA,mBAAmB,CAACvC,YAAD,EAAe,KAAf,EAAsBgD,oBAAtB,CAAnB;AACD;;AACDT,QAAAA,mBAAmB,CAACvC,YAAD,EAAe,IAAf,EAAqBgD,oBAArB,CAAnB;AACD;AACF,KATD;AAUA,UAAME,aAAa,GAChBF,oBAAD,CAA4BG,QAA5B,KAAyClE,aAAzC,GACI+D,oBADJ,GAEKA,oBAAD,CAA4BE,aAHlC;;AAIA,QAAIA,aAAa,KAAK,IAAtB,EAA4B;AAC1B;AACA;AACA,UAAI,CAAEA,aAAD,CAAqBR,eAArB,CAAL,EAA4C;AACzCQ,QAAAA,aAAD,CAAqBR,eAArB,IAAwC,IAAxC;AACAH,QAAAA,mBAAmB,CAAC,iBAAD,EAAoB,KAApB,EAA2BW,aAA3B,CAAnB;AACD;AACF;AACF;AACF;;AAED,SAASb,uBAAT,CACEhC,eADF,EAEEL,YAFF,EAGEI,gBAHF,EAIE6B,sBAJF,EAKEmB,oCALF,EAME;AACA,MAAIxC,QAAQ,GAAG1B,sCAAsC,CACnDmB,eADmD,EAEnDL,YAFmD,EAGnDI,gBAHmD,CAArD,CADA,CAMA;AACA;;AACA,MAAIiD,iBAAiB,GAAGtC,SAAxB;;AACA,MAAIpC,6BAAJ,EAAmC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,QACEqB,YAAY,KAAK,YAAjB,IACAA,YAAY,KAAK,WADjB,IAEAA,YAAY,KAAK,OAHnB,EAIE;AACAqD,MAAAA,iBAAiB,GAAG,IAApB;AACD;AACF;;AAEDhD,EAAAA,eAAe,GACbzB,qBAAqB,IAAIwE,oCAAzB,GACK/C,eAAD,CAAuB6C,aAD3B,GAEI7C,eAHN;AAKA,MAAIiD,mBAAJ,CA9BA,CA+BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAI1E,qBAAqB,IAAIwE,oCAA7B,EAAmE;AACjE,UAAMG,gBAAgB,GAAG3C,QAAzB;;AACAA,IAAAA,QAAQ,GAAG,UAAS,GAAG4C,CAAZ,EAAe;AACxBrE,MAAAA,mBAAmB,CACjBkB,eADiB,EAEjBL,YAFiB,EAGjBsD,mBAHiB,EAIjBrB,sBAJiB,CAAnB;AAMA,aAAOsB,gBAAgB,CAACE,KAAjB,CAAuB,IAAvB,EAA6BD,CAA7B,CAAP;AACD,KARD;AASD,GArDD,CAsDA;;;AACA,MAAIvB,sBAAJ,EAA4B;AAC1B,QAAIoB,iBAAiB,KAAKtC,SAA1B,EAAqC;AACnCuC,MAAAA,mBAAmB,GAAG/D,sCAAsC,CAC1Dc,eAD0D,EAE1DL,YAF0D,EAG1DY,QAH0D,EAI1DyC,iBAJ0D,CAA5D;AAMD,KAPD,MAOO;AACLC,MAAAA,mBAAmB,GAAGlE,uBAAuB,CAC3CiB,eAD2C,EAE3CL,YAF2C,EAG3CY,QAH2C,CAA7C;AAKD;AACF,GAfD,MAeO;AACL,QAAIyC,iBAAiB,KAAKtC,SAA1B,EAAqC;AACnCuC,MAAAA,mBAAmB,GAAGhE,qCAAqC,CACzDe,eADyD,EAEzDL,YAFyD,EAGzDY,QAHyD,EAIzDyC,iBAJyD,CAA3D;AAMD,KAPD,MAOO;AACLC,MAAAA,mBAAmB,GAAGjE,sBAAsB,CAC1CgB,eAD0C,EAE1CL,YAF0C,EAG1CY,QAH0C,CAA5C;AAKD;AACF;AACF;;AAED,SAAS8C,sCAAT,CACE1D,YADF,EAEEK,eAFF,EAGQ;AACN;AACA;AACA;AACA,QAAM+C,oCAAoC,GAAG,IAA7C;AACAf,EAAAA,uBAAuB,CACrBhC,eADqB,EAErBL,YAFqB,EAGrBvC,yBAHqB,EAIrB,KAJqB,EAKrB2F,oCALqB,CAAvB;AAOD;;AAED,SAASO,uBAAT,CACEC,cADF,EAEEvD,eAFF,EAGW;AACT,SACEuD,cAAc,KAAKvD,eAAnB,IACCuD,cAAc,CAACT,QAAf,KAA4B3E,YAA5B,IACCoF,cAAc,CAACC,UAAf,KAA8BxD,eAHlC;AAKD;;AAED,OAAO,SAASyD,iCAAT,CACL9D,YADK,EAELI,gBAFK,EAGLF,WAHK,EAILD,UAJK,EAKLI,eALK,EAMC;AACN,MAAI0D,YAAY,GAAG9D,UAAnB;;AACA,MACE,CAACG,gBAAgB,GAAGvC,gCAApB,MAA0D,CAA1D,IACA,CAACuC,gBAAgB,GAAGtC,gBAApB,MAA0C,CAF5C,EAGE;AACA,UAAMkG,mBAAmB,GAAK3D,eAA9B,CADA,CAGA;AACA;AACA;;AACA,QACEzB,qBAAqB,IACrB;AACA;AACA;AACA;AACA;AACAoB,IAAAA,YAAY,KAAK,OANjB,IAOA,CAACI,gBAAgB,GAAG5C,0CAApB,MAAoE,CARtE,EASE;AACAkG,MAAAA,sCAAsC,CAAC1D,YAAD,EAAeK,eAAf,CAAtC;AACA;AACD;;AACD,QAAIJ,UAAU,KAAK,IAAnB,EAAyB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAIgE,IAAI,GAAGhE,UAAX;;AAEAiE,MAAAA,QAAQ,EAAE,OAAO,IAAP,EAAa;AACrB,YAAID,IAAI,KAAK,IAAb,EAAmB;AACjB;AACD;;AACD,cAAME,OAAO,GAAGF,IAAI,CAACG,GAArB;;AACA,YAAID,OAAO,KAAKpG,QAAZ,IAAwBoG,OAAO,KAAKnG,UAAxC,EAAoD;AAClD,cAAIqG,SAAS,GAAGJ,IAAI,CAACK,SAAL,CAAeC,aAA/B;;AACA,cAAIZ,uBAAuB,CAACU,SAAD,EAAYL,mBAAZ,CAA3B,EAA6D;AAC3D;AACD;;AACD,cAAIG,OAAO,KAAKnG,UAAhB,EAA4B;AAC1B;AACA;AACA;AACA;AACA,gBAAIwG,SAAS,GAAGP,IAAI,CAACQ,MAArB;;AACA,mBAAOD,SAAS,KAAK,IAArB,EAA2B;AACzB,oBAAME,QAAQ,GAAGF,SAAS,CAACJ,GAA3B;;AACA,kBAAIM,QAAQ,KAAK3G,QAAb,IAAyB2G,QAAQ,KAAK1G,UAA1C,EAAsD;AACpD,sBAAM4F,cAAc,GAAGY,SAAS,CAACF,SAAV,CAAoBC,aAA3C;;AACA,oBACEZ,uBAAuB,CAACC,cAAD,EAAiBI,mBAAjB,CADzB,EAEE;AACA;AACA;AACA;AACA;AACD;AACF;;AACDQ,cAAAA,SAAS,GAAGA,SAAS,CAACC,MAAtB;AACD;AACF,WA1BiD,CA2BlD;AACA;AACA;AACA;AACA;;;AACA,iBAAOJ,SAAS,KAAK,IAArB,EAA2B;AACzB,kBAAMR,UAAU,GAAGxF,0BAA0B,CAACgG,SAAD,CAA7C;;AACA,gBAAIR,UAAU,KAAK,IAAnB,EAAyB;AACvB;AACD;;AACD,kBAAMc,SAAS,GAAGd,UAAU,CAACO,GAA7B;;AACA,gBAAIO,SAAS,KAAK1G,aAAd,IAA+B0G,SAAS,KAAKzG,QAAjD,EAA2D;AACzD+F,cAAAA,IAAI,GAAGF,YAAY,GAAGF,UAAtB;AACA,uBAASK,QAAT;AACD;;AACDG,YAAAA,SAAS,GAAGA,SAAS,CAACR,UAAtB;AACD;AACF;;AACDI,QAAAA,IAAI,GAAGA,IAAI,CAACQ,MAAZ;AACD;AACF;AACF;;AAEDhG,EAAAA,cAAc,CAAC,MACbiD,wBAAwB,CACtB1B,YADsB,EAEtBI,gBAFsB,EAGtBF,WAHsB,EAItB6D,YAJsB,EAKtB1D,eALsB,CADZ,CAAd;AASD;;AAED,SAASuE,sBAAT,CACEtD,QADF,EAEEV,QAFF,EAGEC,aAHF,EAIoB;AAClB,SAAO;AACLS,IAAAA,QADK;AAELV,IAAAA,QAFK;AAGLC,IAAAA;AAHK,GAAP;AAKD;;AAED,OAAO,SAASgE,8BAAT,CACLC,WADK,EAELC,SAFK,EAGLC,eAHK,EAIL9D,cAJK,EAKL+D,oBALK,EAML/E,WANK,EAOoB;AACzB,QAAMgF,WAAW,GAAGH,SAAS,KAAK,IAAd,GAAqBA,SAAS,GAAG,SAAjC,GAA6C,IAAjE;AACA,QAAMI,cAAc,GAAGjE,cAAc,GAAGgE,WAAH,GAAiBH,SAAtD;AACA,MAAItD,SAAkC,GAAG,EAAzC;AAEA,MAAIH,QAAQ,GAAGwD,WAAf;AACA,MAAIM,iBAAiB,GAAG,IAAxB,CANyB,CAQzB;;AACA,SAAO9D,QAAQ,KAAK,IAApB,EAA0B;AACxB,UAAM;AAACgD,MAAAA,SAAD;AAAYF,MAAAA;AAAZ,QAAmB9C,QAAzB,CADwB,CAExB;;AACA,QAAI8C,GAAG,KAAKnG,aAAR,IAAyBqG,SAAS,KAAK,IAA3C,EAAiD;AAC/Cc,MAAAA,iBAAiB,GAAGd,SAApB,CAD+C,CAG/C;;AACA,UAAIzF,0BAAJ,EAAgC;AAC9B,cAAMwG,qBAAqB,GAAG9G,wBAAwB,CACpD6G,iBADoD,CAAtD;;AAGA,YAAIC,qBAAqB,KAAK,IAA9B,EAAoC;AAClCA,UAAAA,qBAAqB,CAACpC,OAAtB,CAA8BqC,KAAK,IAAI;AACrC,gBACEA,KAAK,CAACxE,IAAN,KAAekE,eAAf,IACAM,KAAK,CAACC,OAAN,KAAkBrE,cAFpB,EAGE;AACAO,cAAAA,SAAS,CAAC+D,IAAV,CACEZ,sBAAsB,CACpBtD,QADoB,EAEpBgE,KAAK,CAACG,QAFc,EAGnBL,iBAHmB,CADxB;AAOD;AACF,WAbD;AAcD;AACF,OAxB8C,CA0B/C;;;AACA,UAAID,cAAc,KAAK,IAAvB,EAA6B;AAC3B,cAAMvE,QAAQ,GAAGlC,WAAW,CAAC4C,QAAD,EAAW6D,cAAX,CAA5B;;AACA,YAAIvE,QAAQ,IAAI,IAAhB,EAAsB;AACpBa,UAAAA,SAAS,CAAC+D,IAAV,CACEZ,sBAAsB,CAACtD,QAAD,EAAWV,QAAX,EAAqBwE,iBAArB,CADxB;AAGD;AACF;AACF,KAnCD,MAmCO,IACLvG,0BAA0B,IAC1BC,cADA,IAEAsF,GAAG,KAAKjG,cAFR,IAGAiH,iBAAiB,KAAK,IAHtB,IAIAd,SAAS,KAAK,IALT,EAML;AACA;AACA,YAAMoB,kBAAkB,GAAGpB,SAA3B;AACA,YAAMe,qBAAqB,GAAG9G,wBAAwB,CACpDmH,kBADoD,CAAtD;;AAGA,UAAIL,qBAAqB,KAAK,IAA9B,EAAoC;AAClCA,QAAAA,qBAAqB,CAACpC,OAAtB,CAA8BqC,KAAK,IAAI;AACrC,cACEA,KAAK,CAACxE,IAAN,KAAekE,eAAf,IACAM,KAAK,CAACC,OAAN,KAAkBrE,cAFpB,EAGE;AACAO,YAAAA,SAAS,CAAC+D,IAAV,CACEZ,sBAAsB,CACpBtD,QADoB,EAEpBgE,KAAK,CAACG,QAFc,EAGnBL,iBAHmB,CADxB;AAOD;AACF,SAbD;AAcD;AACF,KAlEuB,CAmExB;AACA;AACA;;;AACA,QAAIH,oBAAJ,EAA0B;AACxB;AACD,KAxEuB,CAyExB;AACA;AACA;AACA;AACA;AACA;;;AACA,QAAIpG,0BAA0B,IAAIqB,WAAW,CAACY,IAAZ,KAAqB,YAAvD,EAAqE;AACnE;AACA,YAAM6E,sBAAsB,GAAGzF,WAAW,CAAC0F,uBAA3C;;AACA,UACED,sBAAsB,KAAK,IAA3B,KACCA,sBAAsB,KAAKrE,QAA3B,IACCqE,sBAAsB,KAAKrE,QAAQ,CAACuE,SAFtC,CADF,EAIE;AACApE,QAAAA,SAAS,GAAG,EAAZ;AACD;AACF;;AACDH,IAAAA,QAAQ,GAAGA,QAAQ,CAACmD,MAApB;AACD;;AACD,SAAOhD,SAAP;AACD,C,CAED;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASqE,2BAAT,CACLhB,WADK,EAELC,SAFK,EAGoB;AACzB,QAAMG,WAAW,GAAGH,SAAS,GAAG,SAAhC;AACA,QAAMtD,SAAkC,GAAG,EAA3C;AACA,MAAIH,QAAQ,GAAGwD,WAAf,CAHyB,CAKzB;;AACA,SAAOxD,QAAQ,KAAK,IAApB,EAA0B;AACxB,UAAM;AAACgD,MAAAA,SAAD;AAAYF,MAAAA;AAAZ,QAAmB9C,QAAzB,CADwB,CAExB;;AACA,QAAI8C,GAAG,KAAKnG,aAAR,IAAyBqG,SAAS,KAAK,IAA3C,EAAiD;AAC/C,YAAMzD,aAAa,GAAGyD,SAAtB;AACA,YAAMyB,eAAe,GAAGrH,WAAW,CAAC4C,QAAD,EAAW4D,WAAX,CAAnC;;AACA,UAAIa,eAAe,IAAI,IAAvB,EAA6B;AAC3BtE,QAAAA,SAAS,CAACuE,OAAV,CACEpB,sBAAsB,CAACtD,QAAD,EAAWyE,eAAX,EAA4BlF,aAA5B,CADxB;AAGD;;AACD,YAAMoF,cAAc,GAAGvH,WAAW,CAAC4C,QAAD,EAAWyD,SAAX,CAAlC;;AACA,UAAIkB,cAAc,IAAI,IAAtB,EAA4B;AAC1BxE,QAAAA,SAAS,CAAC+D,IAAV,CACEZ,sBAAsB,CAACtD,QAAD,EAAW2E,cAAX,EAA2BpF,aAA3B,CADxB;AAGD;AACF;;AACDS,IAAAA,QAAQ,GAAGA,QAAQ,CAACmD,MAApB;AACD;;AACD,SAAOhD,SAAP;AACD;;AAED,SAASyE,SAAT,CAAmBC,IAAnB,EAAqD;AACnD,MAAIA,IAAI,KAAK,IAAb,EAAmB;AACjB,WAAO,IAAP;AACD;;AACD,KAAG;AACDA,IAAAA,IAAI,GAAGA,IAAI,CAAC1B,MAAZ,CADC,CAED;AACA;AACA;AACA;AACA;AACD,GAPD,QAOS0B,IAAI,IAAIA,IAAI,CAAC/B,GAAL,KAAanG,aAP9B;;AAQA,MAAIkI,IAAJ,EAAU;AACR,WAAOA,IAAP;AACD;;AACD,SAAO,IAAP;AACD;AAED;AACA;AACA;AACA;;;AACA,SAASC,uBAAT,CAAiCC,KAAjC,EAA+CC,KAA/C,EAA2E;AACzE,MAAIC,KAAK,GAAGF,KAAZ;AACA,MAAIG,KAAK,GAAGF,KAAZ;AACA,MAAIG,MAAM,GAAG,CAAb;;AACA,OAAK,IAAIC,KAAK,GAAGH,KAAjB,EAAwBG,KAAxB,EAA+BA,KAAK,GAAGR,SAAS,CAACQ,KAAD,CAAhD,EAAyD;AACvDD,IAAAA,MAAM;AACP;;AACD,MAAIE,MAAM,GAAG,CAAb;;AACA,OAAK,IAAIC,KAAK,GAAGJ,KAAjB,EAAwBI,KAAxB,EAA+BA,KAAK,GAAGV,SAAS,CAACU,KAAD,CAAhD,EAAyD;AACvDD,IAAAA,MAAM;AACP,GAVwE,CAYzE;;;AACA,SAAOF,MAAM,GAAGE,MAAT,GAAkB,CAAzB,EAA4B;AAC1BJ,IAAAA,KAAK,GAAGL,SAAS,CAACK,KAAD,CAAjB;AACAE,IAAAA,MAAM;AACP,GAhBwE,CAkBzE;;;AACA,SAAOE,MAAM,GAAGF,MAAT,GAAkB,CAAzB,EAA4B;AAC1BD,IAAAA,KAAK,GAAGN,SAAS,CAACM,KAAD,CAAjB;AACAG,IAAAA,MAAM;AACP,GAtBwE,CAwBzE;;;AACA,MAAIE,KAAK,GAAGJ,MAAZ;;AACA,SAAOI,KAAK,EAAZ,EAAgB;AACd,QAAIN,KAAK,KAAKC,KAAV,IAAoBA,KAAK,KAAK,IAAV,IAAkBD,KAAK,KAAKC,KAAK,CAACX,SAA1D,EAAsE;AACpE,aAAOU,KAAP;AACD;;AACDA,IAAAA,KAAK,GAAGL,SAAS,CAACK,KAAD,CAAjB;AACAC,IAAAA,KAAK,GAAGN,SAAS,CAACM,KAAD,CAAjB;AACD;;AACD,SAAO,IAAP;AACD;;AAED,SAASM,qCAAT,CACE/G,aADF,EAEEY,KAFF,EAGE6B,MAHF,EAIEuE,MAJF,EAKE7F,cALF,EAMQ;AACN,QAAM8F,gBAAgB,GAAGrG,KAAK,CAACsG,UAA/B;AACA,QAAMxF,SAAkC,GAAG,EAA3C;AAEA,MAAIH,QAAQ,GAAGkB,MAAf;;AACA,SAAOlB,QAAQ,KAAK,IAApB,EAA0B;AACxB,QAAIA,QAAQ,KAAKyF,MAAjB,EAAyB;AACvB;AACD;;AACD,UAAM;AAAClB,MAAAA,SAAD;AAAYvB,MAAAA,SAAZ;AAAuBF,MAAAA;AAAvB,QAA8B9C,QAApC;;AACA,QAAIuE,SAAS,KAAK,IAAd,IAAsBA,SAAS,KAAKkB,MAAxC,EAAgD;AAC9C;AACD;;AACD,QAAI3C,GAAG,KAAKnG,aAAR,IAAyBqG,SAAS,KAAK,IAA3C,EAAiD;AAC/C,YAAMzD,aAAa,GAAGyD,SAAtB;;AACA,UAAIpD,cAAJ,EAAoB;AAClB,cAAM6E,eAAe,GAAGrH,WAAW,CAAC4C,QAAD,EAAW0F,gBAAX,CAAnC;;AACA,YAAIjB,eAAe,IAAI,IAAvB,EAA6B;AAC3BtE,UAAAA,SAAS,CAACuE,OAAV,CACEpB,sBAAsB,CAACtD,QAAD,EAAWyE,eAAX,EAA4BlF,aAA5B,CADxB;AAGD;AACF,OAPD,MAOO,IAAI,CAACK,cAAL,EAAqB;AAC1B,cAAM+E,cAAc,GAAGvH,WAAW,CAAC4C,QAAD,EAAW0F,gBAAX,CAAlC;;AACA,YAAIf,cAAc,IAAI,IAAtB,EAA4B;AAC1BxE,UAAAA,SAAS,CAAC+D,IAAV,CACEZ,sBAAsB,CAACtD,QAAD,EAAW2E,cAAX,EAA2BpF,aAA3B,CADxB;AAGD;AACF;AACF;;AACDS,IAAAA,QAAQ,GAAGA,QAAQ,CAACmD,MAApB;AACD;;AACD,MAAIhD,SAAS,CAACJ,MAAV,KAAqB,CAAzB,EAA4B;AAC1BtB,IAAAA,aAAa,CAACyF,IAAd,CAAmB;AAAC7E,MAAAA,KAAD;AAAQc,MAAAA;AAAR,KAAnB;AACD;AACF,C,CAED;AACA;AACA;AACA;AACA;;;AACA,OAAO,SAASyF,qCAAT,CACLnH,aADK,EAELoH,UAFK,EAGLC,UAHK,EAILC,IAJK,EAKLC,EALK,EAMC;AACN,QAAMP,MAAM,GAAGM,IAAI,IAAIC,EAAR,GAAalB,uBAAuB,CAACiB,IAAD,EAAOC,EAAP,CAApC,GAAiD,IAAhE;;AAEA,MAAID,IAAI,KAAK,IAAb,EAAmB;AACjBP,IAAAA,qCAAqC,CACnC/G,aADmC,EAEnCoH,UAFmC,EAGnCE,IAHmC,EAInCN,MAJmC,EAKnC,KALmC,CAArC;AAOD;;AACD,MAAIO,EAAE,KAAK,IAAP,IAAeF,UAAU,KAAK,IAAlC,EAAwC;AACtCN,IAAAA,qCAAqC,CACnC/G,aADmC,EAEnCqH,UAFmC,EAGnCE,EAHmC,EAInCP,MAJmC,EAKnC,IALmC,CAArC;AAOD;AACF;AAED,OAAO,SAASQ,4CAAT,CACLC,cADK,EAEL3G,aAFK,EAGLK,cAHK,EAIoB;AACzB,QAAMO,SAAkC,GAAG,EAA3C;AAEA,QAAMgG,cAAc,GAAGlJ,wBAAwB,CAACsC,aAAD,CAA/C;;AACA,MAAI4G,cAAc,KAAK,IAAvB,EAA6B;AAC3BA,IAAAA,cAAc,CAACxE,OAAf,CAAuBqC,KAAK,IAAI;AAC9B,UAAIA,KAAK,CAACxE,IAAN,KAAe0G,cAAf,IAAiClC,KAAK,CAACC,OAAN,KAAkBrE,cAAvD,EAAuE;AACrEO,QAAAA,SAAS,CAAC+D,IAAV,CACEZ,sBAAsB,CAAC,IAAD,EAAOU,KAAK,CAACG,QAAb,EAAuB5E,aAAvB,CADxB;AAGD;AACF,KAND;AAOD;;AACD,SAAOY,SAAP;AACD;AAED,OAAO,SAASW,iBAAT,CACLpC,YADK,EAELuF,OAFK,EAGG;AACR,SAAQ,GAAEvF,YAAa,KAAIuF,OAAO,GAAG,SAAH,GAAe,QAAS,EAA1D;AACD","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {DOMEventName} from './DOMEventNames';\nimport {\n  type EventSystemFlags,\n  SHOULD_NOT_DEFER_CLICK_FOR_FB_SUPPORT_MODE,\n  IS_LEGACY_FB_SUPPORT_MODE,\n  SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS,\n} from './EventSystemFlags';\nimport type {AnyNativeEvent} from './PluginModuleType';\nimport type {\n  KnownReactSyntheticEvent,\n  ReactSyntheticEvent,\n} from './ReactSyntheticEventType';\nimport type {Fiber} from 'react-reconciler/src/ReactInternalTypes';\n\nimport {allNativeEvents} from './EventRegistry';\nimport {\n  IS_CAPTURE_PHASE,\n  IS_EVENT_HANDLE_NON_MANAGED_NODE,\n  IS_NON_DELEGATED,\n} from './EventSystemFlags';\n\nimport {\n  HostRoot,\n  HostPortal,\n  HostComponent,\n  HostText,\n  ScopeComponent,\n} from 'react-reconciler/src/ReactWorkTags';\n\nimport getEventTarget from './getEventTarget';\nimport {\n  getClosestInstanceFromNode,\n  getEventListenerSet,\n  getEventHandlerListeners,\n} from '../client/ReactDOMComponentTree';\nimport {COMMENT_NODE} from '../shared/HTMLNodeType';\nimport {batchedUpdates} from './ReactDOMUpdateBatching';\nimport getListener from './getListener';\nimport {passiveBrowserEventsSupported} from './checkPassiveEvents';\n\nimport {\n  enableLegacyFBSupport,\n  enableCreateEventHandleAPI,\n  enableScopeAPI,\n} from 'shared/ReactFeatureFlags';\nimport {\n  invokeGuardedCallbackAndCatchFirstError,\n  rethrowCaughtError,\n} from 'shared/ReactErrorUtils';\nimport {DOCUMENT_NODE} from '../shared/HTMLNodeType';\nimport {createEventListenerWrapperWithPriority} from './ReactDOMEventListener';\nimport {\n  removeEventListener,\n  addEventCaptureListener,\n  addEventBubbleListener,\n  addEventBubbleListenerWithPassiveFlag,\n  addEventCaptureListenerWithPassiveFlag,\n} from './EventListener';\nimport * as BeforeInputEventPlugin from './plugins/BeforeInputEventPlugin';\nimport * as ChangeEventPlugin from './plugins/ChangeEventPlugin';\nimport * as EnterLeaveEventPlugin from './plugins/EnterLeaveEventPlugin';\nimport * as SelectEventPlugin from './plugins/SelectEventPlugin';\nimport * as SimpleEventPlugin from './plugins/SimpleEventPlugin';\n\ntype DispatchListener = {|\n  instance: null | Fiber,\n  listener: Function,\n  currentTarget: EventTarget,\n|};\n\ntype DispatchEntry = {|\n  event: ReactSyntheticEvent,\n  listeners: Array<DispatchListener>,\n|};\n\nexport type DispatchQueue = Array<DispatchEntry>;\n\n// TODO: remove top-level side effect.\nSimpleEventPlugin.registerEvents();\nEnterLeaveEventPlugin.registerEvents();\nChangeEventPlugin.registerEvents();\nSelectEventPlugin.registerEvents();\nBeforeInputEventPlugin.registerEvents();\n\nfunction extractEvents(\n  dispatchQueue: DispatchQueue,\n  domEventName: DOMEventName,\n  targetInst: null | Fiber,\n  nativeEvent: AnyNativeEvent,\n  nativeEventTarget: null | EventTarget,\n  eventSystemFlags: EventSystemFlags,\n  targetContainer: EventTarget,\n) {\n  // TODO: we should remove the concept of a \"SimpleEventPlugin\".\n  // This is the basic functionality of the event system. All\n  // the other plugins are essentially polyfills. So the plugin\n  // should probably be inlined somewhere and have its logic\n  // be core the to event system. This would potentially allow\n  // us to ship builds of React without the polyfilled plugins below.\n  SimpleEventPlugin.extractEvents(\n    dispatchQueue,\n    domEventName,\n    targetInst,\n    nativeEvent,\n    nativeEventTarget,\n    eventSystemFlags,\n    targetContainer,\n  );\n  const shouldProcessPolyfillPlugins =\n    (eventSystemFlags & SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS) === 0;\n  // We don't process these events unless we are in the\n  // event's native \"bubble\" phase, which means that we're\n  // not in the capture phase. That's because we emulate\n  // the capture phase here still. This is a trade-off,\n  // because in an ideal world we would not emulate and use\n  // the phases properly, like we do with the SimpleEvent\n  // plugin. However, the plugins below either expect\n  // emulation (EnterLeave) or use state localized to that\n  // plugin (BeforeInput, Change, Select). The state in\n  // these modules complicates things, as you'll essentially\n  // get the case where the capture phase event might change\n  // state, only for the following bubble event to come in\n  // later and not trigger anything as the state now\n  // invalidates the heuristics of the event plugin. We\n  // could alter all these plugins to work in such ways, but\n  // that might cause other unknown side-effects that we\n  // can't foresee right now.\n  if (shouldProcessPolyfillPlugins) {\n    EnterLeaveEventPlugin.extractEvents(\n      dispatchQueue,\n      domEventName,\n      targetInst,\n      nativeEvent,\n      nativeEventTarget,\n      eventSystemFlags,\n      targetContainer,\n    );\n    ChangeEventPlugin.extractEvents(\n      dispatchQueue,\n      domEventName,\n      targetInst,\n      nativeEvent,\n      nativeEventTarget,\n      eventSystemFlags,\n      targetContainer,\n    );\n    SelectEventPlugin.extractEvents(\n      dispatchQueue,\n      domEventName,\n      targetInst,\n      nativeEvent,\n      nativeEventTarget,\n      eventSystemFlags,\n      targetContainer,\n    );\n    BeforeInputEventPlugin.extractEvents(\n      dispatchQueue,\n      domEventName,\n      targetInst,\n      nativeEvent,\n      nativeEventTarget,\n      eventSystemFlags,\n      targetContainer,\n    );\n  }\n}\n\n// List of events that need to be individually attached to media elements.\nexport const mediaEventTypes: Array<DOMEventName> = [\n  'abort',\n  'canplay',\n  'canplaythrough',\n  'durationchange',\n  'emptied',\n  'encrypted',\n  'ended',\n  'error',\n  'loadeddata',\n  'loadedmetadata',\n  'loadstart',\n  'pause',\n  'play',\n  'playing',\n  'progress',\n  'ratechange',\n  'resize',\n  'seeked',\n  'seeking',\n  'stalled',\n  'suspend',\n  'timeupdate',\n  'volumechange',\n  'waiting',\n];\n\n// We should not delegate these events to the container, but rather\n// set them on the actual target element itself. This is primarily\n// because these events do not consistently bubble in the DOM.\nexport const nonDelegatedEvents: Set<DOMEventName> = new Set([\n  'cancel',\n  'close',\n  'invalid',\n  'load',\n  'scroll',\n  'toggle',\n  // In order to reduce bytes, we insert the above array of media events\n  // into this Set. Note: the \"error\" event isn't an exclusive media event,\n  // and can occur on other elements too. Rather than duplicate that event,\n  // we just take it from the media events array.\n  ...mediaEventTypes,\n]);\n\nfunction executeDispatch(\n  event: ReactSyntheticEvent,\n  listener: Function,\n  currentTarget: EventTarget,\n): void {\n  const type = event.type || 'unknown-event';\n  event.currentTarget = currentTarget;\n  invokeGuardedCallbackAndCatchFirstError(type, listener, undefined, event);\n  event.currentTarget = null;\n}\n\nfunction processDispatchQueueItemsInOrder(\n  event: ReactSyntheticEvent,\n  dispatchListeners: Array<DispatchListener>,\n  inCapturePhase: boolean,\n): void {\n  let previousInstance;\n  if (inCapturePhase) {\n    for (let i = dispatchListeners.length - 1; i >= 0; i--) {\n      const {instance, currentTarget, listener} = dispatchListeners[i];\n      if (instance !== previousInstance && event.isPropagationStopped()) {\n        return;\n      }\n      executeDispatch(event, listener, currentTarget);\n      previousInstance = instance;\n    }\n  } else {\n    for (let i = 0; i < dispatchListeners.length; i++) {\n      const {instance, currentTarget, listener} = dispatchListeners[i];\n      if (instance !== previousInstance && event.isPropagationStopped()) {\n        return;\n      }\n      executeDispatch(event, listener, currentTarget);\n      previousInstance = instance;\n    }\n  }\n}\n\nexport function processDispatchQueue(\n  dispatchQueue: DispatchQueue,\n  eventSystemFlags: EventSystemFlags,\n): void {\n  const inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;\n  for (let i = 0; i < dispatchQueue.length; i++) {\n    const {event, listeners} = dispatchQueue[i];\n    processDispatchQueueItemsInOrder(event, listeners, inCapturePhase);\n    //  event system doesn't use pooling.\n  }\n  // This would be a good time to rethrow if any of the event handlers threw.\n  rethrowCaughtError();\n}\n\nfunction dispatchEventsForPlugins(\n  domEventName: DOMEventName,\n  eventSystemFlags: EventSystemFlags,\n  nativeEvent: AnyNativeEvent,\n  targetInst: null | Fiber,\n  targetContainer: EventTarget,\n): void {\n  const nativeEventTarget = getEventTarget(nativeEvent);\n  const dispatchQueue: DispatchQueue = [];\n  extractEvents(\n    dispatchQueue,\n    domEventName,\n    targetInst,\n    nativeEvent,\n    nativeEventTarget,\n    eventSystemFlags,\n    targetContainer,\n  );\n  processDispatchQueue(dispatchQueue, eventSystemFlags);\n}\n\nexport function listenToNonDelegatedEvent(\n  domEventName: DOMEventName,\n  targetElement: Element,\n): void {\n  if (__DEV__) {\n    if (!nonDelegatedEvents.has(domEventName)) {\n      console.error(\n        'Did not expect a listenToNonDelegatedEvent() call for \"%s\". ' +\n          'This is a bug in React. Please file an issue.',\n        domEventName,\n      );\n    }\n  }\n  const isCapturePhaseListener = false;\n  const listenerSet = getEventListenerSet(targetElement);\n  const listenerSetKey = getListenerSetKey(\n    domEventName,\n    isCapturePhaseListener,\n  );\n  if (!listenerSet.has(listenerSetKey)) {\n    addTrappedEventListener(\n      targetElement,\n      domEventName,\n      IS_NON_DELEGATED,\n      isCapturePhaseListener,\n    );\n    listenerSet.add(listenerSetKey);\n  }\n}\n\nexport function listenToNativeEvent(\n  domEventName: DOMEventName,\n  isCapturePhaseListener: boolean,\n  target: EventTarget,\n): void {\n  if (__DEV__) {\n    if (nonDelegatedEvents.has(domEventName) && !isCapturePhaseListener) {\n      console.error(\n        'Did not expect a listenToNativeEvent() call for \"%s\" in the bubble phase. ' +\n          'This is a bug in React. Please file an issue.',\n        domEventName,\n      );\n    }\n  }\n\n  let eventSystemFlags = 0;\n  if (isCapturePhaseListener) {\n    eventSystemFlags |= IS_CAPTURE_PHASE;\n  }\n  addTrappedEventListener(\n    target,\n    domEventName,\n    eventSystemFlags,\n    isCapturePhaseListener,\n  );\n}\n\n// This is only used by createEventHandle when the\n// target is not a DOM element. E.g. window.\nexport function listenToNativeEventForNonManagedEventTarget(\n  domEventName: DOMEventName,\n  isCapturePhaseListener: boolean,\n  target: EventTarget,\n): void {\n  let eventSystemFlags = IS_EVENT_HANDLE_NON_MANAGED_NODE;\n  const listenerSet = getEventListenerSet(target);\n  const listenerSetKey = getListenerSetKey(\n    domEventName,\n    isCapturePhaseListener,\n  );\n  if (!listenerSet.has(listenerSetKey)) {\n    if (isCapturePhaseListener) {\n      eventSystemFlags |= IS_CAPTURE_PHASE;\n    }\n    addTrappedEventListener(\n      target,\n      domEventName,\n      eventSystemFlags,\n      isCapturePhaseListener,\n    );\n    listenerSet.add(listenerSetKey);\n  }\n}\n\nconst listeningMarker =\n  '_reactListening' +\n  Math.random()\n    .toString(36)\n    .slice(2);\n\nexport function listenToAllSupportedEvents(rootContainerElement: EventTarget) {\n  if (!(rootContainerElement: any)[listeningMarker]) {\n    (rootContainerElement: any)[listeningMarker] = true;\n    allNativeEvents.forEach(domEventName => {\n      // We handle selectionchange separately because it\n      // doesn't bubble and needs to be on the document.\n      if (domEventName !== 'selectionchange') {\n        if (!nonDelegatedEvents.has(domEventName)) {\n          listenToNativeEvent(domEventName, false, rootContainerElement);\n        }\n        listenToNativeEvent(domEventName, true, rootContainerElement);\n      }\n    });\n    const ownerDocument =\n      (rootContainerElement: any).nodeType === DOCUMENT_NODE\n        ? rootContainerElement\n        : (rootContainerElement: any).ownerDocument;\n    if (ownerDocument !== null) {\n      // The selectionchange event also needs deduplication\n      // but it is attached to the document.\n      if (!(ownerDocument: any)[listeningMarker]) {\n        (ownerDocument: any)[listeningMarker] = true;\n        listenToNativeEvent('selectionchange', false, ownerDocument);\n      }\n    }\n  }\n}\n\nfunction addTrappedEventListener(\n  targetContainer: EventTarget,\n  domEventName: DOMEventName,\n  eventSystemFlags: EventSystemFlags,\n  isCapturePhaseListener: boolean,\n  isDeferredListenerForLegacyFBSupport?: boolean,\n) {\n  let listener = createEventListenerWrapperWithPriority(\n    targetContainer,\n    domEventName,\n    eventSystemFlags,\n  );\n  // If passive option is not supported, then the event will be\n  // active and not passive.\n  let isPassiveListener = undefined;\n  if (passiveBrowserEventsSupported) {\n    // Browsers introduced an intervention, making these events\n    // passive by default on document. React doesn't bind them\n    // to document anymore, but changing this now would undo\n    // the performance wins from the change. So we emulate\n    // the existing behavior manually on the roots now.\n    // https://github.com/facebook/react/issues/19651\n    if (\n      domEventName === 'touchstart' ||\n      domEventName === 'touchmove' ||\n      domEventName === 'wheel'\n    ) {\n      isPassiveListener = true;\n    }\n  }\n\n  targetContainer =\n    enableLegacyFBSupport && isDeferredListenerForLegacyFBSupport\n      ? (targetContainer: any).ownerDocument\n      : targetContainer;\n\n  let unsubscribeListener;\n  // When legacyFBSupport is enabled, it's for when we\n  // want to add a one time event listener to a container.\n  // This should only be used with enableLegacyFBSupport\n  // due to requirement to provide compatibility with\n  // internal FB www event tooling. This works by removing\n  // the event listener as soon as it is invoked. We could\n  // also attempt to use the {once: true} param on\n  // addEventListener, but that requires support and some\n  // browsers do not support this today, and given this is\n  // to support legacy code patterns, it's likely they'll\n  // need support for such browsers.\n  if (enableLegacyFBSupport && isDeferredListenerForLegacyFBSupport) {\n    const originalListener = listener;\n    listener = function(...p) {\n      removeEventListener(\n        targetContainer,\n        domEventName,\n        unsubscribeListener,\n        isCapturePhaseListener,\n      );\n      return originalListener.apply(this, p);\n    };\n  }\n  // TODO: There are too many combinations here. Consolidate them.\n  if (isCapturePhaseListener) {\n    if (isPassiveListener !== undefined) {\n      unsubscribeListener = addEventCaptureListenerWithPassiveFlag(\n        targetContainer,\n        domEventName,\n        listener,\n        isPassiveListener,\n      );\n    } else {\n      unsubscribeListener = addEventCaptureListener(\n        targetContainer,\n        domEventName,\n        listener,\n      );\n    }\n  } else {\n    if (isPassiveListener !== undefined) {\n      unsubscribeListener = addEventBubbleListenerWithPassiveFlag(\n        targetContainer,\n        domEventName,\n        listener,\n        isPassiveListener,\n      );\n    } else {\n      unsubscribeListener = addEventBubbleListener(\n        targetContainer,\n        domEventName,\n        listener,\n      );\n    }\n  }\n}\n\nfunction deferClickToDocumentForLegacyFBSupport(\n  domEventName: DOMEventName,\n  targetContainer: EventTarget,\n): void {\n  // We defer all click events with legacy FB support mode on.\n  // This means we add a one time event listener to trigger\n  // after the FB delegated listeners fire.\n  const isDeferredListenerForLegacyFBSupport = true;\n  addTrappedEventListener(\n    targetContainer,\n    domEventName,\n    IS_LEGACY_FB_SUPPORT_MODE,\n    false,\n    isDeferredListenerForLegacyFBSupport,\n  );\n}\n\nfunction isMatchingRootContainer(\n  grandContainer: Element,\n  targetContainer: EventTarget,\n): boolean {\n  return (\n    grandContainer === targetContainer ||\n    (grandContainer.nodeType === COMMENT_NODE &&\n      grandContainer.parentNode === targetContainer)\n  );\n}\n\nexport function dispatchEventForPluginEventSystem(\n  domEventName: DOMEventName,\n  eventSystemFlags: EventSystemFlags,\n  nativeEvent: AnyNativeEvent,\n  targetInst: null | Fiber,\n  targetContainer: EventTarget,\n): void {\n  let ancestorInst = targetInst;\n  if (\n    (eventSystemFlags & IS_EVENT_HANDLE_NON_MANAGED_NODE) === 0 &&\n    (eventSystemFlags & IS_NON_DELEGATED) === 0\n  ) {\n    const targetContainerNode = ((targetContainer: any): Node);\n\n    // If we are using the legacy FB support flag, we\n    // defer the event to the null with a one\n    // time event listener so we can defer the event.\n    if (\n      enableLegacyFBSupport &&\n      // If our event flags match the required flags for entering\n      // FB legacy mode and we are processing the \"click\" event,\n      // then we can defer the event to the \"document\", to allow\n      // for legacy FB support, where the expected behavior was to\n      // match React < 16 behavior of delegated clicks to the doc.\n      domEventName === 'click' &&\n      (eventSystemFlags & SHOULD_NOT_DEFER_CLICK_FOR_FB_SUPPORT_MODE) === 0\n    ) {\n      deferClickToDocumentForLegacyFBSupport(domEventName, targetContainer);\n      return;\n    }\n    if (targetInst !== null) {\n      // The below logic attempts to work out if we need to change\n      // the target fiber to a different ancestor. We had similar logic\n      // in the legacy event system, except the big difference between\n      // systems is that the modern event system now has an event listener\n      // attached to each React Root and React Portal Root. Together,\n      // the DOM nodes representing these roots are the \"rootContainer\".\n      // To figure out which ancestor instance we should use, we traverse\n      // up the fiber tree from the target instance and attempt to find\n      // root boundaries that match that of our current \"rootContainer\".\n      // If we find that \"rootContainer\", we find the parent fiber\n      // sub-tree for that root and make that our ancestor instance.\n      let node = targetInst;\n\n      mainLoop: while (true) {\n        if (node === null) {\n          return;\n        }\n        const nodeTag = node.tag;\n        if (nodeTag === HostRoot || nodeTag === HostPortal) {\n          let container = node.stateNode.containerInfo;\n          if (isMatchingRootContainer(container, targetContainerNode)) {\n            break;\n          }\n          if (nodeTag === HostPortal) {\n            // The target is a portal, but it's not the rootContainer we're looking for.\n            // Normally portals handle their own events all the way down to the root.\n            // So we should be able to stop now. However, we don't know if this portal\n            // was part of *our* root.\n            let grandNode = node.return;\n            while (grandNode !== null) {\n              const grandTag = grandNode.tag;\n              if (grandTag === HostRoot || grandTag === HostPortal) {\n                const grandContainer = grandNode.stateNode.containerInfo;\n                if (\n                  isMatchingRootContainer(grandContainer, targetContainerNode)\n                ) {\n                  // This is the rootContainer we're looking for and we found it as\n                  // a parent of the Portal. That means we can ignore it because the\n                  // Portal will bubble through to us.\n                  return;\n                }\n              }\n              grandNode = grandNode.return;\n            }\n          }\n          // Now we need to find it's corresponding host fiber in the other\n          // tree. To do this we can use getClosestInstanceFromNode, but we\n          // need to validate that the fiber is a host instance, otherwise\n          // we need to traverse up through the DOM till we find the correct\n          // node that is from the other tree.\n          while (container !== null) {\n            const parentNode = getClosestInstanceFromNode(container);\n            if (parentNode === null) {\n              return;\n            }\n            const parentTag = parentNode.tag;\n            if (parentTag === HostComponent || parentTag === HostText) {\n              node = ancestorInst = parentNode;\n              continue mainLoop;\n            }\n            container = container.parentNode;\n          }\n        }\n        node = node.return;\n      }\n    }\n  }\n\n  batchedUpdates(() =>\n    dispatchEventsForPlugins(\n      domEventName,\n      eventSystemFlags,\n      nativeEvent,\n      ancestorInst,\n      targetContainer,\n    ),\n  );\n}\n\nfunction createDispatchListener(\n  instance: null | Fiber,\n  listener: Function,\n  currentTarget: EventTarget,\n): DispatchListener {\n  return {\n    instance,\n    listener,\n    currentTarget,\n  };\n}\n\nexport function accumulateSinglePhaseListeners(\n  targetFiber: Fiber | null,\n  reactName: string | null,\n  nativeEventType: string,\n  inCapturePhase: boolean,\n  accumulateTargetOnly: boolean,\n  nativeEvent: AnyNativeEvent,\n): Array<DispatchListener> {\n  const captureName = reactName !== null ? reactName + 'Capture' : null;\n  const reactEventName = inCapturePhase ? captureName : reactName;\n  let listeners: Array<DispatchListener> = [];\n\n  let instance = targetFiber;\n  let lastHostComponent = null;\n\n  // Accumulate all instances and listeners via the target -> root path.\n  while (instance !== null) {\n    const {stateNode, tag} = instance;\n    // Handle listeners that are on HostComponents (i.e. <div>)\n    if (tag === HostComponent && stateNode !== null) {\n      lastHostComponent = stateNode;\n\n      // createEventHandle listeners\n      if (enableCreateEventHandleAPI) {\n        const eventHandlerListeners = getEventHandlerListeners(\n          lastHostComponent,\n        );\n        if (eventHandlerListeners !== null) {\n          eventHandlerListeners.forEach(entry => {\n            if (\n              entry.type === nativeEventType &&\n              entry.capture === inCapturePhase\n            ) {\n              listeners.push(\n                createDispatchListener(\n                  instance,\n                  entry.callback,\n                  (lastHostComponent: any),\n                ),\n              );\n            }\n          });\n        }\n      }\n\n      // Standard React on* listeners, i.e. onClick or onClickCapture\n      if (reactEventName !== null) {\n        const listener = getListener(instance, reactEventName);\n        if (listener != null) {\n          listeners.push(\n            createDispatchListener(instance, listener, lastHostComponent),\n          );\n        }\n      }\n    } else if (\n      enableCreateEventHandleAPI &&\n      enableScopeAPI &&\n      tag === ScopeComponent &&\n      lastHostComponent !== null &&\n      stateNode !== null\n    ) {\n      // Scopes\n      const reactScopeInstance = stateNode;\n      const eventHandlerListeners = getEventHandlerListeners(\n        reactScopeInstance,\n      );\n      if (eventHandlerListeners !== null) {\n        eventHandlerListeners.forEach(entry => {\n          if (\n            entry.type === nativeEventType &&\n            entry.capture === inCapturePhase\n          ) {\n            listeners.push(\n              createDispatchListener(\n                instance,\n                entry.callback,\n                (lastHostComponent: any),\n              ),\n            );\n          }\n        });\n      }\n    }\n    // If we are only accumulating events for the target, then we don't\n    // continue to propagate through the React fiber tree to find other\n    // listeners.\n    if (accumulateTargetOnly) {\n      break;\n    }\n    // If we are processing the onBeforeBlur event, then we need to take\n    // into consideration that part of the React tree might have been hidden\n    // or deleted (as we're invoking this event during commit). We can find\n    // this out by checking if intercept fiber set on the event matches the\n    // current instance fiber. In which case, we should clear all existing\n    // listeners.\n    if (enableCreateEventHandleAPI && nativeEvent.type === 'beforeblur') {\n      // $FlowFixMe: internal field\n      const detachedInterceptFiber = nativeEvent._detachedInterceptFiber;\n      if (\n        detachedInterceptFiber !== null &&\n        (detachedInterceptFiber === instance ||\n          detachedInterceptFiber === instance.alternate)\n      ) {\n        listeners = [];\n      }\n    }\n    instance = instance.return;\n  }\n  return listeners;\n}\n\n// We should only use this function for:\n// - BeforeInputEventPlugin\n// - ChangeEventPlugin\n// - SelectEventPlugin\n// This is because we only process these plugins\n// in the bubble phase, so we need to accumulate two\n// phase event listeners (via emulation).\nexport function accumulateTwoPhaseListeners(\n  targetFiber: Fiber | null,\n  reactName: string,\n): Array<DispatchListener> {\n  const captureName = reactName + 'Capture';\n  const listeners: Array<DispatchListener> = [];\n  let instance = targetFiber;\n\n  // Accumulate all instances and listeners via the target -> root path.\n  while (instance !== null) {\n    const {stateNode, tag} = instance;\n    // Handle listeners that are on HostComponents (i.e. <div>)\n    if (tag === HostComponent && stateNode !== null) {\n      const currentTarget = stateNode;\n      const captureListener = getListener(instance, captureName);\n      if (captureListener != null) {\n        listeners.unshift(\n          createDispatchListener(instance, captureListener, currentTarget),\n        );\n      }\n      const bubbleListener = getListener(instance, reactName);\n      if (bubbleListener != null) {\n        listeners.push(\n          createDispatchListener(instance, bubbleListener, currentTarget),\n        );\n      }\n    }\n    instance = instance.return;\n  }\n  return listeners;\n}\n\nfunction getParent(inst: Fiber | null): Fiber | null {\n  if (inst === null) {\n    return null;\n  }\n  do {\n    inst = inst.return;\n    // TODO: If this is a HostRoot we might want to bail out.\n    // That is depending on if we want nested subtrees (layers) to bubble\n    // events to their parent. We could also go through parentNode on the\n    // host node but that wouldn't work for React Native and doesn't let us\n    // do the portal feature.\n  } while (inst && inst.tag !== HostComponent);\n  if (inst) {\n    return inst;\n  }\n  return null;\n}\n\n/**\n * Return the lowest common ancestor of A and B, or null if they are in\n * different trees.\n */\nfunction getLowestCommonAncestor(instA: Fiber, instB: Fiber): Fiber | null {\n  let nodeA = instA;\n  let nodeB = instB;\n  let depthA = 0;\n  for (let tempA = nodeA; tempA; tempA = getParent(tempA)) {\n    depthA++;\n  }\n  let depthB = 0;\n  for (let tempB = nodeB; tempB; tempB = getParent(tempB)) {\n    depthB++;\n  }\n\n  // If A is deeper, crawl up.\n  while (depthA - depthB > 0) {\n    nodeA = getParent(nodeA);\n    depthA--;\n  }\n\n  // If B is deeper, crawl up.\n  while (depthB - depthA > 0) {\n    nodeB = getParent(nodeB);\n    depthB--;\n  }\n\n  // Walk in lockstep until we find a match.\n  let depth = depthA;\n  while (depth--) {\n    if (nodeA === nodeB || (nodeB !== null && nodeA === nodeB.alternate)) {\n      return nodeA;\n    }\n    nodeA = getParent(nodeA);\n    nodeB = getParent(nodeB);\n  }\n  return null;\n}\n\nfunction accumulateEnterLeaveListenersForEvent(\n  dispatchQueue: DispatchQueue,\n  event: KnownReactSyntheticEvent,\n  target: Fiber,\n  common: Fiber | null,\n  inCapturePhase: boolean,\n): void {\n  const registrationName = event._reactName;\n  const listeners: Array<DispatchListener> = [];\n\n  let instance = target;\n  while (instance !== null) {\n    if (instance === common) {\n      break;\n    }\n    const {alternate, stateNode, tag} = instance;\n    if (alternate !== null && alternate === common) {\n      break;\n    }\n    if (tag === HostComponent && stateNode !== null) {\n      const currentTarget = stateNode;\n      if (inCapturePhase) {\n        const captureListener = getListener(instance, registrationName);\n        if (captureListener != null) {\n          listeners.unshift(\n            createDispatchListener(instance, captureListener, currentTarget),\n          );\n        }\n      } else if (!inCapturePhase) {\n        const bubbleListener = getListener(instance, registrationName);\n        if (bubbleListener != null) {\n          listeners.push(\n            createDispatchListener(instance, bubbleListener, currentTarget),\n          );\n        }\n      }\n    }\n    instance = instance.return;\n  }\n  if (listeners.length !== 0) {\n    dispatchQueue.push({event, listeners});\n  }\n}\n\n// We should only use this function for:\n// - EnterLeaveEventPlugin\n// This is because we only process this plugin\n// in the bubble phase, so we need to accumulate two\n// phase event listeners.\nexport function accumulateEnterLeaveTwoPhaseListeners(\n  dispatchQueue: DispatchQueue,\n  leaveEvent: KnownReactSyntheticEvent,\n  enterEvent: null | KnownReactSyntheticEvent,\n  from: Fiber | null,\n  to: Fiber | null,\n): void {\n  const common = from && to ? getLowestCommonAncestor(from, to) : null;\n\n  if (from !== null) {\n    accumulateEnterLeaveListenersForEvent(\n      dispatchQueue,\n      leaveEvent,\n      from,\n      common,\n      false,\n    );\n  }\n  if (to !== null && enterEvent !== null) {\n    accumulateEnterLeaveListenersForEvent(\n      dispatchQueue,\n      enterEvent,\n      to,\n      common,\n      true,\n    );\n  }\n}\n\nexport function accumulateEventHandleNonManagedNodeListeners(\n  reactEventType: DOMEventName,\n  currentTarget: EventTarget,\n  inCapturePhase: boolean,\n): Array<DispatchListener> {\n  const listeners: Array<DispatchListener> = [];\n\n  const eventListeners = getEventHandlerListeners(currentTarget);\n  if (eventListeners !== null) {\n    eventListeners.forEach(entry => {\n      if (entry.type === reactEventType && entry.capture === inCapturePhase) {\n        listeners.push(\n          createDispatchListener(null, entry.callback, currentTarget),\n        );\n      }\n    });\n  }\n  return listeners;\n}\n\nexport function getListenerSetKey(\n  domEventName: DOMEventName,\n  capture: boolean,\n): string {\n  return `${domEventName}__${capture ? 'capture' : 'bubble'}`;\n}\n"]},"metadata":{},"sourceType":"module"}