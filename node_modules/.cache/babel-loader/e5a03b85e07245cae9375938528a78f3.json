{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { precacheFiberNode, updateFiberProps, getClosestInstanceFromNode, getFiberFromScopeInstance, getInstanceFromNode as getInstanceFromNodeDOMTree, isContainerMarkedAsRoot } from './ReactDOMComponentTree';\nexport { detachDeletedInstance } from './ReactDOMComponentTree';\nimport { hasRole } from './DOMAccessibilityRoles';\nimport { createElement, createTextNode, setInitialProperties, diffProperties, updateProperties, diffHydratedProperties, diffHydratedText, trapClickOnNonInteractiveElement, warnForUnmatchedText, warnForDeletedHydratableElement, warnForDeletedHydratableText, warnForInsertedHydratedElement, warnForInsertedHydratedText } from './ReactDOMComponent';\nimport { getSelectionInformation, restoreSelection } from './ReactInputSelection';\nimport setTextContent from './setTextContent';\nimport { validateDOMNesting, updatedAncestorInfo } from './validateDOMNesting';\nimport { isEnabled as ReactBrowserEventEmitterIsEnabled, setEnabled as ReactBrowserEventEmitterSetEnabled, getEventPriority } from '../events/ReactDOMEventListener';\nimport { getChildNamespace } from '../shared/DOMNamespaces';\nimport { ELEMENT_NODE, TEXT_NODE, COMMENT_NODE, DOCUMENT_NODE, DOCUMENT_FRAGMENT_NODE } from '../shared/HTMLNodeType';\nimport dangerousStyleValue from '../shared/dangerousStyleValue';\nimport { retryIfBlockedOn } from '../events/ReactDOMEventReplaying';\nimport { enableSuspenseServerRenderer, enableCreateEventHandleAPI, enableScopeAPI } from 'shared/ReactFeatureFlags';\nimport { HostComponent, HostText } from 'react-reconciler/src/ReactWorkTags';\nimport { listenToAllSupportedEvents } from '../events/DOMPluginEventSystem';\nimport { DefaultEventPriority } from 'react-reconciler/src/ReactEventPriorities';\nlet SUPPRESS_HYDRATION_WARNING;\n\nif (__DEV__) {\n  SUPPRESS_HYDRATION_WARNING = 'suppressHydrationWarning';\n}\n\nconst SUSPENSE_START_DATA = '$';\nconst SUSPENSE_END_DATA = '/$';\nconst SUSPENSE_PENDING_START_DATA = '$?';\nconst SUSPENSE_FALLBACK_START_DATA = '$!';\nconst STYLE = 'style';\nlet eventsEnabled = null;\nlet selectionInformation = null;\n\nfunction shouldAutoFocusHostComponent(type, props) {\n  switch (type) {\n    case 'button':\n    case 'input':\n    case 'select':\n    case 'textarea':\n      return !!props.autoFocus;\n  }\n\n  return false;\n}\n\nexport * from 'react-reconciler/src/ReactFiberHostConfigWithNoPersistence';\nexport function getRootHostContext(rootContainerInstance) {\n  let type;\n  let namespace;\n  const nodeType = rootContainerInstance.nodeType;\n\n  switch (nodeType) {\n    case DOCUMENT_NODE:\n    case DOCUMENT_FRAGMENT_NODE:\n      {\n        type = nodeType === DOCUMENT_NODE ? '#document' : '#fragment';\n        const root = rootContainerInstance.documentElement;\n        namespace = root ? root.namespaceURI : getChildNamespace(null, '');\n        break;\n      }\n\n    default:\n      {\n        const container = nodeType === COMMENT_NODE ? rootContainerInstance.parentNode : rootContainerInstance;\n        const ownNamespace = container.namespaceURI || null;\n        type = container.tagName;\n        namespace = getChildNamespace(ownNamespace, type);\n        break;\n      }\n  }\n\n  if (__DEV__) {\n    const validatedTag = type.toLowerCase();\n    const ancestorInfo = updatedAncestorInfo(null, validatedTag);\n    return {\n      namespace,\n      ancestorInfo\n    };\n  }\n\n  return namespace;\n}\nexport function getChildHostContext(parentHostContext, type, rootContainerInstance) {\n  if (__DEV__) {\n    const parentHostContextDev = parentHostContext;\n    const namespace = getChildNamespace(parentHostContextDev.namespace, type);\n    const ancestorInfo = updatedAncestorInfo(parentHostContextDev.ancestorInfo, type);\n    return {\n      namespace,\n      ancestorInfo\n    };\n  }\n\n  const parentNamespace = parentHostContext;\n  return getChildNamespace(parentNamespace, type);\n}\nexport function getPublicInstance(instance) {\n  return instance;\n}\nexport function prepareForCommit(containerInfo) {\n  eventsEnabled = ReactBrowserEventEmitterIsEnabled();\n  selectionInformation = getSelectionInformation();\n  let activeInstance = null;\n\n  if (enableCreateEventHandleAPI) {\n    const focusedElem = selectionInformation.focusedElem;\n\n    if (focusedElem !== null) {\n      activeInstance = getClosestInstanceFromNode(focusedElem);\n    }\n  }\n\n  ReactBrowserEventEmitterSetEnabled(false);\n  return activeInstance;\n}\nexport function beforeActiveInstanceBlur(internalInstanceHandle) {\n  if (enableCreateEventHandleAPI) {\n    ReactBrowserEventEmitterSetEnabled(true);\n    dispatchBeforeDetachedBlur(selectionInformation.focusedElem, internalInstanceHandle);\n    ReactBrowserEventEmitterSetEnabled(false);\n  }\n}\nexport function afterActiveInstanceBlur() {\n  if (enableCreateEventHandleAPI) {\n    ReactBrowserEventEmitterSetEnabled(true);\n    dispatchAfterDetachedBlur(selectionInformation.focusedElem);\n    ReactBrowserEventEmitterSetEnabled(false);\n  }\n}\nexport function resetAfterCommit(containerInfo) {\n  restoreSelection(selectionInformation);\n  ReactBrowserEventEmitterSetEnabled(eventsEnabled);\n  eventsEnabled = null;\n  selectionInformation = null;\n}\nexport function createInstance(type, props, rootContainerInstance, hostContext, internalInstanceHandle) {\n  let parentNamespace;\n\n  if (__DEV__) {\n    // TODO: take namespace into account when validating.\n    const hostContextDev = hostContext;\n    validateDOMNesting(type, null, hostContextDev.ancestorInfo);\n\n    if (typeof props.children === 'string' || typeof props.children === 'number') {\n      const string = '' + props.children;\n      const ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);\n      validateDOMNesting(null, string, ownAncestorInfo);\n    }\n\n    parentNamespace = hostContextDev.namespace;\n  } else {\n    parentNamespace = hostContext;\n  }\n\n  const domElement = createElement(type, props, rootContainerInstance, parentNamespace);\n  precacheFiberNode(internalInstanceHandle, domElement);\n  updateFiberProps(domElement, props);\n  return domElement;\n}\nexport function appendInitialChild(parentInstance, child) {\n  parentInstance.appendChild(child);\n}\nexport function finalizeInitialChildren(domElement, type, props, rootContainerInstance, hostContext) {\n  setInitialProperties(domElement, type, props, rootContainerInstance);\n  return shouldAutoFocusHostComponent(type, props);\n}\nexport function prepareUpdate(domElement, type, oldProps, newProps, rootContainerInstance, hostContext) {\n  if (__DEV__) {\n    const hostContextDev = hostContext;\n\n    if (typeof newProps.children !== typeof oldProps.children && (typeof newProps.children === 'string' || typeof newProps.children === 'number')) {\n      const string = '' + newProps.children;\n      const ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);\n      validateDOMNesting(null, string, ownAncestorInfo);\n    }\n  }\n\n  return diffProperties(domElement, type, oldProps, newProps, rootContainerInstance);\n}\nexport function shouldSetTextContent(type, props) {\n  return type === 'textarea' || type === 'noscript' || typeof props.children === 'string' || typeof props.children === 'number' || typeof props.dangerouslySetInnerHTML === 'object' && props.dangerouslySetInnerHTML !== null && props.dangerouslySetInnerHTML.__html != null;\n}\nexport function createTextInstance(text, rootContainerInstance, hostContext, internalInstanceHandle) {\n  if (__DEV__) {\n    const hostContextDev = hostContext;\n    validateDOMNesting(null, text, hostContextDev.ancestorInfo);\n  }\n\n  const textNode = createTextNode(text, rootContainerInstance);\n  precacheFiberNode(internalInstanceHandle, textNode);\n  return textNode;\n}\nexport function getCurrentEventPriority() {\n  const currentEvent = window.event;\n\n  if (currentEvent === undefined) {\n    return DefaultEventPriority;\n  }\n\n  return getEventPriority(currentEvent.type);\n}\nexport const isPrimaryRenderer = true;\nexport const warnsIfNotActing = true; // This initialization code may run even on server environments\n// if a component just imports ReactDOM (e.g. for findDOMNode).\n// Some environments might not have setTimeout or clearTimeout.\n\nexport const scheduleTimeout = typeof setTimeout === 'function' ? setTimeout : undefined;\nexport const cancelTimeout = typeof clearTimeout === 'function' ? clearTimeout : undefined;\nexport const noTimeout = -1;\nconst localPromise = typeof Promise === 'function' ? Promise : undefined; // -------------------\n//     Microtasks\n// -------------------\n\nexport const supportsMicrotasks = true;\nexport const scheduleMicrotask = typeof queueMicrotask === 'function' ? queueMicrotask : typeof localPromise !== 'undefined' ? callback => localPromise.resolve(null).then(callback).catch(handleErrorInNextTick) : scheduleTimeout; // TODO: Determine the best fallback here.\n\nfunction handleErrorInNextTick(error) {\n  setTimeout(() => {\n    throw error;\n  });\n} // -------------------\n//     Mutation\n// -------------------\n\n\nexport const supportsMutation = true;\nexport function commitMount(domElement, type, newProps, internalInstanceHandle) {\n  // Despite the naming that might imply otherwise, this method only\n  // fires if there is an `Update` effect scheduled during mounting.\n  // This happens if `finalizeInitialChildren` returns `true` (which it\n  // does to implement the `autoFocus` attribute on the client). But\n  // there are also other cases when this might happen (such as patching\n  // up text content during hydration mismatch). So we'll check this again.\n  if (shouldAutoFocusHostComponent(type, newProps)) {\n    domElement.focus();\n  }\n}\nexport function commitUpdate(domElement, updatePayload, type, oldProps, newProps, internalInstanceHandle) {\n  // Update the props handle so that we know which props are the ones with\n  // with current event handlers.\n  updateFiberProps(domElement, newProps); // Apply the diff to the DOM node.\n\n  updateProperties(domElement, updatePayload, type, oldProps, newProps);\n}\nexport function resetTextContent(domElement) {\n  setTextContent(domElement, '');\n}\nexport function commitTextUpdate(textInstance, oldText, newText) {\n  textInstance.nodeValue = newText;\n}\nexport function appendChild(parentInstance, child) {\n  parentInstance.appendChild(child);\n}\nexport function appendChildToContainer(container, child) {\n  let parentNode;\n\n  if (container.nodeType === COMMENT_NODE) {\n    parentNode = container.parentNode;\n    parentNode.insertBefore(child, container);\n  } else {\n    parentNode = container;\n    parentNode.appendChild(child);\n  } // This container might be used for a portal.\n  // If something inside a portal is clicked, that click should bubble\n  // through the React tree. However, on Mobile Safari the click would\n  // never bubble through the *DOM* tree unless an ancestor with onclick\n  // event exists. So we wouldn't see it and dispatch it.\n  // This is why we ensure that non React root containers have inline onclick\n  // defined.\n  // https://github.com/facebook/react/issues/11918\n\n\n  const reactRootContainer = container._reactRootContainer;\n\n  if ((reactRootContainer === null || reactRootContainer === undefined) && parentNode.onclick === null) {\n    // TODO: This cast may not be sound for SVG, MathML or custom elements.\n    trapClickOnNonInteractiveElement(parentNode);\n  }\n}\nexport function insertBefore(parentInstance, child, beforeChild) {\n  parentInstance.insertBefore(child, beforeChild);\n}\nexport function insertInContainerBefore(container, child, beforeChild) {\n  if (container.nodeType === COMMENT_NODE) {\n    container.parentNode.insertBefore(child, beforeChild);\n  } else {\n    container.insertBefore(child, beforeChild);\n  }\n}\n\nfunction createEvent(type, bubbles) {\n  const event = document.createEvent('Event');\n  event.initEvent(type, bubbles, false);\n  return event;\n}\n\nfunction dispatchBeforeDetachedBlur(target, internalInstanceHandle) {\n  if (enableCreateEventHandleAPI) {\n    const event = createEvent('beforeblur', true); // Dispatch \"beforeblur\" directly on the target,\n    // so it gets picked up by the event system and\n    // can propagate through the React internal tree.\n    // $FlowFixMe: internal field\n\n    event._detachedInterceptFiber = internalInstanceHandle;\n    target.dispatchEvent(event);\n  }\n}\n\nfunction dispatchAfterDetachedBlur(target) {\n  if (enableCreateEventHandleAPI) {\n    const event = createEvent('afterblur', false); // So we know what was detached, make the relatedTarget the\n    // detached target on the \"afterblur\" event.\n\n    event.relatedTarget = target; // Dispatch the event on the document.\n\n    document.dispatchEvent(event);\n  }\n}\n\nexport function removeChild(parentInstance, child) {\n  parentInstance.removeChild(child);\n}\nexport function removeChildFromContainer(container, child) {\n  if (container.nodeType === COMMENT_NODE) {\n    container.parentNode.removeChild(child);\n  } else {\n    container.removeChild(child);\n  }\n}\nexport function clearSuspenseBoundary(parentInstance, suspenseInstance) {\n  let node = suspenseInstance; // Delete all nodes within this suspense boundary.\n  // There might be nested nodes so we need to keep track of how\n  // deep we are and only break out when we're back on top.\n\n  let depth = 0;\n\n  do {\n    const nextNode = node.nextSibling;\n    parentInstance.removeChild(node);\n\n    if (nextNode && nextNode.nodeType === COMMENT_NODE) {\n      const data = nextNode.data;\n\n      if (data === SUSPENSE_END_DATA) {\n        if (depth === 0) {\n          parentInstance.removeChild(nextNode); // Retry if any event replaying was blocked on this.\n\n          retryIfBlockedOn(suspenseInstance);\n          return;\n        } else {\n          depth--;\n        }\n      } else if (data === SUSPENSE_START_DATA || data === SUSPENSE_PENDING_START_DATA || data === SUSPENSE_FALLBACK_START_DATA) {\n        depth++;\n      }\n    }\n\n    node = nextNode;\n  } while (node); // TODO: Warn, we didn't find the end comment boundary.\n  // Retry if any event replaying was blocked on this.\n\n\n  retryIfBlockedOn(suspenseInstance);\n}\nexport function clearSuspenseBoundaryFromContainer(container, suspenseInstance) {\n  if (container.nodeType === COMMENT_NODE) {\n    clearSuspenseBoundary(container.parentNode, suspenseInstance);\n  } else if (container.nodeType === ELEMENT_NODE) {\n    clearSuspenseBoundary(container, suspenseInstance);\n  } else {// Document nodes should never contain suspense boundaries.\n  } // Retry if any event replaying was blocked on this.\n\n\n  retryIfBlockedOn(container);\n}\nexport function hideInstance(instance) {\n  // TODO: Does this work for all element types? What about MathML? Should we\n  // pass host context to this method?\n  instance = instance;\n  const style = instance.style;\n\n  if (typeof style.setProperty === 'function') {\n    style.setProperty('display', 'none', 'important');\n  } else {\n    style.display = 'none';\n  }\n}\nexport function hideTextInstance(textInstance) {\n  textInstance.nodeValue = '';\n}\nexport function unhideInstance(instance, props) {\n  instance = instance;\n  const styleProp = props[STYLE];\n  const display = styleProp !== undefined && styleProp !== null && styleProp.hasOwnProperty('display') ? styleProp.display : null;\n  instance.style.display = dangerousStyleValue('display', display);\n}\nexport function unhideTextInstance(textInstance, text) {\n  textInstance.nodeValue = text;\n}\nexport function clearContainer(container) {\n  if (container.nodeType === ELEMENT_NODE) {\n    container.textContent = '';\n  } else if (container.nodeType === DOCUMENT_NODE) {\n    const body = container.body;\n\n    if (body != null) {\n      body.textContent = '';\n    }\n  }\n} // -------------------\n//     Hydration\n// -------------------\n\nexport const supportsHydration = true;\nexport function canHydrateInstance(instance, type, props) {\n  if (instance.nodeType !== ELEMENT_NODE || type.toLowerCase() !== instance.nodeName.toLowerCase()) {\n    return null;\n  } // This has now been refined to an element node.\n\n\n  return instance;\n}\nexport function canHydrateTextInstance(instance, text) {\n  if (text === '' || instance.nodeType !== TEXT_NODE) {\n    // Empty strings are not parsed by HTML so there won't be a correct match here.\n    return null;\n  } // This has now been refined to a text node.\n\n\n  return instance;\n}\nexport function canHydrateSuspenseInstance(instance) {\n  if (instance.nodeType !== COMMENT_NODE) {\n    // Empty strings are not parsed by HTML so there won't be a correct match here.\n    return null;\n  } // This has now been refined to a suspense node.\n\n\n  return instance;\n}\nexport function isSuspenseInstancePending(instance) {\n  return instance.data === SUSPENSE_PENDING_START_DATA;\n}\nexport function isSuspenseInstanceFallback(instance) {\n  return instance.data === SUSPENSE_FALLBACK_START_DATA;\n}\nexport function registerSuspenseInstanceRetry(instance, callback) {\n  instance._reactRetry = callback;\n}\n\nfunction getNextHydratable(node) {\n  // Skip non-hydratable nodes.\n  for (; node != null; node = node.nextSibling) {\n    const nodeType = node.nodeType;\n\n    if (nodeType === ELEMENT_NODE || nodeType === TEXT_NODE) {\n      break;\n    }\n\n    if (enableSuspenseServerRenderer) {\n      if (nodeType === COMMENT_NODE) {\n        const nodeData = node.data;\n\n        if (nodeData === SUSPENSE_START_DATA || nodeData === SUSPENSE_FALLBACK_START_DATA || nodeData === SUSPENSE_PENDING_START_DATA) {\n          break;\n        }\n\n        if (nodeData === SUSPENSE_END_DATA) {\n          return null;\n        }\n      }\n    }\n  }\n\n  return node;\n}\n\nexport function getNextHydratableSibling(instance) {\n  return getNextHydratable(instance.nextSibling);\n}\nexport function getFirstHydratableChild(parentInstance) {\n  return getNextHydratable(parentInstance.firstChild);\n}\nexport function getFirstHydratableChildWithinContainer(parentContainer) {\n  return getNextHydratable(parentContainer.firstChild);\n}\nexport function getFirstHydratableChildWithinSuspenseInstance(parentInstance) {\n  return getNextHydratable(parentInstance.nextSibling);\n}\nexport function hydrateInstance(instance, type, props, rootContainerInstance, hostContext, internalInstanceHandle) {\n  precacheFiberNode(internalInstanceHandle, instance); // TODO: Possibly defer this until the commit phase where all the events\n  // get attached.\n\n  updateFiberProps(instance, props);\n  let parentNamespace;\n\n  if (__DEV__) {\n    const hostContextDev = hostContext;\n    parentNamespace = hostContextDev.namespace;\n  } else {\n    parentNamespace = hostContext;\n  }\n\n  return diffHydratedProperties(instance, type, props, parentNamespace, rootContainerInstance);\n}\nexport function hydrateTextInstance(textInstance, text, internalInstanceHandle) {\n  precacheFiberNode(internalInstanceHandle, textInstance);\n  return diffHydratedText(textInstance, text);\n}\nexport function hydrateSuspenseInstance(suspenseInstance, internalInstanceHandle) {\n  precacheFiberNode(internalInstanceHandle, suspenseInstance);\n}\nexport function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance) {\n  let node = suspenseInstance.nextSibling; // Skip past all nodes within this suspense boundary.\n  // There might be nested nodes so we need to keep track of how\n  // deep we are and only break out when we're back on top.\n\n  let depth = 0;\n\n  while (node) {\n    if (node.nodeType === COMMENT_NODE) {\n      const data = node.data;\n\n      if (data === SUSPENSE_END_DATA) {\n        if (depth === 0) {\n          return getNextHydratableSibling(node);\n        } else {\n          depth--;\n        }\n      } else if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {\n        depth++;\n      }\n    }\n\n    node = node.nextSibling;\n  } // TODO: Warn, we didn't find the end comment boundary.\n\n\n  return null;\n} // Returns the SuspenseInstance if this node is a direct child of a\n// SuspenseInstance. I.e. if its previous sibling is a Comment with\n// SUSPENSE_x_START_DATA. Otherwise, null.\n\nexport function getParentSuspenseInstance(targetInstance) {\n  let node = targetInstance.previousSibling; // Skip past all nodes within this suspense boundary.\n  // There might be nested nodes so we need to keep track of how\n  // deep we are and only break out when we're back on top.\n\n  let depth = 0;\n\n  while (node) {\n    if (node.nodeType === COMMENT_NODE) {\n      const data = node.data;\n\n      if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {\n        if (depth === 0) {\n          return node;\n        } else {\n          depth--;\n        }\n      } else if (data === SUSPENSE_END_DATA) {\n        depth++;\n      }\n    }\n\n    node = node.previousSibling;\n  }\n\n  return null;\n}\nexport function commitHydratedContainer(container) {\n  // Retry if any event replaying was blocked on this.\n  retryIfBlockedOn(container);\n}\nexport function commitHydratedSuspenseInstance(suspenseInstance) {\n  // Retry if any event replaying was blocked on this.\n  retryIfBlockedOn(suspenseInstance);\n}\nexport function shouldDeleteUnhydratedTailInstances(parentType) {\n  return parentType !== 'head' && parentType !== 'body';\n}\nexport function didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, text) {\n  if (__DEV__) {\n    warnForUnmatchedText(textInstance, text);\n  }\n}\nexport function didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, text) {\n  if (__DEV__ && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n    warnForUnmatchedText(textInstance, text);\n  }\n}\nexport function didNotHydrateInstanceWithinContainer(parentContainer, instance) {\n  if (__DEV__) {\n    if (instance.nodeType === ELEMENT_NODE) {\n      warnForDeletedHydratableElement(parentContainer, instance);\n    } else if (instance.nodeType === COMMENT_NODE) {// TODO: warnForDeletedHydratableSuspenseBoundary\n    } else {\n      warnForDeletedHydratableText(parentContainer, instance);\n    }\n  }\n}\nexport function didNotHydrateInstanceWithinSuspenseInstance(parentInstance, instance) {\n  if (__DEV__) {\n    // $FlowFixMe: Only Element or Document can be parent nodes.\n    const parentNode = parentInstance.parentNode;\n\n    if (parentNode !== null) {\n      if (instance.nodeType === ELEMENT_NODE) {\n        warnForDeletedHydratableElement(parentNode, instance);\n      } else if (instance.nodeType === COMMENT_NODE) {// TODO: warnForDeletedHydratableSuspenseBoundary\n      } else {\n        warnForDeletedHydratableText(parentNode, instance);\n      }\n    }\n  }\n}\nexport function didNotHydrateInstance(parentType, parentProps, parentInstance, instance) {\n  if (__DEV__ && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n    if (instance.nodeType === ELEMENT_NODE) {\n      warnForDeletedHydratableElement(parentInstance, instance);\n    } else if (instance.nodeType === COMMENT_NODE) {// TODO: warnForDeletedHydratableSuspenseBoundary\n    } else {\n      warnForDeletedHydratableText(parentInstance, instance);\n    }\n  }\n}\nexport function didNotFindHydratableInstanceWithinContainer(parentContainer, type, props) {\n  if (__DEV__) {\n    warnForInsertedHydratedElement(parentContainer, type, props);\n  }\n}\nexport function didNotFindHydratableTextInstanceWithinContainer(parentContainer, text) {\n  if (__DEV__) {\n    warnForInsertedHydratedText(parentContainer, text);\n  }\n}\nexport function didNotFindHydratableSuspenseInstanceWithinContainer(parentContainer) {\n  if (__DEV__) {// TODO: warnForInsertedHydratedSuspense(parentContainer);\n  }\n}\nexport function didNotFindHydratableInstanceWithinSuspenseInstance(parentInstance, type, props) {\n  if (__DEV__) {\n    // $FlowFixMe: Only Element or Document can be parent nodes.\n    const parentNode = parentInstance.parentNode;\n    if (parentNode !== null) warnForInsertedHydratedElement(parentNode, type, props);\n  }\n}\nexport function didNotFindHydratableTextInstanceWithinSuspenseInstance(parentInstance, text) {\n  if (__DEV__) {\n    // $FlowFixMe: Only Element or Document can be parent nodes.\n    const parentNode = parentInstance.parentNode;\n    if (parentNode !== null) warnForInsertedHydratedText(parentNode, text);\n  }\n}\nexport function didNotFindHydratableSuspenseInstanceWithinSuspenseInstance(parentInstance) {\n  if (__DEV__) {// const parentNode: Element | Document | null = parentInstance.parentNode;\n    // TODO: warnForInsertedHydratedSuspense(parentNode);\n  }\n}\nexport function didNotFindHydratableInstance(parentType, parentProps, parentInstance, type, props) {\n  if (__DEV__ && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n    warnForInsertedHydratedElement(parentInstance, type, props);\n  }\n}\nexport function didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, text) {\n  if (__DEV__ && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n    warnForInsertedHydratedText(parentInstance, text);\n  }\n}\nexport function didNotFindHydratableSuspenseInstance(parentType, parentProps, parentInstance) {\n  if (__DEV__ && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {// TODO: warnForInsertedHydratedSuspense(parentInstance);\n  }\n}\nexport function errorHydratingContainer(parentContainer) {\n  if (__DEV__) {\n    console.error('An error occurred during hydration. The server HTML was replaced with client content in <%s>.', parentContainer.nodeName.toLowerCase());\n  }\n}\nexport function getInstanceFromNode(node) {\n  return getClosestInstanceFromNode(node) || null;\n}\nexport function preparePortalMount(portalInstance) {\n  listenToAllSupportedEvents(portalInstance);\n}\nexport function prepareScopeUpdate(scopeInstance, internalInstanceHandle) {\n  if (enableScopeAPI) {\n    precacheFiberNode(internalInstanceHandle, scopeInstance);\n  }\n}\nexport function getInstanceFromScope(scopeInstance) {\n  if (enableScopeAPI) {\n    return getFiberFromScopeInstance(scopeInstance);\n  }\n\n  return null;\n}\nexport const supportsTestSelectors = true;\nexport function findFiberRoot(node) {\n  const stack = [node];\n  let index = 0;\n\n  while (index < stack.length) {\n    const current = stack[index++];\n\n    if (isContainerMarkedAsRoot(current)) {\n      return getInstanceFromNodeDOMTree(current);\n    }\n\n    stack.push(...current.children);\n  }\n\n  return null;\n}\nexport function getBoundingRect(node) {\n  const rect = node.getBoundingClientRect();\n  return {\n    x: rect.left,\n    y: rect.top,\n    width: rect.width,\n    height: rect.height\n  };\n}\nexport function matchAccessibilityRole(node, role) {\n  if (hasRole(node, role)) {\n    return true;\n  }\n\n  return false;\n}\nexport function getTextContent(fiber) {\n  switch (fiber.tag) {\n    case HostComponent:\n      let textContent = '';\n      const childNodes = fiber.stateNode.childNodes;\n\n      for (let i = 0; i < childNodes.length; i++) {\n        const childNode = childNodes[i];\n\n        if (childNode.nodeType === Node.TEXT_NODE) {\n          textContent += childNode.textContent;\n        }\n      }\n\n      return textContent;\n\n    case HostText:\n      return fiber.stateNode.textContent;\n  }\n\n  return null;\n}\nexport function isHiddenSubtree(fiber) {\n  return fiber.tag === HostComponent && fiber.memoizedProps.hidden === true;\n}\nexport function setFocusIfFocusable(node) {\n  // The logic for determining if an element is focusable is kind of complex,\n  // and since we want to actually change focus anyway- we can just skip it.\n  // Instead we'll just listen for a \"focus\" event to verify that focus was set.\n  //\n  // We could compare the node to document.activeElement after focus,\n  // but this would not handle the case where application code managed focus to automatically blur.\n  let didFocus = false;\n\n  const handleFocus = () => {\n    didFocus = true;\n  };\n\n  const element = node;\n\n  try {\n    element.addEventListener('focus', handleFocus);\n    (element.focus || HTMLElement.prototype.focus).call(element);\n  } finally {\n    element.removeEventListener('focus', handleFocus);\n  }\n\n  return didFocus;\n}\nexport function setupIntersectionObserver(targets, callback, options) {\n  const rectRatioCache = new Map();\n  targets.forEach(target => {\n    rectRatioCache.set(target, {\n      rect: getBoundingRect(target),\n      ratio: 0\n    });\n  });\n\n  const handleIntersection = entries => {\n    entries.forEach(entry => {\n      const {\n        boundingClientRect,\n        intersectionRatio,\n        target\n      } = entry;\n      rectRatioCache.set(target, {\n        rect: {\n          x: boundingClientRect.left,\n          y: boundingClientRect.top,\n          width: boundingClientRect.width,\n          height: boundingClientRect.height\n        },\n        ratio: intersectionRatio\n      });\n    });\n    callback(Array.from(rectRatioCache.values()));\n  };\n\n  const observer = new IntersectionObserver(handleIntersection, options);\n  targets.forEach(target => {\n    observer.observe(target);\n  });\n  return {\n    disconnect: () => observer.disconnect(),\n    observe: target => {\n      rectRatioCache.set(target, {\n        rect: getBoundingRect(target),\n        ratio: 0\n      });\n      observer.observe(target);\n    },\n    unobserve: target => {\n      rectRatioCache.delete(target);\n      observer.unobserve(target);\n    }\n  };\n}","map":{"version":3,"sources":["/Users/zhangshuo/git/react-source-test/src/react/packages/react-dom/src/client/ReactDOMHostConfig.js"],"names":["precacheFiberNode","updateFiberProps","getClosestInstanceFromNode","getFiberFromScopeInstance","getInstanceFromNode","getInstanceFromNodeDOMTree","isContainerMarkedAsRoot","detachDeletedInstance","hasRole","createElement","createTextNode","setInitialProperties","diffProperties","updateProperties","diffHydratedProperties","diffHydratedText","trapClickOnNonInteractiveElement","warnForUnmatchedText","warnForDeletedHydratableElement","warnForDeletedHydratableText","warnForInsertedHydratedElement","warnForInsertedHydratedText","getSelectionInformation","restoreSelection","setTextContent","validateDOMNesting","updatedAncestorInfo","isEnabled","ReactBrowserEventEmitterIsEnabled","setEnabled","ReactBrowserEventEmitterSetEnabled","getEventPriority","getChildNamespace","ELEMENT_NODE","TEXT_NODE","COMMENT_NODE","DOCUMENT_NODE","DOCUMENT_FRAGMENT_NODE","dangerousStyleValue","retryIfBlockedOn","enableSuspenseServerRenderer","enableCreateEventHandleAPI","enableScopeAPI","HostComponent","HostText","listenToAllSupportedEvents","DefaultEventPriority","SUPPRESS_HYDRATION_WARNING","__DEV__","SUSPENSE_START_DATA","SUSPENSE_END_DATA","SUSPENSE_PENDING_START_DATA","SUSPENSE_FALLBACK_START_DATA","STYLE","eventsEnabled","selectionInformation","shouldAutoFocusHostComponent","type","props","autoFocus","getRootHostContext","rootContainerInstance","namespace","nodeType","root","documentElement","namespaceURI","container","parentNode","ownNamespace","tagName","validatedTag","toLowerCase","ancestorInfo","getChildHostContext","parentHostContext","parentHostContextDev","parentNamespace","getPublicInstance","instance","prepareForCommit","containerInfo","activeInstance","focusedElem","beforeActiveInstanceBlur","internalInstanceHandle","dispatchBeforeDetachedBlur","afterActiveInstanceBlur","dispatchAfterDetachedBlur","resetAfterCommit","createInstance","hostContext","hostContextDev","children","string","ownAncestorInfo","domElement","appendInitialChild","parentInstance","child","appendChild","finalizeInitialChildren","prepareUpdate","oldProps","newProps","shouldSetTextContent","dangerouslySetInnerHTML","__html","createTextInstance","text","textNode","getCurrentEventPriority","currentEvent","window","event","undefined","isPrimaryRenderer","warnsIfNotActing","scheduleTimeout","setTimeout","cancelTimeout","clearTimeout","noTimeout","localPromise","Promise","supportsMicrotasks","scheduleMicrotask","queueMicrotask","callback","resolve","then","catch","handleErrorInNextTick","error","supportsMutation","commitMount","focus","commitUpdate","updatePayload","resetTextContent","commitTextUpdate","textInstance","oldText","newText","nodeValue","appendChildToContainer","insertBefore","reactRootContainer","_reactRootContainer","onclick","beforeChild","insertInContainerBefore","createEvent","bubbles","document","initEvent","target","_detachedInterceptFiber","dispatchEvent","relatedTarget","removeChild","removeChildFromContainer","clearSuspenseBoundary","suspenseInstance","node","depth","nextNode","nextSibling","data","clearSuspenseBoundaryFromContainer","hideInstance","style","setProperty","display","hideTextInstance","unhideInstance","styleProp","hasOwnProperty","unhideTextInstance","clearContainer","textContent","body","supportsHydration","canHydrateInstance","nodeName","canHydrateTextInstance","canHydrateSuspenseInstance","isSuspenseInstancePending","isSuspenseInstanceFallback","registerSuspenseInstanceRetry","_reactRetry","getNextHydratable","nodeData","getNextHydratableSibling","getFirstHydratableChild","firstChild","getFirstHydratableChildWithinContainer","parentContainer","getFirstHydratableChildWithinSuspenseInstance","hydrateInstance","hydrateTextInstance","hydrateSuspenseInstance","getNextHydratableInstanceAfterSuspenseInstance","getParentSuspenseInstance","targetInstance","previousSibling","commitHydratedContainer","commitHydratedSuspenseInstance","shouldDeleteUnhydratedTailInstances","parentType","didNotMatchHydratedContainerTextInstance","didNotMatchHydratedTextInstance","parentProps","didNotHydrateInstanceWithinContainer","didNotHydrateInstanceWithinSuspenseInstance","didNotHydrateInstance","didNotFindHydratableInstanceWithinContainer","didNotFindHydratableTextInstanceWithinContainer","didNotFindHydratableSuspenseInstanceWithinContainer","didNotFindHydratableInstanceWithinSuspenseInstance","didNotFindHydratableTextInstanceWithinSuspenseInstance","didNotFindHydratableSuspenseInstanceWithinSuspenseInstance","didNotFindHydratableInstance","didNotFindHydratableTextInstance","didNotFindHydratableSuspenseInstance","errorHydratingContainer","console","preparePortalMount","portalInstance","prepareScopeUpdate","scopeInstance","getInstanceFromScope","supportsTestSelectors","findFiberRoot","stack","index","length","current","push","getBoundingRect","rect","getBoundingClientRect","x","left","y","top","width","height","matchAccessibilityRole","role","getTextContent","fiber","tag","childNodes","stateNode","i","childNode","Node","isHiddenSubtree","memoizedProps","hidden","setFocusIfFocusable","didFocus","handleFocus","element","addEventListener","HTMLElement","prototype","call","removeEventListener","setupIntersectionObserver","targets","options","rectRatioCache","Map","forEach","set","ratio","handleIntersection","entries","entry","boundingClientRect","intersectionRatio","Array","from","values","observer","IntersectionObserver","observe","disconnect","unobserve","delete"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {DOMEventName} from '../events/DOMEventNames';\nimport type {Fiber, FiberRoot} from 'react-reconciler/src/ReactInternalTypes';\nimport type {\n  BoundingRect,\n  IntersectionObserverOptions,\n  ObserveVisibleRectsCallback,\n} from 'react-reconciler/src/ReactTestSelectors';\nimport type {ReactScopeInstance} from 'shared/ReactTypes';\n\nimport {\n  precacheFiberNode,\n  updateFiberProps,\n  getClosestInstanceFromNode,\n  getFiberFromScopeInstance,\n  getInstanceFromNode as getInstanceFromNodeDOMTree,\n  isContainerMarkedAsRoot,\n} from './ReactDOMComponentTree';\nexport {detachDeletedInstance} from './ReactDOMComponentTree';\nimport {hasRole} from './DOMAccessibilityRoles';\nimport {\n  createElement,\n  createTextNode,\n  setInitialProperties,\n  diffProperties,\n  updateProperties,\n  diffHydratedProperties,\n  diffHydratedText,\n  trapClickOnNonInteractiveElement,\n  warnForUnmatchedText,\n  warnForDeletedHydratableElement,\n  warnForDeletedHydratableText,\n  warnForInsertedHydratedElement,\n  warnForInsertedHydratedText,\n} from './ReactDOMComponent';\nimport {getSelectionInformation, restoreSelection} from './ReactInputSelection';\nimport setTextContent from './setTextContent';\nimport {validateDOMNesting, updatedAncestorInfo} from './validateDOMNesting';\nimport {\n  isEnabled as ReactBrowserEventEmitterIsEnabled,\n  setEnabled as ReactBrowserEventEmitterSetEnabled,\n  getEventPriority,\n} from '../events/ReactDOMEventListener';\nimport {getChildNamespace} from '../shared/DOMNamespaces';\nimport {\n  ELEMENT_NODE,\n  TEXT_NODE,\n  COMMENT_NODE,\n  DOCUMENT_NODE,\n  DOCUMENT_FRAGMENT_NODE,\n} from '../shared/HTMLNodeType';\nimport dangerousStyleValue from '../shared/dangerousStyleValue';\n\nimport {retryIfBlockedOn} from '../events/ReactDOMEventReplaying';\n\nimport {\n  enableSuspenseServerRenderer,\n  enableCreateEventHandleAPI,\n  enableScopeAPI,\n} from 'shared/ReactFeatureFlags';\nimport {HostComponent, HostText} from 'react-reconciler/src/ReactWorkTags';\nimport {listenToAllSupportedEvents} from '../events/DOMPluginEventSystem';\n\nimport {DefaultEventPriority} from 'react-reconciler/src/ReactEventPriorities';\n\nexport type Type = string;\nexport type Props = {\n  autoFocus?: boolean,\n  children?: mixed,\n  disabled?: boolean,\n  hidden?: boolean,\n  suppressHydrationWarning?: boolean,\n  dangerouslySetInnerHTML?: mixed,\n  style?: {display?: string, ...},\n  bottom?: null | number,\n  left?: null | number,\n  right?: null | number,\n  top?: null | number,\n  ...\n};\nexport type EventTargetChildElement = {\n  type: string,\n  props: null | {\n    style?: {\n      position?: string,\n      zIndex?: number,\n      bottom?: string,\n      left?: string,\n      right?: string,\n      top?: string,\n      ...\n    },\n    ...\n  },\n  ...\n};\nexport type Container =\n  | (Element & {_reactRootContainer?: FiberRoot, ...})\n  | (Document & {_reactRootContainer?: FiberRoot, ...});\nexport type Instance = Element;\nexport type TextInstance = Text;\nexport type SuspenseInstance = Comment & {_reactRetry?: () => void, ...};\nexport type HydratableInstance = Instance | TextInstance | SuspenseInstance;\nexport type PublicInstance = Element | Text;\ntype HostContextDev = {\n  namespace: string,\n  ancestorInfo: mixed,\n  ...\n};\ntype HostContextProd = string;\nexport type HostContext = HostContextDev | HostContextProd;\nexport type UpdatePayload = Array<mixed>;\nexport type ChildSet = void; // Unused\nexport type TimeoutHandle = TimeoutID;\nexport type NoTimeout = -1;\nexport type RendererInspectionConfig = $ReadOnly<{||}>;\n\ntype SelectionInformation = {|\n  focusedElem: null | HTMLElement,\n  selectionRange: mixed,\n|};\n\nlet SUPPRESS_HYDRATION_WARNING;\nif (__DEV__) {\n  SUPPRESS_HYDRATION_WARNING = 'suppressHydrationWarning';\n}\n\nconst SUSPENSE_START_DATA = '$';\nconst SUSPENSE_END_DATA = '/$';\nconst SUSPENSE_PENDING_START_DATA = '$?';\nconst SUSPENSE_FALLBACK_START_DATA = '$!';\n\nconst STYLE = 'style';\n\nlet eventsEnabled: ?boolean = null;\nlet selectionInformation: null | SelectionInformation = null;\n\nfunction shouldAutoFocusHostComponent(type: string, props: Props): boolean {\n  switch (type) {\n    case 'button':\n    case 'input':\n    case 'select':\n    case 'textarea':\n      return !!props.autoFocus;\n  }\n  return false;\n}\n\nexport * from 'react-reconciler/src/ReactFiberHostConfigWithNoPersistence';\n\nexport function getRootHostContext(\n  rootContainerInstance: Container,\n): HostContext {\n  let type;\n  let namespace;\n  const nodeType = rootContainerInstance.nodeType;\n  switch (nodeType) {\n    case DOCUMENT_NODE:\n    case DOCUMENT_FRAGMENT_NODE: {\n      type = nodeType === DOCUMENT_NODE ? '#document' : '#fragment';\n      const root = (rootContainerInstance: any).documentElement;\n      namespace = root ? root.namespaceURI : getChildNamespace(null, '');\n      break;\n    }\n    default: {\n      const container: any =\n        nodeType === COMMENT_NODE\n          ? rootContainerInstance.parentNode\n          : rootContainerInstance;\n      const ownNamespace = container.namespaceURI || null;\n      type = container.tagName;\n      namespace = getChildNamespace(ownNamespace, type);\n      break;\n    }\n  }\n  if (__DEV__) {\n    const validatedTag = type.toLowerCase();\n    const ancestorInfo = updatedAncestorInfo(null, validatedTag);\n    return {namespace, ancestorInfo};\n  }\n  return namespace;\n}\n\nexport function getChildHostContext(\n  parentHostContext: HostContext,\n  type: string,\n  rootContainerInstance: Container,\n): HostContext {\n  if (__DEV__) {\n    const parentHostContextDev = ((parentHostContext: any): HostContextDev);\n    const namespace = getChildNamespace(parentHostContextDev.namespace, type);\n    const ancestorInfo = updatedAncestorInfo(\n      parentHostContextDev.ancestorInfo,\n      type,\n    );\n    return {namespace, ancestorInfo};\n  }\n  const parentNamespace = ((parentHostContext: any): HostContextProd);\n  return getChildNamespace(parentNamespace, type);\n}\n\nexport function getPublicInstance(instance: Instance): * {\n  return instance;\n}\n\nexport function prepareForCommit(containerInfo: Container): Object | null {\n  eventsEnabled = ReactBrowserEventEmitterIsEnabled();\n  selectionInformation = getSelectionInformation();\n  let activeInstance = null;\n  if (enableCreateEventHandleAPI) {\n    const focusedElem = selectionInformation.focusedElem;\n    if (focusedElem !== null) {\n      activeInstance = getClosestInstanceFromNode(focusedElem);\n    }\n  }\n  ReactBrowserEventEmitterSetEnabled(false);\n  return activeInstance;\n}\n\nexport function beforeActiveInstanceBlur(internalInstanceHandle: Object): void {\n  if (enableCreateEventHandleAPI) {\n    ReactBrowserEventEmitterSetEnabled(true);\n    dispatchBeforeDetachedBlur(\n      (selectionInformation: any).focusedElem,\n      internalInstanceHandle,\n    );\n    ReactBrowserEventEmitterSetEnabled(false);\n  }\n}\n\nexport function afterActiveInstanceBlur(): void {\n  if (enableCreateEventHandleAPI) {\n    ReactBrowserEventEmitterSetEnabled(true);\n    dispatchAfterDetachedBlur((selectionInformation: any).focusedElem);\n    ReactBrowserEventEmitterSetEnabled(false);\n  }\n}\n\nexport function resetAfterCommit(containerInfo: Container): void {\n  restoreSelection(selectionInformation);\n  ReactBrowserEventEmitterSetEnabled(eventsEnabled);\n  eventsEnabled = null;\n  selectionInformation = null;\n}\n\nexport function createInstance(\n  type: string,\n  props: Props,\n  rootContainerInstance: Container,\n  hostContext: HostContext,\n  internalInstanceHandle: Object,\n): Instance {\n  let parentNamespace: string;\n  if (__DEV__) {\n    // TODO: take namespace into account when validating.\n    const hostContextDev = ((hostContext: any): HostContextDev);\n    validateDOMNesting(type, null, hostContextDev.ancestorInfo);\n    if (\n      typeof props.children === 'string' ||\n      typeof props.children === 'number'\n    ) {\n      const string = '' + props.children;\n      const ownAncestorInfo = updatedAncestorInfo(\n        hostContextDev.ancestorInfo,\n        type,\n      );\n      validateDOMNesting(null, string, ownAncestorInfo);\n    }\n    parentNamespace = hostContextDev.namespace;\n  } else {\n    parentNamespace = ((hostContext: any): HostContextProd);\n  }\n  const domElement: Instance = createElement(\n    type,\n    props,\n    rootContainerInstance,\n    parentNamespace,\n  );\n  precacheFiberNode(internalInstanceHandle, domElement);\n  updateFiberProps(domElement, props);\n  return domElement;\n}\n\nexport function appendInitialChild(\n  parentInstance: Instance,\n  child: Instance | TextInstance,\n): void {\n  parentInstance.appendChild(child);\n}\n\nexport function finalizeInitialChildren(\n  domElement: Instance,\n  type: string,\n  props: Props,\n  rootContainerInstance: Container,\n  hostContext: HostContext,\n): boolean {\n  setInitialProperties(domElement, type, props, rootContainerInstance);\n  return shouldAutoFocusHostComponent(type, props);\n}\n\nexport function prepareUpdate(\n  domElement: Instance,\n  type: string,\n  oldProps: Props,\n  newProps: Props,\n  rootContainerInstance: Container,\n  hostContext: HostContext,\n): null | Array<mixed> {\n  if (__DEV__) {\n    const hostContextDev = ((hostContext: any): HostContextDev);\n    if (\n      typeof newProps.children !== typeof oldProps.children &&\n      (typeof newProps.children === 'string' ||\n        typeof newProps.children === 'number')\n    ) {\n      const string = '' + newProps.children;\n      const ownAncestorInfo = updatedAncestorInfo(\n        hostContextDev.ancestorInfo,\n        type,\n      );\n      validateDOMNesting(null, string, ownAncestorInfo);\n    }\n  }\n  return diffProperties(\n    domElement,\n    type,\n    oldProps,\n    newProps,\n    rootContainerInstance,\n  );\n}\n\nexport function shouldSetTextContent(type: string, props: Props): boolean {\n  return (\n    type === 'textarea' ||\n    type === 'noscript' ||\n    typeof props.children === 'string' ||\n    typeof props.children === 'number' ||\n    (typeof props.dangerouslySetInnerHTML === 'object' &&\n      props.dangerouslySetInnerHTML !== null &&\n      props.dangerouslySetInnerHTML.__html != null)\n  );\n}\n\nexport function createTextInstance(\n  text: string,\n  rootContainerInstance: Container,\n  hostContext: HostContext,\n  internalInstanceHandle: Object,\n): TextInstance {\n  if (__DEV__) {\n    const hostContextDev = ((hostContext: any): HostContextDev);\n    validateDOMNesting(null, text, hostContextDev.ancestorInfo);\n  }\n  const textNode: TextInstance = createTextNode(text, rootContainerInstance);\n  precacheFiberNode(internalInstanceHandle, textNode);\n  return textNode;\n}\n\nexport function getCurrentEventPriority(): * {\n  const currentEvent = window.event;\n  if (currentEvent === undefined) {\n    return DefaultEventPriority;\n  }\n  return getEventPriority(currentEvent.type);\n}\n\nexport const isPrimaryRenderer = true;\nexport const warnsIfNotActing = true;\n// This initialization code may run even on server environments\n// if a component just imports ReactDOM (e.g. for findDOMNode).\n// Some environments might not have setTimeout or clearTimeout.\nexport const scheduleTimeout: any =\n  typeof setTimeout === 'function' ? setTimeout : (undefined: any);\nexport const cancelTimeout: any =\n  typeof clearTimeout === 'function' ? clearTimeout : (undefined: any);\nexport const noTimeout = -1;\nconst localPromise = typeof Promise === 'function' ? Promise : undefined;\n\n// -------------------\n//     Microtasks\n// -------------------\nexport const supportsMicrotasks = true;\nexport const scheduleMicrotask: any =\n  typeof queueMicrotask === 'function'\n    ? queueMicrotask\n    : typeof localPromise !== 'undefined'\n    ? callback =>\n        localPromise\n          .resolve(null)\n          .then(callback)\n          .catch(handleErrorInNextTick)\n    : scheduleTimeout; // TODO: Determine the best fallback here.\n\nfunction handleErrorInNextTick(error) {\n  setTimeout(() => {\n    throw error;\n  });\n}\n\n// -------------------\n//     Mutation\n// -------------------\n\nexport const supportsMutation = true;\n\nexport function commitMount(\n  domElement: Instance,\n  type: string,\n  newProps: Props,\n  internalInstanceHandle: Object,\n): void {\n  // Despite the naming that might imply otherwise, this method only\n  // fires if there is an `Update` effect scheduled during mounting.\n  // This happens if `finalizeInitialChildren` returns `true` (which it\n  // does to implement the `autoFocus` attribute on the client). But\n  // there are also other cases when this might happen (such as patching\n  // up text content during hydration mismatch). So we'll check this again.\n  if (shouldAutoFocusHostComponent(type, newProps)) {\n    ((domElement: any):\n      | HTMLButtonElement\n      | HTMLInputElement\n      | HTMLSelectElement\n      | HTMLTextAreaElement).focus();\n  }\n}\n\nexport function commitUpdate(\n  domElement: Instance,\n  updatePayload: Array<mixed>,\n  type: string,\n  oldProps: Props,\n  newProps: Props,\n  internalInstanceHandle: Object,\n): void {\n  // Update the props handle so that we know which props are the ones with\n  // with current event handlers.\n  updateFiberProps(domElement, newProps);\n  // Apply the diff to the DOM node.\n  updateProperties(domElement, updatePayload, type, oldProps, newProps);\n}\n\nexport function resetTextContent(domElement: Instance): void {\n  setTextContent(domElement, '');\n}\n\nexport function commitTextUpdate(\n  textInstance: TextInstance,\n  oldText: string,\n  newText: string,\n): void {\n  textInstance.nodeValue = newText;\n}\n\nexport function appendChild(\n  parentInstance: Instance,\n  child: Instance | TextInstance,\n): void {\n  parentInstance.appendChild(child);\n}\n\nexport function appendChildToContainer(\n  container: Container,\n  child: Instance | TextInstance,\n): void {\n  let parentNode;\n  if (container.nodeType === COMMENT_NODE) {\n    parentNode = (container.parentNode: any);\n    parentNode.insertBefore(child, container);\n  } else {\n    parentNode = container;\n    parentNode.appendChild(child);\n  }\n  // This container might be used for a portal.\n  // If something inside a portal is clicked, that click should bubble\n  // through the React tree. However, on Mobile Safari the click would\n  // never bubble through the *DOM* tree unless an ancestor with onclick\n  // event exists. So we wouldn't see it and dispatch it.\n  // This is why we ensure that non React root containers have inline onclick\n  // defined.\n  // https://github.com/facebook/react/issues/11918\n  const reactRootContainer = container._reactRootContainer;\n  if (\n    (reactRootContainer === null || reactRootContainer === undefined) &&\n    parentNode.onclick === null\n  ) {\n    // TODO: This cast may not be sound for SVG, MathML or custom elements.\n    trapClickOnNonInteractiveElement(((parentNode: any): HTMLElement));\n  }\n}\n\nexport function insertBefore(\n  parentInstance: Instance,\n  child: Instance | TextInstance,\n  beforeChild: Instance | TextInstance | SuspenseInstance,\n): void {\n  parentInstance.insertBefore(child, beforeChild);\n}\n\nexport function insertInContainerBefore(\n  container: Container,\n  child: Instance | TextInstance,\n  beforeChild: Instance | TextInstance | SuspenseInstance,\n): void {\n  if (container.nodeType === COMMENT_NODE) {\n    (container.parentNode: any).insertBefore(child, beforeChild);\n  } else {\n    container.insertBefore(child, beforeChild);\n  }\n}\n\nfunction createEvent(type: DOMEventName, bubbles: boolean): Event {\n  const event = document.createEvent('Event');\n  event.initEvent(((type: any): string), bubbles, false);\n  return event;\n}\n\nfunction dispatchBeforeDetachedBlur(\n  target: HTMLElement,\n  internalInstanceHandle: Object,\n): void {\n  if (enableCreateEventHandleAPI) {\n    const event = createEvent('beforeblur', true);\n    // Dispatch \"beforeblur\" directly on the target,\n    // so it gets picked up by the event system and\n    // can propagate through the React internal tree.\n    // $FlowFixMe: internal field\n    event._detachedInterceptFiber = internalInstanceHandle;\n    target.dispatchEvent(event);\n  }\n}\n\nfunction dispatchAfterDetachedBlur(target: HTMLElement): void {\n  if (enableCreateEventHandleAPI) {\n    const event = createEvent('afterblur', false);\n    // So we know what was detached, make the relatedTarget the\n    // detached target on the \"afterblur\" event.\n    (event: any).relatedTarget = target;\n    // Dispatch the event on the document.\n    document.dispatchEvent(event);\n  }\n}\n\nexport function removeChild(\n  parentInstance: Instance,\n  child: Instance | TextInstance | SuspenseInstance,\n): void {\n  parentInstance.removeChild(child);\n}\n\nexport function removeChildFromContainer(\n  container: Container,\n  child: Instance | TextInstance | SuspenseInstance,\n): void {\n  if (container.nodeType === COMMENT_NODE) {\n    (container.parentNode: any).removeChild(child);\n  } else {\n    container.removeChild(child);\n  }\n}\n\nexport function clearSuspenseBoundary(\n  parentInstance: Instance,\n  suspenseInstance: SuspenseInstance,\n): void {\n  let node = suspenseInstance;\n  // Delete all nodes within this suspense boundary.\n  // There might be nested nodes so we need to keep track of how\n  // deep we are and only break out when we're back on top.\n  let depth = 0;\n  do {\n    const nextNode = node.nextSibling;\n    parentInstance.removeChild(node);\n    if (nextNode && nextNode.nodeType === COMMENT_NODE) {\n      const data = ((nextNode: any).data: string);\n      if (data === SUSPENSE_END_DATA) {\n        if (depth === 0) {\n          parentInstance.removeChild(nextNode);\n          // Retry if any event replaying was blocked on this.\n          retryIfBlockedOn(suspenseInstance);\n          return;\n        } else {\n          depth--;\n        }\n      } else if (\n        data === SUSPENSE_START_DATA ||\n        data === SUSPENSE_PENDING_START_DATA ||\n        data === SUSPENSE_FALLBACK_START_DATA\n      ) {\n        depth++;\n      }\n    }\n    node = nextNode;\n  } while (node);\n  // TODO: Warn, we didn't find the end comment boundary.\n  // Retry if any event replaying was blocked on this.\n  retryIfBlockedOn(suspenseInstance);\n}\n\nexport function clearSuspenseBoundaryFromContainer(\n  container: Container,\n  suspenseInstance: SuspenseInstance,\n): void {\n  if (container.nodeType === COMMENT_NODE) {\n    clearSuspenseBoundary((container.parentNode: any), suspenseInstance);\n  } else if (container.nodeType === ELEMENT_NODE) {\n    clearSuspenseBoundary((container: any), suspenseInstance);\n  } else {\n    // Document nodes should never contain suspense boundaries.\n  }\n  // Retry if any event replaying was blocked on this.\n  retryIfBlockedOn(container);\n}\n\nexport function hideInstance(instance: Instance): void {\n  // TODO: Does this work for all element types? What about MathML? Should we\n  // pass host context to this method?\n  instance = ((instance: any): HTMLElement);\n  const style = instance.style;\n  if (typeof style.setProperty === 'function') {\n    style.setProperty('display', 'none', 'important');\n  } else {\n    style.display = 'none';\n  }\n}\n\nexport function hideTextInstance(textInstance: TextInstance): void {\n  textInstance.nodeValue = '';\n}\n\nexport function unhideInstance(instance: Instance, props: Props): void {\n  instance = ((instance: any): HTMLElement);\n  const styleProp = props[STYLE];\n  const display =\n    styleProp !== undefined &&\n    styleProp !== null &&\n    styleProp.hasOwnProperty('display')\n      ? styleProp.display\n      : null;\n  instance.style.display = dangerousStyleValue('display', display);\n}\n\nexport function unhideTextInstance(\n  textInstance: TextInstance,\n  text: string,\n): void {\n  textInstance.nodeValue = text;\n}\n\nexport function clearContainer(container: Container): void {\n  if (container.nodeType === ELEMENT_NODE) {\n    ((container: any): Element).textContent = '';\n  } else if (container.nodeType === DOCUMENT_NODE) {\n    const body = ((container: any): Document).body;\n    if (body != null) {\n      body.textContent = '';\n    }\n  }\n}\n\n// -------------------\n//     Hydration\n// -------------------\n\nexport const supportsHydration = true;\n\nexport function canHydrateInstance(\n  instance: HydratableInstance,\n  type: string,\n  props: Props,\n): null | Instance {\n  if (\n    instance.nodeType !== ELEMENT_NODE ||\n    type.toLowerCase() !== instance.nodeName.toLowerCase()\n  ) {\n    return null;\n  }\n  // This has now been refined to an element node.\n  return ((instance: any): Instance);\n}\n\nexport function canHydrateTextInstance(\n  instance: HydratableInstance,\n  text: string,\n): null | TextInstance {\n  if (text === '' || instance.nodeType !== TEXT_NODE) {\n    // Empty strings are not parsed by HTML so there won't be a correct match here.\n    return null;\n  }\n  // This has now been refined to a text node.\n  return ((instance: any): TextInstance);\n}\n\nexport function canHydrateSuspenseInstance(\n  instance: HydratableInstance,\n): null | SuspenseInstance {\n  if (instance.nodeType !== COMMENT_NODE) {\n    // Empty strings are not parsed by HTML so there won't be a correct match here.\n    return null;\n  }\n  // This has now been refined to a suspense node.\n  return ((instance: any): SuspenseInstance);\n}\n\nexport function isSuspenseInstancePending(instance: SuspenseInstance) {\n  return instance.data === SUSPENSE_PENDING_START_DATA;\n}\n\nexport function isSuspenseInstanceFallback(instance: SuspenseInstance) {\n  return instance.data === SUSPENSE_FALLBACK_START_DATA;\n}\n\nexport function registerSuspenseInstanceRetry(\n  instance: SuspenseInstance,\n  callback: () => void,\n) {\n  instance._reactRetry = callback;\n}\n\nfunction getNextHydratable(node) {\n  // Skip non-hydratable nodes.\n  for (; node != null; node = node.nextSibling) {\n    const nodeType = node.nodeType;\n    if (nodeType === ELEMENT_NODE || nodeType === TEXT_NODE) {\n      break;\n    }\n    if (enableSuspenseServerRenderer) {\n      if (nodeType === COMMENT_NODE) {\n        const nodeData = (node: any).data;\n        if (\n          nodeData === SUSPENSE_START_DATA ||\n          nodeData === SUSPENSE_FALLBACK_START_DATA ||\n          nodeData === SUSPENSE_PENDING_START_DATA\n        ) {\n          break;\n        }\n        if (nodeData === SUSPENSE_END_DATA) {\n          return null;\n        }\n      }\n    }\n  }\n  return (node: any);\n}\n\nexport function getNextHydratableSibling(\n  instance: HydratableInstance,\n): null | HydratableInstance {\n  return getNextHydratable(instance.nextSibling);\n}\n\nexport function getFirstHydratableChild(\n  parentInstance: Instance,\n): null | HydratableInstance {\n  return getNextHydratable(parentInstance.firstChild);\n}\n\nexport function getFirstHydratableChildWithinContainer(\n  parentContainer: Container,\n): null | HydratableInstance {\n  return getNextHydratable(parentContainer.firstChild);\n}\n\nexport function getFirstHydratableChildWithinSuspenseInstance(\n  parentInstance: SuspenseInstance,\n): null | HydratableInstance {\n  return getNextHydratable(parentInstance.nextSibling);\n}\n\nexport function hydrateInstance(\n  instance: Instance,\n  type: string,\n  props: Props,\n  rootContainerInstance: Container,\n  hostContext: HostContext,\n  internalInstanceHandle: Object,\n): null | Array<mixed> {\n  precacheFiberNode(internalInstanceHandle, instance);\n  // TODO: Possibly defer this until the commit phase where all the events\n  // get attached.\n  updateFiberProps(instance, props);\n  let parentNamespace: string;\n  if (__DEV__) {\n    const hostContextDev = ((hostContext: any): HostContextDev);\n    parentNamespace = hostContextDev.namespace;\n  } else {\n    parentNamespace = ((hostContext: any): HostContextProd);\n  }\n  return diffHydratedProperties(\n    instance,\n    type,\n    props,\n    parentNamespace,\n    rootContainerInstance,\n  );\n}\n\nexport function hydrateTextInstance(\n  textInstance: TextInstance,\n  text: string,\n  internalInstanceHandle: Object,\n): boolean {\n  precacheFiberNode(internalInstanceHandle, textInstance);\n  return diffHydratedText(textInstance, text);\n}\n\nexport function hydrateSuspenseInstance(\n  suspenseInstance: SuspenseInstance,\n  internalInstanceHandle: Object,\n) {\n  precacheFiberNode(internalInstanceHandle, suspenseInstance);\n}\n\nexport function getNextHydratableInstanceAfterSuspenseInstance(\n  suspenseInstance: SuspenseInstance,\n): null | HydratableInstance {\n  let node = suspenseInstance.nextSibling;\n  // Skip past all nodes within this suspense boundary.\n  // There might be nested nodes so we need to keep track of how\n  // deep we are and only break out when we're back on top.\n  let depth = 0;\n  while (node) {\n    if (node.nodeType === COMMENT_NODE) {\n      const data = ((node: any).data: string);\n      if (data === SUSPENSE_END_DATA) {\n        if (depth === 0) {\n          return getNextHydratableSibling((node: any));\n        } else {\n          depth--;\n        }\n      } else if (\n        data === SUSPENSE_START_DATA ||\n        data === SUSPENSE_FALLBACK_START_DATA ||\n        data === SUSPENSE_PENDING_START_DATA\n      ) {\n        depth++;\n      }\n    }\n    node = node.nextSibling;\n  }\n  // TODO: Warn, we didn't find the end comment boundary.\n  return null;\n}\n\n// Returns the SuspenseInstance if this node is a direct child of a\n// SuspenseInstance. I.e. if its previous sibling is a Comment with\n// SUSPENSE_x_START_DATA. Otherwise, null.\nexport function getParentSuspenseInstance(\n  targetInstance: Node,\n): null | SuspenseInstance {\n  let node = targetInstance.previousSibling;\n  // Skip past all nodes within this suspense boundary.\n  // There might be nested nodes so we need to keep track of how\n  // deep we are and only break out when we're back on top.\n  let depth = 0;\n  while (node) {\n    if (node.nodeType === COMMENT_NODE) {\n      const data = ((node: any).data: string);\n      if (\n        data === SUSPENSE_START_DATA ||\n        data === SUSPENSE_FALLBACK_START_DATA ||\n        data === SUSPENSE_PENDING_START_DATA\n      ) {\n        if (depth === 0) {\n          return ((node: any): SuspenseInstance);\n        } else {\n          depth--;\n        }\n      } else if (data === SUSPENSE_END_DATA) {\n        depth++;\n      }\n    }\n    node = node.previousSibling;\n  }\n  return null;\n}\n\nexport function commitHydratedContainer(container: Container): void {\n  // Retry if any event replaying was blocked on this.\n  retryIfBlockedOn(container);\n}\n\nexport function commitHydratedSuspenseInstance(\n  suspenseInstance: SuspenseInstance,\n): void {\n  // Retry if any event replaying was blocked on this.\n  retryIfBlockedOn(suspenseInstance);\n}\n\nexport function shouldDeleteUnhydratedTailInstances(\n  parentType: string,\n): boolean {\n  return parentType !== 'head' && parentType !== 'body';\n}\n\nexport function didNotMatchHydratedContainerTextInstance(\n  parentContainer: Container,\n  textInstance: TextInstance,\n  text: string,\n) {\n  if (__DEV__) {\n    warnForUnmatchedText(textInstance, text);\n  }\n}\n\nexport function didNotMatchHydratedTextInstance(\n  parentType: string,\n  parentProps: Props,\n  parentInstance: Instance,\n  textInstance: TextInstance,\n  text: string,\n) {\n  if (__DEV__ && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n    warnForUnmatchedText(textInstance, text);\n  }\n}\n\nexport function didNotHydrateInstanceWithinContainer(\n  parentContainer: Container,\n  instance: HydratableInstance,\n) {\n  if (__DEV__) {\n    if (instance.nodeType === ELEMENT_NODE) {\n      warnForDeletedHydratableElement(parentContainer, (instance: any));\n    } else if (instance.nodeType === COMMENT_NODE) {\n      // TODO: warnForDeletedHydratableSuspenseBoundary\n    } else {\n      warnForDeletedHydratableText(parentContainer, (instance: any));\n    }\n  }\n}\n\nexport function didNotHydrateInstanceWithinSuspenseInstance(\n  parentInstance: SuspenseInstance,\n  instance: HydratableInstance,\n) {\n  if (__DEV__) {\n    // $FlowFixMe: Only Element or Document can be parent nodes.\n    const parentNode: Element | Document | null = parentInstance.parentNode;\n    if (parentNode !== null) {\n      if (instance.nodeType === ELEMENT_NODE) {\n        warnForDeletedHydratableElement(parentNode, (instance: any));\n      } else if (instance.nodeType === COMMENT_NODE) {\n        // TODO: warnForDeletedHydratableSuspenseBoundary\n      } else {\n        warnForDeletedHydratableText(parentNode, (instance: any));\n      }\n    }\n  }\n}\n\nexport function didNotHydrateInstance(\n  parentType: string,\n  parentProps: Props,\n  parentInstance: Instance,\n  instance: HydratableInstance,\n) {\n  if (__DEV__ && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n    if (instance.nodeType === ELEMENT_NODE) {\n      warnForDeletedHydratableElement(parentInstance, (instance: any));\n    } else if (instance.nodeType === COMMENT_NODE) {\n      // TODO: warnForDeletedHydratableSuspenseBoundary\n    } else {\n      warnForDeletedHydratableText(parentInstance, (instance: any));\n    }\n  }\n}\n\nexport function didNotFindHydratableInstanceWithinContainer(\n  parentContainer: Container,\n  type: string,\n  props: Props,\n) {\n  if (__DEV__) {\n    warnForInsertedHydratedElement(parentContainer, type, props);\n  }\n}\n\nexport function didNotFindHydratableTextInstanceWithinContainer(\n  parentContainer: Container,\n  text: string,\n) {\n  if (__DEV__) {\n    warnForInsertedHydratedText(parentContainer, text);\n  }\n}\n\nexport function didNotFindHydratableSuspenseInstanceWithinContainer(\n  parentContainer: Container,\n) {\n  if (__DEV__) {\n    // TODO: warnForInsertedHydratedSuspense(parentContainer);\n  }\n}\n\nexport function didNotFindHydratableInstanceWithinSuspenseInstance(\n  parentInstance: SuspenseInstance,\n  type: string,\n  props: Props,\n) {\n  if (__DEV__) {\n    // $FlowFixMe: Only Element or Document can be parent nodes.\n    const parentNode: Element | Document | null = parentInstance.parentNode;\n    if (parentNode !== null)\n      warnForInsertedHydratedElement(parentNode, type, props);\n  }\n}\n\nexport function didNotFindHydratableTextInstanceWithinSuspenseInstance(\n  parentInstance: SuspenseInstance,\n  text: string,\n) {\n  if (__DEV__) {\n    // $FlowFixMe: Only Element or Document can be parent nodes.\n    const parentNode: Element | Document | null = parentInstance.parentNode;\n    if (parentNode !== null) warnForInsertedHydratedText(parentNode, text);\n  }\n}\n\nexport function didNotFindHydratableSuspenseInstanceWithinSuspenseInstance(\n  parentInstance: SuspenseInstance,\n) {\n  if (__DEV__) {\n    // const parentNode: Element | Document | null = parentInstance.parentNode;\n    // TODO: warnForInsertedHydratedSuspense(parentNode);\n  }\n}\n\nexport function didNotFindHydratableInstance(\n  parentType: string,\n  parentProps: Props,\n  parentInstance: Instance,\n  type: string,\n  props: Props,\n) {\n  if (__DEV__ && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n    warnForInsertedHydratedElement(parentInstance, type, props);\n  }\n}\n\nexport function didNotFindHydratableTextInstance(\n  parentType: string,\n  parentProps: Props,\n  parentInstance: Instance,\n  text: string,\n) {\n  if (__DEV__ && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n    warnForInsertedHydratedText(parentInstance, text);\n  }\n}\n\nexport function didNotFindHydratableSuspenseInstance(\n  parentType: string,\n  parentProps: Props,\n  parentInstance: Instance,\n) {\n  if (__DEV__ && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n    // TODO: warnForInsertedHydratedSuspense(parentInstance);\n  }\n}\n\nexport function errorHydratingContainer(parentContainer: Container): void {\n  if (__DEV__) {\n    console.error(\n      'An error occurred during hydration. The server HTML was replaced with client content in <%s>.',\n      parentContainer.nodeName.toLowerCase(),\n    );\n  }\n}\n\nexport function getInstanceFromNode(node: HTMLElement): null | Object {\n  return getClosestInstanceFromNode(node) || null;\n}\n\nexport function preparePortalMount(portalInstance: Instance): void {\n  listenToAllSupportedEvents(portalInstance);\n}\n\nexport function prepareScopeUpdate(\n  scopeInstance: ReactScopeInstance,\n  internalInstanceHandle: Object,\n): void {\n  if (enableScopeAPI) {\n    precacheFiberNode(internalInstanceHandle, scopeInstance);\n  }\n}\n\nexport function getInstanceFromScope(\n  scopeInstance: ReactScopeInstance,\n): null | Object {\n  if (enableScopeAPI) {\n    return getFiberFromScopeInstance(scopeInstance);\n  }\n  return null;\n}\n\nexport const supportsTestSelectors = true;\n\nexport function findFiberRoot(node: Instance): null | FiberRoot {\n  const stack = [node];\n  let index = 0;\n  while (index < stack.length) {\n    const current = stack[index++];\n    if (isContainerMarkedAsRoot(current)) {\n      return ((getInstanceFromNodeDOMTree(current): any): FiberRoot);\n    }\n    stack.push(...current.children);\n  }\n  return null;\n}\n\nexport function getBoundingRect(node: Instance): BoundingRect {\n  const rect = node.getBoundingClientRect();\n  return {\n    x: rect.left,\n    y: rect.top,\n    width: rect.width,\n    height: rect.height,\n  };\n}\n\nexport function matchAccessibilityRole(node: Instance, role: string): boolean {\n  if (hasRole(node, role)) {\n    return true;\n  }\n\n  return false;\n}\n\nexport function getTextContent(fiber: Fiber): string | null {\n  switch (fiber.tag) {\n    case HostComponent:\n      let textContent = '';\n      const childNodes = fiber.stateNode.childNodes;\n      for (let i = 0; i < childNodes.length; i++) {\n        const childNode = childNodes[i];\n        if (childNode.nodeType === Node.TEXT_NODE) {\n          textContent += childNode.textContent;\n        }\n      }\n      return textContent;\n    case HostText:\n      return fiber.stateNode.textContent;\n  }\n\n  return null;\n}\n\nexport function isHiddenSubtree(fiber: Fiber): boolean {\n  return fiber.tag === HostComponent && fiber.memoizedProps.hidden === true;\n}\n\nexport function setFocusIfFocusable(node: Instance): boolean {\n  // The logic for determining if an element is focusable is kind of complex,\n  // and since we want to actually change focus anyway- we can just skip it.\n  // Instead we'll just listen for a \"focus\" event to verify that focus was set.\n  //\n  // We could compare the node to document.activeElement after focus,\n  // but this would not handle the case where application code managed focus to automatically blur.\n  let didFocus = false;\n  const handleFocus = () => {\n    didFocus = true;\n  };\n\n  const element = ((node: any): HTMLElement);\n  try {\n    element.addEventListener('focus', handleFocus);\n    (element.focus || HTMLElement.prototype.focus).call(element);\n  } finally {\n    element.removeEventListener('focus', handleFocus);\n  }\n\n  return didFocus;\n}\n\ntype RectRatio = {\n  ratio: number,\n  rect: BoundingRect,\n};\n\nexport function setupIntersectionObserver(\n  targets: Array<Instance>,\n  callback: ObserveVisibleRectsCallback,\n  options?: IntersectionObserverOptions,\n): {|\n  disconnect: () => void,\n  observe: (instance: Instance) => void,\n  unobserve: (instance: Instance) => void,\n|} {\n  const rectRatioCache: Map<Instance, RectRatio> = new Map();\n  targets.forEach(target => {\n    rectRatioCache.set(target, {\n      rect: getBoundingRect(target),\n      ratio: 0,\n    });\n  });\n\n  const handleIntersection = (entries: Array<IntersectionObserverEntry>) => {\n    entries.forEach(entry => {\n      const {boundingClientRect, intersectionRatio, target} = entry;\n      rectRatioCache.set(target, {\n        rect: {\n          x: boundingClientRect.left,\n          y: boundingClientRect.top,\n          width: boundingClientRect.width,\n          height: boundingClientRect.height,\n        },\n        ratio: intersectionRatio,\n      });\n    });\n\n    callback(Array.from(rectRatioCache.values()));\n  };\n\n  const observer = new IntersectionObserver(handleIntersection, options);\n  targets.forEach(target => {\n    observer.observe((target: any));\n  });\n\n  return {\n    disconnect: () => observer.disconnect(),\n    observe: target => {\n      rectRatioCache.set(target, {\n        rect: getBoundingRect(target),\n        ratio: 0,\n      });\n      observer.observe((target: any));\n    },\n    unobserve: target => {\n      rectRatioCache.delete(target);\n      observer.unobserve((target: any));\n    },\n  };\n}\n"]},"metadata":{},"sourceType":"module"}