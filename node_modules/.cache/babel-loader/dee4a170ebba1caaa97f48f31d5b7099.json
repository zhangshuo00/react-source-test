{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport getComponentNameFromType from 'shared/getComponentNameFromType';\nimport { REACT_ELEMENT_TYPE } from 'shared/ReactSymbols';\nimport hasOwnProperty from 'shared/hasOwnProperty';\nimport { checkKeyStringCoercion } from 'shared/CheckStringCoercion';\nimport ReactCurrentOwner from './ReactCurrentOwner';\nconst RESERVED_PROPS = {\n  key: true,\n  ref: true,\n  __self: true,\n  __source: true\n};\nlet specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;\n\nif (__DEV__) {\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  if (__DEV__) {\n    if (hasOwnProperty.call(config, 'ref')) {\n      const getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  if (__DEV__) {\n    if (hasOwnProperty.call(config, 'key')) {\n      const getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  const warnAboutAccessingKey = function () {\n    if (__DEV__) {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n        console.error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    }\n  };\n\n  warnAboutAccessingKey.isReactWarning = true;\n  Object.defineProperty(props, 'key', {\n    get: warnAboutAccessingKey,\n    configurable: true\n  });\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  const warnAboutAccessingRef = function () {\n    if (__DEV__) {\n      if (!specialPropRefWarningShown) {\n        specialPropRefWarningShown = true;\n        console.error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    }\n  };\n\n  warnAboutAccessingRef.isReactWarning = true;\n  Object.defineProperty(props, 'ref', {\n    get: warnAboutAccessingRef,\n    configurable: true\n  });\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config) {\n  if (__DEV__) {\n    if (typeof config.ref === 'string' && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {\n      const componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        console.error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nconst ReactElement = function (type, key, ref, self, source, owner, props) {\n  const element = {\n    // This tag allows us to uniquely identify this as a React Element\n    $$typeof: REACT_ELEMENT_TYPE,\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n    // Record the component responsible for creating this element.\n    _owner: owner\n  };\n\n  if (__DEV__) {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // self and source are DEV only properties.\n\n    Object.defineProperty(element, '_self', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: self\n    }); // Two elements created in two different places should be considered\n    // equal for testing purposes and therefore we hide it from enumeration.\n\n    Object.defineProperty(element, '_source', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: source\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n};\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\n\n_c = ReactElement;\nexport function jsx(type, config, maybeKey) {\n  let propName; // Reserved names are extracted\n\n  const props = {};\n  let key = null;\n  let ref = null; // Currently, key can be spread in as a prop. This causes a potential\n  // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n  // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n  // but as an intermediary step, we will use jsxDEV for everything except\n  // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n  // key is explicitly declared to be undefined or not.\n\n  if (maybeKey !== undefined) {\n    if (__DEV__) {\n      checkKeyStringCoercion(maybeKey);\n    }\n\n    key = '' + maybeKey;\n  }\n\n  if (hasValidKey(config)) {\n    if (__DEV__) {\n      checkKeyStringCoercion(config.key);\n    }\n\n    key = '' + config.key;\n  }\n\n  if (hasValidRef(config)) {\n    ref = config.ref;\n  } // Remaining properties are added to a new props object\n\n\n  for (propName in config) {\n    if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n      props[propName] = config[propName];\n    }\n  } // Resolve default props\n\n\n  if (type && type.defaultProps) {\n    const defaultProps = type.defaultProps;\n\n    for (propName in defaultProps) {\n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  }\n\n  return ReactElement(type, key, ref, undefined, undefined, ReactCurrentOwner.current, props);\n}\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\nexport function jsxDEV(type, config, maybeKey, source, self) {\n  let propName; // Reserved names are extracted\n\n  const props = {};\n  let key = null;\n  let ref = null; // Currently, key can be spread in as a prop. This causes a potential\n  // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n  // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n  // but as an intermediary step, we will use jsxDEV for everything except\n  // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n  // key is explicitly declared to be undefined or not.\n\n  if (maybeKey !== undefined) {\n    if (__DEV__) {\n      checkKeyStringCoercion(maybeKey);\n    }\n\n    key = '' + maybeKey;\n  }\n\n  if (hasValidKey(config)) {\n    if (__DEV__) {\n      checkKeyStringCoercion(config.key);\n    }\n\n    key = '' + config.key;\n  }\n\n  if (hasValidRef(config)) {\n    ref = config.ref;\n    warnIfStringRefCannotBeAutoConverted(config);\n  } // Remaining properties are added to a new props object\n\n\n  for (propName in config) {\n    if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n      props[propName] = config[propName];\n    }\n  } // Resolve default props\n\n\n  if (type && type.defaultProps) {\n    const defaultProps = type.defaultProps;\n\n    for (propName in defaultProps) {\n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  }\n\n  if (key || ref) {\n    const displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n    if (key) {\n      defineKeyPropWarningGetter(props, displayName);\n    }\n\n    if (ref) {\n      defineRefPropWarningGetter(props, displayName);\n    }\n  }\n\n  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n}\n/**\n * Create and return a new ReactElement of the given type.\n * See https://reactjs.org/docs/react-api.html#createelement\n */\n\nexport function createElement(type, config, children) {\n  let propName; // Reserved names are extracted\n\n  const props = {};\n  let key = null;\n  let ref = null;\n  let self = null;\n  let source = null;\n\n  if (config != null) {\n    if (hasValidRef(config)) {\n      ref = config.ref;\n\n      if (__DEV__) {\n        warnIfStringRefCannotBeAutoConverted(config);\n      }\n    }\n\n    if (hasValidKey(config)) {\n      if (__DEV__) {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    }\n\n    self = config.__self === undefined ? null : config.__self;\n    source = config.__source === undefined ? null : config.__source; // Remaining properties are added to a new props object\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        props[propName] = config[propName];\n      }\n    }\n  } // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n\n\n  const childrenLength = arguments.length - 2;\n\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    const childArray = Array(childrenLength);\n\n    for (let i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n\n    if (__DEV__) {\n      if (Object.freeze) {\n        Object.freeze(childArray);\n      }\n    }\n\n    props.children = childArray;\n  } // Resolve default props\n\n\n  if (type && type.defaultProps) {\n    const defaultProps = type.defaultProps;\n\n    for (propName in defaultProps) {\n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  }\n\n  if (__DEV__) {\n    if (key || ref) {\n      const displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n  }\n\n  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n}\n/**\n * Return a function that produces ReactElements of a given type.\n * See https://reactjs.org/docs/react-api.html#createfactory\n */\n\nexport function createFactory(type) {\n  const factory = createElement.bind(null, type); // Expose the type on the factory and the prototype so that it can be\n  // easily accessed on elements. E.g. `<Foo />.type === Foo`.\n  // This should not be named `constructor` since this may not be the function\n  // that created the element, and it may not even be a constructor.\n  // Legacy hook: remove it\n\n  factory.type = type;\n  return factory;\n}\nexport function cloneAndReplaceKey(oldElement, newKey) {\n  const newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);\n  return newElement;\n}\n/**\n * Clone and return a new ReactElement using element as the starting point.\n * See https://reactjs.org/docs/react-api.html#cloneelement\n */\n\nexport function cloneElement(element, config, children) {\n  if (element === null || element === undefined) {\n    throw new Error(`React.cloneElement(...): The argument must be a React element, but you passed ${element}.`);\n  }\n\n  let propName; // Original props are copied\n\n  const props = Object.assign({}, element.props); // Reserved names are extracted\n\n  let key = element.key;\n  let ref = element.ref; // Self is preserved since the owner is preserved.\n\n  const self = element._self; // Source is preserved since cloneElement is unlikely to be targeted by a\n  // transpiler, and the original source is probably a better indicator of the\n  // true owner.\n\n  const source = element._source; // Owner will be preserved, unless ref is overridden\n\n  let owner = element._owner;\n\n  if (config != null) {\n    if (hasValidRef(config)) {\n      // Silently steal the ref from the parent.\n      ref = config.ref;\n      owner = ReactCurrentOwner.current;\n    }\n\n    if (hasValidKey(config)) {\n      if (__DEV__) {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    } // Remaining properties override existing props\n\n\n    let defaultProps;\n\n    if (element.type && element.type.defaultProps) {\n      defaultProps = element.type.defaultProps;\n    }\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        if (config[propName] === undefined && defaultProps !== undefined) {\n          // Resolve default props\n          props[propName] = defaultProps[propName];\n        } else {\n          props[propName] = config[propName];\n        }\n      }\n    }\n  } // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n\n\n  const childrenLength = arguments.length - 2;\n\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    const childArray = Array(childrenLength);\n\n    for (let i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n\n    props.children = childArray;\n  }\n\n  return ReactElement(element.type, key, ref, self, source, owner, props);\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\nexport function isValidElement(object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n}\n\nvar _c;\n\n$RefreshReg$(_c, \"ReactElement\");","map":{"version":3,"sources":["/Users/zhangshuo/git/my-app/src/react/packages/react/src/ReactElement.js"],"names":["getComponentNameFromType","REACT_ELEMENT_TYPE","hasOwnProperty","checkKeyStringCoercion","ReactCurrentOwner","RESERVED_PROPS","key","ref","__self","__source","specialPropKeyWarningShown","specialPropRefWarningShown","didWarnAboutStringRefs","__DEV__","hasValidRef","config","call","getter","Object","getOwnPropertyDescriptor","get","isReactWarning","undefined","hasValidKey","defineKeyPropWarningGetter","props","displayName","warnAboutAccessingKey","console","error","defineProperty","configurable","defineRefPropWarningGetter","warnAboutAccessingRef","warnIfStringRefCannotBeAutoConverted","current","stateNode","componentName","type","ReactElement","self","source","owner","element","$$typeof","_owner","_store","enumerable","writable","value","freeze","jsx","maybeKey","propName","defaultProps","jsxDEV","name","createElement","children","childrenLength","arguments","length","childArray","Array","i","createFactory","factory","bind","cloneAndReplaceKey","oldElement","newKey","newElement","_self","_source","cloneElement","Error","assign","isValidElement","object"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport getComponentNameFromType from 'shared/getComponentNameFromType';\nimport {REACT_ELEMENT_TYPE} from 'shared/ReactSymbols';\nimport hasOwnProperty from 'shared/hasOwnProperty';\nimport {checkKeyStringCoercion} from 'shared/CheckStringCoercion';\n\nimport ReactCurrentOwner from './ReactCurrentOwner';\n\nconst RESERVED_PROPS = {\n  key: true,\n  ref: true,\n  __self: true,\n  __source: true,\n};\n\nlet specialPropKeyWarningShown,\n  specialPropRefWarningShown,\n  didWarnAboutStringRefs;\n\nif (__DEV__) {\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  if (__DEV__) {\n    if (hasOwnProperty.call(config, 'ref')) {\n      const getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  if (__DEV__) {\n    if (hasOwnProperty.call(config, 'key')) {\n      const getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n  return config.key !== undefined;\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  const warnAboutAccessingKey = function() {\n    if (__DEV__) {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n        console.error(\n          '%s: `key` is not a prop. Trying to access it will result ' +\n            'in `undefined` being returned. If you need to access the same ' +\n            'value within the child component, you should pass it as a different ' +\n            'prop. (https://reactjs.org/link/special-props)',\n          displayName,\n        );\n      }\n    }\n  };\n  warnAboutAccessingKey.isReactWarning = true;\n  Object.defineProperty(props, 'key', {\n    get: warnAboutAccessingKey,\n    configurable: true,\n  });\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  const warnAboutAccessingRef = function() {\n    if (__DEV__) {\n      if (!specialPropRefWarningShown) {\n        specialPropRefWarningShown = true;\n        console.error(\n          '%s: `ref` is not a prop. Trying to access it will result ' +\n            'in `undefined` being returned. If you need to access the same ' +\n            'value within the child component, you should pass it as a different ' +\n            'prop. (https://reactjs.org/link/special-props)',\n          displayName,\n        );\n      }\n    }\n  };\n  warnAboutAccessingRef.isReactWarning = true;\n  Object.defineProperty(props, 'ref', {\n    get: warnAboutAccessingRef,\n    configurable: true,\n  });\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config) {\n  if (__DEV__) {\n    if (\n      typeof config.ref === 'string' &&\n      ReactCurrentOwner.current &&\n      config.__self &&\n      ReactCurrentOwner.current.stateNode !== config.__self\n    ) {\n      const componentName = getComponentNameFromType(\n        ReactCurrentOwner.current.type,\n      );\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        console.error(\n          'Component \"%s\" contains the string ref \"%s\". ' +\n            'Support for string refs will be removed in a future major release. ' +\n            'This case cannot be automatically converted to an arrow function. ' +\n            'We ask you to manually fix this case by using useRef() or createRef() instead. ' +\n            'Learn more about using refs safely here: ' +\n            'https://reactjs.org/link/strict-mode-string-ref',\n          componentName,\n          config.ref,\n        );\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\nconst ReactElement = function(type, key, ref, self, source, owner, props) {\n  const element = {\n    // This tag allows us to uniquely identify this as a React Element\n    $$typeof: REACT_ELEMENT_TYPE,\n\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n\n    // Record the component responsible for creating this element.\n    _owner: owner,\n  };\n\n  if (__DEV__) {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {};\n\n    // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false,\n    });\n    // self and source are DEV only properties.\n    Object.defineProperty(element, '_self', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: self,\n    });\n    // Two elements created in two different places should be considered\n    // equal for testing purposes and therefore we hide it from enumeration.\n    Object.defineProperty(element, '_source', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: source,\n    });\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n};\n\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\nexport function jsx(type, config, maybeKey) {\n  let propName;\n\n  // Reserved names are extracted\n  const props = {};\n\n  let key = null;\n  let ref = null;\n\n  // Currently, key can be spread in as a prop. This causes a potential\n  // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n  // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n  // but as an intermediary step, we will use jsxDEV for everything except\n  // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n  // key is explicitly declared to be undefined or not.\n  if (maybeKey !== undefined) {\n    if (__DEV__) {\n      checkKeyStringCoercion(maybeKey);\n    }\n    key = '' + maybeKey;\n  }\n\n  if (hasValidKey(config)) {\n    if (__DEV__) {\n      checkKeyStringCoercion(config.key);\n    }\n    key = '' + config.key;\n  }\n\n  if (hasValidRef(config)) {\n    ref = config.ref;\n  }\n\n  // Remaining properties are added to a new props object\n  for (propName in config) {\n    if (\n      hasOwnProperty.call(config, propName) &&\n      !RESERVED_PROPS.hasOwnProperty(propName)\n    ) {\n      props[propName] = config[propName];\n    }\n  }\n\n  // Resolve default props\n  if (type && type.defaultProps) {\n    const defaultProps = type.defaultProps;\n    for (propName in defaultProps) {\n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  }\n\n  return ReactElement(\n    type,\n    key,\n    ref,\n    undefined,\n    undefined,\n    ReactCurrentOwner.current,\n    props,\n  );\n}\n\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\nexport function jsxDEV(type, config, maybeKey, source, self) {\n  let propName;\n\n  // Reserved names are extracted\n  const props = {};\n\n  let key = null;\n  let ref = null;\n\n  // Currently, key can be spread in as a prop. This causes a potential\n  // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n  // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n  // but as an intermediary step, we will use jsxDEV for everything except\n  // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n  // key is explicitly declared to be undefined or not.\n  if (maybeKey !== undefined) {\n    if (__DEV__) {\n      checkKeyStringCoercion(maybeKey);\n    }\n    key = '' + maybeKey;\n  }\n\n  if (hasValidKey(config)) {\n    if (__DEV__) {\n      checkKeyStringCoercion(config.key);\n    }\n    key = '' + config.key;\n  }\n\n  if (hasValidRef(config)) {\n    ref = config.ref;\n    warnIfStringRefCannotBeAutoConverted(config);\n  }\n\n  // Remaining properties are added to a new props object\n  for (propName in config) {\n    if (\n      hasOwnProperty.call(config, propName) &&\n      !RESERVED_PROPS.hasOwnProperty(propName)\n    ) {\n      props[propName] = config[propName];\n    }\n  }\n\n  // Resolve default props\n  if (type && type.defaultProps) {\n    const defaultProps = type.defaultProps;\n    for (propName in defaultProps) {\n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  }\n\n  if (key || ref) {\n    const displayName =\n      typeof type === 'function'\n        ? type.displayName || type.name || 'Unknown'\n        : type;\n    if (key) {\n      defineKeyPropWarningGetter(props, displayName);\n    }\n    if (ref) {\n      defineRefPropWarningGetter(props, displayName);\n    }\n  }\n\n  return ReactElement(\n    type,\n    key,\n    ref,\n    self,\n    source,\n    ReactCurrentOwner.current,\n    props,\n  );\n}\n\n/**\n * Create and return a new ReactElement of the given type.\n * See https://reactjs.org/docs/react-api.html#createelement\n */\nexport function createElement(type, config, children) {\n  let propName;\n\n  // Reserved names are extracted\n  const props = {};\n\n  let key = null;\n  let ref = null;\n  let self = null;\n  let source = null;\n\n  if (config != null) {\n    if (hasValidRef(config)) {\n      ref = config.ref;\n\n      if (__DEV__) {\n        warnIfStringRefCannotBeAutoConverted(config);\n      }\n    }\n    if (hasValidKey(config)) {\n      if (__DEV__) {\n        checkKeyStringCoercion(config.key);\n      }\n      key = '' + config.key;\n    }\n\n    self = config.__self === undefined ? null : config.__self;\n    source = config.__source === undefined ? null : config.__source;\n    // Remaining properties are added to a new props object\n    for (propName in config) {\n      if (\n        hasOwnProperty.call(config, propName) &&\n        !RESERVED_PROPS.hasOwnProperty(propName)\n      ) {\n        props[propName] = config[propName];\n      }\n    }\n  }\n\n  // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n  const childrenLength = arguments.length - 2;\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    const childArray = Array(childrenLength);\n    for (let i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n    if (__DEV__) {\n      if (Object.freeze) {\n        Object.freeze(childArray);\n      }\n    }\n    props.children = childArray;\n  }\n\n  // Resolve default props\n  if (type && type.defaultProps) {\n    const defaultProps = type.defaultProps;\n    for (propName in defaultProps) {\n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  }\n  if (__DEV__) {\n    if (key || ref) {\n      const displayName =\n        typeof type === 'function'\n          ? type.displayName || type.name || 'Unknown'\n          : type;\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n  }\n  return ReactElement(\n    type,\n    key,\n    ref,\n    self,\n    source,\n    ReactCurrentOwner.current,\n    props,\n  );\n}\n\n/**\n * Return a function that produces ReactElements of a given type.\n * See https://reactjs.org/docs/react-api.html#createfactory\n */\nexport function createFactory(type) {\n  const factory = createElement.bind(null, type);\n  // Expose the type on the factory and the prototype so that it can be\n  // easily accessed on elements. E.g. `<Foo />.type === Foo`.\n  // This should not be named `constructor` since this may not be the function\n  // that created the element, and it may not even be a constructor.\n  // Legacy hook: remove it\n  factory.type = type;\n  return factory;\n}\n\nexport function cloneAndReplaceKey(oldElement, newKey) {\n  const newElement = ReactElement(\n    oldElement.type,\n    newKey,\n    oldElement.ref,\n    oldElement._self,\n    oldElement._source,\n    oldElement._owner,\n    oldElement.props,\n  );\n\n  return newElement;\n}\n\n/**\n * Clone and return a new ReactElement using element as the starting point.\n * See https://reactjs.org/docs/react-api.html#cloneelement\n */\nexport function cloneElement(element, config, children) {\n  if (element === null || element === undefined) {\n    throw new Error(\n      `React.cloneElement(...): The argument must be a React element, but you passed ${element}.`,\n    );\n  }\n\n  let propName;\n\n  // Original props are copied\n  const props = Object.assign({}, element.props);\n\n  // Reserved names are extracted\n  let key = element.key;\n  let ref = element.ref;\n  // Self is preserved since the owner is preserved.\n  const self = element._self;\n  // Source is preserved since cloneElement is unlikely to be targeted by a\n  // transpiler, and the original source is probably a better indicator of the\n  // true owner.\n  const source = element._source;\n\n  // Owner will be preserved, unless ref is overridden\n  let owner = element._owner;\n\n  if (config != null) {\n    if (hasValidRef(config)) {\n      // Silently steal the ref from the parent.\n      ref = config.ref;\n      owner = ReactCurrentOwner.current;\n    }\n    if (hasValidKey(config)) {\n      if (__DEV__) {\n        checkKeyStringCoercion(config.key);\n      }\n      key = '' + config.key;\n    }\n\n    // Remaining properties override existing props\n    let defaultProps;\n    if (element.type && element.type.defaultProps) {\n      defaultProps = element.type.defaultProps;\n    }\n    for (propName in config) {\n      if (\n        hasOwnProperty.call(config, propName) &&\n        !RESERVED_PROPS.hasOwnProperty(propName)\n      ) {\n        if (config[propName] === undefined && defaultProps !== undefined) {\n          // Resolve default props\n          props[propName] = defaultProps[propName];\n        } else {\n          props[propName] = config[propName];\n        }\n      }\n    }\n  }\n\n  // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n  const childrenLength = arguments.length - 2;\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    const childArray = Array(childrenLength);\n    for (let i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n    props.children = childArray;\n  }\n\n  return ReactElement(element.type, key, ref, self, source, owner, props);\n}\n\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\nexport function isValidElement(object) {\n  return (\n    typeof object === 'object' &&\n    object !== null &&\n    object.$$typeof === REACT_ELEMENT_TYPE\n  );\n}\n"]},"metadata":{},"sourceType":"module"}