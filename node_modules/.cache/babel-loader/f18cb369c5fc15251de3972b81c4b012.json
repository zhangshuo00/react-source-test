{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport ReactCurrentActQueue from './ReactCurrentActQueue';\nimport enqueueTask from 'shared/enqueueTask';\nlet actScopeDepth = 0;\nlet didWarnNoAwaitAct = false;\nexport function act(callback) {\n  if (__DEV__) {\n    // `act` calls can be nested, so we track the depth. This represents the\n    // number of `act` scopes on the stack.\n    const prevActScopeDepth = actScopeDepth;\n    actScopeDepth++;\n\n    if (ReactCurrentActQueue.current === null) {\n      // This is the outermost `act` scope. Initialize the queue. The reconciler\n      // will detect the queue and use it instead of Scheduler.\n      ReactCurrentActQueue.current = [];\n    }\n\n    const prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;\n    let result;\n\n    try {\n      // Used to reproduce behavior of `batchedUpdates` in legacy mode. Only\n      // set to `true` while the given callback is executed, not for updates\n      // triggered during an async event, because this is how the legacy\n      // implementation of `act` behaved.\n      ReactCurrentActQueue.isBatchingLegacy = true;\n      result = callback(); // Replicate behavior of original `act` implementation in legacy mode,\n      // which flushed updates immediately after the scope function exits, even\n      // if it's an async function.\n\n      if (!prevIsBatchingLegacy && ReactCurrentActQueue.didScheduleLegacyUpdate) {\n        const queue = ReactCurrentActQueue.current;\n\n        if (queue !== null) {\n          ReactCurrentActQueue.didScheduleLegacyUpdate = false;\n          flushActQueue(queue);\n        }\n      }\n    } catch (error) {\n      popActScope(prevActScopeDepth);\n      throw error;\n    } finally {\n      ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;\n    }\n\n    if (result !== null && typeof result === 'object' && typeof result.then === 'function') {\n      const thenableResult = result; // The callback is an async function (i.e. returned a promise). Wait\n      // for it to resolve before exiting the current scope.\n\n      let wasAwaited = false;\n      const thenable = {\n        then(resolve, reject) {\n          wasAwaited = true;\n          thenableResult.then(returnValue => {\n            popActScope(prevActScopeDepth);\n\n            if (actScopeDepth === 0) {\n              // We've exited the outermost act scope. Recursively flush the\n              // queue until there's no remaining work.\n              recursivelyFlushAsyncActWork(returnValue, resolve, reject);\n            } else {\n              resolve(returnValue);\n            }\n          }, error => {\n            // The callback threw an error.\n            popActScope(prevActScopeDepth);\n            reject(error);\n          });\n        }\n\n      };\n\n      if (__DEV__) {\n        if (!didWarnNoAwaitAct && typeof Promise !== 'undefined') {\n          // eslint-disable-next-line no-undef\n          Promise.resolve().then(() => {}).then(() => {\n            if (!wasAwaited) {\n              didWarnNoAwaitAct = true;\n              console.error('You called act(async () => ...) without await. ' + 'This could lead to unexpected testing behaviour, ' + 'interleaving multiple act calls and mixing their ' + 'scopes. ' + 'You should - await act(async () => ...);');\n            }\n          });\n        }\n      }\n\n      return thenable;\n    } else {\n      const returnValue = result; // The callback is not an async function. Exit the current scope\n      // immediately, without awaiting.\n\n      popActScope(prevActScopeDepth);\n\n      if (actScopeDepth === 0) {\n        // Exiting the outermost act scope. Flush the queue.\n        const queue = ReactCurrentActQueue.current;\n\n        if (queue !== null) {\n          flushActQueue(queue);\n          ReactCurrentActQueue.current = null;\n        } // Return a thenable. If the user awaits it, we'll flush again in\n        // case additional work was scheduled by a microtask.\n\n\n        const thenable = {\n          then(resolve, reject) {\n            // Confirm we haven't re-entered another `act` scope, in case\n            // the user does something weird like await the thenable\n            // multiple times.\n            if (ReactCurrentActQueue.current === null) {\n              // Recursively flush the queue until there's no remaining work.\n              ReactCurrentActQueue.current = [];\n              recursivelyFlushAsyncActWork(returnValue, resolve, reject);\n            } else {\n              resolve(returnValue);\n            }\n          }\n\n        };\n        return thenable;\n      } else {\n        // Since we're inside a nested `act` scope, the returned thenable\n        // immediately resolves. The outer scope will flush the queue.\n        const thenable = {\n          then(resolve, reject) {\n            resolve(returnValue);\n          }\n\n        };\n        return thenable;\n      }\n    }\n  } else {\n    throw new Error('act(...) is not supported in production builds of React.');\n  }\n}\n\nfunction popActScope(prevActScopeDepth) {\n  if (__DEV__) {\n    if (prevActScopeDepth !== actScopeDepth - 1) {\n      console.error('You seem to have overlapping act() calls, this is not supported. ' + 'Be sure to await previous act() calls before making a new one. ');\n    }\n\n    actScopeDepth = prevActScopeDepth;\n  }\n}\n\nfunction recursivelyFlushAsyncActWork(returnValue, resolve, reject) {\n  if (__DEV__) {\n    const queue = ReactCurrentActQueue.current;\n\n    if (queue !== null) {\n      try {\n        flushActQueue(queue);\n        enqueueTask(() => {\n          if (queue.length === 0) {\n            // No additional work was scheduled. Finish.\n            ReactCurrentActQueue.current = null;\n            resolve(returnValue);\n          } else {\n            // Keep flushing work until there's none left.\n            recursivelyFlushAsyncActWork(returnValue, resolve, reject);\n          }\n        });\n      } catch (error) {\n        reject(error);\n      }\n    } else {\n      resolve(returnValue);\n    }\n  }\n}\n\nlet isFlushing = false;\n\nfunction flushActQueue(queue) {\n  if (__DEV__) {\n    if (!isFlushing) {\n      // Prevent re-entrance.\n      isFlushing = true;\n      let i = 0;\n\n      try {\n        for (; i < queue.length; i++) {\n          let callback = queue[i];\n\n          do {\n            callback = callback(true);\n          } while (callback !== null);\n        }\n\n        queue.length = 0;\n      } catch (error) {\n        // If something throws, leave the remaining callbacks on the queue.\n        queue = queue.slice(i + 1);\n        throw error;\n      } finally {\n        isFlushing = false;\n      }\n    }\n  }\n}","map":{"version":3,"sources":["/Users/zhangshuo/git/my-app/src/react/packages/react/src/ReactAct.js"],"names":["ReactCurrentActQueue","enqueueTask","actScopeDepth","didWarnNoAwaitAct","act","callback","__DEV__","prevActScopeDepth","current","prevIsBatchingLegacy","isBatchingLegacy","result","didScheduleLegacyUpdate","queue","flushActQueue","error","popActScope","then","thenableResult","wasAwaited","thenable","resolve","reject","returnValue","recursivelyFlushAsyncActWork","Promise","console","Error","length","isFlushing","i","slice"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Thenable} from 'shared/ReactTypes';\nimport ReactCurrentActQueue from './ReactCurrentActQueue';\nimport enqueueTask from 'shared/enqueueTask';\n\nlet actScopeDepth = 0;\nlet didWarnNoAwaitAct = false;\n\nexport function act<T>(callback: () => T | Thenable<T>): Thenable<T> {\n  if (__DEV__) {\n    // `act` calls can be nested, so we track the depth. This represents the\n    // number of `act` scopes on the stack.\n    const prevActScopeDepth = actScopeDepth;\n    actScopeDepth++;\n\n    if (ReactCurrentActQueue.current === null) {\n      // This is the outermost `act` scope. Initialize the queue. The reconciler\n      // will detect the queue and use it instead of Scheduler.\n      ReactCurrentActQueue.current = [];\n    }\n\n    const prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;\n    let result;\n    try {\n      // Used to reproduce behavior of `batchedUpdates` in legacy mode. Only\n      // set to `true` while the given callback is executed, not for updates\n      // triggered during an async event, because this is how the legacy\n      // implementation of `act` behaved.\n      ReactCurrentActQueue.isBatchingLegacy = true;\n      result = callback();\n\n      // Replicate behavior of original `act` implementation in legacy mode,\n      // which flushed updates immediately after the scope function exits, even\n      // if it's an async function.\n      if (\n        !prevIsBatchingLegacy &&\n        ReactCurrentActQueue.didScheduleLegacyUpdate\n      ) {\n        const queue = ReactCurrentActQueue.current;\n        if (queue !== null) {\n          ReactCurrentActQueue.didScheduleLegacyUpdate = false;\n          flushActQueue(queue);\n        }\n      }\n    } catch (error) {\n      popActScope(prevActScopeDepth);\n      throw error;\n    } finally {\n      ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;\n    }\n\n    if (\n      result !== null &&\n      typeof result === 'object' &&\n      typeof result.then === 'function'\n    ) {\n      const thenableResult: Thenable<T> = (result: any);\n      // The callback is an async function (i.e. returned a promise). Wait\n      // for it to resolve before exiting the current scope.\n      let wasAwaited = false;\n      const thenable: Thenable<T> = {\n        then(resolve, reject) {\n          wasAwaited = true;\n          thenableResult.then(\n            returnValue => {\n              popActScope(prevActScopeDepth);\n              if (actScopeDepth === 0) {\n                // We've exited the outermost act scope. Recursively flush the\n                // queue until there's no remaining work.\n                recursivelyFlushAsyncActWork(returnValue, resolve, reject);\n              } else {\n                resolve(returnValue);\n              }\n            },\n            error => {\n              // The callback threw an error.\n              popActScope(prevActScopeDepth);\n              reject(error);\n            },\n          );\n        },\n      };\n\n      if (__DEV__) {\n        if (!didWarnNoAwaitAct && typeof Promise !== 'undefined') {\n          // eslint-disable-next-line no-undef\n          Promise.resolve()\n            .then(() => {})\n            .then(() => {\n              if (!wasAwaited) {\n                didWarnNoAwaitAct = true;\n                console.error(\n                  'You called act(async () => ...) without await. ' +\n                    'This could lead to unexpected testing behaviour, ' +\n                    'interleaving multiple act calls and mixing their ' +\n                    'scopes. ' +\n                    'You should - await act(async () => ...);',\n                );\n              }\n            });\n        }\n      }\n      return thenable;\n    } else {\n      const returnValue: T = (result: any);\n      // The callback is not an async function. Exit the current scope\n      // immediately, without awaiting.\n      popActScope(prevActScopeDepth);\n      if (actScopeDepth === 0) {\n        // Exiting the outermost act scope. Flush the queue.\n        const queue = ReactCurrentActQueue.current;\n        if (queue !== null) {\n          flushActQueue(queue);\n          ReactCurrentActQueue.current = null;\n        }\n        // Return a thenable. If the user awaits it, we'll flush again in\n        // case additional work was scheduled by a microtask.\n        const thenable: Thenable<T> = {\n          then(resolve, reject) {\n            // Confirm we haven't re-entered another `act` scope, in case\n            // the user does something weird like await the thenable\n            // multiple times.\n            if (ReactCurrentActQueue.current === null) {\n              // Recursively flush the queue until there's no remaining work.\n              ReactCurrentActQueue.current = [];\n              recursivelyFlushAsyncActWork(returnValue, resolve, reject);\n            } else {\n              resolve(returnValue);\n            }\n          },\n        };\n        return thenable;\n      } else {\n        // Since we're inside a nested `act` scope, the returned thenable\n        // immediately resolves. The outer scope will flush the queue.\n        const thenable: Thenable<T> = {\n          then(resolve, reject) {\n            resolve(returnValue);\n          },\n        };\n        return thenable;\n      }\n    }\n  } else {\n    throw new Error('act(...) is not supported in production builds of React.');\n  }\n}\n\nfunction popActScope(prevActScopeDepth) {\n  if (__DEV__) {\n    if (prevActScopeDepth !== actScopeDepth - 1) {\n      console.error(\n        'You seem to have overlapping act() calls, this is not supported. ' +\n          'Be sure to await previous act() calls before making a new one. ',\n      );\n    }\n    actScopeDepth = prevActScopeDepth;\n  }\n}\n\nfunction recursivelyFlushAsyncActWork<T>(\n  returnValue: T,\n  resolve: T => mixed,\n  reject: mixed => mixed,\n) {\n  if (__DEV__) {\n    const queue = ReactCurrentActQueue.current;\n    if (queue !== null) {\n      try {\n        flushActQueue(queue);\n        enqueueTask(() => {\n          if (queue.length === 0) {\n            // No additional work was scheduled. Finish.\n            ReactCurrentActQueue.current = null;\n            resolve(returnValue);\n          } else {\n            // Keep flushing work until there's none left.\n            recursivelyFlushAsyncActWork(returnValue, resolve, reject);\n          }\n        });\n      } catch (error) {\n        reject(error);\n      }\n    } else {\n      resolve(returnValue);\n    }\n  }\n}\n\nlet isFlushing = false;\nfunction flushActQueue(queue) {\n  if (__DEV__) {\n    if (!isFlushing) {\n      // Prevent re-entrance.\n      isFlushing = true;\n      let i = 0;\n      try {\n        for (; i < queue.length; i++) {\n          let callback = queue[i];\n          do {\n            callback = callback(true);\n          } while (callback !== null);\n        }\n        queue.length = 0;\n      } catch (error) {\n        // If something throws, leave the remaining callbacks on the queue.\n        queue = queue.slice(i + 1);\n        throw error;\n      } finally {\n        isFlushing = false;\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}