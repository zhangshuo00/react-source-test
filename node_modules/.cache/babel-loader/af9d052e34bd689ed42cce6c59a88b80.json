{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport getComponentNameFromFiber from 'react-reconciler/src/getComponentNameFromFiber';\nimport { ClassComponent, HostRoot, SuspenseComponent, IncompleteClassComponent, FunctionComponent, ForwardRef, SimpleMemoComponent } from './ReactWorkTags';\nimport { DidCapture, Incomplete, NoFlags, ShouldCapture, LifecycleEffectMask, ForceUpdateForLegacySuspense, ForceClientRender } from './ReactFiberFlags';\nimport { supportsPersistence, getOffscreenContainerProps } from './ReactFiberHostConfig';\nimport { shouldCaptureSuspense } from './ReactFiberSuspenseComponent.new';\nimport { NoMode, ConcurrentMode, DebugTracingMode } from './ReactTypeOfMode';\nimport { enableDebugTracing, enableLazyContextPropagation, enableUpdaterTracking, enablePersistentOffscreenHostContainer } from 'shared/ReactFeatureFlags';\nimport { createCapturedValue } from './ReactCapturedValue';\nimport { enqueueCapturedUpdate, createUpdate, CaptureUpdate, ForceUpdate, enqueueUpdate } from './ReactUpdateQueue.new';\nimport { markFailedErrorBoundaryForHotReloading } from './ReactFiberHotReloading.new';\nimport { suspenseStackCursor, InvisibleParentSuspenseContext, hasSuspenseContext } from './ReactFiberSuspenseContext.new';\nimport { renderDidError, onUncaughtError, markLegacyErrorBoundaryAsFailed, isAlreadyFailedLegacyErrorBoundary, pingSuspendedRoot, restorePendingUpdaters } from './ReactFiberWorkLoop.new';\nimport { propagateParentContextChangesToDeferredTree } from './ReactFiberNewContext.new';\nimport { logCapturedError } from './ReactFiberErrorLogger';\nimport { logComponentSuspended } from './DebugTracing';\nimport { isDevToolsPresent } from './ReactFiberDevToolsHook.new';\nimport { SyncLane, NoTimestamp, includesSomeLane, mergeLanes, pickArbitraryLane } from './ReactFiberLane.new';\nimport { getIsHydrating } from './ReactFiberHydrationContext.new';\nconst PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n\nfunction createRootErrorUpdate(fiber, errorInfo, lane) {\n  const update = createUpdate(NoTimestamp, lane); // Unmount the root by rendering null.\n\n  update.tag = CaptureUpdate; // Caution: React DevTools currently depends on this property\n  // being called \"element\".\n\n  update.payload = {\n    element: null\n  };\n  const error = errorInfo.value;\n\n  update.callback = () => {\n    onUncaughtError(error);\n    logCapturedError(fiber, errorInfo);\n  };\n\n  return update;\n}\n\nfunction createClassErrorUpdate(fiber, errorInfo, lane) {\n  const update = createUpdate(NoTimestamp, lane);\n  update.tag = CaptureUpdate;\n  const getDerivedStateFromError = fiber.type.getDerivedStateFromError;\n\n  if (typeof getDerivedStateFromError === 'function') {\n    const error = errorInfo.value;\n\n    update.payload = () => {\n      return getDerivedStateFromError(error);\n    };\n\n    update.callback = () => {\n      if (__DEV__) {\n        markFailedErrorBoundaryForHotReloading(fiber);\n      }\n\n      logCapturedError(fiber, errorInfo);\n    };\n  }\n\n  const inst = fiber.stateNode;\n\n  if (inst !== null && typeof inst.componentDidCatch === 'function') {\n    update.callback = function callback() {\n      if (__DEV__) {\n        markFailedErrorBoundaryForHotReloading(fiber);\n      }\n\n      logCapturedError(fiber, errorInfo);\n\n      if (typeof getDerivedStateFromError !== 'function') {\n        // To preserve the preexisting retry behavior of error boundaries,\n        // we keep track of which ones already failed during this batch.\n        // This gets reset before we yield back to the browser.\n        // TODO: Warn in strict mode if getDerivedStateFromError is\n        // not defined.\n        markLegacyErrorBoundaryAsFailed(this);\n      }\n\n      const error = errorInfo.value;\n      const stack = errorInfo.stack;\n      this.componentDidCatch(error, {\n        componentStack: stack !== null ? stack : ''\n      });\n\n      if (__DEV__) {\n        if (typeof getDerivedStateFromError !== 'function') {\n          // If componentDidCatch is the only error boundary method defined,\n          // then it needs to call setState to recover from errors.\n          // If no state update is scheduled then the boundary will swallow the error.\n          if (!includesSomeLane(fiber.lanes, SyncLane)) {\n            console.error('%s: Error boundaries should implement getDerivedStateFromError(). ' + 'In that method, return a state update to display an error message or fallback UI.', getComponentNameFromFiber(fiber) || 'Unknown');\n          }\n        }\n      }\n    };\n  }\n\n  return update;\n}\n\nfunction attachWakeableListeners(suspenseBoundary, root, wakeable, lanes) {\n  // Attach a ping listener\n  //\n  // The data might resolve before we have a chance to commit the fallback. Or,\n  // in the case of a refresh, we'll never commit a fallback. So we need to\n  // attach a listener now. When it resolves (\"pings\"), we can decide whether to\n  // try rendering the tree again.\n  //\n  // Only attach a listener if one does not already exist for the lanes\n  // we're currently rendering (which acts like a \"thread ID\" here).\n  //\n  // We only need to do this in concurrent mode. Legacy Suspense always\n  // commits fallbacks synchronously, so there are no pings.\n  if (suspenseBoundary.mode & ConcurrentMode) {\n    let pingCache = root.pingCache;\n    let threadIDs;\n\n    if (pingCache === null) {\n      pingCache = root.pingCache = new PossiblyWeakMap();\n      threadIDs = new Set();\n      pingCache.set(wakeable, threadIDs);\n    } else {\n      threadIDs = pingCache.get(wakeable);\n\n      if (threadIDs === undefined) {\n        threadIDs = new Set();\n        pingCache.set(wakeable, threadIDs);\n      }\n    }\n\n    if (!threadIDs.has(lanes)) {\n      // Memoize using the thread ID to prevent redundant listeners.\n      threadIDs.add(lanes);\n      const ping = pingSuspendedRoot.bind(null, root, wakeable, lanes);\n\n      if (enableUpdaterTracking) {\n        if (isDevToolsPresent) {\n          // If we have pending work still, restore the original updaters\n          restorePendingUpdaters(root, lanes);\n        }\n      }\n\n      wakeable.then(ping, ping);\n    }\n  } // Retry listener\n  //\n  // If the fallback does commit, we need to attach a different type of\n  // listener. This one schedules an update on the Suspense boundary to turn\n  // the fallback state off.\n  //\n  // Stash the wakeable on the boundary fiber so we can access it in the\n  // commit phase.\n  //\n  // When the wakeable resolves, we'll attempt to render the boundary\n  // again (\"retry\").\n\n\n  const wakeables = suspenseBoundary.updateQueue;\n\n  if (wakeables === null) {\n    const updateQueue = new Set();\n    updateQueue.add(wakeable);\n    suspenseBoundary.updateQueue = updateQueue;\n  } else {\n    wakeables.add(wakeable);\n  }\n}\n\nfunction resetSuspendedComponent(sourceFiber, rootRenderLanes) {\n  if (enableLazyContextPropagation) {\n    const currentSourceFiber = sourceFiber.alternate;\n\n    if (currentSourceFiber !== null) {\n      // Since we never visited the children of the suspended component, we\n      // need to propagate the context change now, to ensure that we visit\n      // them during the retry.\n      //\n      // We don't have to do this for errors because we retry errors without\n      // committing in between. So this is specific to Suspense.\n      propagateParentContextChangesToDeferredTree(currentSourceFiber, sourceFiber, rootRenderLanes);\n    }\n  } // Reset the memoizedState to what it was before we attempted to render it.\n  // A legacy mode Suspense quirk, only relevant to hook components.\n\n\n  const tag = sourceFiber.tag;\n\n  if ((sourceFiber.mode & ConcurrentMode) === NoMode && (tag === FunctionComponent || tag === ForwardRef || tag === SimpleMemoComponent)) {\n    const currentSource = sourceFiber.alternate;\n\n    if (currentSource) {\n      sourceFiber.updateQueue = currentSource.updateQueue;\n      sourceFiber.memoizedState = currentSource.memoizedState;\n      sourceFiber.lanes = currentSource.lanes;\n    } else {\n      sourceFiber.updateQueue = null;\n      sourceFiber.memoizedState = null;\n    }\n  }\n}\n\nfunction getNearestSuspenseBoundaryToCapture(returnFiber) {\n  let node = returnFiber;\n  const hasInvisibleParentBoundary = hasSuspenseContext(suspenseStackCursor.current, InvisibleParentSuspenseContext);\n\n  do {\n    if (node.tag === SuspenseComponent && shouldCaptureSuspense(node, hasInvisibleParentBoundary)) {\n      return node;\n    } // This boundary already captured during this render. Continue to the next\n    // boundary.\n\n\n    node = node.return;\n  } while (node !== null);\n\n  return null;\n}\n\nfunction markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root, rootRenderLanes) {\n  // This marks a Suspense boundary so that when we're unwinding the stack,\n  // it captures the suspended \"exception\" and does a second (fallback) pass.\n  if ((suspenseBoundary.mode & ConcurrentMode) === NoMode) {\n    // Legacy Mode Suspense\n    //\n    // If the boundary is in legacy mode, we should *not*\n    // suspend the commit. Pretend as if the suspended component rendered\n    // null and keep rendering. When the Suspense boundary completes,\n    // we'll do a second pass to render the fallback.\n    if (suspenseBoundary === returnFiber) {\n      // Special case where we suspended while reconciling the children of\n      // a Suspense boundary's inner Offscreen wrapper fiber. This happens\n      // when a React.lazy component is a direct child of a\n      // Suspense boundary.\n      //\n      // Suspense boundaries are implemented as multiple fibers, but they\n      // are a single conceptual unit. The legacy mode behavior where we\n      // pretend the suspended fiber committed as `null` won't work,\n      // because in this case the \"suspended\" fiber is the inner\n      // Offscreen wrapper.\n      //\n      // Because the contents of the boundary haven't started rendering\n      // yet (i.e. nothing in the tree has partially rendered) we can\n      // switch to the regular, concurrent mode behavior: mark the\n      // boundary with ShouldCapture and enter the unwind phase.\n      suspenseBoundary.flags |= ShouldCapture;\n    } else {\n      suspenseBoundary.flags |= DidCapture;\n      sourceFiber.flags |= ForceUpdateForLegacySuspense; // We're going to commit this fiber even though it didn't complete.\n      // But we shouldn't call any lifecycle methods or callbacks. Remove\n      // all lifecycle effect tags.\n\n      sourceFiber.flags &= ~(LifecycleEffectMask | Incomplete);\n\n      if (supportsPersistence && enablePersistentOffscreenHostContainer) {\n        // Another legacy Suspense quirk. In persistent mode, if this is the\n        // initial mount, override the props of the host container to hide\n        // its contents.\n        const currentSuspenseBoundary = suspenseBoundary.alternate;\n\n        if (currentSuspenseBoundary === null) {\n          const offscreenFiber = suspenseBoundary.child;\n          const offscreenContainer = offscreenFiber.child;\n\n          if (offscreenContainer !== null) {\n            const children = offscreenContainer.memoizedProps.children;\n            const containerProps = getOffscreenContainerProps('hidden', children);\n            offscreenContainer.pendingProps = containerProps;\n            offscreenContainer.memoizedProps = containerProps;\n          }\n        }\n      }\n\n      if (sourceFiber.tag === ClassComponent) {\n        const currentSourceFiber = sourceFiber.alternate;\n\n        if (currentSourceFiber === null) {\n          // This is a new mount. Change the tag so it's not mistaken for a\n          // completed class component. For example, we should not call\n          // componentWillUnmount if it is deleted.\n          sourceFiber.tag = IncompleteClassComponent;\n        } else {\n          // When we try rendering again, we should not reuse the current fiber,\n          // since it's known to be in an inconsistent state. Use a force update to\n          // prevent a bail out.\n          const update = createUpdate(NoTimestamp, SyncLane);\n          update.tag = ForceUpdate;\n          enqueueUpdate(sourceFiber, update, SyncLane);\n        }\n      } // The source fiber did not complete. Mark it with Sync priority to\n      // indicate that it still has pending work.\n\n\n      sourceFiber.lanes = mergeLanes(sourceFiber.lanes, SyncLane);\n    }\n\n    return suspenseBoundary;\n  } // Confirmed that the boundary is in a concurrent mode tree. Continue\n  // with the normal suspend path.\n  //\n  // After this we'll use a set of heuristics to determine whether this\n  // render pass will run to completion or restart or \"suspend\" the commit.\n  // The actual logic for this is spread out in different places.\n  //\n  // This first principle is that if we're going to suspend when we complete\n  // a root, then we should also restart if we get an update or ping that\n  // might unsuspend it, and vice versa. The only reason to suspend is\n  // because you think you might want to restart before committing. However,\n  // it doesn't make sense to restart only while in the period we're suspended.\n  //\n  // Restarting too aggressively is also not good because it starves out any\n  // intermediate loading state. So we use heuristics to determine when.\n  // Suspense Heuristics\n  //\n  // If nothing threw a Promise or all the same fallbacks are already showing,\n  // then don't suspend/restart.\n  //\n  // If this is an initial render of a new tree of Suspense boundaries and\n  // those trigger a fallback, then don't suspend/restart. We want to ensure\n  // that we can show the initial loading state as quickly as possible.\n  //\n  // If we hit a \"Delayed\" case, such as when we'd switch from content back into\n  // a fallback, then we should always suspend/restart. Transitions apply\n  // to this case. If none is defined, JND is used instead.\n  //\n  // If we're already showing a fallback and it gets \"retried\", allowing us to show\n  // another level, but there's still an inner boundary that would show a fallback,\n  // then we suspend/restart for 500ms since the last time we showed a fallback\n  // anywhere in the tree. This effectively throttles progressive loading into a\n  // consistent train of commits. This also gives us an opportunity to restart to\n  // get to the completed state slightly earlier.\n  //\n  // If there's ambiguity due to batching it's resolved in preference of:\n  // 1) \"delayed\", 2) \"initial render\", 3) \"retry\".\n  //\n  // We want to ensure that a \"busy\" state doesn't get force committed. We want to\n  // ensure that new initial loading states can commit as soon as possible.\n\n\n  suspenseBoundary.flags |= ShouldCapture; // TODO: I think we can remove this, since we now use `DidCapture` in\n  // the begin phase to prevent an early bailout.\n\n  suspenseBoundary.lanes = rootRenderLanes;\n  return suspenseBoundary;\n}\n\nfunction throwException(root, returnFiber, sourceFiber, value, rootRenderLanes) {\n  // The source fiber did not complete.\n  sourceFiber.flags |= Incomplete;\n\n  if (enableUpdaterTracking) {\n    if (isDevToolsPresent) {\n      // If we have pending work still, restore the original updaters\n      restorePendingUpdaters(root, rootRenderLanes);\n    }\n  }\n\n  if (value !== null && typeof value === 'object' && typeof value.then === 'function') {\n    // This is a wakeable. The component suspended.\n    const wakeable = value;\n    resetSuspendedComponent(sourceFiber, rootRenderLanes);\n\n    if (__DEV__) {\n      if (enableDebugTracing) {\n        if (sourceFiber.mode & DebugTracingMode) {\n          const name = getComponentNameFromFiber(sourceFiber) || 'Unknown';\n          logComponentSuspended(name, wakeable);\n        }\n      }\n    } // Schedule the nearest Suspense to re-render the timed out view.\n\n\n    const suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber);\n\n    if (suspenseBoundary !== null) {\n      suspenseBoundary.flags &= ~ForceClientRender;\n      markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root, rootRenderLanes);\n      attachWakeableListeners(suspenseBoundary, root, wakeable, rootRenderLanes);\n      return;\n    } else {\n      // No boundary was found. Fallthrough to error mode.\n      // TODO: We should never call getComponentNameFromFiber in production.\n      // Log a warning or something to prevent us from accidentally bundling it.\n      value = new Error((getComponentNameFromFiber(sourceFiber) || 'A React component') + ' suspended while rendering, but no fallback UI was specified.\\n' + '\\n' + 'Add a <Suspense fallback=...> component higher in the tree to ' + 'provide a loading indicator or placeholder to display.');\n    }\n  } else {\n    // This is a regular error, not a Suspense wakeable.\n    if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {\n      const suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber); // If the error was thrown during hydration, we may be able to recover by\n      // discarding the dehydrated content and switching to a client render.\n      // Instead of surfacing the error, find the nearest Suspense boundary\n      // and render it again without hydration.\n\n      if (suspenseBoundary !== null) {\n        if ((suspenseBoundary.flags & ShouldCapture) === NoFlags) {\n          // Set a flag to indicate that we should try rendering the normal\n          // children again, not the fallback.\n          suspenseBoundary.flags |= ForceClientRender;\n        }\n\n        markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root, rootRenderLanes);\n        return;\n      }\n    } else {// Otherwise, fall through to the error path.\n    }\n  } // We didn't find a boundary that could handle this type of exception. Start\n  // over and traverse parent path again, this time treating the exception\n  // as an error.\n\n\n  renderDidError();\n  value = createCapturedValue(value, sourceFiber);\n  let workInProgress = returnFiber;\n\n  do {\n    switch (workInProgress.tag) {\n      case HostRoot:\n        {\n          const errorInfo = value;\n          workInProgress.flags |= ShouldCapture;\n          const lane = pickArbitraryLane(rootRenderLanes);\n          workInProgress.lanes = mergeLanes(workInProgress.lanes, lane);\n          const update = createRootErrorUpdate(workInProgress, errorInfo, lane);\n          enqueueCapturedUpdate(workInProgress, update);\n          return;\n        }\n\n      case ClassComponent:\n        // Capture and retry\n        const errorInfo = value;\n        const ctor = workInProgress.type;\n        const instance = workInProgress.stateNode;\n\n        if ((workInProgress.flags & DidCapture) === NoFlags && (typeof ctor.getDerivedStateFromError === 'function' || instance !== null && typeof instance.componentDidCatch === 'function' && !isAlreadyFailedLegacyErrorBoundary(instance))) {\n          workInProgress.flags |= ShouldCapture;\n          const lane = pickArbitraryLane(rootRenderLanes);\n          workInProgress.lanes = mergeLanes(workInProgress.lanes, lane); // Schedule the error boundary to re-render using updated state\n\n          const update = createClassErrorUpdate(workInProgress, errorInfo, lane);\n          enqueueCapturedUpdate(workInProgress, update);\n          return;\n        }\n\n        break;\n\n      default:\n        break;\n    }\n\n    workInProgress = workInProgress.return;\n  } while (workInProgress !== null);\n}\n\nexport { throwException, createRootErrorUpdate, createClassErrorUpdate };","map":{"version":3,"sources":["/Users/zhangshuo/git/react-source-test/src/react/packages/react-reconciler/src/ReactFiberThrow.new.js"],"names":["getComponentNameFromFiber","ClassComponent","HostRoot","SuspenseComponent","IncompleteClassComponent","FunctionComponent","ForwardRef","SimpleMemoComponent","DidCapture","Incomplete","NoFlags","ShouldCapture","LifecycleEffectMask","ForceUpdateForLegacySuspense","ForceClientRender","supportsPersistence","getOffscreenContainerProps","shouldCaptureSuspense","NoMode","ConcurrentMode","DebugTracingMode","enableDebugTracing","enableLazyContextPropagation","enableUpdaterTracking","enablePersistentOffscreenHostContainer","createCapturedValue","enqueueCapturedUpdate","createUpdate","CaptureUpdate","ForceUpdate","enqueueUpdate","markFailedErrorBoundaryForHotReloading","suspenseStackCursor","InvisibleParentSuspenseContext","hasSuspenseContext","renderDidError","onUncaughtError","markLegacyErrorBoundaryAsFailed","isAlreadyFailedLegacyErrorBoundary","pingSuspendedRoot","restorePendingUpdaters","propagateParentContextChangesToDeferredTree","logCapturedError","logComponentSuspended","isDevToolsPresent","SyncLane","NoTimestamp","includesSomeLane","mergeLanes","pickArbitraryLane","getIsHydrating","PossiblyWeakMap","WeakMap","Map","createRootErrorUpdate","fiber","errorInfo","lane","update","tag","payload","element","error","value","callback","createClassErrorUpdate","getDerivedStateFromError","type","__DEV__","inst","stateNode","componentDidCatch","stack","componentStack","lanes","console","attachWakeableListeners","suspenseBoundary","root","wakeable","mode","pingCache","threadIDs","Set","set","get","undefined","has","add","ping","bind","then","wakeables","updateQueue","resetSuspendedComponent","sourceFiber","rootRenderLanes","currentSourceFiber","alternate","currentSource","memoizedState","getNearestSuspenseBoundaryToCapture","returnFiber","node","hasInvisibleParentBoundary","current","return","markSuspenseBoundaryShouldCapture","flags","currentSuspenseBoundary","offscreenFiber","child","offscreenContainer","children","memoizedProps","containerProps","pendingProps","throwException","name","Error","workInProgress","ctor","instance"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Fiber} from './ReactInternalTypes';\nimport type {FiberRoot} from './ReactInternalTypes';\nimport type {Lane, Lanes} from './ReactFiberLane.new';\nimport type {CapturedValue} from './ReactCapturedValue';\nimport type {Update} from './ReactUpdateQueue.new';\nimport type {Wakeable} from 'shared/ReactTypes';\nimport type {SuspenseContext} from './ReactFiberSuspenseContext.new';\n\nimport getComponentNameFromFiber from 'react-reconciler/src/getComponentNameFromFiber';\nimport {\n  ClassComponent,\n  HostRoot,\n  SuspenseComponent,\n  IncompleteClassComponent,\n  FunctionComponent,\n  ForwardRef,\n  SimpleMemoComponent,\n} from './ReactWorkTags';\nimport {\n  DidCapture,\n  Incomplete,\n  NoFlags,\n  ShouldCapture,\n  LifecycleEffectMask,\n  ForceUpdateForLegacySuspense,\n  ForceClientRender,\n} from './ReactFiberFlags';\nimport {\n  supportsPersistence,\n  getOffscreenContainerProps,\n} from './ReactFiberHostConfig';\nimport {shouldCaptureSuspense} from './ReactFiberSuspenseComponent.new';\nimport {NoMode, ConcurrentMode, DebugTracingMode} from './ReactTypeOfMode';\nimport {\n  enableDebugTracing,\n  enableLazyContextPropagation,\n  enableUpdaterTracking,\n  enablePersistentOffscreenHostContainer,\n} from 'shared/ReactFeatureFlags';\nimport {createCapturedValue} from './ReactCapturedValue';\nimport {\n  enqueueCapturedUpdate,\n  createUpdate,\n  CaptureUpdate,\n  ForceUpdate,\n  enqueueUpdate,\n} from './ReactUpdateQueue.new';\nimport {markFailedErrorBoundaryForHotReloading} from './ReactFiberHotReloading.new';\nimport {\n  suspenseStackCursor,\n  InvisibleParentSuspenseContext,\n  hasSuspenseContext,\n} from './ReactFiberSuspenseContext.new';\nimport {\n  renderDidError,\n  onUncaughtError,\n  markLegacyErrorBoundaryAsFailed,\n  isAlreadyFailedLegacyErrorBoundary,\n  pingSuspendedRoot,\n  restorePendingUpdaters,\n} from './ReactFiberWorkLoop.new';\nimport {propagateParentContextChangesToDeferredTree} from './ReactFiberNewContext.new';\nimport {logCapturedError} from './ReactFiberErrorLogger';\nimport {logComponentSuspended} from './DebugTracing';\nimport {isDevToolsPresent} from './ReactFiberDevToolsHook.new';\nimport {\n  SyncLane,\n  NoTimestamp,\n  includesSomeLane,\n  mergeLanes,\n  pickArbitraryLane,\n} from './ReactFiberLane.new';\nimport {getIsHydrating} from './ReactFiberHydrationContext.new';\n\nconst PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n\nfunction createRootErrorUpdate(\n  fiber: Fiber,\n  errorInfo: CapturedValue<mixed>,\n  lane: Lane,\n): Update<mixed> {\n  const update = createUpdate(NoTimestamp, lane);\n  // Unmount the root by rendering null.\n  update.tag = CaptureUpdate;\n  // Caution: React DevTools currently depends on this property\n  // being called \"element\".\n  update.payload = {element: null};\n  const error = errorInfo.value;\n  update.callback = () => {\n    onUncaughtError(error);\n    logCapturedError(fiber, errorInfo);\n  };\n  return update;\n}\n\nfunction createClassErrorUpdate(\n  fiber: Fiber,\n  errorInfo: CapturedValue<mixed>,\n  lane: Lane,\n): Update<mixed> {\n  const update = createUpdate(NoTimestamp, lane);\n  update.tag = CaptureUpdate;\n  const getDerivedStateFromError = fiber.type.getDerivedStateFromError;\n  if (typeof getDerivedStateFromError === 'function') {\n    const error = errorInfo.value;\n    update.payload = () => {\n      return getDerivedStateFromError(error);\n    };\n    update.callback = () => {\n      if (__DEV__) {\n        markFailedErrorBoundaryForHotReloading(fiber);\n      }\n      logCapturedError(fiber, errorInfo);\n    };\n  }\n\n  const inst = fiber.stateNode;\n  if (inst !== null && typeof inst.componentDidCatch === 'function') {\n    update.callback = function callback() {\n      if (__DEV__) {\n        markFailedErrorBoundaryForHotReloading(fiber);\n      }\n      logCapturedError(fiber, errorInfo);\n      if (typeof getDerivedStateFromError !== 'function') {\n        // To preserve the preexisting retry behavior of error boundaries,\n        // we keep track of which ones already failed during this batch.\n        // This gets reset before we yield back to the browser.\n        // TODO: Warn in strict mode if getDerivedStateFromError is\n        // not defined.\n        markLegacyErrorBoundaryAsFailed(this);\n      }\n      const error = errorInfo.value;\n      const stack = errorInfo.stack;\n      this.componentDidCatch(error, {\n        componentStack: stack !== null ? stack : '',\n      });\n      if (__DEV__) {\n        if (typeof getDerivedStateFromError !== 'function') {\n          // If componentDidCatch is the only error boundary method defined,\n          // then it needs to call setState to recover from errors.\n          // If no state update is scheduled then the boundary will swallow the error.\n          if (!includesSomeLane(fiber.lanes, (SyncLane: Lane))) {\n            console.error(\n              '%s: Error boundaries should implement getDerivedStateFromError(). ' +\n                'In that method, return a state update to display an error message or fallback UI.',\n              getComponentNameFromFiber(fiber) || 'Unknown',\n            );\n          }\n        }\n      }\n    };\n  }\n  return update;\n}\n\nfunction attachWakeableListeners(\n  suspenseBoundary: Fiber,\n  root: FiberRoot,\n  wakeable: Wakeable,\n  lanes: Lanes,\n) {\n  // Attach a ping listener\n  //\n  // The data might resolve before we have a chance to commit the fallback. Or,\n  // in the case of a refresh, we'll never commit a fallback. So we need to\n  // attach a listener now. When it resolves (\"pings\"), we can decide whether to\n  // try rendering the tree again.\n  //\n  // Only attach a listener if one does not already exist for the lanes\n  // we're currently rendering (which acts like a \"thread ID\" here).\n  //\n  // We only need to do this in concurrent mode. Legacy Suspense always\n  // commits fallbacks synchronously, so there are no pings.\n  if (suspenseBoundary.mode & ConcurrentMode) {\n    let pingCache = root.pingCache;\n    let threadIDs;\n    if (pingCache === null) {\n      pingCache = root.pingCache = new PossiblyWeakMap();\n      threadIDs = new Set();\n      pingCache.set(wakeable, threadIDs);\n    } else {\n      threadIDs = pingCache.get(wakeable);\n      if (threadIDs === undefined) {\n        threadIDs = new Set();\n        pingCache.set(wakeable, threadIDs);\n      }\n    }\n    if (!threadIDs.has(lanes)) {\n      // Memoize using the thread ID to prevent redundant listeners.\n      threadIDs.add(lanes);\n      const ping = pingSuspendedRoot.bind(null, root, wakeable, lanes);\n      if (enableUpdaterTracking) {\n        if (isDevToolsPresent) {\n          // If we have pending work still, restore the original updaters\n          restorePendingUpdaters(root, lanes);\n        }\n      }\n      wakeable.then(ping, ping);\n    }\n  }\n\n  // Retry listener\n  //\n  // If the fallback does commit, we need to attach a different type of\n  // listener. This one schedules an update on the Suspense boundary to turn\n  // the fallback state off.\n  //\n  // Stash the wakeable on the boundary fiber so we can access it in the\n  // commit phase.\n  //\n  // When the wakeable resolves, we'll attempt to render the boundary\n  // again (\"retry\").\n  const wakeables: Set<Wakeable> | null = (suspenseBoundary.updateQueue: any);\n  if (wakeables === null) {\n    const updateQueue = (new Set(): any);\n    updateQueue.add(wakeable);\n    suspenseBoundary.updateQueue = updateQueue;\n  } else {\n    wakeables.add(wakeable);\n  }\n}\n\nfunction resetSuspendedComponent(sourceFiber: Fiber, rootRenderLanes: Lanes) {\n  if (enableLazyContextPropagation) {\n    const currentSourceFiber = sourceFiber.alternate;\n    if (currentSourceFiber !== null) {\n      // Since we never visited the children of the suspended component, we\n      // need to propagate the context change now, to ensure that we visit\n      // them during the retry.\n      //\n      // We don't have to do this for errors because we retry errors without\n      // committing in between. So this is specific to Suspense.\n      propagateParentContextChangesToDeferredTree(\n        currentSourceFiber,\n        sourceFiber,\n        rootRenderLanes,\n      );\n    }\n  }\n\n  // Reset the memoizedState to what it was before we attempted to render it.\n  // A legacy mode Suspense quirk, only relevant to hook components.\n  const tag = sourceFiber.tag;\n  if (\n    (sourceFiber.mode & ConcurrentMode) === NoMode &&\n    (tag === FunctionComponent ||\n      tag === ForwardRef ||\n      tag === SimpleMemoComponent)\n  ) {\n    const currentSource = sourceFiber.alternate;\n    if (currentSource) {\n      sourceFiber.updateQueue = currentSource.updateQueue;\n      sourceFiber.memoizedState = currentSource.memoizedState;\n      sourceFiber.lanes = currentSource.lanes;\n    } else {\n      sourceFiber.updateQueue = null;\n      sourceFiber.memoizedState = null;\n    }\n  }\n}\n\nfunction getNearestSuspenseBoundaryToCapture(returnFiber: Fiber) {\n  let node = returnFiber;\n  const hasInvisibleParentBoundary = hasSuspenseContext(\n    suspenseStackCursor.current,\n    (InvisibleParentSuspenseContext: SuspenseContext),\n  );\n  do {\n    if (\n      node.tag === SuspenseComponent &&\n      shouldCaptureSuspense(node, hasInvisibleParentBoundary)\n    ) {\n      return node;\n    }\n    // This boundary already captured during this render. Continue to the next\n    // boundary.\n    node = node.return;\n  } while (node !== null);\n  return null;\n}\n\nfunction markSuspenseBoundaryShouldCapture(\n  suspenseBoundary: Fiber,\n  returnFiber: Fiber,\n  sourceFiber: Fiber,\n  root: FiberRoot,\n  rootRenderLanes: Lanes,\n): Fiber | null {\n  // This marks a Suspense boundary so that when we're unwinding the stack,\n  // it captures the suspended \"exception\" and does a second (fallback) pass.\n  if ((suspenseBoundary.mode & ConcurrentMode) === NoMode) {\n    // Legacy Mode Suspense\n    //\n    // If the boundary is in legacy mode, we should *not*\n    // suspend the commit. Pretend as if the suspended component rendered\n    // null and keep rendering. When the Suspense boundary completes,\n    // we'll do a second pass to render the fallback.\n    if (suspenseBoundary === returnFiber) {\n      // Special case where we suspended while reconciling the children of\n      // a Suspense boundary's inner Offscreen wrapper fiber. This happens\n      // when a React.lazy component is a direct child of a\n      // Suspense boundary.\n      //\n      // Suspense boundaries are implemented as multiple fibers, but they\n      // are a single conceptual unit. The legacy mode behavior where we\n      // pretend the suspended fiber committed as `null` won't work,\n      // because in this case the \"suspended\" fiber is the inner\n      // Offscreen wrapper.\n      //\n      // Because the contents of the boundary haven't started rendering\n      // yet (i.e. nothing in the tree has partially rendered) we can\n      // switch to the regular, concurrent mode behavior: mark the\n      // boundary with ShouldCapture and enter the unwind phase.\n      suspenseBoundary.flags |= ShouldCapture;\n    } else {\n      suspenseBoundary.flags |= DidCapture;\n      sourceFiber.flags |= ForceUpdateForLegacySuspense;\n\n      // We're going to commit this fiber even though it didn't complete.\n      // But we shouldn't call any lifecycle methods or callbacks. Remove\n      // all lifecycle effect tags.\n      sourceFiber.flags &= ~(LifecycleEffectMask | Incomplete);\n\n      if (supportsPersistence && enablePersistentOffscreenHostContainer) {\n        // Another legacy Suspense quirk. In persistent mode, if this is the\n        // initial mount, override the props of the host container to hide\n        // its contents.\n        const currentSuspenseBoundary = suspenseBoundary.alternate;\n        if (currentSuspenseBoundary === null) {\n          const offscreenFiber: Fiber = (suspenseBoundary.child: any);\n          const offscreenContainer = offscreenFiber.child;\n          if (offscreenContainer !== null) {\n            const children = offscreenContainer.memoizedProps.children;\n            const containerProps = getOffscreenContainerProps(\n              'hidden',\n              children,\n            );\n            offscreenContainer.pendingProps = containerProps;\n            offscreenContainer.memoizedProps = containerProps;\n          }\n        }\n      }\n\n      if (sourceFiber.tag === ClassComponent) {\n        const currentSourceFiber = sourceFiber.alternate;\n        if (currentSourceFiber === null) {\n          // This is a new mount. Change the tag so it's not mistaken for a\n          // completed class component. For example, we should not call\n          // componentWillUnmount if it is deleted.\n          sourceFiber.tag = IncompleteClassComponent;\n        } else {\n          // When we try rendering again, we should not reuse the current fiber,\n          // since it's known to be in an inconsistent state. Use a force update to\n          // prevent a bail out.\n          const update = createUpdate(NoTimestamp, SyncLane);\n          update.tag = ForceUpdate;\n          enqueueUpdate(sourceFiber, update, SyncLane);\n        }\n      }\n\n      // The source fiber did not complete. Mark it with Sync priority to\n      // indicate that it still has pending work.\n      sourceFiber.lanes = mergeLanes(sourceFiber.lanes, SyncLane);\n    }\n    return suspenseBoundary;\n  }\n  // Confirmed that the boundary is in a concurrent mode tree. Continue\n  // with the normal suspend path.\n  //\n  // After this we'll use a set of heuristics to determine whether this\n  // render pass will run to completion or restart or \"suspend\" the commit.\n  // The actual logic for this is spread out in different places.\n  //\n  // This first principle is that if we're going to suspend when we complete\n  // a root, then we should also restart if we get an update or ping that\n  // might unsuspend it, and vice versa. The only reason to suspend is\n  // because you think you might want to restart before committing. However,\n  // it doesn't make sense to restart only while in the period we're suspended.\n  //\n  // Restarting too aggressively is also not good because it starves out any\n  // intermediate loading state. So we use heuristics to determine when.\n\n  // Suspense Heuristics\n  //\n  // If nothing threw a Promise or all the same fallbacks are already showing,\n  // then don't suspend/restart.\n  //\n  // If this is an initial render of a new tree of Suspense boundaries and\n  // those trigger a fallback, then don't suspend/restart. We want to ensure\n  // that we can show the initial loading state as quickly as possible.\n  //\n  // If we hit a \"Delayed\" case, such as when we'd switch from content back into\n  // a fallback, then we should always suspend/restart. Transitions apply\n  // to this case. If none is defined, JND is used instead.\n  //\n  // If we're already showing a fallback and it gets \"retried\", allowing us to show\n  // another level, but there's still an inner boundary that would show a fallback,\n  // then we suspend/restart for 500ms since the last time we showed a fallback\n  // anywhere in the tree. This effectively throttles progressive loading into a\n  // consistent train of commits. This also gives us an opportunity to restart to\n  // get to the completed state slightly earlier.\n  //\n  // If there's ambiguity due to batching it's resolved in preference of:\n  // 1) \"delayed\", 2) \"initial render\", 3) \"retry\".\n  //\n  // We want to ensure that a \"busy\" state doesn't get force committed. We want to\n  // ensure that new initial loading states can commit as soon as possible.\n  suspenseBoundary.flags |= ShouldCapture;\n  // TODO: I think we can remove this, since we now use `DidCapture` in\n  // the begin phase to prevent an early bailout.\n  suspenseBoundary.lanes = rootRenderLanes;\n  return suspenseBoundary;\n}\n\nfunction throwException(\n  root: FiberRoot,\n  returnFiber: Fiber,\n  sourceFiber: Fiber,\n  value: mixed,\n  rootRenderLanes: Lanes,\n) {\n  // The source fiber did not complete.\n  sourceFiber.flags |= Incomplete;\n\n  if (enableUpdaterTracking) {\n    if (isDevToolsPresent) {\n      // If we have pending work still, restore the original updaters\n      restorePendingUpdaters(root, rootRenderLanes);\n    }\n  }\n\n  if (\n    value !== null &&\n    typeof value === 'object' &&\n    typeof value.then === 'function'\n  ) {\n    // This is a wakeable. The component suspended.\n    const wakeable: Wakeable = (value: any);\n    resetSuspendedComponent(sourceFiber, rootRenderLanes);\n\n    if (__DEV__) {\n      if (enableDebugTracing) {\n        if (sourceFiber.mode & DebugTracingMode) {\n          const name = getComponentNameFromFiber(sourceFiber) || 'Unknown';\n          logComponentSuspended(name, wakeable);\n        }\n      }\n    }\n\n    // Schedule the nearest Suspense to re-render the timed out view.\n    const suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber);\n    if (suspenseBoundary !== null) {\n      suspenseBoundary.flags &= ~ForceClientRender;\n      markSuspenseBoundaryShouldCapture(\n        suspenseBoundary,\n        returnFiber,\n        sourceFiber,\n        root,\n        rootRenderLanes,\n      );\n      attachWakeableListeners(\n        suspenseBoundary,\n        root,\n        wakeable,\n        rootRenderLanes,\n      );\n      return;\n    } else {\n      // No boundary was found. Fallthrough to error mode.\n      // TODO: We should never call getComponentNameFromFiber in production.\n      // Log a warning or something to prevent us from accidentally bundling it.\n      value = new Error(\n        (getComponentNameFromFiber(sourceFiber) || 'A React component') +\n          ' suspended while rendering, but no fallback UI was specified.\\n' +\n          '\\n' +\n          'Add a <Suspense fallback=...> component higher in the tree to ' +\n          'provide a loading indicator or placeholder to display.',\n      );\n    }\n  } else {\n    // This is a regular error, not a Suspense wakeable.\n    if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {\n      const suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber);\n      // If the error was thrown during hydration, we may be able to recover by\n      // discarding the dehydrated content and switching to a client render.\n      // Instead of surfacing the error, find the nearest Suspense boundary\n      // and render it again without hydration.\n      if (suspenseBoundary !== null) {\n        if ((suspenseBoundary.flags & ShouldCapture) === NoFlags) {\n          // Set a flag to indicate that we should try rendering the normal\n          // children again, not the fallback.\n          suspenseBoundary.flags |= ForceClientRender;\n        }\n        markSuspenseBoundaryShouldCapture(\n          suspenseBoundary,\n          returnFiber,\n          sourceFiber,\n          root,\n          rootRenderLanes,\n        );\n        return;\n      }\n    } else {\n      // Otherwise, fall through to the error path.\n    }\n  }\n\n  // We didn't find a boundary that could handle this type of exception. Start\n  // over and traverse parent path again, this time treating the exception\n  // as an error.\n  renderDidError();\n\n  value = createCapturedValue(value, sourceFiber);\n  let workInProgress = returnFiber;\n  do {\n    switch (workInProgress.tag) {\n      case HostRoot: {\n        const errorInfo = value;\n        workInProgress.flags |= ShouldCapture;\n        const lane = pickArbitraryLane(rootRenderLanes);\n        workInProgress.lanes = mergeLanes(workInProgress.lanes, lane);\n        const update = createRootErrorUpdate(workInProgress, errorInfo, lane);\n        enqueueCapturedUpdate(workInProgress, update);\n        return;\n      }\n      case ClassComponent:\n        // Capture and retry\n        const errorInfo = value;\n        const ctor = workInProgress.type;\n        const instance = workInProgress.stateNode;\n        if (\n          (workInProgress.flags & DidCapture) === NoFlags &&\n          (typeof ctor.getDerivedStateFromError === 'function' ||\n            (instance !== null &&\n              typeof instance.componentDidCatch === 'function' &&\n              !isAlreadyFailedLegacyErrorBoundary(instance)))\n        ) {\n          workInProgress.flags |= ShouldCapture;\n          const lane = pickArbitraryLane(rootRenderLanes);\n          workInProgress.lanes = mergeLanes(workInProgress.lanes, lane);\n          // Schedule the error boundary to re-render using updated state\n          const update = createClassErrorUpdate(\n            workInProgress,\n            errorInfo,\n            lane,\n          );\n          enqueueCapturedUpdate(workInProgress, update);\n          return;\n        }\n        break;\n      default:\n        break;\n    }\n    workInProgress = workInProgress.return;\n  } while (workInProgress !== null);\n}\n\nexport {throwException, createRootErrorUpdate, createClassErrorUpdate};\n"]},"metadata":{},"sourceType":"module"}