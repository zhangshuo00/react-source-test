{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { isFiberMounted } from './ReactFiberTreeReflection';\nimport { disableLegacyContext } from 'shared/ReactFeatureFlags';\nimport { ClassComponent, HostRoot } from './ReactWorkTags';\nimport getComponentNameFromFiber from 'react-reconciler/src/getComponentNameFromFiber';\nimport checkPropTypes from 'shared/checkPropTypes';\nimport { createCursor, push, pop } from './ReactFiberStack.old';\nlet warnedAboutMissingGetChildContext;\n\nif (__DEV__) {\n  warnedAboutMissingGetChildContext = {};\n}\n\nexport const emptyContextObject = {};\n\nif (__DEV__) {\n  Object.freeze(emptyContextObject);\n} // A cursor to the current merged context object on the stack.\n\n\nconst contextStackCursor = createCursor(emptyContextObject); // A cursor to a boolean indicating whether the context has changed.\n\nconst didPerformWorkStackCursor = createCursor(false); // Keep track of the previous context object that was on the stack.\n// We use this to get access to the parent context after we have already\n// pushed the next context provider, and now need to merge their contexts.\n\nlet previousContext = emptyContextObject;\n\nfunction getUnmaskedContext(workInProgress, Component, didPushOwnContextIfProvider) {\n  if (disableLegacyContext) {\n    return emptyContextObject;\n  } else {\n    if (didPushOwnContextIfProvider && isContextProvider(Component)) {\n      // If the fiber is a context provider itself, when we read its context\n      // we may have already pushed its own child context on the stack. A context\n      // provider should not \"see\" its own child context. Therefore we read the\n      // previous (parent) context instead for a context provider.\n      return previousContext;\n    }\n\n    return contextStackCursor.current;\n  }\n}\n\nfunction cacheContext(workInProgress, unmaskedContext, maskedContext) {\n  if (disableLegacyContext) {\n    return;\n  } else {\n    const instance = workInProgress.stateNode;\n    instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;\n    instance.__reactInternalMemoizedMaskedChildContext = maskedContext;\n  }\n}\n\nfunction getMaskedContext(workInProgress, unmaskedContext) {\n  if (disableLegacyContext) {\n    return emptyContextObject;\n  } else {\n    const type = workInProgress.type;\n    const contextTypes = type.contextTypes;\n\n    if (!contextTypes) {\n      return emptyContextObject;\n    } // Avoid recreating masked context unless unmasked context has changed.\n    // Failing to do this will result in unnecessary calls to componentWillReceiveProps.\n    // This may trigger infinite loops if componentWillReceiveProps calls setState.\n\n\n    const instance = workInProgress.stateNode;\n\n    if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {\n      return instance.__reactInternalMemoizedMaskedChildContext;\n    }\n\n    const context = {};\n\n    for (const key in contextTypes) {\n      context[key] = unmaskedContext[key];\n    }\n\n    if (__DEV__) {\n      const name = getComponentNameFromFiber(workInProgress) || 'Unknown';\n      checkPropTypes(contextTypes, context, 'context', name);\n    } // Cache unmasked context so we can avoid recreating masked context unless necessary.\n    // Context is created before the class component is instantiated so check for instance.\n\n\n    if (instance) {\n      cacheContext(workInProgress, unmaskedContext, context);\n    }\n\n    return context;\n  }\n}\n\nfunction hasContextChanged() {\n  if (disableLegacyContext) {\n    return false;\n  } else {\n    return didPerformWorkStackCursor.current;\n  }\n}\n\nfunction isContextProvider(type) {\n  if (disableLegacyContext) {\n    return false;\n  } else {\n    const childContextTypes = type.childContextTypes;\n    return childContextTypes !== null && childContextTypes !== undefined;\n  }\n}\n\nfunction popContext(fiber) {\n  if (disableLegacyContext) {\n    return;\n  } else {\n    pop(didPerformWorkStackCursor, fiber);\n    pop(contextStackCursor, fiber);\n  }\n}\n\nfunction popTopLevelContextObject(fiber) {\n  if (disableLegacyContext) {\n    return;\n  } else {\n    pop(didPerformWorkStackCursor, fiber);\n    pop(contextStackCursor, fiber);\n  }\n}\n\nfunction pushTopLevelContextObject(fiber, context, didChange) {\n  if (disableLegacyContext) {\n    return;\n  } else {\n    if (contextStackCursor.current !== emptyContextObject) {\n      throw new Error('Unexpected context found on stack. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n    }\n\n    push(contextStackCursor, context, fiber);\n    push(didPerformWorkStackCursor, didChange, fiber);\n  }\n}\n\nfunction processChildContext(fiber, type, parentContext) {\n  if (disableLegacyContext) {\n    return parentContext;\n  } else {\n    const instance = fiber.stateNode;\n    const childContextTypes = type.childContextTypes; // TODO (bvaughn) Replace this behavior with an invariant() in the future.\n    // It has only been added in Fiber to match the (unintentional) behavior in Stack.\n\n    if (typeof instance.getChildContext !== 'function') {\n      if (__DEV__) {\n        const componentName = getComponentNameFromFiber(fiber) || 'Unknown';\n\n        if (!warnedAboutMissingGetChildContext[componentName]) {\n          warnedAboutMissingGetChildContext[componentName] = true;\n          console.error('%s.childContextTypes is specified but there is no getChildContext() method ' + 'on the instance. You can either define getChildContext() on %s or remove ' + 'childContextTypes from it.', componentName, componentName);\n        }\n      }\n\n      return parentContext;\n    }\n\n    const childContext = instance.getChildContext();\n\n    for (const contextKey in childContext) {\n      if (!(contextKey in childContextTypes)) {\n        throw new Error(`${getComponentNameFromFiber(fiber) || 'Unknown'}.getChildContext(): key \"${contextKey}\" is not defined in childContextTypes.`);\n      }\n    }\n\n    if (__DEV__) {\n      const name = getComponentNameFromFiber(fiber) || 'Unknown';\n      checkPropTypes(childContextTypes, childContext, 'child context', name);\n    }\n\n    return { ...parentContext,\n      ...childContext\n    };\n  }\n}\n\nfunction pushContextProvider(workInProgress) {\n  if (disableLegacyContext) {\n    return false;\n  } else {\n    const instance = workInProgress.stateNode; // We push the context as early as possible to ensure stack integrity.\n    // If the instance does not exist yet, we will push null at first,\n    // and replace it on the stack later when invalidating the context.\n\n    const memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyContextObject; // Remember the parent context so we can merge with it later.\n    // Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.\n\n    previousContext = contextStackCursor.current;\n    push(contextStackCursor, memoizedMergedChildContext, workInProgress);\n    push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress);\n    return true;\n  }\n}\n\nfunction invalidateContextProvider(workInProgress, type, didChange) {\n  if (disableLegacyContext) {\n    return;\n  } else {\n    const instance = workInProgress.stateNode;\n\n    if (!instance) {\n      throw new Error('Expected to have an instance by this point. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n    }\n\n    if (didChange) {\n      // Merge parent and own context.\n      // Skip this if we're not updating due to sCU.\n      // This avoids unnecessarily recomputing memoized values.\n      const mergedContext = processChildContext(workInProgress, type, previousContext);\n      instance.__reactInternalMemoizedMergedChildContext = mergedContext; // Replace the old (or empty) context with the new one.\n      // It is important to unwind the context in the reverse order.\n\n      pop(didPerformWorkStackCursor, workInProgress);\n      pop(contextStackCursor, workInProgress); // Now push the new context and mark that it has changed.\n\n      push(contextStackCursor, mergedContext, workInProgress);\n      push(didPerformWorkStackCursor, didChange, workInProgress);\n    } else {\n      pop(didPerformWorkStackCursor, workInProgress);\n      push(didPerformWorkStackCursor, didChange, workInProgress);\n    }\n  }\n}\n\nfunction findCurrentUnmaskedContext(fiber) {\n  if (disableLegacyContext) {\n    return emptyContextObject;\n  } else {\n    // Currently this is only used with renderSubtreeIntoContainer; not sure if it\n    // makes sense elsewhere\n    if (!isFiberMounted(fiber) || fiber.tag !== ClassComponent) {\n      throw new Error('Expected subtree parent to be a mounted class component. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n    }\n\n    let node = fiber;\n\n    do {\n      switch (node.tag) {\n        case HostRoot:\n          return node.stateNode.context;\n\n        case ClassComponent:\n          {\n            const Component = node.type;\n\n            if (isContextProvider(Component)) {\n              return node.stateNode.__reactInternalMemoizedMergedChildContext;\n            }\n\n            break;\n          }\n      }\n\n      node = node.return;\n    } while (node !== null);\n\n    throw new Error('Found unexpected detached subtree parent. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n  }\n}\n\nexport { getUnmaskedContext, cacheContext, getMaskedContext, hasContextChanged, popContext, popTopLevelContextObject, pushTopLevelContextObject, processChildContext, isContextProvider, pushContextProvider, invalidateContextProvider, findCurrentUnmaskedContext };","map":{"version":3,"sources":["/Users/zhangshuo/git/my-app/src/react/packages/react-reconciler/src/ReactFiberContext.old.js"],"names":["isFiberMounted","disableLegacyContext","ClassComponent","HostRoot","getComponentNameFromFiber","checkPropTypes","createCursor","push","pop","warnedAboutMissingGetChildContext","__DEV__","emptyContextObject","Object","freeze","contextStackCursor","didPerformWorkStackCursor","previousContext","getUnmaskedContext","workInProgress","Component","didPushOwnContextIfProvider","isContextProvider","current","cacheContext","unmaskedContext","maskedContext","instance","stateNode","__reactInternalMemoizedUnmaskedChildContext","__reactInternalMemoizedMaskedChildContext","getMaskedContext","type","contextTypes","context","key","name","hasContextChanged","childContextTypes","undefined","popContext","fiber","popTopLevelContextObject","pushTopLevelContextObject","didChange","Error","processChildContext","parentContext","getChildContext","componentName","console","error","childContext","contextKey","pushContextProvider","memoizedMergedChildContext","__reactInternalMemoizedMergedChildContext","invalidateContextProvider","mergedContext","findCurrentUnmaskedContext","tag","node","return"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Fiber} from './ReactInternalTypes';\nimport type {StackCursor} from './ReactFiberStack.old';\n\nimport {isFiberMounted} from './ReactFiberTreeReflection';\nimport {disableLegacyContext} from 'shared/ReactFeatureFlags';\nimport {ClassComponent, HostRoot} from './ReactWorkTags';\nimport getComponentNameFromFiber from 'react-reconciler/src/getComponentNameFromFiber';\nimport checkPropTypes from 'shared/checkPropTypes';\n\nimport {createCursor, push, pop} from './ReactFiberStack.old';\n\nlet warnedAboutMissingGetChildContext;\n\nif (__DEV__) {\n  warnedAboutMissingGetChildContext = {};\n}\n\nexport const emptyContextObject = {};\nif (__DEV__) {\n  Object.freeze(emptyContextObject);\n}\n\n// A cursor to the current merged context object on the stack.\nconst contextStackCursor: StackCursor<Object> = createCursor(\n  emptyContextObject,\n);\n// A cursor to a boolean indicating whether the context has changed.\nconst didPerformWorkStackCursor: StackCursor<boolean> = createCursor(false);\n// Keep track of the previous context object that was on the stack.\n// We use this to get access to the parent context after we have already\n// pushed the next context provider, and now need to merge their contexts.\nlet previousContext: Object = emptyContextObject;\n\nfunction getUnmaskedContext(\n  workInProgress: Fiber,\n  Component: Function,\n  didPushOwnContextIfProvider: boolean,\n): Object {\n  if (disableLegacyContext) {\n    return emptyContextObject;\n  } else {\n    if (didPushOwnContextIfProvider && isContextProvider(Component)) {\n      // If the fiber is a context provider itself, when we read its context\n      // we may have already pushed its own child context on the stack. A context\n      // provider should not \"see\" its own child context. Therefore we read the\n      // previous (parent) context instead for a context provider.\n      return previousContext;\n    }\n    return contextStackCursor.current;\n  }\n}\n\nfunction cacheContext(\n  workInProgress: Fiber,\n  unmaskedContext: Object,\n  maskedContext: Object,\n): void {\n  if (disableLegacyContext) {\n    return;\n  } else {\n    const instance = workInProgress.stateNode;\n    instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;\n    instance.__reactInternalMemoizedMaskedChildContext = maskedContext;\n  }\n}\n\nfunction getMaskedContext(\n  workInProgress: Fiber,\n  unmaskedContext: Object,\n): Object {\n  if (disableLegacyContext) {\n    return emptyContextObject;\n  } else {\n    const type = workInProgress.type;\n    const contextTypes = type.contextTypes;\n    if (!contextTypes) {\n      return emptyContextObject;\n    }\n\n    // Avoid recreating masked context unless unmasked context has changed.\n    // Failing to do this will result in unnecessary calls to componentWillReceiveProps.\n    // This may trigger infinite loops if componentWillReceiveProps calls setState.\n    const instance = workInProgress.stateNode;\n    if (\n      instance &&\n      instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext\n    ) {\n      return instance.__reactInternalMemoizedMaskedChildContext;\n    }\n\n    const context = {};\n    for (const key in contextTypes) {\n      context[key] = unmaskedContext[key];\n    }\n\n    if (__DEV__) {\n      const name = getComponentNameFromFiber(workInProgress) || 'Unknown';\n      checkPropTypes(contextTypes, context, 'context', name);\n    }\n\n    // Cache unmasked context so we can avoid recreating masked context unless necessary.\n    // Context is created before the class component is instantiated so check for instance.\n    if (instance) {\n      cacheContext(workInProgress, unmaskedContext, context);\n    }\n\n    return context;\n  }\n}\n\nfunction hasContextChanged(): boolean {\n  if (disableLegacyContext) {\n    return false;\n  } else {\n    return didPerformWorkStackCursor.current;\n  }\n}\n\nfunction isContextProvider(type: Function): boolean {\n  if (disableLegacyContext) {\n    return false;\n  } else {\n    const childContextTypes = type.childContextTypes;\n    return childContextTypes !== null && childContextTypes !== undefined;\n  }\n}\n\nfunction popContext(fiber: Fiber): void {\n  if (disableLegacyContext) {\n    return;\n  } else {\n    pop(didPerformWorkStackCursor, fiber);\n    pop(contextStackCursor, fiber);\n  }\n}\n\nfunction popTopLevelContextObject(fiber: Fiber): void {\n  if (disableLegacyContext) {\n    return;\n  } else {\n    pop(didPerformWorkStackCursor, fiber);\n    pop(contextStackCursor, fiber);\n  }\n}\n\nfunction pushTopLevelContextObject(\n  fiber: Fiber,\n  context: Object,\n  didChange: boolean,\n): void {\n  if (disableLegacyContext) {\n    return;\n  } else {\n    if (contextStackCursor.current !== emptyContextObject) {\n      throw new Error(\n        'Unexpected context found on stack. ' +\n          'This error is likely caused by a bug in React. Please file an issue.',\n      );\n    }\n\n    push(contextStackCursor, context, fiber);\n    push(didPerformWorkStackCursor, didChange, fiber);\n  }\n}\n\nfunction processChildContext(\n  fiber: Fiber,\n  type: any,\n  parentContext: Object,\n): Object {\n  if (disableLegacyContext) {\n    return parentContext;\n  } else {\n    const instance = fiber.stateNode;\n    const childContextTypes = type.childContextTypes;\n\n    // TODO (bvaughn) Replace this behavior with an invariant() in the future.\n    // It has only been added in Fiber to match the (unintentional) behavior in Stack.\n    if (typeof instance.getChildContext !== 'function') {\n      if (__DEV__) {\n        const componentName = getComponentNameFromFiber(fiber) || 'Unknown';\n\n        if (!warnedAboutMissingGetChildContext[componentName]) {\n          warnedAboutMissingGetChildContext[componentName] = true;\n          console.error(\n            '%s.childContextTypes is specified but there is no getChildContext() method ' +\n              'on the instance. You can either define getChildContext() on %s or remove ' +\n              'childContextTypes from it.',\n            componentName,\n            componentName,\n          );\n        }\n      }\n      return parentContext;\n    }\n\n    const childContext = instance.getChildContext();\n    for (const contextKey in childContext) {\n      if (!(contextKey in childContextTypes)) {\n        throw new Error(\n          `${getComponentNameFromFiber(fiber) ||\n            'Unknown'}.getChildContext(): key \"${contextKey}\" is not defined in childContextTypes.`,\n        );\n      }\n    }\n    if (__DEV__) {\n      const name = getComponentNameFromFiber(fiber) || 'Unknown';\n      checkPropTypes(childContextTypes, childContext, 'child context', name);\n    }\n\n    return {...parentContext, ...childContext};\n  }\n}\n\nfunction pushContextProvider(workInProgress: Fiber): boolean {\n  if (disableLegacyContext) {\n    return false;\n  } else {\n    const instance = workInProgress.stateNode;\n    // We push the context as early as possible to ensure stack integrity.\n    // If the instance does not exist yet, we will push null at first,\n    // and replace it on the stack later when invalidating the context.\n    const memoizedMergedChildContext =\n      (instance && instance.__reactInternalMemoizedMergedChildContext) ||\n      emptyContextObject;\n\n    // Remember the parent context so we can merge with it later.\n    // Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.\n    previousContext = contextStackCursor.current;\n    push(contextStackCursor, memoizedMergedChildContext, workInProgress);\n    push(\n      didPerformWorkStackCursor,\n      didPerformWorkStackCursor.current,\n      workInProgress,\n    );\n\n    return true;\n  }\n}\n\nfunction invalidateContextProvider(\n  workInProgress: Fiber,\n  type: any,\n  didChange: boolean,\n): void {\n  if (disableLegacyContext) {\n    return;\n  } else {\n    const instance = workInProgress.stateNode;\n\n    if (!instance) {\n      throw new Error(\n        'Expected to have an instance by this point. ' +\n          'This error is likely caused by a bug in React. Please file an issue.',\n      );\n    }\n\n    if (didChange) {\n      // Merge parent and own context.\n      // Skip this if we're not updating due to sCU.\n      // This avoids unnecessarily recomputing memoized values.\n      const mergedContext = processChildContext(\n        workInProgress,\n        type,\n        previousContext,\n      );\n      instance.__reactInternalMemoizedMergedChildContext = mergedContext;\n\n      // Replace the old (or empty) context with the new one.\n      // It is important to unwind the context in the reverse order.\n      pop(didPerformWorkStackCursor, workInProgress);\n      pop(contextStackCursor, workInProgress);\n      // Now push the new context and mark that it has changed.\n      push(contextStackCursor, mergedContext, workInProgress);\n      push(didPerformWorkStackCursor, didChange, workInProgress);\n    } else {\n      pop(didPerformWorkStackCursor, workInProgress);\n      push(didPerformWorkStackCursor, didChange, workInProgress);\n    }\n  }\n}\n\nfunction findCurrentUnmaskedContext(fiber: Fiber): Object {\n  if (disableLegacyContext) {\n    return emptyContextObject;\n  } else {\n    // Currently this is only used with renderSubtreeIntoContainer; not sure if it\n    // makes sense elsewhere\n    if (!isFiberMounted(fiber) || fiber.tag !== ClassComponent) {\n      throw new Error(\n        'Expected subtree parent to be a mounted class component. ' +\n          'This error is likely caused by a bug in React. Please file an issue.',\n      );\n    }\n\n    let node = fiber;\n    do {\n      switch (node.tag) {\n        case HostRoot:\n          return node.stateNode.context;\n        case ClassComponent: {\n          const Component = node.type;\n          if (isContextProvider(Component)) {\n            return node.stateNode.__reactInternalMemoizedMergedChildContext;\n          }\n          break;\n        }\n      }\n      node = node.return;\n    } while (node !== null);\n\n    throw new Error(\n      'Found unexpected detached subtree parent. ' +\n        'This error is likely caused by a bug in React. Please file an issue.',\n    );\n  }\n}\n\nexport {\n  getUnmaskedContext,\n  cacheContext,\n  getMaskedContext,\n  hasContextChanged,\n  popContext,\n  popTopLevelContextObject,\n  pushTopLevelContextObject,\n  processChildContext,\n  isContextProvider,\n  pushContextProvider,\n  invalidateContextProvider,\n  findCurrentUnmaskedContext,\n};\n"]},"metadata":{},"sourceType":"module"}