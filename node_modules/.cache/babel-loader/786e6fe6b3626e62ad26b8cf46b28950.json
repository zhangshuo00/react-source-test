{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n// UpdateQueue is a linked list of prioritized updates.\n//\n// Like fibers, update queues come in pairs: a current queue, which represents\n// the visible state of the screen, and a work-in-progress queue, which can be\n// mutated and processed asynchronously before it is committed — a form of\n// double buffering. If a work-in-progress render is discarded before finishing,\n// we create a new work-in-progress by cloning the current queue.\n//\n// Both queues share a persistent, singly-linked list structure. To schedule an\n// update, we append it to the end of both queues. Each queue maintains a\n// pointer to first update in the persistent list that hasn't been processed.\n// The work-in-progress pointer always has a position equal to or greater than\n// the current queue, since we always work on that one. The current queue's\n// pointer is only updated during the commit phase, when we swap in the\n// work-in-progress.\n//\n// For example:\n//\n//   Current pointer:           A - B - C - D - E - F\n//   Work-in-progress pointer:              D - E - F\n//                                          ^\n//                                          The work-in-progress queue has\n//                                          processed more updates than current.\n//\n// The reason we append to both queues is because otherwise we might drop\n// updates without ever processing them. For example, if we only add updates to\n// the work-in-progress queue, some updates could be lost whenever a work-in\n// -progress render restarts by cloning from current. Similarly, if we only add\n// updates to the current queue, the updates will be lost whenever an already\n// in-progress queue commits and swaps with the current queue. However, by\n// adding to both queues, we guarantee that the update will be part of the next\n// work-in-progress. (And because the work-in-progress queue becomes the\n// current queue once it commits, there's no danger of applying the same\n// update twice.)\n//\n// Prioritization\n// --------------\n//\n// Updates are not sorted by priority, but by insertion; new updates are always\n// appended to the end of the list.\n//\n// The priority is still important, though. When processing the update queue\n// during the render phase, only the updates with sufficient priority are\n// included in the result. If we skip an update because it has insufficient\n// priority, it remains in the queue to be processed later, during a lower\n// priority render. Crucially, all updates subsequent to a skipped update also\n// remain in the queue *regardless of their priority*. That means high priority\n// updates are sometimes processed twice, at two separate priorities. We also\n// keep track of a base state, that represents the state before the first\n// update in the queue is applied.\n//\n// For example:\n//\n//   Given a base state of '', and the following queue of updates\n//\n//     A1 - B2 - C1 - D2\n//\n//   where the number indicates the priority, and the update is applied to the\n//   previous state by appending a letter, React will process these updates as\n//   two separate renders, one per distinct priority level:\n//\n//   First render, at priority 1:\n//     Base state: ''\n//     Updates: [A1, C1]\n//     Result state: 'AC'\n//\n//   Second render, at priority 2:\n//     Base state: 'A'            <-  The base state does not include C1,\n//                                    because B2 was skipped.\n//     Updates: [B2, C1, D2]      <-  C1 was rebased on top of B2\n//     Result state: 'ABCD'\n//\n// Because we process updates in insertion order, and rebase high priority\n// updates when preceding updates are skipped, the final result is deterministic\n// regardless of priority. Intermediate state may vary according to system\n// resources, but the final state is always the same.\nimport { NoLane, NoLanes, isSubsetOfLanes, mergeLanes, isTransitionLane, intersectLanes, markRootEntangled } from './ReactFiberLane.new';\nimport { enterDisallowedContextReadInDEV, exitDisallowedContextReadInDEV } from './ReactFiberNewContext.new';\nimport { Callback, ShouldCapture, DidCapture } from './ReactFiberFlags';\nimport { debugRenderPhaseSideEffectsForStrictMode } from 'shared/ReactFeatureFlags';\nimport { StrictLegacyMode } from './ReactTypeOfMode';\nimport { markSkippedUpdateLanes, isInterleavedUpdate } from './ReactFiberWorkLoop.new';\nimport { pushInterleavedQueue } from './ReactFiberInterleavedUpdates.new';\nimport { setIsStrictModeForDevtools } from './ReactFiberDevToolsHook.new';\nexport const UpdateState = 0;\nexport const ReplaceState = 1;\nexport const ForceUpdate = 2;\nexport const CaptureUpdate = 3; // Global state that is reset at the beginning of calling `processUpdateQueue`.\n// It should only be read right after calling `processUpdateQueue`, via\n// `checkHasForceUpdateAfterProcessing`.\n\nlet hasForceUpdate = false;\nlet didWarnUpdateInsideUpdate;\nlet currentlyProcessingQueue;\nexport let resetCurrentlyProcessingQueue;\n\nif (__DEV__) {\n  didWarnUpdateInsideUpdate = false;\n  currentlyProcessingQueue = null;\n\n  resetCurrentlyProcessingQueue = () => {\n    currentlyProcessingQueue = null;\n  };\n}\n\nexport function initializeUpdateQueue(fiber) {\n  const queue = {\n    baseState: fiber.memoizedState,\n    firstBaseUpdate: null,\n    lastBaseUpdate: null,\n    shared: {\n      pending: null,\n      interleaved: null,\n      lanes: NoLanes\n    },\n    effects: null\n  };\n  fiber.updateQueue = queue;\n}\nexport function cloneUpdateQueue(current, workInProgress) {\n  // Clone the update queue from current. Unless it's already a clone.\n  const queue = workInProgress.updateQueue;\n  const currentQueue = current.updateQueue;\n\n  if (queue === currentQueue) {\n    const clone = {\n      baseState: currentQueue.baseState,\n      firstBaseUpdate: currentQueue.firstBaseUpdate,\n      lastBaseUpdate: currentQueue.lastBaseUpdate,\n      shared: currentQueue.shared,\n      effects: currentQueue.effects\n    };\n    workInProgress.updateQueue = clone;\n  }\n}\nexport function createUpdate(eventTime, lane) {\n  const update = {\n    eventTime,\n    lane,\n    tag: UpdateState,\n    payload: null,\n    callback: null,\n    next: null\n  };\n  return update;\n}\nexport function enqueueUpdate(fiber, update, lane) {\n  const updateQueue = fiber.updateQueue;\n\n  if (updateQueue === null) {\n    // Only occurs if the fiber has been unmounted.\n    return;\n  }\n\n  const sharedQueue = updateQueue.shared;\n\n  if (isInterleavedUpdate(fiber, lane)) {\n    const interleaved = sharedQueue.interleaved;\n\n    if (interleaved === null) {\n      // This is the first update. Create a circular list.\n      update.next = update; // At the end of the current render, this queue's interleaved updates will\n      // be transferred to the pending queue.\n\n      pushInterleavedQueue(sharedQueue);\n    } else {\n      update.next = interleaved.next;\n      interleaved.next = update;\n    }\n\n    sharedQueue.interleaved = update;\n  } else {\n    const pending = sharedQueue.pending;\n\n    if (pending === null) {\n      // This is the first update. Create a circular list.\n      update.next = update;\n    } else {\n      update.next = pending.next;\n      pending.next = update;\n    }\n\n    sharedQueue.pending = update;\n  }\n\n  if (__DEV__) {\n    if (currentlyProcessingQueue === sharedQueue && !didWarnUpdateInsideUpdate) {\n      console.error('An update (setState, replaceState, or forceUpdate) was scheduled ' + 'from inside an update function. Update functions should be pure, ' + 'with zero side-effects. Consider using componentDidUpdate or a ' + 'callback.');\n      didWarnUpdateInsideUpdate = true;\n    }\n  }\n}\nexport function entangleTransitions(root, fiber, lane) {\n  const updateQueue = fiber.updateQueue;\n\n  if (updateQueue === null) {\n    // Only occurs if the fiber has been unmounted.\n    return;\n  }\n\n  const sharedQueue = updateQueue.shared;\n\n  if (isTransitionLane(lane)) {\n    let queueLanes = sharedQueue.lanes; // If any entangled lanes are no longer pending on the root, then they must\n    // have finished. We can remove them from the shared queue, which represents\n    // a superset of the actually pending lanes. In some cases we may entangle\n    // more than we need to, but that's OK. In fact it's worse if we *don't*\n    // entangle when we should.\n\n    queueLanes = intersectLanes(queueLanes, root.pendingLanes); // Entangle the new transition lane with the other transition lanes.\n\n    const newQueueLanes = mergeLanes(queueLanes, lane);\n    sharedQueue.lanes = newQueueLanes; // Even if queue.lanes already include lane, we don't know for certain if\n    // the lane finished since the last time we entangled it. So we need to\n    // entangle it again, just to be sure.\n\n    markRootEntangled(root, newQueueLanes);\n  }\n}\nexport function enqueueCapturedUpdate(workInProgress, capturedUpdate) {\n  // Captured updates are updates that are thrown by a child during the render\n  // phase. They should be discarded if the render is aborted. Therefore,\n  // we should only put them on the work-in-progress queue, not the current one.\n  let queue = workInProgress.updateQueue; // Check if the work-in-progress queue is a clone.\n\n  const current = workInProgress.alternate;\n\n  if (current !== null) {\n    const currentQueue = current.updateQueue;\n\n    if (queue === currentQueue) {\n      // The work-in-progress queue is the same as current. This happens when\n      // we bail out on a parent fiber that then captures an error thrown by\n      // a child. Since we want to append the update only to the work-in\n      // -progress queue, we need to clone the updates. We usually clone during\n      // processUpdateQueue, but that didn't happen in this case because we\n      // skipped over the parent when we bailed out.\n      let newFirst = null;\n      let newLast = null;\n      const firstBaseUpdate = queue.firstBaseUpdate;\n\n      if (firstBaseUpdate !== null) {\n        // Loop through the updates and clone them.\n        let update = firstBaseUpdate;\n\n        do {\n          const clone = {\n            eventTime: update.eventTime,\n            lane: update.lane,\n            tag: update.tag,\n            payload: update.payload,\n            callback: update.callback,\n            next: null\n          };\n\n          if (newLast === null) {\n            newFirst = newLast = clone;\n          } else {\n            newLast.next = clone;\n            newLast = clone;\n          }\n\n          update = update.next;\n        } while (update !== null); // Append the captured update the end of the cloned list.\n\n\n        if (newLast === null) {\n          newFirst = newLast = capturedUpdate;\n        } else {\n          newLast.next = capturedUpdate;\n          newLast = capturedUpdate;\n        }\n      } else {\n        // There are no base updates.\n        newFirst = newLast = capturedUpdate;\n      }\n\n      queue = {\n        baseState: currentQueue.baseState,\n        firstBaseUpdate: newFirst,\n        lastBaseUpdate: newLast,\n        shared: currentQueue.shared,\n        effects: currentQueue.effects\n      };\n      workInProgress.updateQueue = queue;\n      return;\n    }\n  } // Append the update to the end of the list.\n\n\n  const lastBaseUpdate = queue.lastBaseUpdate;\n\n  if (lastBaseUpdate === null) {\n    queue.firstBaseUpdate = capturedUpdate;\n  } else {\n    lastBaseUpdate.next = capturedUpdate;\n  }\n\n  queue.lastBaseUpdate = capturedUpdate;\n}\n\nfunction getStateFromUpdate(workInProgress, queue, update, prevState, nextProps, instance) {\n  switch (update.tag) {\n    case ReplaceState:\n      {\n        const payload = update.payload;\n\n        if (typeof payload === 'function') {\n          // Updater function\n          if (__DEV__) {\n            enterDisallowedContextReadInDEV();\n          }\n\n          const nextState = payload.call(instance, prevState, nextProps);\n\n          if (__DEV__) {\n            if (debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictLegacyMode) {\n              setIsStrictModeForDevtools(true);\n\n              try {\n                payload.call(instance, prevState, nextProps);\n              } finally {\n                setIsStrictModeForDevtools(false);\n              }\n            }\n\n            exitDisallowedContextReadInDEV();\n          }\n\n          return nextState;\n        } // State object\n\n\n        return payload;\n      }\n\n    case CaptureUpdate:\n      {\n        workInProgress.flags = workInProgress.flags & ~ShouldCapture | DidCapture;\n      }\n    // Intentional fallthrough\n\n    case UpdateState:\n      {\n        const payload = update.payload;\n        let partialState;\n\n        if (typeof payload === 'function') {\n          // Updater function\n          if (__DEV__) {\n            enterDisallowedContextReadInDEV();\n          }\n\n          partialState = payload.call(instance, prevState, nextProps);\n\n          if (__DEV__) {\n            if (debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictLegacyMode) {\n              setIsStrictModeForDevtools(true);\n\n              try {\n                payload.call(instance, prevState, nextProps);\n              } finally {\n                setIsStrictModeForDevtools(false);\n              }\n            }\n\n            exitDisallowedContextReadInDEV();\n          }\n        } else {\n          // Partial state object\n          partialState = payload;\n        }\n\n        if (partialState === null || partialState === undefined) {\n          // Null and undefined are treated as no-ops.\n          return prevState;\n        } // Merge the partial state and the previous state.\n\n\n        return Object.assign({}, prevState, partialState);\n      }\n\n    case ForceUpdate:\n      {\n        hasForceUpdate = true;\n        return prevState;\n      }\n  }\n\n  return prevState;\n}\n\nexport function processUpdateQueue(workInProgress, props, instance, renderLanes) {\n  // This is always non-null on a ClassComponent or HostRoot\n  const queue = workInProgress.updateQueue;\n  hasForceUpdate = false;\n\n  if (__DEV__) {\n    currentlyProcessingQueue = queue.shared;\n  }\n\n  let firstBaseUpdate = queue.firstBaseUpdate;\n  let lastBaseUpdate = queue.lastBaseUpdate; // Check if there are pending updates. If so, transfer them to the base queue.\n\n  let pendingQueue = queue.shared.pending;\n\n  if (pendingQueue !== null) {\n    queue.shared.pending = null; // The pending queue is circular. Disconnect the pointer between first\n    // and last so that it's non-circular.\n\n    const lastPendingUpdate = pendingQueue;\n    const firstPendingUpdate = lastPendingUpdate.next;\n    lastPendingUpdate.next = null; // Append pending updates to base queue\n\n    if (lastBaseUpdate === null) {\n      firstBaseUpdate = firstPendingUpdate;\n    } else {\n      lastBaseUpdate.next = firstPendingUpdate;\n    }\n\n    lastBaseUpdate = lastPendingUpdate; // If there's a current queue, and it's different from the base queue, then\n    // we need to transfer the updates to that queue, too. Because the base\n    // queue is a singly-linked list with no cycles, we can append to both\n    // lists and take advantage of structural sharing.\n    // TODO: Pass `current` as argument\n\n    const current = workInProgress.alternate;\n\n    if (current !== null) {\n      // This is always non-null on a ClassComponent or HostRoot\n      const currentQueue = current.updateQueue;\n      const currentLastBaseUpdate = currentQueue.lastBaseUpdate;\n\n      if (currentLastBaseUpdate !== lastBaseUpdate) {\n        if (currentLastBaseUpdate === null) {\n          currentQueue.firstBaseUpdate = firstPendingUpdate;\n        } else {\n          currentLastBaseUpdate.next = firstPendingUpdate;\n        }\n\n        currentQueue.lastBaseUpdate = lastPendingUpdate;\n      }\n    }\n  } // These values may change as we process the queue.\n\n\n  if (firstBaseUpdate !== null) {\n    // Iterate through the list of updates to compute the result.\n    let newState = queue.baseState; // TODO: Don't need to accumulate this. Instead, we can remove renderLanes\n    // from the original lanes.\n\n    let newLanes = NoLanes;\n    let newBaseState = null;\n    let newFirstBaseUpdate = null;\n    let newLastBaseUpdate = null;\n    let update = firstBaseUpdate;\n\n    do {\n      const updateLane = update.lane;\n      const updateEventTime = update.eventTime;\n\n      if (!isSubsetOfLanes(renderLanes, updateLane)) {\n        // Priority is insufficient. Skip this update. If this is the first\n        // skipped update, the previous update/state is the new base\n        // update/state.\n        const clone = {\n          eventTime: updateEventTime,\n          lane: updateLane,\n          tag: update.tag,\n          payload: update.payload,\n          callback: update.callback,\n          next: null\n        };\n\n        if (newLastBaseUpdate === null) {\n          newFirstBaseUpdate = newLastBaseUpdate = clone;\n          newBaseState = newState;\n        } else {\n          newLastBaseUpdate = newLastBaseUpdate.next = clone;\n        } // Update the remaining priority in the queue.\n\n\n        newLanes = mergeLanes(newLanes, updateLane);\n      } else {\n        // This update does have sufficient priority.\n        if (newLastBaseUpdate !== null) {\n          const clone = {\n            eventTime: updateEventTime,\n            // This update is going to be committed so we never want uncommit\n            // it. Using NoLane works because 0 is a subset of all bitmasks, so\n            // this will never be skipped by the check above.\n            lane: NoLane,\n            tag: update.tag,\n            payload: update.payload,\n            callback: update.callback,\n            next: null\n          };\n          newLastBaseUpdate = newLastBaseUpdate.next = clone;\n        } // Process this update.\n\n\n        newState = getStateFromUpdate(workInProgress, queue, update, newState, props, instance);\n        const callback = update.callback;\n\n        if (callback !== null && // If the update was already committed, we should not queue its\n        // callback again.\n        update.lane !== NoLane) {\n          workInProgress.flags |= Callback;\n          const effects = queue.effects;\n\n          if (effects === null) {\n            queue.effects = [update];\n          } else {\n            effects.push(update);\n          }\n        }\n      }\n\n      update = update.next;\n\n      if (update === null) {\n        pendingQueue = queue.shared.pending;\n\n        if (pendingQueue === null) {\n          break;\n        } else {\n          // An update was scheduled from inside a reducer. Add the new\n          // pending updates to the end of the list and keep processing.\n          const lastPendingUpdate = pendingQueue; // Intentionally unsound. Pending updates form a circular list, but we\n          // unravel them when transferring them to the base queue.\n\n          const firstPendingUpdate = lastPendingUpdate.next;\n          lastPendingUpdate.next = null;\n          update = firstPendingUpdate;\n          queue.lastBaseUpdate = lastPendingUpdate;\n          queue.shared.pending = null;\n        }\n      }\n    } while (true);\n\n    if (newLastBaseUpdate === null) {\n      newBaseState = newState;\n    }\n\n    queue.baseState = newBaseState;\n    queue.firstBaseUpdate = newFirstBaseUpdate;\n    queue.lastBaseUpdate = newLastBaseUpdate; // Interleaved updates are stored on a separate queue. We aren't going to\n    // process them during this render, but we do need to track which lanes\n    // are remaining.\n\n    const lastInterleaved = queue.shared.interleaved;\n\n    if (lastInterleaved !== null) {\n      let interleaved = lastInterleaved;\n\n      do {\n        newLanes = mergeLanes(newLanes, interleaved.lane);\n        interleaved = interleaved.next;\n      } while (interleaved !== lastInterleaved);\n    } else if (firstBaseUpdate === null) {\n      // `queue.lanes` is used for entangling transitions. We can set it back to\n      // zero once the queue is empty.\n      queue.shared.lanes = NoLanes;\n    } // Set the remaining expiration time to be whatever is remaining in the queue.\n    // This should be fine because the only two other things that contribute to\n    // expiration time are props and context. We're already in the middle of the\n    // begin phase by the time we start processing the queue, so we've already\n    // dealt with the props. Context in components that specify\n    // shouldComponentUpdate is tricky; but we'll have to account for\n    // that regardless.\n\n\n    markSkippedUpdateLanes(newLanes);\n    workInProgress.lanes = newLanes;\n    workInProgress.memoizedState = newState;\n  }\n\n  if (__DEV__) {\n    currentlyProcessingQueue = null;\n  }\n}\n\nfunction callCallback(callback, context) {\n  if (typeof callback !== 'function') {\n    throw new Error('Invalid argument passed as callback. Expected a function. Instead ' + `received: ${callback}`);\n  }\n\n  callback.call(context);\n}\n\nexport function resetHasForceUpdateBeforeProcessing() {\n  hasForceUpdate = false;\n}\nexport function checkHasForceUpdateAfterProcessing() {\n  return hasForceUpdate;\n}\nexport function commitUpdateQueue(finishedWork, finishedQueue, instance) {\n  // Commit the effects\n  const effects = finishedQueue.effects;\n  finishedQueue.effects = null;\n\n  if (effects !== null) {\n    for (let i = 0; i < effects.length; i++) {\n      const effect = effects[i];\n      const callback = effect.callback;\n\n      if (callback !== null) {\n        effect.callback = null;\n        callCallback(callback, instance);\n      }\n    }\n  }\n}","map":{"version":3,"sources":["/Users/zhangshuo/git/react-source-test/src/react/packages/react-reconciler/src/ReactUpdateQueue.new.js"],"names":["NoLane","NoLanes","isSubsetOfLanes","mergeLanes","isTransitionLane","intersectLanes","markRootEntangled","enterDisallowedContextReadInDEV","exitDisallowedContextReadInDEV","Callback","ShouldCapture","DidCapture","debugRenderPhaseSideEffectsForStrictMode","StrictLegacyMode","markSkippedUpdateLanes","isInterleavedUpdate","pushInterleavedQueue","setIsStrictModeForDevtools","UpdateState","ReplaceState","ForceUpdate","CaptureUpdate","hasForceUpdate","didWarnUpdateInsideUpdate","currentlyProcessingQueue","resetCurrentlyProcessingQueue","__DEV__","initializeUpdateQueue","fiber","queue","baseState","memoizedState","firstBaseUpdate","lastBaseUpdate","shared","pending","interleaved","lanes","effects","updateQueue","cloneUpdateQueue","current","workInProgress","currentQueue","clone","createUpdate","eventTime","lane","update","tag","payload","callback","next","enqueueUpdate","sharedQueue","console","error","entangleTransitions","root","queueLanes","pendingLanes","newQueueLanes","enqueueCapturedUpdate","capturedUpdate","alternate","newFirst","newLast","getStateFromUpdate","prevState","nextProps","instance","nextState","call","mode","flags","partialState","undefined","Object","assign","processUpdateQueue","props","renderLanes","pendingQueue","lastPendingUpdate","firstPendingUpdate","currentLastBaseUpdate","newState","newLanes","newBaseState","newFirstBaseUpdate","newLastBaseUpdate","updateLane","updateEventTime","push","lastInterleaved","callCallback","context","Error","resetHasForceUpdateBeforeProcessing","checkHasForceUpdateAfterProcessing","commitUpdateQueue","finishedWork","finishedQueue","i","length","effect"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA,SACEA,MADF,EAEEC,OAFF,EAGEC,eAHF,EAIEC,UAJF,EAKEC,gBALF,EAMEC,cANF,EAOEC,iBAPF,QAQO,sBARP;AASA,SACEC,+BADF,EAEEC,8BAFF,QAGO,4BAHP;AAIA,SAAQC,QAAR,EAAkBC,aAAlB,EAAiCC,UAAjC,QAAkD,mBAAlD;AAEA,SAAQC,wCAAR,QAAuD,0BAAvD;AAEA,SAAQC,gBAAR,QAA+B,mBAA/B;AACA,SACEC,sBADF,EAEEC,mBAFF,QAGO,0BAHP;AAIA,SAAQC,oBAAR,QAAmC,oCAAnC;AACA,SAAQC,0BAAR,QAAyC,8BAAzC;AA6BA,OAAO,MAAMC,WAAW,GAAG,CAApB;AACP,OAAO,MAAMC,YAAY,GAAG,CAArB;AACP,OAAO,MAAMC,WAAW,GAAG,CAApB;AACP,OAAO,MAAMC,aAAa,GAAG,CAAtB,C,CAEP;AACA;AACA;;AACA,IAAIC,cAAc,GAAG,KAArB;AAEA,IAAIC,yBAAJ;AACA,IAAIC,wBAAJ;AACA,OAAO,IAAIC,6BAAJ;;AACP,IAAIC,OAAJ,EAAa;AACXH,EAAAA,yBAAyB,GAAG,KAA5B;AACAC,EAAAA,wBAAwB,GAAG,IAA3B;;AACAC,EAAAA,6BAA6B,GAAG,MAAM;AACpCD,IAAAA,wBAAwB,GAAG,IAA3B;AACD,GAFD;AAGD;;AAED,OAAO,SAASG,qBAAT,CAAsCC,KAAtC,EAA0D;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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\n// UpdateQueue is a linked list of prioritized updates.\n//\n// Like fibers, update queues come in pairs: a current queue, which represents\n// the visible state of the screen, and a work-in-progress queue, which can be\n// mutated and processed asynchronously before it is committed — a form of\n// double buffering. If a work-in-progress render is discarded before finishing,\n// we create a new work-in-progress by cloning the current queue.\n//\n// Both queues share a persistent, singly-linked list structure. To schedule an\n// update, we append it to the end of both queues. Each queue maintains a\n// pointer to first update in the persistent list that hasn't been processed.\n// The work-in-progress pointer always has a position equal to or greater than\n// the current queue, since we always work on that one. The current queue's\n// pointer is only updated during the commit phase, when we swap in the\n// work-in-progress.\n//\n// For example:\n//\n//   Current pointer:           A - B - C - D - E - F\n//   Work-in-progress pointer:              D - E - F\n//                                          ^\n//                                          The work-in-progress queue has\n//                                          processed more updates than current.\n//\n// The reason we append to both queues is because otherwise we might drop\n// updates without ever processing them. For example, if we only add updates to\n// the work-in-progress queue, some updates could be lost whenever a work-in\n// -progress render restarts by cloning from current. Similarly, if we only add\n// updates to the current queue, the updates will be lost whenever an already\n// in-progress queue commits and swaps with the current queue. However, by\n// adding to both queues, we guarantee that the update will be part of the next\n// work-in-progress. (And because the work-in-progress queue becomes the\n// current queue once it commits, there's no danger of applying the same\n// update twice.)\n//\n// Prioritization\n// --------------\n//\n// Updates are not sorted by priority, but by insertion; new updates are always\n// appended to the end of the list.\n//\n// The priority is still important, though. When processing the update queue\n// during the render phase, only the updates with sufficient priority are\n// included in the result. If we skip an update because it has insufficient\n// priority, it remains in the queue to be processed later, during a lower\n// priority render. Crucially, all updates subsequent to a skipped update also\n// remain in the queue *regardless of their priority*. That means high priority\n// updates are sometimes processed twice, at two separate priorities. We also\n// keep track of a base state, that represents the state before the first\n// update in the queue is applied.\n//\n// For example:\n//\n//   Given a base state of '', and the following queue of updates\n//\n//     A1 - B2 - C1 - D2\n//\n//   where the number indicates the priority, and the update is applied to the\n//   previous state by appending a letter, React will process these updates as\n//   two separate renders, one per distinct priority level:\n//\n//   First render, at priority 1:\n//     Base state: ''\n//     Updates: [A1, C1]\n//     Result state: 'AC'\n//\n//   Second render, at priority 2:\n//     Base state: 'A'            <-  The base state does not include C1,\n//                                    because B2 was skipped.\n//     Updates: [B2, C1, D2]      <-  C1 was rebased on top of B2\n//     Result state: 'ABCD'\n//\n// Because we process updates in insertion order, and rebase high priority\n// updates when preceding updates are skipped, the final result is deterministic\n// regardless of priority. Intermediate state may vary according to system\n// resources, but the final state is always the same.\n\nimport type {Fiber, FiberRoot} from './ReactInternalTypes';\nimport type {Lanes, Lane} from './ReactFiberLane.new';\n\nimport {\n  NoLane,\n  NoLanes,\n  isSubsetOfLanes,\n  mergeLanes,\n  isTransitionLane,\n  intersectLanes,\n  markRootEntangled,\n} from './ReactFiberLane.new';\nimport {\n  enterDisallowedContextReadInDEV,\n  exitDisallowedContextReadInDEV,\n} from './ReactFiberNewContext.new';\nimport {Callback, ShouldCapture, DidCapture} from './ReactFiberFlags';\n\nimport {debugRenderPhaseSideEffectsForStrictMode} from 'shared/ReactFeatureFlags';\n\nimport {StrictLegacyMode} from './ReactTypeOfMode';\nimport {\n  markSkippedUpdateLanes,\n  isInterleavedUpdate,\n} from './ReactFiberWorkLoop.new';\nimport {pushInterleavedQueue} from './ReactFiberInterleavedUpdates.new';\nimport {setIsStrictModeForDevtools} from './ReactFiberDevToolsHook.new';\n\nexport type Update<State> = {|\n  // TODO: Temporary field. Will remove this by storing a map of\n  // transition -> event time on the root.\n  eventTime: number,\n  lane: Lane,\n\n  tag: 0 | 1 | 2 | 3,\n  payload: any,\n  callback: (() => mixed) | null,\n\n  next: Update<State> | null,\n|};\n\nexport type SharedQueue<State> = {|\n  pending: Update<State> | null,\n  interleaved: Update<State> | null,\n  lanes: Lanes,\n|};\n\nexport type UpdateQueue<State> = {|\n  baseState: State,\n  firstBaseUpdate: Update<State> | null,\n  lastBaseUpdate: Update<State> | null,\n  shared: SharedQueue<State>,\n  effects: Array<Update<State>> | null,\n|};\n\nexport const UpdateState = 0;\nexport const ReplaceState = 1;\nexport const ForceUpdate = 2;\nexport const CaptureUpdate = 3;\n\n// Global state that is reset at the beginning of calling `processUpdateQueue`.\n// It should only be read right after calling `processUpdateQueue`, via\n// `checkHasForceUpdateAfterProcessing`.\nlet hasForceUpdate = false;\n\nlet didWarnUpdateInsideUpdate;\nlet currentlyProcessingQueue;\nexport let resetCurrentlyProcessingQueue;\nif (__DEV__) {\n  didWarnUpdateInsideUpdate = false;\n  currentlyProcessingQueue = null;\n  resetCurrentlyProcessingQueue = () => {\n    currentlyProcessingQueue = null;\n  };\n}\n\nexport function initializeUpdateQueue<State>(fiber: Fiber): void {\n  const queue: UpdateQueue<State> = {\n    baseState: fiber.memoizedState,\n    firstBaseUpdate: null,\n    lastBaseUpdate: null,\n    shared: {\n      pending: null,\n      interleaved: null,\n      lanes: NoLanes,\n    },\n    effects: null,\n  };\n  fiber.updateQueue = queue;\n}\n\nexport function cloneUpdateQueue<State>(\n  current: Fiber,\n  workInProgress: Fiber,\n): void {\n  // Clone the update queue from current. Unless it's already a clone.\n  const queue: UpdateQueue<State> = (workInProgress.updateQueue: any);\n  const currentQueue: UpdateQueue<State> = (current.updateQueue: any);\n  if (queue === currentQueue) {\n    const clone: UpdateQueue<State> = {\n      baseState: currentQueue.baseState,\n      firstBaseUpdate: currentQueue.firstBaseUpdate,\n      lastBaseUpdate: currentQueue.lastBaseUpdate,\n      shared: currentQueue.shared,\n      effects: currentQueue.effects,\n    };\n    workInProgress.updateQueue = clone;\n  }\n}\n\nexport function createUpdate(eventTime: number, lane: Lane): Update<*> {\n  const update: Update<*> = {\n    eventTime,\n    lane,\n\n    tag: UpdateState,\n    payload: null,\n    callback: null,\n\n    next: null,\n  };\n  return update;\n}\n\nexport function enqueueUpdate<State>(\n  fiber: Fiber,\n  update: Update<State>,\n  lane: Lane,\n) {\n  const updateQueue = fiber.updateQueue;\n  if (updateQueue === null) {\n    // Only occurs if the fiber has been unmounted.\n    return;\n  }\n\n  const sharedQueue: SharedQueue<State> = (updateQueue: any).shared;\n\n  if (isInterleavedUpdate(fiber, lane)) {\n    const interleaved = sharedQueue.interleaved;\n    if (interleaved === null) {\n      // This is the first update. Create a circular list.\n      update.next = update;\n      // At the end of the current render, this queue's interleaved updates will\n      // be transferred to the pending queue.\n      pushInterleavedQueue(sharedQueue);\n    } else {\n      update.next = interleaved.next;\n      interleaved.next = update;\n    }\n    sharedQueue.interleaved = update;\n  } else {\n    const pending = sharedQueue.pending;\n    if (pending === null) {\n      // This is the first update. Create a circular list.\n      update.next = update;\n    } else {\n      update.next = pending.next;\n      pending.next = update;\n    }\n    sharedQueue.pending = update;\n  }\n\n  if (__DEV__) {\n    if (\n      currentlyProcessingQueue === sharedQueue &&\n      !didWarnUpdateInsideUpdate\n    ) {\n      console.error(\n        'An update (setState, replaceState, or forceUpdate) was scheduled ' +\n          'from inside an update function. Update functions should be pure, ' +\n          'with zero side-effects. Consider using componentDidUpdate or a ' +\n          'callback.',\n      );\n      didWarnUpdateInsideUpdate = true;\n    }\n  }\n}\n\nexport function entangleTransitions(root: FiberRoot, fiber: Fiber, lane: Lane) {\n  const updateQueue = fiber.updateQueue;\n  if (updateQueue === null) {\n    // Only occurs if the fiber has been unmounted.\n    return;\n  }\n\n  const sharedQueue: SharedQueue<mixed> = (updateQueue: any).shared;\n  if (isTransitionLane(lane)) {\n    let queueLanes = sharedQueue.lanes;\n\n    // If any entangled lanes are no longer pending on the root, then they must\n    // have finished. We can remove them from the shared queue, which represents\n    // a superset of the actually pending lanes. In some cases we may entangle\n    // more than we need to, but that's OK. In fact it's worse if we *don't*\n    // entangle when we should.\n    queueLanes = intersectLanes(queueLanes, root.pendingLanes);\n\n    // Entangle the new transition lane with the other transition lanes.\n    const newQueueLanes = mergeLanes(queueLanes, lane);\n    sharedQueue.lanes = newQueueLanes;\n    // Even if queue.lanes already include lane, we don't know for certain if\n    // the lane finished since the last time we entangled it. So we need to\n    // entangle it again, just to be sure.\n    markRootEntangled(root, newQueueLanes);\n  }\n}\n\nexport function enqueueCapturedUpdate<State>(\n  workInProgress: Fiber,\n  capturedUpdate: Update<State>,\n) {\n  // Captured updates are updates that are thrown by a child during the render\n  // phase. They should be discarded if the render is aborted. Therefore,\n  // we should only put them on the work-in-progress queue, not the current one.\n  let queue: UpdateQueue<State> = (workInProgress.updateQueue: any);\n\n  // Check if the work-in-progress queue is a clone.\n  const current = workInProgress.alternate;\n  if (current !== null) {\n    const currentQueue: UpdateQueue<State> = (current.updateQueue: any);\n    if (queue === currentQueue) {\n      // The work-in-progress queue is the same as current. This happens when\n      // we bail out on a parent fiber that then captures an error thrown by\n      // a child. Since we want to append the update only to the work-in\n      // -progress queue, we need to clone the updates. We usually clone during\n      // processUpdateQueue, but that didn't happen in this case because we\n      // skipped over the parent when we bailed out.\n      let newFirst = null;\n      let newLast = null;\n      const firstBaseUpdate = queue.firstBaseUpdate;\n      if (firstBaseUpdate !== null) {\n        // Loop through the updates and clone them.\n        let update = firstBaseUpdate;\n        do {\n          const clone: Update<State> = {\n            eventTime: update.eventTime,\n            lane: update.lane,\n\n            tag: update.tag,\n            payload: update.payload,\n            callback: update.callback,\n\n            next: null,\n          };\n          if (newLast === null) {\n            newFirst = newLast = clone;\n          } else {\n            newLast.next = clone;\n            newLast = clone;\n          }\n          update = update.next;\n        } while (update !== null);\n\n        // Append the captured update the end of the cloned list.\n        if (newLast === null) {\n          newFirst = newLast = capturedUpdate;\n        } else {\n          newLast.next = capturedUpdate;\n          newLast = capturedUpdate;\n        }\n      } else {\n        // There are no base updates.\n        newFirst = newLast = capturedUpdate;\n      }\n      queue = {\n        baseState: currentQueue.baseState,\n        firstBaseUpdate: newFirst,\n        lastBaseUpdate: newLast,\n        shared: currentQueue.shared,\n        effects: currentQueue.effects,\n      };\n      workInProgress.updateQueue = queue;\n      return;\n    }\n  }\n\n  // Append the update to the end of the list.\n  const lastBaseUpdate = queue.lastBaseUpdate;\n  if (lastBaseUpdate === null) {\n    queue.firstBaseUpdate = capturedUpdate;\n  } else {\n    lastBaseUpdate.next = capturedUpdate;\n  }\n  queue.lastBaseUpdate = capturedUpdate;\n}\n\nfunction getStateFromUpdate<State>(\n  workInProgress: Fiber,\n  queue: UpdateQueue<State>,\n  update: Update<State>,\n  prevState: State,\n  nextProps: any,\n  instance: any,\n): any {\n  switch (update.tag) {\n    case ReplaceState: {\n      const payload = update.payload;\n      if (typeof payload === 'function') {\n        // Updater function\n        if (__DEV__) {\n          enterDisallowedContextReadInDEV();\n        }\n        const nextState = payload.call(instance, prevState, nextProps);\n        if (__DEV__) {\n          if (\n            debugRenderPhaseSideEffectsForStrictMode &&\n            workInProgress.mode & StrictLegacyMode\n          ) {\n            setIsStrictModeForDevtools(true);\n            try {\n              payload.call(instance, prevState, nextProps);\n            } finally {\n              setIsStrictModeForDevtools(false);\n            }\n          }\n          exitDisallowedContextReadInDEV();\n        }\n        return nextState;\n      }\n      // State object\n      return payload;\n    }\n    case CaptureUpdate: {\n      workInProgress.flags =\n        (workInProgress.flags & ~ShouldCapture) | DidCapture;\n    }\n    // Intentional fallthrough\n    case UpdateState: {\n      const payload = update.payload;\n      let partialState;\n      if (typeof payload === 'function') {\n        // Updater function\n        if (__DEV__) {\n          enterDisallowedContextReadInDEV();\n        }\n        partialState = payload.call(instance, prevState, nextProps);\n        if (__DEV__) {\n          if (\n            debugRenderPhaseSideEffectsForStrictMode &&\n            workInProgress.mode & StrictLegacyMode\n          ) {\n            setIsStrictModeForDevtools(true);\n            try {\n              payload.call(instance, prevState, nextProps);\n            } finally {\n              setIsStrictModeForDevtools(false);\n            }\n          }\n          exitDisallowedContextReadInDEV();\n        }\n      } else {\n        // Partial state object\n        partialState = payload;\n      }\n      if (partialState === null || partialState === undefined) {\n        // Null and undefined are treated as no-ops.\n        return prevState;\n      }\n      // Merge the partial state and the previous state.\n      return Object.assign({}, prevState, partialState);\n    }\n    case ForceUpdate: {\n      hasForceUpdate = true;\n      return prevState;\n    }\n  }\n  return prevState;\n}\n\nexport function processUpdateQueue<State>(\n  workInProgress: Fiber,\n  props: any,\n  instance: any,\n  renderLanes: Lanes,\n): void {\n  // This is always non-null on a ClassComponent or HostRoot\n  const queue: UpdateQueue<State> = (workInProgress.updateQueue: any);\n\n  hasForceUpdate = false;\n\n  if (__DEV__) {\n    currentlyProcessingQueue = queue.shared;\n  }\n\n  let firstBaseUpdate = queue.firstBaseUpdate;\n  let lastBaseUpdate = queue.lastBaseUpdate;\n\n  // Check if there are pending updates. If so, transfer them to the base queue.\n  let pendingQueue = queue.shared.pending;\n  if (pendingQueue !== null) {\n    queue.shared.pending = null;\n\n    // The pending queue is circular. Disconnect the pointer between first\n    // and last so that it's non-circular.\n    const lastPendingUpdate = pendingQueue;\n    const firstPendingUpdate = lastPendingUpdate.next;\n    lastPendingUpdate.next = null;\n    // Append pending updates to base queue\n    if (lastBaseUpdate === null) {\n      firstBaseUpdate = firstPendingUpdate;\n    } else {\n      lastBaseUpdate.next = firstPendingUpdate;\n    }\n    lastBaseUpdate = lastPendingUpdate;\n\n    // If there's a current queue, and it's different from the base queue, then\n    // we need to transfer the updates to that queue, too. Because the base\n    // queue is a singly-linked list with no cycles, we can append to both\n    // lists and take advantage of structural sharing.\n    // TODO: Pass `current` as argument\n    const current = workInProgress.alternate;\n    if (current !== null) {\n      // This is always non-null on a ClassComponent or HostRoot\n      const currentQueue: UpdateQueue<State> = (current.updateQueue: any);\n      const currentLastBaseUpdate = currentQueue.lastBaseUpdate;\n      if (currentLastBaseUpdate !== lastBaseUpdate) {\n        if (currentLastBaseUpdate === null) {\n          currentQueue.firstBaseUpdate = firstPendingUpdate;\n        } else {\n          currentLastBaseUpdate.next = firstPendingUpdate;\n        }\n        currentQueue.lastBaseUpdate = lastPendingUpdate;\n      }\n    }\n  }\n\n  // These values may change as we process the queue.\n  if (firstBaseUpdate !== null) {\n    // Iterate through the list of updates to compute the result.\n    let newState = queue.baseState;\n    // TODO: Don't need to accumulate this. Instead, we can remove renderLanes\n    // from the original lanes.\n    let newLanes = NoLanes;\n\n    let newBaseState = null;\n    let newFirstBaseUpdate = null;\n    let newLastBaseUpdate = null;\n\n    let update = firstBaseUpdate;\n    do {\n      const updateLane = update.lane;\n      const updateEventTime = update.eventTime;\n      if (!isSubsetOfLanes(renderLanes, updateLane)) {\n        // Priority is insufficient. Skip this update. If this is the first\n        // skipped update, the previous update/state is the new base\n        // update/state.\n        const clone: Update<State> = {\n          eventTime: updateEventTime,\n          lane: updateLane,\n\n          tag: update.tag,\n          payload: update.payload,\n          callback: update.callback,\n\n          next: null,\n        };\n        if (newLastBaseUpdate === null) {\n          newFirstBaseUpdate = newLastBaseUpdate = clone;\n          newBaseState = newState;\n        } else {\n          newLastBaseUpdate = newLastBaseUpdate.next = clone;\n        }\n        // Update the remaining priority in the queue.\n        newLanes = mergeLanes(newLanes, updateLane);\n      } else {\n        // This update does have sufficient priority.\n\n        if (newLastBaseUpdate !== null) {\n          const clone: Update<State> = {\n            eventTime: updateEventTime,\n            // This update is going to be committed so we never want uncommit\n            // it. Using NoLane works because 0 is a subset of all bitmasks, so\n            // this will never be skipped by the check above.\n            lane: NoLane,\n\n            tag: update.tag,\n            payload: update.payload,\n            callback: update.callback,\n\n            next: null,\n          };\n          newLastBaseUpdate = newLastBaseUpdate.next = clone;\n        }\n\n        // Process this update.\n        newState = getStateFromUpdate(\n          workInProgress,\n          queue,\n          update,\n          newState,\n          props,\n          instance,\n        );\n        const callback = update.callback;\n        if (\n          callback !== null &&\n          // If the update was already committed, we should not queue its\n          // callback again.\n          update.lane !== NoLane\n        ) {\n          workInProgress.flags |= Callback;\n          const effects = queue.effects;\n          if (effects === null) {\n            queue.effects = [update];\n          } else {\n            effects.push(update);\n          }\n        }\n      }\n      update = update.next;\n      if (update === null) {\n        pendingQueue = queue.shared.pending;\n        if (pendingQueue === null) {\n          break;\n        } else {\n          // An update was scheduled from inside a reducer. Add the new\n          // pending updates to the end of the list and keep processing.\n          const lastPendingUpdate = pendingQueue;\n          // Intentionally unsound. Pending updates form a circular list, but we\n          // unravel them when transferring them to the base queue.\n          const firstPendingUpdate = ((lastPendingUpdate.next: any): Update<State>);\n          lastPendingUpdate.next = null;\n          update = firstPendingUpdate;\n          queue.lastBaseUpdate = lastPendingUpdate;\n          queue.shared.pending = null;\n        }\n      }\n    } while (true);\n\n    if (newLastBaseUpdate === null) {\n      newBaseState = newState;\n    }\n\n    queue.baseState = ((newBaseState: any): State);\n    queue.firstBaseUpdate = newFirstBaseUpdate;\n    queue.lastBaseUpdate = newLastBaseUpdate;\n\n    // Interleaved updates are stored on a separate queue. We aren't going to\n    // process them during this render, but we do need to track which lanes\n    // are remaining.\n    const lastInterleaved = queue.shared.interleaved;\n    if (lastInterleaved !== null) {\n      let interleaved = lastInterleaved;\n      do {\n        newLanes = mergeLanes(newLanes, interleaved.lane);\n        interleaved = ((interleaved: any).next: Update<State>);\n      } while (interleaved !== lastInterleaved);\n    } else if (firstBaseUpdate === null) {\n      // `queue.lanes` is used for entangling transitions. We can set it back to\n      // zero once the queue is empty.\n      queue.shared.lanes = NoLanes;\n    }\n\n    // Set the remaining expiration time to be whatever is remaining in the queue.\n    // This should be fine because the only two other things that contribute to\n    // expiration time are props and context. We're already in the middle of the\n    // begin phase by the time we start processing the queue, so we've already\n    // dealt with the props. Context in components that specify\n    // shouldComponentUpdate is tricky; but we'll have to account for\n    // that regardless.\n    markSkippedUpdateLanes(newLanes);\n    workInProgress.lanes = newLanes;\n    workInProgress.memoizedState = newState;\n  }\n\n  if (__DEV__) {\n    currentlyProcessingQueue = null;\n  }\n}\n\nfunction callCallback(callback, context) {\n  if (typeof callback !== 'function') {\n    throw new Error(\n      'Invalid argument passed as callback. Expected a function. Instead ' +\n        `received: ${callback}`,\n    );\n  }\n\n  callback.call(context);\n}\n\nexport function resetHasForceUpdateBeforeProcessing() {\n  hasForceUpdate = false;\n}\n\nexport function checkHasForceUpdateAfterProcessing(): boolean {\n  return hasForceUpdate;\n}\n\nexport function commitUpdateQueue<State>(\n  finishedWork: Fiber,\n  finishedQueue: UpdateQueue<State>,\n  instance: any,\n): void {\n  // Commit the effects\n  const effects = finishedQueue.effects;\n  finishedQueue.effects = null;\n  if (effects !== null) {\n    for (let i = 0; i < effects.length; i++) {\n      const effect = effects[i];\n      const callback = effect.callback;\n      if (callback !== null) {\n        effect.callback = null;\n        callCallback(callback, instance);\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}