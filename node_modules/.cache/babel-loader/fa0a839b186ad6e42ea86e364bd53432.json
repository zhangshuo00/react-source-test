{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { HostComponent, HostText } from 'react-reconciler/src/ReactWorkTags';\nimport getComponentNameFromType from 'shared/getComponentNameFromType';\nimport { findFiberRoot, getBoundingRect, getInstanceFromNode, getTextContent, isHiddenSubtree, matchAccessibilityRole, setFocusIfFocusable, setupIntersectionObserver, supportsTestSelectors } from './ReactFiberHostConfig';\nlet COMPONENT_TYPE = 0b000;\nlet HAS_PSEUDO_CLASS_TYPE = 0b001;\nlet ROLE_TYPE = 0b010;\nlet TEST_NAME_TYPE = 0b011;\nlet TEXT_TYPE = 0b100;\n\nif (typeof Symbol === 'function' && Symbol.for) {\n  const symbolFor = Symbol.for;\n  COMPONENT_TYPE = symbolFor('selector.component');\n  HAS_PSEUDO_CLASS_TYPE = symbolFor('selector.has_pseudo_class');\n  ROLE_TYPE = symbolFor('selector.role');\n  TEST_NAME_TYPE = symbolFor('selector.test_id');\n  TEXT_TYPE = symbolFor('selector.text');\n}\n\nexport function createComponentSelector(component) {\n  return {\n    $$typeof: COMPONENT_TYPE,\n    value: component\n  };\n}\nexport function createHasPseudoClassSelector(selectors) {\n  return {\n    $$typeof: HAS_PSEUDO_CLASS_TYPE,\n    value: selectors\n  };\n}\nexport function createRoleSelector(role) {\n  return {\n    $$typeof: ROLE_TYPE,\n    value: role\n  };\n}\nexport function createTextSelector(text) {\n  return {\n    $$typeof: TEXT_TYPE,\n    value: text\n  };\n}\nexport function createTestNameSelector(id) {\n  return {\n    $$typeof: TEST_NAME_TYPE,\n    value: id\n  };\n}\n\nfunction findFiberRootForHostRoot(hostRoot) {\n  const maybeFiber = getInstanceFromNode(hostRoot);\n\n  if (maybeFiber != null) {\n    if (typeof maybeFiber.memoizedProps['data-testname'] !== 'string') {\n      throw new Error('Invalid host root specified. Should be either a React container or a node with a testname attribute.');\n    }\n\n    return maybeFiber;\n  } else {\n    const fiberRoot = findFiberRoot(hostRoot);\n\n    if (fiberRoot === null) {\n      throw new Error('Could not find React container within specified host subtree.');\n    } // The Flow type for FiberRoot is a little funky.\n    // createFiberRoot() cheats this by treating the root as :any and adding stateNode lazily.\n\n\n    return fiberRoot.stateNode.current;\n  }\n}\n\nfunction matchSelector(fiber, selector) {\n  switch (selector.$$typeof) {\n    case COMPONENT_TYPE:\n      if (fiber.type === selector.value) {\n        return true;\n      }\n\n      break;\n\n    case HAS_PSEUDO_CLASS_TYPE:\n      return hasMatchingPaths(fiber, selector.value);\n\n    case ROLE_TYPE:\n      if (fiber.tag === HostComponent) {\n        const node = fiber.stateNode;\n\n        if (matchAccessibilityRole(node, selector.value)) {\n          return true;\n        }\n      }\n\n      break;\n\n    case TEXT_TYPE:\n      if (fiber.tag === HostComponent || fiber.tag === HostText) {\n        const textContent = getTextContent(fiber);\n\n        if (textContent !== null && textContent.indexOf(selector.value) >= 0) {\n          return true;\n        }\n      }\n\n      break;\n\n    case TEST_NAME_TYPE:\n      if (fiber.tag === HostComponent) {\n        const dataTestID = fiber.memoizedProps['data-testname'];\n\n        if (typeof dataTestID === 'string' && dataTestID.toLowerCase() === selector.value.toLowerCase()) {\n          return true;\n        }\n      }\n\n      break;\n\n    default:\n      throw new Error('Invalid selector type specified.');\n  }\n\n  return false;\n}\n\nfunction selectorToString(selector) {\n  switch (selector.$$typeof) {\n    case COMPONENT_TYPE:\n      const displayName = getComponentNameFromType(selector.value) || 'Unknown';\n      return `<${displayName}>`;\n\n    case HAS_PSEUDO_CLASS_TYPE:\n      return `:has(${selectorToString(selector) || ''})`;\n\n    case ROLE_TYPE:\n      return `[role=\"${selector.value}\"]`;\n\n    case TEXT_TYPE:\n      return `\"${selector.value}\"`;\n\n    case TEST_NAME_TYPE:\n      return `[data-testname=\"${selector.value}\"]`;\n\n    default:\n      throw new Error('Invalid selector type specified.');\n  }\n}\n\nfunction findPaths(root, selectors) {\n  const matchingFibers = [];\n  const stack = [root, 0];\n  let index = 0;\n\n  while (index < stack.length) {\n    const fiber = stack[index++];\n    let selectorIndex = stack[index++];\n    let selector = selectors[selectorIndex];\n\n    if (fiber.tag === HostComponent && isHiddenSubtree(fiber)) {\n      continue;\n    } else {\n      while (selector != null && matchSelector(fiber, selector)) {\n        selectorIndex++;\n        selector = selectors[selectorIndex];\n      }\n    }\n\n    if (selectorIndex === selectors.length) {\n      matchingFibers.push(fiber);\n    } else {\n      let child = fiber.child;\n\n      while (child !== null) {\n        stack.push(child, selectorIndex);\n        child = child.sibling;\n      }\n    }\n  }\n\n  return matchingFibers;\n} // Same as findPaths but with eager bailout on first match\n\n\nfunction hasMatchingPaths(root, selectors) {\n  const stack = [root, 0];\n  let index = 0;\n\n  while (index < stack.length) {\n    const fiber = stack[index++];\n    let selectorIndex = stack[index++];\n    let selector = selectors[selectorIndex];\n\n    if (fiber.tag === HostComponent && isHiddenSubtree(fiber)) {\n      continue;\n    } else {\n      while (selector != null && matchSelector(fiber, selector)) {\n        selectorIndex++;\n        selector = selectors[selectorIndex];\n      }\n    }\n\n    if (selectorIndex === selectors.length) {\n      return true;\n    } else {\n      let child = fiber.child;\n\n      while (child !== null) {\n        stack.push(child, selectorIndex);\n        child = child.sibling;\n      }\n    }\n  }\n\n  return false;\n}\n\nexport function findAllNodes(hostRoot, selectors) {\n  if (!supportsTestSelectors) {\n    throw new Error('Test selector API is not supported by this renderer.');\n  }\n\n  const root = findFiberRootForHostRoot(hostRoot);\n  const matchingFibers = findPaths(root, selectors);\n  const instanceRoots = [];\n  const stack = Array.from(matchingFibers);\n  let index = 0;\n\n  while (index < stack.length) {\n    const node = stack[index++];\n\n    if (node.tag === HostComponent) {\n      if (isHiddenSubtree(node)) {\n        continue;\n      }\n\n      instanceRoots.push(node.stateNode);\n    } else {\n      let child = node.child;\n\n      while (child !== null) {\n        stack.push(child);\n        child = child.sibling;\n      }\n    }\n  }\n\n  return instanceRoots;\n}\nexport function getFindAllNodesFailureDescription(hostRoot, selectors) {\n  if (!supportsTestSelectors) {\n    throw new Error('Test selector API is not supported by this renderer.');\n  }\n\n  const root = findFiberRootForHostRoot(hostRoot);\n  let maxSelectorIndex = 0;\n  const matchedNames = []; // The logic of this loop should be kept in sync with findPaths()\n\n  const stack = [root, 0];\n  let index = 0;\n\n  while (index < stack.length) {\n    const fiber = stack[index++];\n    let selectorIndex = stack[index++];\n    const selector = selectors[selectorIndex];\n\n    if (fiber.tag === HostComponent && isHiddenSubtree(fiber)) {\n      continue;\n    } else if (matchSelector(fiber, selector)) {\n      matchedNames.push(selectorToString(selector));\n      selectorIndex++;\n\n      if (selectorIndex > maxSelectorIndex) {\n        maxSelectorIndex = selectorIndex;\n      }\n    }\n\n    if (selectorIndex < selectors.length) {\n      let child = fiber.child;\n\n      while (child !== null) {\n        stack.push(child, selectorIndex);\n        child = child.sibling;\n      }\n    }\n  }\n\n  if (maxSelectorIndex < selectors.length) {\n    const unmatchedNames = [];\n\n    for (let i = maxSelectorIndex; i < selectors.length; i++) {\n      unmatchedNames.push(selectorToString(selectors[i]));\n    }\n\n    return 'findAllNodes was able to match part of the selector:\\n' + `  ${matchedNames.join(' > ')}\\n\\n` + 'No matching component was found for:\\n' + `  ${unmatchedNames.join(' > ')}`;\n  }\n\n  return null;\n}\nexport function findBoundingRects(hostRoot, selectors) {\n  if (!supportsTestSelectors) {\n    throw new Error('Test selector API is not supported by this renderer.');\n  }\n\n  const instanceRoots = findAllNodes(hostRoot, selectors);\n  const boundingRects = [];\n\n  for (let i = 0; i < instanceRoots.length; i++) {\n    boundingRects.push(getBoundingRect(instanceRoots[i]));\n  }\n\n  for (let i = boundingRects.length - 1; i > 0; i--) {\n    const targetRect = boundingRects[i];\n    const targetLeft = targetRect.x;\n    const targetRight = targetLeft + targetRect.width;\n    const targetTop = targetRect.y;\n    const targetBottom = targetTop + targetRect.height;\n\n    for (let j = i - 1; j >= 0; j--) {\n      if (i !== j) {\n        const otherRect = boundingRects[j];\n        const otherLeft = otherRect.x;\n        const otherRight = otherLeft + otherRect.width;\n        const otherTop = otherRect.y;\n        const otherBottom = otherTop + otherRect.height; // Merging all rects to the minimums set would be complicated,\n        // but we can handle the most common cases:\n        // 1. completely overlapping rects\n        // 2. adjacent rects that are the same width or height (e.g. items in a list)\n        //\n        // Even given the above constraints,\n        // we still won't end up with the fewest possible rects without doing multiple passes,\n        // but it's good enough for this purpose.\n\n        if (targetLeft >= otherLeft && targetTop >= otherTop && targetRight <= otherRight && targetBottom <= otherBottom) {\n          // Complete overlapping rects; remove the inner one.\n          boundingRects.splice(i, 1);\n          break;\n        } else if (targetLeft === otherLeft && targetRect.width === otherRect.width && !(otherBottom < targetTop) && !(otherTop > targetBottom)) {\n          // Adjacent vertical rects; merge them.\n          if (otherTop > targetTop) {\n            otherRect.height += otherTop - targetTop;\n            otherRect.y = targetTop;\n          }\n\n          if (otherBottom < targetBottom) {\n            otherRect.height = targetBottom - otherTop;\n          }\n\n          boundingRects.splice(i, 1);\n          break;\n        } else if (targetTop === otherTop && targetRect.height === otherRect.height && !(otherRight < targetLeft) && !(otherLeft > targetRight)) {\n          // Adjacent horizontal rects; merge them.\n          if (otherLeft > targetLeft) {\n            otherRect.width += otherLeft - targetLeft;\n            otherRect.x = targetLeft;\n          }\n\n          if (otherRight < targetRight) {\n            otherRect.width = targetRight - otherLeft;\n          }\n\n          boundingRects.splice(i, 1);\n          break;\n        }\n      }\n    }\n  }\n\n  return boundingRects;\n}\nexport function focusWithin(hostRoot, selectors) {\n  if (!supportsTestSelectors) {\n    throw new Error('Test selector API is not supported by this renderer.');\n  }\n\n  const root = findFiberRootForHostRoot(hostRoot);\n  const matchingFibers = findPaths(root, selectors);\n  const stack = Array.from(matchingFibers);\n  let index = 0;\n\n  while (index < stack.length) {\n    const fiber = stack[index++];\n\n    if (isHiddenSubtree(fiber)) {\n      continue;\n    }\n\n    if (fiber.tag === HostComponent) {\n      const node = fiber.stateNode;\n\n      if (setFocusIfFocusable(node)) {\n        return true;\n      }\n    }\n\n    let child = fiber.child;\n\n    while (child !== null) {\n      stack.push(child);\n      child = child.sibling;\n    }\n  }\n\n  return false;\n}\nconst commitHooks = [];\nexport function onCommitRoot() {\n  if (supportsTestSelectors) {\n    commitHooks.forEach(commitHook => commitHook());\n  }\n}\nexport function observeVisibleRects(hostRoot, selectors, callback, options) {\n  if (!supportsTestSelectors) {\n    throw new Error('Test selector API is not supported by this renderer.');\n  }\n\n  const instanceRoots = findAllNodes(hostRoot, selectors);\n  const {\n    disconnect,\n    observe,\n    unobserve\n  } = setupIntersectionObserver(instanceRoots, callback, options); // When React mutates the host environment, we may need to change what we're listening to.\n\n  const commitHook = () => {\n    const nextInstanceRoots = findAllNodes(hostRoot, selectors);\n    instanceRoots.forEach(target => {\n      if (nextInstanceRoots.indexOf(target) < 0) {\n        unobserve(target);\n      }\n    });\n    nextInstanceRoots.forEach(target => {\n      if (instanceRoots.indexOf(target) < 0) {\n        observe(target);\n      }\n    });\n  };\n\n  commitHooks.push(commitHook);\n  return {\n    disconnect: () => {\n      // Stop listening for React mutations:\n      const index = commitHooks.indexOf(commitHook);\n\n      if (index >= 0) {\n        commitHooks.splice(index, 1);\n      } // Disconnect the host observer:\n\n\n      disconnect();\n    }\n  };\n}","map":{"version":3,"sources":["/Users/zhangshuo/git/my-app/src/react/packages/react-reconciler/src/ReactTestSelectors.js"],"names":["HostComponent","HostText","getComponentNameFromType","findFiberRoot","getBoundingRect","getInstanceFromNode","getTextContent","isHiddenSubtree","matchAccessibilityRole","setFocusIfFocusable","setupIntersectionObserver","supportsTestSelectors","COMPONENT_TYPE","HAS_PSEUDO_CLASS_TYPE","ROLE_TYPE","TEST_NAME_TYPE","TEXT_TYPE","Symbol","for","symbolFor","createComponentSelector","component","$$typeof","value","createHasPseudoClassSelector","selectors","createRoleSelector","role","createTextSelector","text","createTestNameSelector","id","findFiberRootForHostRoot","hostRoot","maybeFiber","memoizedProps","Error","fiberRoot","stateNode","current","matchSelector","fiber","selector","type","hasMatchingPaths","tag","node","textContent","indexOf","dataTestID","toLowerCase","selectorToString","displayName","findPaths","root","matchingFibers","stack","index","length","selectorIndex","push","child","sibling","findAllNodes","instanceRoots","Array","from","getFindAllNodesFailureDescription","maxSelectorIndex","matchedNames","unmatchedNames","i","join","findBoundingRects","boundingRects","targetRect","targetLeft","x","targetRight","width","targetTop","y","targetBottom","height","j","otherRect","otherLeft","otherRight","otherTop","otherBottom","splice","focusWithin","commitHooks","onCommitRoot","forEach","commitHook","observeVisibleRects","callback","options","disconnect","observe","unobserve","nextInstanceRoots","target"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Fiber} from 'react-reconciler/src/ReactInternalTypes';\nimport type {Instance} from './ReactFiberHostConfig';\n\nimport {HostComponent, HostText} from 'react-reconciler/src/ReactWorkTags';\nimport getComponentNameFromType from 'shared/getComponentNameFromType';\nimport {\n  findFiberRoot,\n  getBoundingRect,\n  getInstanceFromNode,\n  getTextContent,\n  isHiddenSubtree,\n  matchAccessibilityRole,\n  setFocusIfFocusable,\n  setupIntersectionObserver,\n  supportsTestSelectors,\n} from './ReactFiberHostConfig';\n\nlet COMPONENT_TYPE = 0b000;\nlet HAS_PSEUDO_CLASS_TYPE = 0b001;\nlet ROLE_TYPE = 0b010;\nlet TEST_NAME_TYPE = 0b011;\nlet TEXT_TYPE = 0b100;\n\nif (typeof Symbol === 'function' && Symbol.for) {\n  const symbolFor = Symbol.for;\n  COMPONENT_TYPE = symbolFor('selector.component');\n  HAS_PSEUDO_CLASS_TYPE = symbolFor('selector.has_pseudo_class');\n  ROLE_TYPE = symbolFor('selector.role');\n  TEST_NAME_TYPE = symbolFor('selector.test_id');\n  TEXT_TYPE = symbolFor('selector.text');\n}\n\ntype Type = Symbol | number;\n\ntype ComponentSelector = {|\n  $$typeof: Type,\n  value: React$AbstractComponent<empty, mixed>,\n|};\n\ntype HasPseudoClassSelector = {|\n  $$typeof: Type,\n  value: Array<Selector>,\n|};\n\ntype RoleSelector = {|\n  $$typeof: Type,\n  value: string,\n|};\n\ntype TextSelector = {|\n  $$typeof: Type,\n  value: string,\n|};\n\ntype TestNameSelector = {|\n  $$typeof: Type,\n  value: string,\n|};\n\ntype Selector =\n  | ComponentSelector\n  | HasPseudoClassSelector\n  | RoleSelector\n  | TextSelector\n  | TestNameSelector;\n\nexport function createComponentSelector(\n  component: React$AbstractComponent<empty, mixed>,\n): ComponentSelector {\n  return {\n    $$typeof: COMPONENT_TYPE,\n    value: component,\n  };\n}\n\nexport function createHasPseudoClassSelector(\n  selectors: Array<Selector>,\n): HasPseudoClassSelector {\n  return {\n    $$typeof: HAS_PSEUDO_CLASS_TYPE,\n    value: selectors,\n  };\n}\n\nexport function createRoleSelector(role: string): RoleSelector {\n  return {\n    $$typeof: ROLE_TYPE,\n    value: role,\n  };\n}\n\nexport function createTextSelector(text: string): TextSelector {\n  return {\n    $$typeof: TEXT_TYPE,\n    value: text,\n  };\n}\n\nexport function createTestNameSelector(id: string): TestNameSelector {\n  return {\n    $$typeof: TEST_NAME_TYPE,\n    value: id,\n  };\n}\n\nfunction findFiberRootForHostRoot(hostRoot: Instance): Fiber {\n  const maybeFiber = getInstanceFromNode((hostRoot: any));\n  if (maybeFiber != null) {\n    if (typeof maybeFiber.memoizedProps['data-testname'] !== 'string') {\n      throw new Error(\n        'Invalid host root specified. Should be either a React container or a node with a testname attribute.',\n      );\n    }\n\n    return ((maybeFiber: any): Fiber);\n  } else {\n    const fiberRoot = findFiberRoot(hostRoot);\n\n    if (fiberRoot === null) {\n      throw new Error(\n        'Could not find React container within specified host subtree.',\n      );\n    }\n\n    // The Flow type for FiberRoot is a little funky.\n    // createFiberRoot() cheats this by treating the root as :any and adding stateNode lazily.\n    return ((fiberRoot: any).stateNode.current: Fiber);\n  }\n}\n\nfunction matchSelector(fiber: Fiber, selector: Selector): boolean {\n  switch (selector.$$typeof) {\n    case COMPONENT_TYPE:\n      if (fiber.type === selector.value) {\n        return true;\n      }\n      break;\n    case HAS_PSEUDO_CLASS_TYPE:\n      return hasMatchingPaths(\n        fiber,\n        ((selector: any): HasPseudoClassSelector).value,\n      );\n    case ROLE_TYPE:\n      if (fiber.tag === HostComponent) {\n        const node = fiber.stateNode;\n        if (\n          matchAccessibilityRole(node, ((selector: any): RoleSelector).value)\n        ) {\n          return true;\n        }\n      }\n      break;\n    case TEXT_TYPE:\n      if (fiber.tag === HostComponent || fiber.tag === HostText) {\n        const textContent = getTextContent(fiber);\n        if (\n          textContent !== null &&\n          textContent.indexOf(((selector: any): TextSelector).value) >= 0\n        ) {\n          return true;\n        }\n      }\n      break;\n    case TEST_NAME_TYPE:\n      if (fiber.tag === HostComponent) {\n        const dataTestID = fiber.memoizedProps['data-testname'];\n        if (\n          typeof dataTestID === 'string' &&\n          dataTestID.toLowerCase() ===\n            ((selector: any): TestNameSelector).value.toLowerCase()\n        ) {\n          return true;\n        }\n      }\n      break;\n    default:\n      throw new Error('Invalid selector type specified.');\n  }\n\n  return false;\n}\n\nfunction selectorToString(selector: Selector): string | null {\n  switch (selector.$$typeof) {\n    case COMPONENT_TYPE:\n      const displayName = getComponentNameFromType(selector.value) || 'Unknown';\n      return `<${displayName}>`;\n    case HAS_PSEUDO_CLASS_TYPE:\n      return `:has(${selectorToString(selector) || ''})`;\n    case ROLE_TYPE:\n      return `[role=\"${((selector: any): RoleSelector).value}\"]`;\n    case TEXT_TYPE:\n      return `\"${((selector: any): TextSelector).value}\"`;\n    case TEST_NAME_TYPE:\n      return `[data-testname=\"${((selector: any): TestNameSelector).value}\"]`;\n    default:\n      throw new Error('Invalid selector type specified.');\n  }\n}\n\nfunction findPaths(root: Fiber, selectors: Array<Selector>): Array<Fiber> {\n  const matchingFibers: Array<Fiber> = [];\n\n  const stack = [root, 0];\n  let index = 0;\n  while (index < stack.length) {\n    const fiber = ((stack[index++]: any): Fiber);\n    let selectorIndex = ((stack[index++]: any): number);\n    let selector = selectors[selectorIndex];\n\n    if (fiber.tag === HostComponent && isHiddenSubtree(fiber)) {\n      continue;\n    } else {\n      while (selector != null && matchSelector(fiber, selector)) {\n        selectorIndex++;\n        selector = selectors[selectorIndex];\n      }\n    }\n\n    if (selectorIndex === selectors.length) {\n      matchingFibers.push(fiber);\n    } else {\n      let child = fiber.child;\n      while (child !== null) {\n        stack.push(child, selectorIndex);\n        child = child.sibling;\n      }\n    }\n  }\n\n  return matchingFibers;\n}\n\n// Same as findPaths but with eager bailout on first match\nfunction hasMatchingPaths(root: Fiber, selectors: Array<Selector>): boolean {\n  const stack = [root, 0];\n  let index = 0;\n  while (index < stack.length) {\n    const fiber = ((stack[index++]: any): Fiber);\n    let selectorIndex = ((stack[index++]: any): number);\n    let selector = selectors[selectorIndex];\n\n    if (fiber.tag === HostComponent && isHiddenSubtree(fiber)) {\n      continue;\n    } else {\n      while (selector != null && matchSelector(fiber, selector)) {\n        selectorIndex++;\n        selector = selectors[selectorIndex];\n      }\n    }\n\n    if (selectorIndex === selectors.length) {\n      return true;\n    } else {\n      let child = fiber.child;\n      while (child !== null) {\n        stack.push(child, selectorIndex);\n        child = child.sibling;\n      }\n    }\n  }\n\n  return false;\n}\n\nexport function findAllNodes(\n  hostRoot: Instance,\n  selectors: Array<Selector>,\n): Array<Instance> {\n  if (!supportsTestSelectors) {\n    throw new Error('Test selector API is not supported by this renderer.');\n  }\n\n  const root = findFiberRootForHostRoot(hostRoot);\n  const matchingFibers = findPaths(root, selectors);\n\n  const instanceRoots: Array<Instance> = [];\n\n  const stack = Array.from(matchingFibers);\n  let index = 0;\n  while (index < stack.length) {\n    const node = ((stack[index++]: any): Fiber);\n    if (node.tag === HostComponent) {\n      if (isHiddenSubtree(node)) {\n        continue;\n      }\n      instanceRoots.push(node.stateNode);\n    } else {\n      let child = node.child;\n      while (child !== null) {\n        stack.push(child);\n        child = child.sibling;\n      }\n    }\n  }\n\n  return instanceRoots;\n}\n\nexport function getFindAllNodesFailureDescription(\n  hostRoot: Instance,\n  selectors: Array<Selector>,\n): string | null {\n  if (!supportsTestSelectors) {\n    throw new Error('Test selector API is not supported by this renderer.');\n  }\n\n  const root = findFiberRootForHostRoot(hostRoot);\n\n  let maxSelectorIndex: number = 0;\n  const matchedNames = [];\n\n  // The logic of this loop should be kept in sync with findPaths()\n  const stack = [root, 0];\n  let index = 0;\n  while (index < stack.length) {\n    const fiber = ((stack[index++]: any): Fiber);\n    let selectorIndex = ((stack[index++]: any): number);\n    const selector = selectors[selectorIndex];\n\n    if (fiber.tag === HostComponent && isHiddenSubtree(fiber)) {\n      continue;\n    } else if (matchSelector(fiber, selector)) {\n      matchedNames.push(selectorToString(selector));\n      selectorIndex++;\n\n      if (selectorIndex > maxSelectorIndex) {\n        maxSelectorIndex = selectorIndex;\n      }\n    }\n\n    if (selectorIndex < selectors.length) {\n      let child = fiber.child;\n      while (child !== null) {\n        stack.push(child, selectorIndex);\n        child = child.sibling;\n      }\n    }\n  }\n\n  if (maxSelectorIndex < selectors.length) {\n    const unmatchedNames = [];\n    for (let i = maxSelectorIndex; i < selectors.length; i++) {\n      unmatchedNames.push(selectorToString(selectors[i]));\n    }\n\n    return (\n      'findAllNodes was able to match part of the selector:\\n' +\n      `  ${matchedNames.join(' > ')}\\n\\n` +\n      'No matching component was found for:\\n' +\n      `  ${unmatchedNames.join(' > ')}`\n    );\n  }\n\n  return null;\n}\n\nexport type BoundingRect = {|\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n|};\n\nexport function findBoundingRects(\n  hostRoot: Instance,\n  selectors: Array<Selector>,\n): Array<BoundingRect> {\n  if (!supportsTestSelectors) {\n    throw new Error('Test selector API is not supported by this renderer.');\n  }\n\n  const instanceRoots = findAllNodes(hostRoot, selectors);\n\n  const boundingRects: Array<BoundingRect> = [];\n  for (let i = 0; i < instanceRoots.length; i++) {\n    boundingRects.push(getBoundingRect(instanceRoots[i]));\n  }\n\n  for (let i = boundingRects.length - 1; i > 0; i--) {\n    const targetRect = boundingRects[i];\n    const targetLeft = targetRect.x;\n    const targetRight = targetLeft + targetRect.width;\n    const targetTop = targetRect.y;\n    const targetBottom = targetTop + targetRect.height;\n\n    for (let j = i - 1; j >= 0; j--) {\n      if (i !== j) {\n        const otherRect = boundingRects[j];\n        const otherLeft = otherRect.x;\n        const otherRight = otherLeft + otherRect.width;\n        const otherTop = otherRect.y;\n        const otherBottom = otherTop + otherRect.height;\n\n        // Merging all rects to the minimums set would be complicated,\n        // but we can handle the most common cases:\n        // 1. completely overlapping rects\n        // 2. adjacent rects that are the same width or height (e.g. items in a list)\n        //\n        // Even given the above constraints,\n        // we still won't end up with the fewest possible rects without doing multiple passes,\n        // but it's good enough for this purpose.\n\n        if (\n          targetLeft >= otherLeft &&\n          targetTop >= otherTop &&\n          targetRight <= otherRight &&\n          targetBottom <= otherBottom\n        ) {\n          // Complete overlapping rects; remove the inner one.\n          boundingRects.splice(i, 1);\n          break;\n        } else if (\n          targetLeft === otherLeft &&\n          targetRect.width === otherRect.width &&\n          !(otherBottom < targetTop) &&\n          !(otherTop > targetBottom)\n        ) {\n          // Adjacent vertical rects; merge them.\n          if (otherTop > targetTop) {\n            otherRect.height += otherTop - targetTop;\n            otherRect.y = targetTop;\n          }\n          if (otherBottom < targetBottom) {\n            otherRect.height = targetBottom - otherTop;\n          }\n\n          boundingRects.splice(i, 1);\n          break;\n        } else if (\n          targetTop === otherTop &&\n          targetRect.height === otherRect.height &&\n          !(otherRight < targetLeft) &&\n          !(otherLeft > targetRight)\n        ) {\n          // Adjacent horizontal rects; merge them.\n          if (otherLeft > targetLeft) {\n            otherRect.width += otherLeft - targetLeft;\n            otherRect.x = targetLeft;\n          }\n          if (otherRight < targetRight) {\n            otherRect.width = targetRight - otherLeft;\n          }\n\n          boundingRects.splice(i, 1);\n          break;\n        }\n      }\n    }\n  }\n\n  return boundingRects;\n}\n\nexport function focusWithin(\n  hostRoot: Instance,\n  selectors: Array<Selector>,\n): boolean {\n  if (!supportsTestSelectors) {\n    throw new Error('Test selector API is not supported by this renderer.');\n  }\n\n  const root = findFiberRootForHostRoot(hostRoot);\n  const matchingFibers = findPaths(root, selectors);\n\n  const stack = Array.from(matchingFibers);\n  let index = 0;\n  while (index < stack.length) {\n    const fiber = ((stack[index++]: any): Fiber);\n    if (isHiddenSubtree(fiber)) {\n      continue;\n    }\n    if (fiber.tag === HostComponent) {\n      const node = fiber.stateNode;\n      if (setFocusIfFocusable(node)) {\n        return true;\n      }\n    }\n    let child = fiber.child;\n    while (child !== null) {\n      stack.push(child);\n      child = child.sibling;\n    }\n  }\n\n  return false;\n}\n\nconst commitHooks: Array<Function> = [];\n\nexport function onCommitRoot(): void {\n  if (supportsTestSelectors) {\n    commitHooks.forEach(commitHook => commitHook());\n  }\n}\n\nexport type IntersectionObserverOptions = Object;\n\nexport type ObserveVisibleRectsCallback = (\n  intersections: Array<{ratio: number, rect: BoundingRect}>,\n) => void;\n\nexport function observeVisibleRects(\n  hostRoot: Instance,\n  selectors: Array<Selector>,\n  callback: (intersections: Array<{ratio: number, rect: BoundingRect}>) => void,\n  options?: IntersectionObserverOptions,\n): {|disconnect: () => void|} {\n  if (!supportsTestSelectors) {\n    throw new Error('Test selector API is not supported by this renderer.');\n  }\n\n  const instanceRoots = findAllNodes(hostRoot, selectors);\n\n  const {disconnect, observe, unobserve} = setupIntersectionObserver(\n    instanceRoots,\n    callback,\n    options,\n  );\n\n  // When React mutates the host environment, we may need to change what we're listening to.\n  const commitHook = () => {\n    const nextInstanceRoots = findAllNodes(hostRoot, selectors);\n\n    instanceRoots.forEach(target => {\n      if (nextInstanceRoots.indexOf(target) < 0) {\n        unobserve(target);\n      }\n    });\n\n    nextInstanceRoots.forEach(target => {\n      if (instanceRoots.indexOf(target) < 0) {\n        observe(target);\n      }\n    });\n  };\n\n  commitHooks.push(commitHook);\n\n  return {\n    disconnect: () => {\n      // Stop listening for React mutations:\n      const index = commitHooks.indexOf(commitHook);\n      if (index >= 0) {\n        commitHooks.splice(index, 1);\n      }\n\n      // Disconnect the host observer:\n      disconnect();\n    },\n  };\n}\n"]},"metadata":{},"sourceType":"module"}