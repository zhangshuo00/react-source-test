{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport { needsStateRestore, restoreStateIfNeeded } from './ReactDOMControlledComponent'; // Used as a way to call batchedUpdates when we don't have a reference to\n// the renderer. Such as when we're dispatching events or if third party\n// libraries need to call batchedUpdates. Eventually, this API will go away when\n// everything is batched by default. We'll then have a similar API to opt-out of\n// scheduled work and instead do synchronous work.\n// Defaults\n\nlet batchedUpdatesImpl = function (fn, bookkeeping) {\n  return fn(bookkeeping);\n};\n\nlet discreteUpdatesImpl = function (fn, a, b, c, d) {\n  return fn(a, b, c, d);\n};\n\nlet flushSyncImpl = function () {};\n\nlet isInsideEventHandler = false;\n\nfunction finishEventHandler() {\n  // Here we wait until all updates have propagated, which is important\n  // when using controlled components within layers:\n  // https://github.com/facebook/react/issues/1698\n  // Then we restore state of any controlled component.\n  const controlledComponentsHavePendingUpdates = needsStateRestore();\n\n  if (controlledComponentsHavePendingUpdates) {\n    // If a controlled event was fired, we may need to restore the state of\n    // the DOM node back to the controlled value. This is necessary when React\n    // bails out of the update without touching the DOM.\n    // TODO: Restore state in the microtask, after the discrete updates flush,\n    // instead of early flushing them here.\n    flushSyncImpl();\n    restoreStateIfNeeded();\n  }\n}\n\nexport function batchedUpdates(fn, a, b) {\n  if (isInsideEventHandler) {\n    // If we are currently inside another batch, we need to wait until it\n    // fully completes before restoring state.\n    return fn(a, b);\n  }\n\n  isInsideEventHandler = true;\n\n  try {\n    return batchedUpdatesImpl(fn, a, b);\n  } finally {\n    isInsideEventHandler = false;\n    finishEventHandler();\n  }\n} // TODO: Replace with flushSync\n\nexport function discreteUpdates(fn, a, b, c, d) {\n  return discreteUpdatesImpl(fn, a, b, c, d);\n}\nexport function setBatchingImplementation(_batchedUpdatesImpl, _discreteUpdatesImpl, _flushSyncImpl) {\n  batchedUpdatesImpl = _batchedUpdatesImpl;\n  discreteUpdatesImpl = _discreteUpdatesImpl;\n  flushSyncImpl = _flushSyncImpl;\n}","map":{"version":3,"sources":["/Users/zhangshuo/git/my-app/src/react/packages/react-dom/src/events/ReactDOMUpdateBatching.js"],"names":["needsStateRestore","restoreStateIfNeeded","batchedUpdatesImpl","fn","bookkeeping","discreteUpdatesImpl","a","b","c","d","flushSyncImpl","isInsideEventHandler","finishEventHandler","controlledComponentsHavePendingUpdates","batchedUpdates","discreteUpdates","setBatchingImplementation","_batchedUpdatesImpl","_discreteUpdatesImpl","_flushSyncImpl"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AAEA,SACEA,iBADF,EAEEC,oBAFF,QAGO,+BAHP,C,CAKA;AACA;AACA;AACA;AACA;AAEA;;AACA,IAAIC,kBAAkB,GAAG,UAASC,EAAT,EAAaC,WAAb,EAA0B;AACjD,SAAOD,EAAE,CAACC,WAAD,CAAT;AACD,CAFD;;AAGA,IAAIC,mBAAmB,GAAG,UAASF,EAAT,EAAaG,CAAb,EAAgBC,CAAhB,EAAmBC,CAAnB,EAAsBC,CAAtB,EAAyB;AACjD,SAAON,EAAE,CAACG,CAAD,EAAIC,CAAJ,EAAOC,CAAP,EAAUC,CAAV,CAAT;AACD,CAFD;;AAGA,IAAIC,aAAa,GAAG,YAAW,CAAE,CAAjC;;AAEA,IAAIC,oBAAoB,GAAG,KAA3B;;AAEA,SAASC,kBAAT,GAA8B;AAC5B;AACA;AACA;AACA;AACA,QAAMC,sCAAsC,GAAGb,iBAAiB,EAAhE;;AACA,MAAIa,sCAAJ,EAA4C;AAC1C;AACA;AACA;AACA;AACA;AACAH,IAAAA,aAAa;AACbT,IAAAA,oBAAoB;AACrB;AACF;;AAED,OAAO,SAASa,cAAT,CAAwBX,EAAxB,EAA4BG,CAA5B,EAA+BC,CAA/B,EAAkC;AACvC,MAAII,oBAAJ,EAA0B;AACxB;AACA;AACA,WAAOR,EAAE,CAACG,CAAD,EAAIC,CAAJ,CAAT;AACD;;AACDI,EAAAA,oBAAoB,GAAG,IAAvB;;AACA,MAAI;AACF,WAAOT,kBAAkB,CAACC,EAAD,EAAKG,CAAL,EAAQC,CAAR,CAAzB;AACD,GAFD,SAEU;AACRI,IAAAA,oBAAoB,GAAG,KAAvB;AACAC,IAAAA,kBAAkB;AACnB;AACF,C,CAED;;AACA,OAAO,SAASG,eAAT,CAAyBZ,EAAzB,EAA6BG,CAA7B,EAAgCC,CAAhC,EAAmCC,CAAnC,EAAsCC,CAAtC,EAAyC;AAC9C,SAAOJ,mBAAmB,CAACF,EAAD,EAAKG,CAAL,EAAQC,CAAR,EAAWC,CAAX,EAAcC,CAAd,CAA1B;AACD;AAED,OAAO,SAASO,yBAAT,CACLC,mBADK,EAELC,oBAFK,EAGLC,cAHK,EAIL;AACAjB,EAAAA,kBAAkB,GAAGe,mBAArB;AACAZ,EAAAA,mBAAmB,GAAGa,oBAAtB;AACAR,EAAAA,aAAa,GAAGS,cAAhB;AACD","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {\n  needsStateRestore,\n  restoreStateIfNeeded,\n} from './ReactDOMControlledComponent';\n\n// Used as a way to call batchedUpdates when we don't have a reference to\n// the renderer. Such as when we're dispatching events or if third party\n// libraries need to call batchedUpdates. Eventually, this API will go away when\n// everything is batched by default. We'll then have a similar API to opt-out of\n// scheduled work and instead do synchronous work.\n\n// Defaults\nlet batchedUpdatesImpl = function(fn, bookkeeping) {\n  return fn(bookkeeping);\n};\nlet discreteUpdatesImpl = function(fn, a, b, c, d) {\n  return fn(a, b, c, d);\n};\nlet flushSyncImpl = function() {};\n\nlet isInsideEventHandler = false;\n\nfunction finishEventHandler() {\n  // Here we wait until all updates have propagated, which is important\n  // when using controlled components within layers:\n  // https://github.com/facebook/react/issues/1698\n  // Then we restore state of any controlled component.\n  const controlledComponentsHavePendingUpdates = needsStateRestore();\n  if (controlledComponentsHavePendingUpdates) {\n    // If a controlled event was fired, we may need to restore the state of\n    // the DOM node back to the controlled value. This is necessary when React\n    // bails out of the update without touching the DOM.\n    // TODO: Restore state in the microtask, after the discrete updates flush,\n    // instead of early flushing them here.\n    flushSyncImpl();\n    restoreStateIfNeeded();\n  }\n}\n\nexport function batchedUpdates(fn, a, b) {\n  if (isInsideEventHandler) {\n    // If we are currently inside another batch, we need to wait until it\n    // fully completes before restoring state.\n    return fn(a, b);\n  }\n  isInsideEventHandler = true;\n  try {\n    return batchedUpdatesImpl(fn, a, b);\n  } finally {\n    isInsideEventHandler = false;\n    finishEventHandler();\n  }\n}\n\n// TODO: Replace with flushSync\nexport function discreteUpdates(fn, a, b, c, d) {\n  return discreteUpdatesImpl(fn, a, b, c, d);\n}\n\nexport function setBatchingImplementation(\n  _batchedUpdatesImpl,\n  _discreteUpdatesImpl,\n  _flushSyncImpl,\n) {\n  batchedUpdatesImpl = _batchedUpdatesImpl;\n  discreteUpdatesImpl = _discreteUpdatesImpl;\n  flushSyncImpl = _flushSyncImpl;\n}\n"]},"metadata":{},"sourceType":"module"}