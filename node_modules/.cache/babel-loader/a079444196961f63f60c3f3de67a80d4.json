{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { REACT_LAZY_TYPE } from 'shared/ReactSymbols';\nconst Uninitialized = -1;\nconst Pending = 0;\nconst Resolved = 1;\nconst Rejected = 2;\n\nfunction lazyInitializer(payload) {\n  if (payload._status === Uninitialized) {\n    const ctor = payload._result;\n    const thenable = ctor(); // Transition to the next state.\n    // This might throw either because it's missing or throws. If so, we treat it\n    // as still uninitialized and try again next time. Which is the same as what\n    // happens if the ctor or any wrappers processing the ctor throws. This might\n    // end up fixing it if the resolution was a concurrency bug.\n\n    thenable.then(moduleObject => {\n      if (payload._status === Pending || payload._status === Uninitialized) {\n        // Transition to the next state.\n        const resolved = payload;\n        resolved._status = Resolved;\n        resolved._result = moduleObject;\n      }\n    }, error => {\n      if (payload._status === Pending || payload._status === Uninitialized) {\n        // Transition to the next state.\n        const rejected = payload;\n        rejected._status = Rejected;\n        rejected._result = error;\n      }\n    });\n\n    if (payload._status === Uninitialized) {\n      // In case, we're still uninitialized, then we're waiting for the thenable\n      // to resolve. Set it as pending in the meantime.\n      const pending = payload;\n      pending._status = Pending;\n      pending._result = thenable;\n    }\n  }\n\n  if (payload._status === Resolved) {\n    const moduleObject = payload._result;\n\n    if (__DEV__) {\n      if (moduleObject === undefined) {\n        console.error('lazy: Expected the result of a dynamic imp' + 'ort() call. ' + 'Instead received: %s\\n\\nYour code should look like: \\n  ' + // Break up imports to avoid accidentally parsing them as dependencies.\n        'const MyComponent = lazy(() => imp' + \"ort('./MyComponent'))\\n\\n\" + 'Did you accidentally put curly braces around the import?', moduleObject);\n      }\n    }\n\n    if (__DEV__) {\n      if (!('default' in moduleObject)) {\n        console.error('lazy: Expected the result of a dynamic imp' + 'ort() call. ' + 'Instead received: %s\\n\\nYour code should look like: \\n  ' + // Break up imports to avoid accidentally parsing them as dependencies.\n        'const MyComponent = lazy(() => imp' + \"ort('./MyComponent'))\", moduleObject);\n      }\n    }\n\n    return moduleObject.default;\n  } else {\n    throw payload._result;\n  }\n}\n\nexport function lazy(ctor) {\n  const payload = {\n    // We use these fields to store the result.\n    _status: Uninitialized,\n    _result: ctor\n  };\n  const lazyType = {\n    $$typeof: REACT_LAZY_TYPE,\n    _payload: payload,\n    _init: lazyInitializer\n  };\n\n  if (__DEV__) {\n    // In production, this would just set it on the object.\n    let defaultProps;\n    let propTypes; // $FlowFixMe\n\n    Object.defineProperties(lazyType, {\n      defaultProps: {\n        configurable: true,\n\n        get() {\n          return defaultProps;\n        },\n\n        set(newDefaultProps) {\n          console.error('React.lazy(...): It is not supported to assign `defaultProps` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');\n          defaultProps = newDefaultProps; // Match production behavior more closely:\n          // $FlowFixMe\n\n          Object.defineProperty(lazyType, 'defaultProps', {\n            enumerable: true\n          });\n        }\n\n      },\n      propTypes: {\n        configurable: true,\n\n        get() {\n          return propTypes;\n        },\n\n        set(newPropTypes) {\n          console.error('React.lazy(...): It is not supported to assign `propTypes` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');\n          propTypes = newPropTypes; // Match production behavior more closely:\n          // $FlowFixMe\n\n          Object.defineProperty(lazyType, 'propTypes', {\n            enumerable: true\n          });\n        }\n\n      }\n    });\n  }\n\n  return lazyType;\n}","map":{"version":3,"sources":["/Users/zhangshuo/git/react-source-test/src/react/packages/react/src/ReactLazy.js"],"names":["REACT_LAZY_TYPE","Uninitialized","Pending","Resolved","Rejected","lazyInitializer","payload","_status","ctor","_result","thenable","then","moduleObject","resolved","error","rejected","pending","__DEV__","undefined","console","default","lazy","lazyType","$$typeof","_payload","_init","defaultProps","propTypes","Object","defineProperties","configurable","get","set","newDefaultProps","defineProperty","enumerable","newPropTypes"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Wakeable, Thenable} from 'shared/ReactTypes';\n\nimport {REACT_LAZY_TYPE} from 'shared/ReactSymbols';\n\nconst Uninitialized = -1;\nconst Pending = 0;\nconst Resolved = 1;\nconst Rejected = 2;\n\ntype UninitializedPayload<T> = {\n  _status: -1,\n  _result: () => Thenable<{default: T, ...}>,\n};\n\ntype PendingPayload = {\n  _status: 0,\n  _result: Wakeable,\n};\n\ntype ResolvedPayload<T> = {\n  _status: 1,\n  _result: {default: T},\n};\n\ntype RejectedPayload = {\n  _status: 2,\n  _result: mixed,\n};\n\ntype Payload<T> =\n  | UninitializedPayload<T>\n  | PendingPayload\n  | ResolvedPayload<T>\n  | RejectedPayload;\n\nexport type LazyComponent<T, P> = {\n  $$typeof: Symbol | number,\n  _payload: P,\n  _init: (payload: P) => T,\n};\n\nfunction lazyInitializer<T>(payload: Payload<T>): T {\n  if (payload._status === Uninitialized) {\n    const ctor = payload._result;\n    const thenable = ctor();\n    // Transition to the next state.\n    // This might throw either because it's missing or throws. If so, we treat it\n    // as still uninitialized and try again next time. Which is the same as what\n    // happens if the ctor or any wrappers processing the ctor throws. This might\n    // end up fixing it if the resolution was a concurrency bug.\n    thenable.then(\n      moduleObject => {\n        if (payload._status === Pending || payload._status === Uninitialized) {\n          // Transition to the next state.\n          const resolved: ResolvedPayload<T> = (payload: any);\n          resolved._status = Resolved;\n          resolved._result = moduleObject;\n        }\n      },\n      error => {\n        if (payload._status === Pending || payload._status === Uninitialized) {\n          // Transition to the next state.\n          const rejected: RejectedPayload = (payload: any);\n          rejected._status = Rejected;\n          rejected._result = error;\n        }\n      },\n    );\n    if (payload._status === Uninitialized) {\n      // In case, we're still uninitialized, then we're waiting for the thenable\n      // to resolve. Set it as pending in the meantime.\n      const pending: PendingPayload = (payload: any);\n      pending._status = Pending;\n      pending._result = thenable;\n    }\n  }\n  if (payload._status === Resolved) {\n    const moduleObject = payload._result;\n    if (__DEV__) {\n      if (moduleObject === undefined) {\n        console.error(\n          'lazy: Expected the result of a dynamic imp' +\n            'ort() call. ' +\n            'Instead received: %s\\n\\nYour code should look like: \\n  ' +\n            // Break up imports to avoid accidentally parsing them as dependencies.\n            'const MyComponent = lazy(() => imp' +\n            \"ort('./MyComponent'))\\n\\n\" +\n            'Did you accidentally put curly braces around the import?',\n          moduleObject,\n        );\n      }\n    }\n    if (__DEV__) {\n      if (!('default' in moduleObject)) {\n        console.error(\n          'lazy: Expected the result of a dynamic imp' +\n            'ort() call. ' +\n            'Instead received: %s\\n\\nYour code should look like: \\n  ' +\n            // Break up imports to avoid accidentally parsing them as dependencies.\n            'const MyComponent = lazy(() => imp' +\n            \"ort('./MyComponent'))\",\n          moduleObject,\n        );\n      }\n    }\n    return moduleObject.default;\n  } else {\n    throw payload._result;\n  }\n}\n\nexport function lazy<T>(\n  ctor: () => Thenable<{default: T, ...}>,\n): LazyComponent<T, Payload<T>> {\n  const payload: Payload<T> = {\n    // We use these fields to store the result.\n    _status: Uninitialized,\n    _result: ctor,\n  };\n\n  const lazyType: LazyComponent<T, Payload<T>> = {\n    $$typeof: REACT_LAZY_TYPE,\n    _payload: payload,\n    _init: lazyInitializer,\n  };\n\n  if (__DEV__) {\n    // In production, this would just set it on the object.\n    let defaultProps;\n    let propTypes;\n    // $FlowFixMe\n    Object.defineProperties(lazyType, {\n      defaultProps: {\n        configurable: true,\n        get() {\n          return defaultProps;\n        },\n        set(newDefaultProps) {\n          console.error(\n            'React.lazy(...): It is not supported to assign `defaultProps` to ' +\n              'a lazy component import. Either specify them where the component ' +\n              'is defined, or create a wrapping component around it.',\n          );\n          defaultProps = newDefaultProps;\n          // Match production behavior more closely:\n          // $FlowFixMe\n          Object.defineProperty(lazyType, 'defaultProps', {\n            enumerable: true,\n          });\n        },\n      },\n      propTypes: {\n        configurable: true,\n        get() {\n          return propTypes;\n        },\n        set(newPropTypes) {\n          console.error(\n            'React.lazy(...): It is not supported to assign `propTypes` to ' +\n              'a lazy component import. Either specify them where the component ' +\n              'is defined, or create a wrapping component around it.',\n          );\n          propTypes = newPropTypes;\n          // Match production behavior more closely:\n          // $FlowFixMe\n          Object.defineProperty(lazyType, 'propTypes', {\n            enumerable: true,\n          });\n        },\n      },\n    });\n  }\n\n  return lazyType;\n}\n"]},"metadata":{},"sourceType":"module"}