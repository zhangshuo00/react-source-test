{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { warnAboutDeprecatedLifecycles, enableSuspenseServerRenderer, replayFailedUnitOfWorkWithInvokeGuardedCallback, enableCreateEventHandleAPI, enableProfilerTimer, enableProfilerCommitHooks, enableProfilerNestedUpdatePhase, enableProfilerNestedUpdateScheduledHook, deferRenderPhaseUpdateToNextBatch, enableDebugTracing, enableSchedulingProfiler, disableSchedulerTimeoutInWorkLoop, enableStrictEffects, skipUnmountedBoundaries, enableUpdaterTracking, warnOnSubscriptionInsideStartTransition, enableCache } from 'shared/ReactFeatureFlags';\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nimport is from 'shared/objectIs';\nimport { // Aliased because `act` will override and push to an internal queue\nscheduleCallback as Scheduler_scheduleCallback, cancelCallback as Scheduler_cancelCallback, shouldYield, requestPaint, now, ImmediatePriority as ImmediateSchedulerPriority, UserBlockingPriority as UserBlockingSchedulerPriority, NormalPriority as NormalSchedulerPriority, IdlePriority as IdleSchedulerPriority } from './Scheduler';\nimport { flushSyncCallbacks, flushSyncCallbacksOnlyInLegacyMode, scheduleSyncCallback, scheduleLegacySyncCallback } from './ReactFiberSyncTaskQueue.old';\nimport { logCommitStarted, logCommitStopped, logLayoutEffectsStarted, logLayoutEffectsStopped, logPassiveEffectsStarted, logPassiveEffectsStopped, logRenderStarted, logRenderStopped } from './DebugTracing';\nimport { markCommitStarted, markCommitStopped, markComponentRenderStopped, markComponentSuspended, markComponentErrored, markLayoutEffectsStarted, markLayoutEffectsStopped, markPassiveEffectsStarted, markPassiveEffectsStopped, markRenderStarted, markRenderYielded, markRenderStopped } from './SchedulingProfiler';\nimport { resetAfterCommit, scheduleTimeout, cancelTimeout, noTimeout, afterActiveInstanceBlur, clearContainer, getCurrentEventPriority, supportsMicrotasks, errorHydratingContainer, scheduleMicrotask } from './ReactFiberHostConfig';\nimport { createWorkInProgress, assignFiberPropertiesInDEV } from './ReactFiber.old';\nimport { NoMode, ProfileMode, ConcurrentMode } from './ReactTypeOfMode';\nimport { HostRoot, IndeterminateComponent, ClassComponent, SuspenseComponent, SuspenseListComponent, FunctionComponent, ForwardRef, MemoComponent, SimpleMemoComponent, Profiler } from './ReactWorkTags';\nimport { LegacyRoot } from './ReactRootTags';\nimport { NoFlags, Placement, Incomplete, StoreConsistency, HostEffectMask, Hydrating, BeforeMutationMask, MutationMask, LayoutMask, PassiveMask, MountPassiveDev, MountLayoutDev } from './ReactFiberFlags';\nimport { NoLanes, NoLane, SyncLane, NoTimestamp, claimNextTransitionLane, claimNextRetryLane, includesSomeLane, isSubsetOfLanes, mergeLanes, removeLanes, pickArbitraryLane, includesNonIdleWork, includesOnlyRetries, includesOnlyTransitions, includesBlockingLane, includesExpiredLane, getNextLanes, markStarvedLanesAsExpired, getLanesToRetrySynchronouslyOnError, getMostRecentEventTime, markRootUpdated, markRootSuspended as markRootSuspended_dontCallThisOneDirectly, markRootPinged, markRootEntangled, markRootFinished, getHighestPriorityLane, addFiberToLanesMap, movePendingFibersToMemoized } from './ReactFiberLane.old';\nimport { DiscreteEventPriority, ContinuousEventPriority, DefaultEventPriority, IdleEventPriority, getCurrentUpdatePriority, setCurrentUpdatePriority, lowerEventPriority, lanesToEventPriority } from './ReactEventPriorities.old';\nimport { requestCurrentTransition, NoTransition } from './ReactFiberTransition';\nimport { beginWork as originalBeginWork } from './ReactFiberBeginWork.old';\nimport { completeWork } from './ReactFiberCompleteWork.old';\nimport { unwindWork, unwindInterruptedWork } from './ReactFiberUnwindWork.old';\nimport { throwException, createRootErrorUpdate, createClassErrorUpdate } from './ReactFiberThrow.old';\nimport { commitBeforeMutationEffects, commitLayoutEffects, commitMutationEffects, commitPassiveEffectDurations, commitPassiveMountEffects, commitPassiveUnmountEffects, invokeLayoutEffectMountInDEV, invokePassiveEffectMountInDEV, invokeLayoutEffectUnmountInDEV, invokePassiveEffectUnmountInDEV } from './ReactFiberCommitWork.old';\nimport { enqueueUpdate } from './ReactUpdateQueue.old';\nimport { resetContextDependencies } from './ReactFiberNewContext.old';\nimport { resetHooksAfterThrow, ContextOnlyDispatcher, getIsUpdatingOpaqueValueInRenderPhaseInDEV } from './ReactFiberHooks.old';\nimport { createCapturedValue } from './ReactCapturedValue';\nimport { push as pushToStack, pop as popFromStack, createCursor } from './ReactFiberStack.old';\nimport { enqueueInterleavedUpdates } from './ReactFiberInterleavedUpdates.old';\nimport { markNestedUpdateScheduled, recordCommitTime, resetNestedUpdateFlag, startProfilerTimer, stopProfilerTimerIfRunningAndRecordDelta, syncNestedUpdateFlag } from './ReactProfilerTimer.old'; // DEV stuff\n\nimport getComponentNameFromFiber from 'react-reconciler/src/getComponentNameFromFiber';\nimport ReactStrictModeWarnings from './ReactStrictModeWarnings.old';\nimport { isRendering as ReactCurrentDebugFiberIsRenderingInDEV, current as ReactCurrentFiberCurrent, resetCurrentFiber as resetCurrentDebugFiberInDEV, setCurrentFiber as setCurrentDebugFiberInDEV } from './ReactCurrentFiber';\nimport { invokeGuardedCallback, hasCaughtError, clearCaughtError } from 'shared/ReactErrorUtils';\nimport { onCommitRoot as onCommitRootDevTools, onPostCommitRoot as onPostCommitRootDevTools, isDevToolsPresent } from './ReactFiberDevToolsHook.old';\nimport { onCommitRoot as onCommitRootTestSelector } from './ReactTestSelectors';\nimport { releaseCache } from './ReactFiberCacheComponent.old';\nimport { isLegacyActEnvironment, isConcurrentActEnvironment } from './ReactFiberAct.old';\nconst ceil = Math.ceil;\nconst {\n  ReactCurrentDispatcher,\n  ReactCurrentOwner,\n  ReactCurrentBatchConfig,\n  ReactCurrentActQueue\n} = ReactSharedInternals;\nexport const NoContext =\n/*             */\n0b0000;\nconst BatchedContext =\n/*               */\n0b0001;\nconst RenderContext =\n/*                */\n0b0010;\nconst CommitContext =\n/*                */\n0b0100;\nexport const RetryAfterError =\n/*       */\n0b1000;\nconst RootIncomplete = 0;\nconst RootFatalErrored = 1;\nconst RootErrored = 2;\nconst RootSuspended = 3;\nconst RootSuspendedWithDelay = 4;\nconst RootCompleted = 5; // Describes where we are in the React execution stack\n\nlet executionContext = NoContext; // The root we're working on\n\nlet workInProgressRoot = null; // The fiber we're working on\n\nlet workInProgress = null; // The lanes we're rendering\n\nlet workInProgressRootRenderLanes = NoLanes; // Stack that allows components to change the render lanes for its subtree\n// This is a superset of the lanes we started working on at the root. The only\n// case where it's different from `workInProgressRootRenderLanes` is when we\n// enter a subtree that is hidden and needs to be unhidden: Suspense and\n// Offscreen component.\n//\n// Most things in the work loop should deal with workInProgressRootRenderLanes.\n// Most things in begin/complete phases should deal with subtreeRenderLanes.\n\nexport let subtreeRenderLanes = NoLanes;\nconst subtreeRenderLanesCursor = createCursor(NoLanes); // Whether to root completed, errored, suspended, etc.\n\nlet workInProgressRootExitStatus = RootIncomplete; // A fatal error, if one is thrown\n\nlet workInProgressRootFatalError = null; // \"Included\" lanes refer to lanes that were worked on during this render. It's\n// slightly different than `renderLanes` because `renderLanes` can change as you\n// enter and exit an Offscreen tree. This value is the combination of all render\n// lanes for the entire render phase.\n\nlet workInProgressRootIncludedLanes = NoLanes; // The work left over by components that were visited during this render. Only\n// includes unprocessed updates, not work in bailed out children.\n\nlet workInProgressRootSkippedLanes = NoLanes; // Lanes that were updated (in an interleaved event) during this render.\n\nlet workInProgressRootInterleavedUpdatedLanes = NoLanes; // Lanes that were updated during the render phase (*not* an interleaved event).\n\nlet workInProgressRootRenderPhaseUpdatedLanes = NoLanes; // Lanes that were pinged (in an interleaved event) during this render.\n\nlet workInProgressRootPingedLanes = NoLanes; // The most recent time we committed a fallback. This lets us ensure a train\n// model where we don't commit new loading states in too quick succession.\n\nlet globalMostRecentFallbackTime = 0;\nconst FALLBACK_THROTTLE_MS = 500; // The absolute time for when we should start giving up on rendering\n// more and prefer CPU suspense heuristics instead.\n\nlet workInProgressRootRenderTargetTime = Infinity; // How long a render is supposed to take before we start following CPU\n// suspense heuristics and opt out of rendering more content.\n\nconst RENDER_TIMEOUT_MS = 500;\n\nfunction resetRenderTimer() {\n  workInProgressRootRenderTargetTime = now() + RENDER_TIMEOUT_MS;\n}\n\nexport function getRenderTargetTime() {\n  return workInProgressRootRenderTargetTime;\n}\nlet hasUncaughtError = false;\nlet firstUncaughtError = null;\nlet legacyErrorBoundariesThatAlreadyFailed = null; // Only used when enableProfilerNestedUpdateScheduledHook is true;\n// to track which root is currently committing layout effects.\n\nlet rootCommittingMutationOrLayoutEffects = null;\nlet rootDoesHavePassiveEffects = false;\nlet rootWithPendingPassiveEffects = null;\nlet pendingPassiveEffectsLanes = NoLanes;\nlet pendingPassiveProfilerEffects = [];\nlet pendingPassiveEffectsRemainingLanes = NoLanes; // Use these to prevent an infinite loop of nested updates\n\nconst NESTED_UPDATE_LIMIT = 50;\nlet nestedUpdateCount = 0;\nlet rootWithNestedUpdates = null;\nconst NESTED_PASSIVE_UPDATE_LIMIT = 50;\nlet nestedPassiveUpdateCount = 0; // If two updates are scheduled within the same event, we should treat their\n// event times as simultaneous, even if the actual clock time has advanced\n// between the first and second call.\n\nlet currentEventTime = NoTimestamp;\nlet currentEventTransitionLane = NoLanes;\nexport function getWorkInProgressRoot() {\n  return workInProgressRoot;\n}\nexport function requestEventTime() {\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n    // We're inside React, so it's fine to read the actual time.\n    return now();\n  } // We're not inside React, so we may be in the middle of a browser event.\n\n\n  if (currentEventTime !== NoTimestamp) {\n    // Use the same start time for all updates until we enter React again.\n    return currentEventTime;\n  } // This is the first update since React yielded. Compute a new start time.\n\n\n  currentEventTime = now();\n  return currentEventTime;\n}\nexport function getCurrentTime() {\n  return now();\n}\nexport function requestUpdateLane(fiber) {\n  // Special cases\n  const mode = fiber.mode;\n\n  if ((mode & ConcurrentMode) === NoMode) {\n    return SyncLane;\n  } else if (!deferRenderPhaseUpdateToNextBatch && (executionContext & RenderContext) !== NoContext && workInProgressRootRenderLanes !== NoLanes) {\n    // This is a render phase update. These are not officially supported. The\n    // old behavior is to give this the same \"thread\" (lanes) as\n    // whatever is currently rendering. So if you call `setState` on a component\n    // that happens later in the same render, it will flush. Ideally, we want to\n    // remove the special case and treat them as if they came from an\n    // interleaved event. Regardless, this pattern is not officially supported.\n    // This behavior is only a fallback. The flag only exists until we can roll\n    // out the setState warning, since existing code might accidentally rely on\n    // the current behavior.\n    return pickArbitraryLane(workInProgressRootRenderLanes);\n  }\n\n  const isTransition = requestCurrentTransition() !== NoTransition;\n\n  if (isTransition) {\n    if (__DEV__ && warnOnSubscriptionInsideStartTransition && ReactCurrentBatchConfig._updatedFibers) {\n      ReactCurrentBatchConfig._updatedFibers.add(fiber);\n    } // The algorithm for assigning an update to a lane should be stable for all\n    // updates at the same priority within the same event. To do this, the\n    // inputs to the algorithm must be the same.\n    //\n    // The trick we use is to cache the first of each of these inputs within an\n    // event. Then reset the cached values once we can be sure the event is\n    // over. Our heuristic for that is whenever we enter a concurrent work loop.\n\n\n    if (currentEventTransitionLane === NoLane) {\n      // All transitions within the same event are assigned the same lane.\n      currentEventTransitionLane = claimNextTransitionLane();\n    }\n\n    return currentEventTransitionLane;\n  } // Updates originating inside certain React methods, like flushSync, have\n  // their priority set by tracking it with a context variable.\n  //\n  // The opaque type returned by the host config is internally a lane, so we can\n  // use that directly.\n  // TODO: Move this type conversion to the event priority module.\n\n\n  const updateLane = getCurrentUpdatePriority();\n\n  if (updateLane !== NoLane) {\n    return updateLane;\n  } // This update originated outside React. Ask the host environment for an\n  // appropriate priority, based on the type of event.\n  //\n  // The opaque type returned by the host config is internally a lane, so we can\n  // use that directly.\n  // TODO: Move this type conversion to the event priority module.\n\n\n  const eventLane = getCurrentEventPriority();\n  return eventLane;\n}\n\nfunction requestRetryLane(fiber) {\n  // This is a fork of `requestUpdateLane` designed specifically for Suspense\n  // \"retries\" â€” a special update that attempts to flip a Suspense boundary\n  // from its placeholder state to its primary/resolved state.\n  // Special cases\n  const mode = fiber.mode;\n\n  if ((mode & ConcurrentMode) === NoMode) {\n    return SyncLane;\n  }\n\n  return claimNextRetryLane();\n}\n\nexport function scheduleUpdateOnFiber(fiber, lane, eventTime) {\n  checkForNestedUpdates();\n  const root = markUpdateLaneFromFiberToRoot(fiber, lane);\n\n  if (root === null) {\n    return null;\n  } // Mark that the root has a pending update.\n\n\n  markRootUpdated(root, lane, eventTime);\n\n  if ((executionContext & RenderContext) !== NoLanes && root === workInProgressRoot) {\n    // This update was dispatched during the render phase. This is a mistake\n    // if the update originates from user space (with the exception of local\n    // hook updates, which are handled differently and don't reach this\n    // function), but there are some internal React features that use this as\n    // an implementation detail, like selective hydration.\n    warnAboutRenderPhaseUpdatesInDEV(fiber); // Track lanes that were updated during the render phase\n\n    workInProgressRootRenderPhaseUpdatedLanes = mergeLanes(workInProgressRootRenderPhaseUpdatedLanes, lane);\n  } else {\n    // This is a normal update, scheduled from outside the render phase. For\n    // example, during an input event.\n    if (enableUpdaterTracking) {\n      if (isDevToolsPresent) {\n        addFiberToLanesMap(root, fiber, lane);\n      }\n    }\n\n    warnIfUpdatesNotWrappedWithActDEV(fiber);\n\n    if (enableProfilerTimer && enableProfilerNestedUpdateScheduledHook) {\n      if ((executionContext & CommitContext) !== NoContext && root === rootCommittingMutationOrLayoutEffects) {\n        if (fiber.mode & ProfileMode) {\n          let current = fiber;\n\n          while (current !== null) {\n            if (current.tag === Profiler) {\n              const {\n                id,\n                onNestedUpdateScheduled\n              } = current.memoizedProps;\n\n              if (typeof onNestedUpdateScheduled === 'function') {\n                onNestedUpdateScheduled(id);\n              }\n            }\n\n            current = current.return;\n          }\n        }\n      }\n    } // TODO: Consolidate with `isInterleavedUpdate` check\n\n\n    if (root === workInProgressRoot) {\n      // Received an update to a tree that's in the middle of rendering. Mark\n      // that there was an interleaved update work on this root. Unless the\n      // `deferRenderPhaseUpdateToNextBatch` flag is off and this is a render\n      // phase update. In that case, we don't treat render phase updates as if\n      // they were interleaved, for backwards compat reasons.\n      if (deferRenderPhaseUpdateToNextBatch || (executionContext & RenderContext) === NoContext) {\n        workInProgressRootInterleavedUpdatedLanes = mergeLanes(workInProgressRootInterleavedUpdatedLanes, lane);\n      }\n\n      if (workInProgressRootExitStatus === RootSuspendedWithDelay) {\n        // The root already suspended with a delay, which means this render\n        // definitely won't finish. Since we have a new update, let's mark it as\n        // suspended now, right before marking the incoming update. This has the\n        // effect of interrupting the current render and switching to the update.\n        // TODO: Make sure this doesn't override pings that happen while we've\n        // already started rendering.\n        markRootSuspended(root, workInProgressRootRenderLanes);\n      }\n    }\n\n    ensureRootIsScheduled(root, eventTime);\n\n    if (lane === SyncLane && executionContext === NoContext && (fiber.mode & ConcurrentMode) === NoMode && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.\n    !(__DEV__ && ReactCurrentActQueue.isBatchingLegacy)) {\n      // Flush the synchronous work now, unless we're already working or inside\n      // a batch. This is intentionally inside scheduleUpdateOnFiber instead of\n      // scheduleCallbackForFiber to preserve the ability to schedule a callback\n      // without immediately flushing it. We only do this for user-initiated\n      // updates, to preserve historical behavior of legacy mode.\n      resetRenderTimer();\n      flushSyncCallbacksOnlyInLegacyMode();\n    }\n  }\n\n  return root;\n} // This is split into a separate function so we can mark a fiber with pending\n// work without treating it as a typical update that originates from an event;\n// e.g. retrying a Suspense boundary isn't an update, but it does schedule work\n// on a fiber.\n\nfunction markUpdateLaneFromFiberToRoot(sourceFiber, lane) {\n  // Update the source fiber's lanes\n  sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);\n  let alternate = sourceFiber.alternate;\n\n  if (alternate !== null) {\n    alternate.lanes = mergeLanes(alternate.lanes, lane);\n  }\n\n  if (__DEV__) {\n    if (alternate === null && (sourceFiber.flags & (Placement | Hydrating)) !== NoFlags) {\n      warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\n    }\n  } // Walk the parent path to the root and update the child lanes.\n\n\n  let node = sourceFiber;\n  let parent = sourceFiber.return;\n\n  while (parent !== null) {\n    parent.childLanes = mergeLanes(parent.childLanes, lane);\n    alternate = parent.alternate;\n\n    if (alternate !== null) {\n      alternate.childLanes = mergeLanes(alternate.childLanes, lane);\n    } else {\n      if (__DEV__) {\n        if ((parent.flags & (Placement | Hydrating)) !== NoFlags) {\n          warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\n        }\n      }\n    }\n\n    node = parent;\n    parent = parent.return;\n  }\n\n  if (node.tag === HostRoot) {\n    const root = node.stateNode;\n    return root;\n  } else {\n    return null;\n  }\n}\n\nexport function isInterleavedUpdate(fiber, lane) {\n  return (// TODO: Optimize slightly by comparing to root that fiber belongs to.\n    // Requires some refactoring. Not a big deal though since it's rare for\n    // concurrent apps to have more than a single root.\n    workInProgressRoot !== null && (fiber.mode & ConcurrentMode) !== NoMode && ( // If this is a render phase update (i.e. UNSAFE_componentWillReceiveProps),\n    // then don't treat this as an interleaved update. This pattern is\n    // accompanied by a warning but we haven't fully deprecated it yet. We can\n    // remove once the deferRenderPhaseUpdateToNextBatch flag is enabled.\n    deferRenderPhaseUpdateToNextBatch || (executionContext & RenderContext) === NoContext)\n  );\n} // Use this function to schedule a task for a root. There's only one task per\n// root; if a task was already scheduled, we'll check to make sure the priority\n// of the existing task is the same as the priority of the next level that the\n// root has work on. This function is called on every update, and right before\n// exiting a task.\n\nfunction ensureRootIsScheduled(root, currentTime) {\n  const existingCallbackNode = root.callbackNode; // Check if any lanes are being starved by other work. If so, mark them as\n  // expired so we know to work on those next.\n\n  markStarvedLanesAsExpired(root, currentTime); // Determine the next lanes to work on, and their priority.\n\n  const nextLanes = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);\n\n  if (nextLanes === NoLanes) {\n    // Special case: There's nothing to work on.\n    if (existingCallbackNode !== null) {\n      cancelCallback(existingCallbackNode);\n    }\n\n    root.callbackNode = null;\n    root.callbackPriority = NoLane;\n    return;\n  } // We use the highest priority lane to represent the priority of the callback.\n\n\n  const newCallbackPriority = getHighestPriorityLane(nextLanes); // Check if there's an existing task. We may be able to reuse it.\n\n  const existingCallbackPriority = root.callbackPriority;\n\n  if (existingCallbackPriority === newCallbackPriority && // Special case related to `act`. If the currently scheduled task is a\n  // Scheduler task, rather than an `act` task, cancel it and re-scheduled\n  // on the `act` queue.\n  !(__DEV__ && ReactCurrentActQueue.current !== null && existingCallbackNode !== fakeActCallbackNode)) {\n    if (__DEV__) {\n      // If we're going to re-use an existing task, it needs to exist.\n      // Assume that discrete update microtasks are non-cancellable and null.\n      // TODO: Temporary until we confirm this warning is not fired.\n      if (existingCallbackNode == null && existingCallbackPriority !== SyncLane) {\n        console.error('Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.');\n      }\n    } // The priority hasn't changed. We can reuse the existing task. Exit.\n\n\n    return;\n  }\n\n  if (existingCallbackNode != null) {\n    // Cancel the existing callback. We'll schedule a new one below.\n    cancelCallback(existingCallbackNode);\n  } // Schedule a new callback.\n\n\n  let newCallbackNode;\n\n  if (newCallbackPriority === SyncLane) {\n    // Special case: Sync React callbacks are scheduled on a special\n    // internal queue\n    if (root.tag === LegacyRoot) {\n      if (__DEV__ && ReactCurrentActQueue.isBatchingLegacy !== null) {\n        ReactCurrentActQueue.didScheduleLegacyUpdate = true;\n      }\n\n      scheduleLegacySyncCallback(performSyncWorkOnRoot.bind(null, root));\n    } else {\n      scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root));\n    }\n\n    if (supportsMicrotasks) {\n      // Flush the queue in a microtask.\n      if (__DEV__ && ReactCurrentActQueue.current !== null) {\n        // Inside `act`, use our internal `act` queue so that these get flushed\n        // at the end of the current scope even when using the sync version\n        // of `act`.\n        ReactCurrentActQueue.current.push(flushSyncCallbacks);\n      } else {\n        scheduleMicrotask(flushSyncCallbacks);\n      }\n    } else {\n      // Flush the queue in an Immediate task.\n      scheduleCallback(ImmediateSchedulerPriority, flushSyncCallbacks);\n    }\n\n    newCallbackNode = null;\n  } else {\n    let schedulerPriorityLevel;\n\n    switch (lanesToEventPriority(nextLanes)) {\n      case DiscreteEventPriority:\n        schedulerPriorityLevel = ImmediateSchedulerPriority;\n        break;\n\n      case ContinuousEventPriority:\n        schedulerPriorityLevel = UserBlockingSchedulerPriority;\n        break;\n\n      case DefaultEventPriority:\n        schedulerPriorityLevel = NormalSchedulerPriority;\n        break;\n\n      case IdleEventPriority:\n        schedulerPriorityLevel = IdleSchedulerPriority;\n        break;\n\n      default:\n        schedulerPriorityLevel = NormalSchedulerPriority;\n        break;\n    }\n\n    newCallbackNode = scheduleCallback(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root));\n  }\n\n  root.callbackPriority = newCallbackPriority;\n  root.callbackNode = newCallbackNode;\n} // This is the entry point for every concurrent task, i.e. anything that\n// goes through Scheduler.\n\n\nfunction performConcurrentWorkOnRoot(root, didTimeout) {\n  if (enableProfilerTimer && enableProfilerNestedUpdatePhase) {\n    resetNestedUpdateFlag();\n  } // Since we know we're in a React event, we can clear the current\n  // event time. The next update will compute a new event time.\n\n\n  currentEventTime = NoTimestamp;\n  currentEventTransitionLane = NoLanes;\n\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n    throw new Error('Should not already be working.');\n  } // Flush any pending passive effects before deciding which lanes to work on,\n  // in case they schedule additional work.\n\n\n  const originalCallbackNode = root.callbackNode;\n  const didFlushPassiveEffects = flushPassiveEffects();\n\n  if (didFlushPassiveEffects) {\n    // Something in the passive effect phase may have canceled the current task.\n    // Check if the task node for this root was changed.\n    if (root.callbackNode !== originalCallbackNode) {\n      // The current task was canceled. Exit. We don't need to call\n      // `ensureRootIsScheduled` because the check above implies either that\n      // there's a new task, or that there's no remaining work on this root.\n      return null;\n    } else {// Current task was not canceled. Continue.\n    }\n  } // Determine the next lanes to work on, using the fields stored\n  // on the root.\n\n\n  let lanes = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);\n\n  if (lanes === NoLanes) {\n    // Defensive coding. This is never expected to happen.\n    return null;\n  } // We disable time-slicing in some cases: if the work has been CPU-bound\n  // for too long (\"expired\" work, to prevent starvation), or we're in\n  // sync-updates-by-default mode.\n  // TODO: We only check `didTimeout` defensively, to account for a Scheduler\n  // bug we're still investigating. Once the bug in Scheduler is fixed,\n  // we can remove this, since we track expiration ourselves.\n\n\n  const shouldTimeSlice = !includesBlockingLane(root, lanes) && !includesExpiredLane(root, lanes) && (disableSchedulerTimeoutInWorkLoop || !didTimeout);\n  let exitStatus = shouldTimeSlice ? renderRootConcurrent(root, lanes) : renderRootSync(root, lanes);\n\n  if (exitStatus !== RootIncomplete) {\n    if (exitStatus === RootErrored) {\n      // If something threw an error, try rendering one more time. We'll\n      // render synchronously to block concurrent data mutations, and we'll\n      // includes all pending updates are included. If it still fails after\n      // the second attempt, we'll give up and commit the resulting tree.\n      const errorRetryLanes = getLanesToRetrySynchronouslyOnError(root);\n\n      if (errorRetryLanes !== NoLanes) {\n        lanes = errorRetryLanes;\n        exitStatus = recoverFromConcurrentError(root, errorRetryLanes);\n      }\n    }\n\n    if (exitStatus === RootFatalErrored) {\n      const fatalError = workInProgressRootFatalError;\n      prepareFreshStack(root, NoLanes);\n      markRootSuspended(root, lanes);\n      ensureRootIsScheduled(root, now());\n      throw fatalError;\n    } // Check if this render may have yielded to a concurrent event, and if so,\n    // confirm that any newly rendered stores are consistent.\n    // TODO: It's possible that even a concurrent render may never have yielded\n    // to the main thread, if it was fast enough, or if it expired. We could\n    // skip the consistency check in that case, too.\n\n\n    const renderWasConcurrent = !includesBlockingLane(root, lanes);\n    const finishedWork = root.current.alternate;\n\n    if (renderWasConcurrent && !isRenderConsistentWithExternalStores(finishedWork)) {\n      // A store was mutated in an interleaved event. Render again,\n      // synchronously, to block further mutations.\n      exitStatus = renderRootSync(root, lanes); // We need to check again if something threw\n\n      if (exitStatus === RootErrored) {\n        const errorRetryLanes = getLanesToRetrySynchronouslyOnError(root);\n\n        if (errorRetryLanes !== NoLanes) {\n          lanes = errorRetryLanes;\n          exitStatus = recoverFromConcurrentError(root, errorRetryLanes); // We assume the tree is now consistent because we didn't yield to any\n          // concurrent events.\n        }\n      }\n\n      if (exitStatus === RootFatalErrored) {\n        const fatalError = workInProgressRootFatalError;\n        prepareFreshStack(root, NoLanes);\n        markRootSuspended(root, lanes);\n        ensureRootIsScheduled(root, now());\n        throw fatalError;\n      }\n    } // We now have a consistent tree. The next step is either to commit it,\n    // or, if something suspended, wait to commit it after a timeout.\n\n\n    root.finishedWork = finishedWork;\n    root.finishedLanes = lanes;\n    finishConcurrentRender(root, exitStatus, lanes);\n  }\n\n  ensureRootIsScheduled(root, now());\n\n  if (root.callbackNode === originalCallbackNode) {\n    // The task node scheduled for this root is the same one that's\n    // currently executed. Need to return a continuation.\n    return performConcurrentWorkOnRoot.bind(null, root);\n  }\n\n  return null;\n}\n\nfunction recoverFromConcurrentError(root, errorRetryLanes) {\n  const prevExecutionContext = executionContext;\n  executionContext |= RetryAfterError; // If an error occurred during hydration, discard server response and fall\n  // back to client side render.\n\n  if (root.isDehydrated) {\n    root.isDehydrated = false;\n\n    if (__DEV__) {\n      errorHydratingContainer(root.containerInfo);\n    }\n\n    clearContainer(root.containerInfo);\n  }\n\n  let exitStatus;\n  const MAX_ERROR_RETRY_ATTEMPTS = 50;\n\n  for (let i = 0; i < MAX_ERROR_RETRY_ATTEMPTS; i++) {\n    exitStatus = renderRootSync(root, errorRetryLanes);\n\n    if (exitStatus === RootErrored && workInProgressRootRenderPhaseUpdatedLanes !== NoLanes) {\n      // There was a render phase update during this render. Some internal React\n      // implementation details may use this as a trick to schedule another\n      // render pass. To protect against an inifinite loop, eventually\n      // we'll give up.\n      continue;\n    }\n\n    break;\n  }\n\n  executionContext = prevExecutionContext;\n  return exitStatus;\n}\n\nfunction finishConcurrentRender(root, exitStatus, lanes) {\n  switch (exitStatus) {\n    case RootIncomplete:\n    case RootFatalErrored:\n      {\n        throw new Error('Root did not complete. This is a bug in React.');\n      }\n    // Flow knows about invariant, so it complains if I add a break\n    // statement, but eslint doesn't know about invariant, so it complains\n    // if I do. eslint-disable-next-line no-fallthrough\n\n    case RootErrored:\n      {\n        // We should have already attempted to retry this tree. If we reached\n        // this point, it errored again. Commit it.\n        commitRoot(root);\n        break;\n      }\n\n    case RootSuspended:\n      {\n        markRootSuspended(root, lanes); // We have an acceptable loading state. We need to figure out if we\n        // should immediately commit it or wait a bit.\n\n        if (includesOnlyRetries(lanes) && // do not delay if we're inside an act() scope\n        !shouldForceFlushFallbacksInDEV()) {\n          // This render only included retries, no updates. Throttle committing\n          // retries so that we don't show too many loading states too quickly.\n          const msUntilTimeout = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now(); // Don't bother with a very short suspense time.\n\n          if (msUntilTimeout > 10) {\n            const nextLanes = getNextLanes(root, NoLanes);\n\n            if (nextLanes !== NoLanes) {\n              // There's additional work on this root.\n              break;\n            }\n\n            const suspendedLanes = root.suspendedLanes;\n\n            if (!isSubsetOfLanes(suspendedLanes, lanes)) {\n              // We should prefer to render the fallback of at the last\n              // suspended level. Ping the last suspended level to try\n              // rendering it again.\n              // FIXME: What if the suspended lanes are Idle? Should not restart.\n              const eventTime = requestEventTime();\n              markRootPinged(root, suspendedLanes, eventTime);\n              break;\n            } // The render is suspended, it hasn't timed out, and there's no\n            // lower priority work to do. Instead of committing the fallback\n            // immediately, wait for more data to arrive.\n\n\n            root.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root), msUntilTimeout);\n            break;\n          }\n        } // The work expired. Commit immediately.\n\n\n        commitRoot(root);\n        break;\n      }\n\n    case RootSuspendedWithDelay:\n      {\n        markRootSuspended(root, lanes);\n\n        if (includesOnlyTransitions(lanes)) {\n          // This is a transition, so we should exit without committing a\n          // placeholder and without scheduling a timeout. Delay indefinitely\n          // until we receive more data.\n          break;\n        }\n\n        if (!shouldForceFlushFallbacksInDEV()) {\n          // This is not a transition, but we did trigger an avoided state.\n          // Schedule a placeholder to display after a short delay, using the Just\n          // Noticeable Difference.\n          // TODO: Is the JND optimization worth the added complexity? If this is\n          // the only reason we track the event time, then probably not.\n          // Consider removing.\n          const mostRecentEventTime = getMostRecentEventTime(root, lanes);\n          const eventTimeMs = mostRecentEventTime;\n          const timeElapsedMs = now() - eventTimeMs;\n          const msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs; // Don't bother with a very short suspense time.\n\n          if (msUntilTimeout > 10) {\n            // Instead of committing the fallback immediately, wait for more data\n            // to arrive.\n            root.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root), msUntilTimeout);\n            break;\n          }\n        } // Commit the placeholder.\n\n\n        commitRoot(root);\n        break;\n      }\n\n    case RootCompleted:\n      {\n        // The work completed. Ready to commit.\n        commitRoot(root);\n        break;\n      }\n\n    default:\n      {\n        throw new Error('Unknown root exit status.');\n      }\n  }\n}\n\nfunction isRenderConsistentWithExternalStores(finishedWork) {\n  // Search the rendered tree for external store reads, and check whether the\n  // stores were mutated in a concurrent event. Intentionally using an iterative\n  // loop instead of recursion so we can exit early.\n  let node = finishedWork;\n\n  while (true) {\n    if (node.flags & StoreConsistency) {\n      const updateQueue = node.updateQueue;\n\n      if (updateQueue !== null) {\n        const checks = updateQueue.stores;\n\n        if (checks !== null) {\n          for (let i = 0; i < checks.length; i++) {\n            const check = checks[i];\n            const getSnapshot = check.getSnapshot;\n            const renderedValue = check.value;\n\n            try {\n              if (!is(getSnapshot(), renderedValue)) {\n                // Found an inconsistent store.\n                return false;\n              }\n            } catch (error) {\n              // If `getSnapshot` throws, return `false`. This will schedule\n              // a re-render, and the error will be rethrown during render.\n              return false;\n            }\n          }\n        }\n      }\n    }\n\n    const child = node.child;\n\n    if (node.subtreeFlags & StoreConsistency && child !== null) {\n      child.return = node;\n      node = child;\n      continue;\n    }\n\n    if (node === finishedWork) {\n      return true;\n    }\n\n    while (node.sibling === null) {\n      if (node.return === null || node.return === finishedWork) {\n        return true;\n      }\n\n      node = node.return;\n    }\n\n    node.sibling.return = node.return;\n    node = node.sibling;\n  } // Flow doesn't know this is unreachable, but eslint does\n  // eslint-disable-next-line no-unreachable\n\n\n  return true;\n}\n\nfunction markRootSuspended(root, suspendedLanes) {\n  // When suspending, we should always exclude lanes that were pinged or (more\n  // rarely, since we try to avoid it) updated during the render phase.\n  // TODO: Lol maybe there's a better way to factor this besides this\n  // obnoxiously named function :)\n  suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);\n  suspendedLanes = removeLanes(suspendedLanes, workInProgressRootInterleavedUpdatedLanes);\n  markRootSuspended_dontCallThisOneDirectly(root, suspendedLanes);\n} // This is the entry point for synchronous tasks that don't go\n// through Scheduler\n\n\nfunction performSyncWorkOnRoot(root) {\n  if (enableProfilerTimer && enableProfilerNestedUpdatePhase) {\n    syncNestedUpdateFlag();\n  }\n\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n    throw new Error('Should not already be working.');\n  }\n\n  flushPassiveEffects();\n  let lanes = getNextLanes(root, NoLanes);\n\n  if (!includesSomeLane(lanes, SyncLane)) {\n    // There's no remaining sync work left.\n    ensureRootIsScheduled(root, now());\n    return null;\n  }\n\n  let exitStatus = renderRootSync(root, lanes);\n\n  if (root.tag !== LegacyRoot && exitStatus === RootErrored) {\n    // If something threw an error, try rendering one more time. We'll render\n    // synchronously to block concurrent data mutations, and we'll includes\n    // all pending updates are included. If it still fails after the second\n    // attempt, we'll give up and commit the resulting tree.\n    const errorRetryLanes = getLanesToRetrySynchronouslyOnError(root);\n\n    if (errorRetryLanes !== NoLanes) {\n      lanes = errorRetryLanes;\n      exitStatus = recoverFromConcurrentError(root, errorRetryLanes);\n    }\n  }\n\n  if (exitStatus === RootFatalErrored) {\n    const fatalError = workInProgressRootFatalError;\n    prepareFreshStack(root, NoLanes);\n    markRootSuspended(root, lanes);\n    ensureRootIsScheduled(root, now());\n    throw fatalError;\n  } // We now have a consistent tree. Because this is a sync render, we\n  // will commit it even if something suspended.\n\n\n  const finishedWork = root.current.alternate;\n  root.finishedWork = finishedWork;\n  root.finishedLanes = lanes;\n  commitRoot(root); // Before exiting, make sure there's a callback scheduled for the next\n  // pending level.\n\n  ensureRootIsScheduled(root, now());\n  return null;\n}\n\nexport function flushRoot(root, lanes) {\n  if (lanes !== NoLanes) {\n    markRootEntangled(root, mergeLanes(lanes, SyncLane));\n    ensureRootIsScheduled(root, now());\n\n    if ((executionContext & (RenderContext | CommitContext)) === NoContext) {\n      resetRenderTimer();\n      flushSyncCallbacks();\n    }\n  }\n}\nexport function getExecutionContext() {\n  return executionContext;\n}\nexport function deferredUpdates(fn) {\n  const previousPriority = getCurrentUpdatePriority();\n  const prevTransition = ReactCurrentBatchConfig.transition;\n\n  try {\n    ReactCurrentBatchConfig.transition = 0;\n    setCurrentUpdatePriority(DefaultEventPriority);\n    return fn();\n  } finally {\n    setCurrentUpdatePriority(previousPriority);\n    ReactCurrentBatchConfig.transition = prevTransition;\n  }\n}\nexport function batchedUpdates(fn, a) {\n  const prevExecutionContext = executionContext;\n  executionContext |= BatchedContext;\n\n  try {\n    return fn(a);\n  } finally {\n    executionContext = prevExecutionContext; // If there were legacy sync updates, flush them at the end of the outer\n    // most batchedUpdates-like method.\n\n    if (executionContext === NoContext && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.\n    !(__DEV__ && ReactCurrentActQueue.isBatchingLegacy)) {\n      resetRenderTimer();\n      flushSyncCallbacksOnlyInLegacyMode();\n    }\n  }\n}\nexport function discreteUpdates(fn, a, b, c, d) {\n  const previousPriority = getCurrentUpdatePriority();\n  const prevTransition = ReactCurrentBatchConfig.transition;\n\n  try {\n    ReactCurrentBatchConfig.transition = 0;\n    setCurrentUpdatePriority(DiscreteEventPriority);\n    return fn(a, b, c, d);\n  } finally {\n    setCurrentUpdatePriority(previousPriority);\n    ReactCurrentBatchConfig.transition = prevTransition;\n\n    if (executionContext === NoContext) {\n      resetRenderTimer();\n    }\n  }\n} // Overload the definition to the two valid signatures.\n// Warning, this opts-out of checking the function body.\n\n// eslint-disable-next-line no-redeclare\nexport function flushSync(fn) {\n  // In legacy mode, we flush pending passive effects at the beginning of the\n  // next event, not at the end of the previous one.\n  if (rootWithPendingPassiveEffects !== null && rootWithPendingPassiveEffects.tag === LegacyRoot && (executionContext & (RenderContext | CommitContext)) === NoContext) {\n    flushPassiveEffects();\n  }\n\n  const prevExecutionContext = executionContext;\n  executionContext |= BatchedContext;\n  const prevTransition = ReactCurrentBatchConfig.transition;\n  const previousPriority = getCurrentUpdatePriority();\n\n  try {\n    ReactCurrentBatchConfig.transition = 0;\n    setCurrentUpdatePriority(DiscreteEventPriority);\n\n    if (fn) {\n      return fn();\n    } else {\n      return undefined;\n    }\n  } finally {\n    setCurrentUpdatePriority(previousPriority);\n    ReactCurrentBatchConfig.transition = prevTransition;\n    executionContext = prevExecutionContext; // Flush the immediate callbacks that were scheduled during this batch.\n    // Note that this will happen even if batchedUpdates is higher up\n    // the stack.\n\n    if ((executionContext & (RenderContext | CommitContext)) === NoContext) {\n      flushSyncCallbacks();\n    }\n  }\n}\nexport function isAlreadyRendering() {\n  // Used by the renderer to print a warning if certain APIs are called from\n  // the wrong context.\n  return __DEV__ && (executionContext & (RenderContext | CommitContext)) !== NoContext;\n}\nexport function flushControlled(fn) {\n  const prevExecutionContext = executionContext;\n  executionContext |= BatchedContext;\n  const prevTransition = ReactCurrentBatchConfig.transition;\n  const previousPriority = getCurrentUpdatePriority();\n\n  try {\n    ReactCurrentBatchConfig.transition = 0;\n    setCurrentUpdatePriority(DiscreteEventPriority);\n    fn();\n  } finally {\n    setCurrentUpdatePriority(previousPriority);\n    ReactCurrentBatchConfig.transition = prevTransition;\n    executionContext = prevExecutionContext;\n\n    if (executionContext === NoContext) {\n      // Flush the immediate callbacks that were scheduled during this batch\n      resetRenderTimer();\n      flushSyncCallbacks();\n    }\n  }\n}\nexport function pushRenderLanes(fiber, lanes) {\n  pushToStack(subtreeRenderLanesCursor, subtreeRenderLanes, fiber);\n  subtreeRenderLanes = mergeLanes(subtreeRenderLanes, lanes);\n  workInProgressRootIncludedLanes = mergeLanes(workInProgressRootIncludedLanes, lanes);\n}\nexport function popRenderLanes(fiber) {\n  subtreeRenderLanes = subtreeRenderLanesCursor.current;\n  popFromStack(subtreeRenderLanesCursor, fiber);\n}\n\nfunction prepareFreshStack(root, lanes) {\n  root.finishedWork = null;\n  root.finishedLanes = NoLanes;\n  const timeoutHandle = root.timeoutHandle;\n\n  if (timeoutHandle !== noTimeout) {\n    // The root previous suspended and scheduled a timeout to commit a fallback\n    // state. Now that we have additional work, cancel the timeout.\n    root.timeoutHandle = noTimeout; // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above\n\n    cancelTimeout(timeoutHandle);\n  }\n\n  if (workInProgress !== null) {\n    let interruptedWork = workInProgress.return;\n\n    while (interruptedWork !== null) {\n      unwindInterruptedWork(interruptedWork, workInProgressRootRenderLanes);\n      interruptedWork = interruptedWork.return;\n    }\n  }\n\n  workInProgressRoot = root;\n  workInProgress = createWorkInProgress(root.current, null);\n  workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;\n  workInProgressRootExitStatus = RootIncomplete;\n  workInProgressRootFatalError = null;\n  workInProgressRootSkippedLanes = NoLanes;\n  workInProgressRootInterleavedUpdatedLanes = NoLanes;\n  workInProgressRootRenderPhaseUpdatedLanes = NoLanes;\n  workInProgressRootPingedLanes = NoLanes;\n  enqueueInterleavedUpdates();\n\n  if (__DEV__) {\n    ReactStrictModeWarnings.discardPendingWarnings();\n  }\n}\n\nfunction handleError(root, thrownValue) {\n  do {\n    let erroredWork = workInProgress;\n\n    try {\n      // Reset module-level state that was set during the render phase.\n      resetContextDependencies();\n      resetHooksAfterThrow();\n      resetCurrentDebugFiberInDEV(); // TODO: I found and added this missing line while investigating a\n      // separate issue. Write a regression test using string refs.\n\n      ReactCurrentOwner.current = null;\n\n      if (erroredWork === null || erroredWork.return === null) {\n        // Expected to be working on a non-root fiber. This is a fatal error\n        // because there's no ancestor that can handle it; the root is\n        // supposed to capture all errors that weren't caught by an error\n        // boundary.\n        workInProgressRootExitStatus = RootFatalErrored;\n        workInProgressRootFatalError = thrownValue; // Set `workInProgress` to null. This represents advancing to the next\n        // sibling, or the parent if there are no siblings. But since the root\n        // has no siblings nor a parent, we set it to null. Usually this is\n        // handled by `completeUnitOfWork` or `unwindWork`, but since we're\n        // intentionally not calling those, we need set it here.\n        // TODO: Consider calling `unwindWork` to pop the contexts.\n\n        workInProgress = null;\n        return;\n      }\n\n      if (enableProfilerTimer && erroredWork.mode & ProfileMode) {\n        // Record the time spent rendering before an error was thrown. This\n        // avoids inaccurate Profiler durations in the case of a\n        // suspended render.\n        stopProfilerTimerIfRunningAndRecordDelta(erroredWork, true);\n      }\n\n      if (enableSchedulingProfiler) {\n        markComponentRenderStopped();\n\n        if (thrownValue !== null && typeof thrownValue === 'object' && typeof thrownValue.then === 'function') {\n          const wakeable = thrownValue;\n          markComponentSuspended(erroredWork, wakeable, workInProgressRootRenderLanes);\n        } else {\n          markComponentErrored(erroredWork, thrownValue, workInProgressRootRenderLanes);\n        }\n      }\n\n      throwException(root, erroredWork.return, erroredWork, thrownValue, workInProgressRootRenderLanes);\n      completeUnitOfWork(erroredWork);\n    } catch (yetAnotherThrownValue) {\n      // Something in the return path also threw.\n      thrownValue = yetAnotherThrownValue;\n\n      if (workInProgress === erroredWork && erroredWork !== null) {\n        // If this boundary has already errored, then we had trouble processing\n        // the error. Bubble it to the next boundary.\n        erroredWork = erroredWork.return;\n        workInProgress = erroredWork;\n      } else {\n        erroredWork = workInProgress;\n      }\n\n      continue;\n    } // Return to the normal work loop.\n\n\n    return;\n  } while (true);\n}\n\nfunction pushDispatcher() {\n  const prevDispatcher = ReactCurrentDispatcher.current;\n  ReactCurrentDispatcher.current = ContextOnlyDispatcher;\n\n  if (prevDispatcher === null) {\n    // The React isomorphic package does not include a default dispatcher.\n    // Instead the first renderer will lazily attach one, in order to give\n    // nicer error messages.\n    return ContextOnlyDispatcher;\n  } else {\n    return prevDispatcher;\n  }\n}\n\nfunction popDispatcher(prevDispatcher) {\n  ReactCurrentDispatcher.current = prevDispatcher;\n}\n\nexport function markCommitTimeOfFallback() {\n  globalMostRecentFallbackTime = now();\n}\nexport function markSkippedUpdateLanes(lane) {\n  workInProgressRootSkippedLanes = mergeLanes(lane, workInProgressRootSkippedLanes);\n}\nexport function renderDidSuspend() {\n  if (workInProgressRootExitStatus === RootIncomplete) {\n    workInProgressRootExitStatus = RootSuspended;\n  }\n}\nexport function renderDidSuspendDelayIfPossible() {\n  if (workInProgressRootExitStatus === RootIncomplete || workInProgressRootExitStatus === RootSuspended || workInProgressRootExitStatus === RootErrored) {\n    workInProgressRootExitStatus = RootSuspendedWithDelay;\n  } // Check if there are updates that we skipped tree that might have unblocked\n  // this render.\n\n\n  if (workInProgressRoot !== null && (includesNonIdleWork(workInProgressRootSkippedLanes) || includesNonIdleWork(workInProgressRootInterleavedUpdatedLanes))) {\n    // Mark the current render as suspended so that we switch to working on\n    // the updates that were skipped. Usually we only suspend at the end of\n    // the render phase.\n    // TODO: We should probably always mark the root as suspended immediately\n    // (inside this function), since by suspending at the end of the render\n    // phase introduces a potential mistake where we suspend lanes that were\n    // pinged or updated while we were rendering.\n    markRootSuspended(workInProgressRoot, workInProgressRootRenderLanes);\n  }\n}\nexport function renderDidError() {\n  if (workInProgressRootExitStatus !== RootSuspendedWithDelay) {\n    workInProgressRootExitStatus = RootErrored;\n  }\n} // Called during render to determine if anything has suspended.\n// Returns false if we're not sure.\n\nexport function renderHasNotSuspendedYet() {\n  // If something errored or completed, we can't really be sure,\n  // so those are false.\n  return workInProgressRootExitStatus === RootIncomplete;\n}\n\nfunction renderRootSync(root, lanes) {\n  const prevExecutionContext = executionContext;\n  executionContext |= RenderContext;\n  const prevDispatcher = pushDispatcher(); // If the root or lanes have changed, throw out the existing stack\n  // and prepare a fresh one. Otherwise we'll continue where we left off.\n\n  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\n    if (enableUpdaterTracking) {\n      if (isDevToolsPresent) {\n        const memoizedUpdaters = root.memoizedUpdaters;\n\n        if (memoizedUpdaters.size > 0) {\n          restorePendingUpdaters(root, workInProgressRootRenderLanes);\n          memoizedUpdaters.clear();\n        } // At this point, move Fibers that scheduled the upcoming work from the Map to the Set.\n        // If we bailout on this work, we'll move them back (like above).\n        // It's important to move them now in case the work spawns more work at the same priority with different updaters.\n        // That way we can keep the current update and future updates separate.\n\n\n        movePendingFibersToMemoized(root, lanes);\n      }\n    }\n\n    prepareFreshStack(root, lanes);\n  }\n\n  if (__DEV__) {\n    if (enableDebugTracing) {\n      logRenderStarted(lanes);\n    }\n  }\n\n  if (enableSchedulingProfiler) {\n    markRenderStarted(lanes);\n  }\n\n  do {\n    try {\n      workLoopSync();\n      break;\n    } catch (thrownValue) {\n      handleError(root, thrownValue);\n    }\n  } while (true);\n\n  resetContextDependencies();\n  executionContext = prevExecutionContext;\n  popDispatcher(prevDispatcher);\n\n  if (workInProgress !== null) {\n    // This is a sync render, so we should have finished the whole tree.\n    throw new Error('Cannot commit an incomplete root. This error is likely caused by a ' + 'bug in React. Please file an issue.');\n  }\n\n  if (__DEV__) {\n    if (enableDebugTracing) {\n      logRenderStopped();\n    }\n  }\n\n  if (enableSchedulingProfiler) {\n    markRenderStopped();\n  } // Set this to null to indicate there's no in-progress render.\n\n\n  workInProgressRoot = null;\n  workInProgressRootRenderLanes = NoLanes;\n  return workInProgressRootExitStatus;\n} // The work loop is an extremely hot path. Tell Closure not to inline it.\n\n/** @noinline */\n\n\nfunction workLoopSync() {\n  // Already timed out, so perform work without checking if we need to yield.\n  while (workInProgress !== null) {\n    performUnitOfWork(workInProgress);\n  }\n}\n\nfunction renderRootConcurrent(root, lanes) {\n  const prevExecutionContext = executionContext;\n  executionContext |= RenderContext;\n  const prevDispatcher = pushDispatcher(); // If the root or lanes have changed, throw out the existing stack\n  // and prepare a fresh one. Otherwise we'll continue where we left off.\n\n  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\n    if (enableUpdaterTracking) {\n      if (isDevToolsPresent) {\n        const memoizedUpdaters = root.memoizedUpdaters;\n\n        if (memoizedUpdaters.size > 0) {\n          restorePendingUpdaters(root, workInProgressRootRenderLanes);\n          memoizedUpdaters.clear();\n        } // At this point, move Fibers that scheduled the upcoming work from the Map to the Set.\n        // If we bailout on this work, we'll move them back (like above).\n        // It's important to move them now in case the work spawns more work at the same priority with different updaters.\n        // That way we can keep the current update and future updates separate.\n\n\n        movePendingFibersToMemoized(root, lanes);\n      }\n    }\n\n    resetRenderTimer();\n    prepareFreshStack(root, lanes);\n  }\n\n  if (__DEV__) {\n    if (enableDebugTracing) {\n      logRenderStarted(lanes);\n    }\n  }\n\n  if (enableSchedulingProfiler) {\n    markRenderStarted(lanes);\n  }\n\n  do {\n    try {\n      workLoopConcurrent();\n      break;\n    } catch (thrownValue) {\n      handleError(root, thrownValue);\n    }\n  } while (true);\n\n  resetContextDependencies();\n  popDispatcher(prevDispatcher);\n  executionContext = prevExecutionContext;\n\n  if (__DEV__) {\n    if (enableDebugTracing) {\n      logRenderStopped();\n    }\n  } // Check if the tree has completed.\n\n\n  if (workInProgress !== null) {\n    // Still work remaining.\n    if (enableSchedulingProfiler) {\n      markRenderYielded();\n    }\n\n    return RootIncomplete;\n  } else {\n    // Completed the tree.\n    if (enableSchedulingProfiler) {\n      markRenderStopped();\n    } // Set this to null to indicate there's no in-progress render.\n\n\n    workInProgressRoot = null;\n    workInProgressRootRenderLanes = NoLanes; // Return the final exit status.\n\n    return workInProgressRootExitStatus;\n  }\n}\n/** @noinline */\n\n\nfunction workLoopConcurrent() {\n  // Perform work until Scheduler asks us to yield\n  while (workInProgress !== null && !shouldYield()) {\n    performUnitOfWork(workInProgress);\n  }\n}\n\nfunction performUnitOfWork(unitOfWork) {\n  // The current, flushed, state of this fiber is the alternate. Ideally\n  // nothing should rely on this, but relying on it here means that we don't\n  // need an additional field on the work in progress.\n  const current = unitOfWork.alternate;\n  setCurrentDebugFiberInDEV(unitOfWork);\n  let next;\n\n  if (enableProfilerTimer && (unitOfWork.mode & ProfileMode) !== NoMode) {\n    startProfilerTimer(unitOfWork);\n    next = beginWork(current, unitOfWork, subtreeRenderLanes);\n    stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);\n  } else {\n    next = beginWork(current, unitOfWork, subtreeRenderLanes);\n  }\n\n  resetCurrentDebugFiberInDEV();\n  unitOfWork.memoizedProps = unitOfWork.pendingProps;\n\n  if (next === null) {\n    // If this doesn't spawn new work, complete the current work.\n    completeUnitOfWork(unitOfWork);\n  } else {\n    workInProgress = next;\n  }\n\n  ReactCurrentOwner.current = null;\n}\n\nfunction completeUnitOfWork(unitOfWork) {\n  // Attempt to complete the current unit of work, then move to the next\n  // sibling. If there are no more siblings, return to the parent fiber.\n  let completedWork = unitOfWork;\n\n  do {\n    // The current, flushed, state of this fiber is the alternate. Ideally\n    // nothing should rely on this, but relying on it here means that we don't\n    // need an additional field on the work in progress.\n    const current = completedWork.alternate;\n    const returnFiber = completedWork.return; // Check if the work completed or if something threw.\n\n    if ((completedWork.flags & Incomplete) === NoFlags) {\n      setCurrentDebugFiberInDEV(completedWork);\n      let next;\n\n      if (!enableProfilerTimer || (completedWork.mode & ProfileMode) === NoMode) {\n        next = completeWork(current, completedWork, subtreeRenderLanes);\n      } else {\n        startProfilerTimer(completedWork);\n        next = completeWork(current, completedWork, subtreeRenderLanes); // Update render duration assuming we didn't error.\n\n        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);\n      }\n\n      resetCurrentDebugFiberInDEV();\n\n      if (next !== null) {\n        // Completing this fiber spawned new work. Work on that next.\n        workInProgress = next;\n        return;\n      }\n    } else {\n      // This fiber did not complete because something threw. Pop values off\n      // the stack without entering the complete phase. If this is a boundary,\n      // capture values if possible.\n      const next = unwindWork(completedWork, subtreeRenderLanes); // Because this fiber did not complete, don't reset its lanes.\n\n      if (next !== null) {\n        // If completing this work spawned new work, do that next. We'll come\n        // back here again.\n        // Since we're restarting, remove anything that is not a host effect\n        // from the effect tag.\n        next.flags &= HostEffectMask;\n        workInProgress = next;\n        return;\n      }\n\n      if (enableProfilerTimer && (completedWork.mode & ProfileMode) !== NoMode) {\n        // Record the render duration for the fiber that errored.\n        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false); // Include the time spent working on failed children before continuing.\n\n        let actualDuration = completedWork.actualDuration;\n        let child = completedWork.child;\n\n        while (child !== null) {\n          actualDuration += child.actualDuration;\n          child = child.sibling;\n        }\n\n        completedWork.actualDuration = actualDuration;\n      }\n\n      if (returnFiber !== null) {\n        // Mark the parent fiber as incomplete and clear its subtree flags.\n        returnFiber.flags |= Incomplete;\n        returnFiber.subtreeFlags = NoFlags;\n        returnFiber.deletions = null;\n      }\n    }\n\n    const siblingFiber = completedWork.sibling;\n\n    if (siblingFiber !== null) {\n      // If there is more work to do in this returnFiber, do that next.\n      workInProgress = siblingFiber;\n      return;\n    } // Otherwise, return to the parent\n\n\n    completedWork = returnFiber; // Update the next thing we're working on in case something throws.\n\n    workInProgress = completedWork;\n  } while (completedWork !== null); // We've reached the root.\n\n\n  if (workInProgressRootExitStatus === RootIncomplete) {\n    workInProgressRootExitStatus = RootCompleted;\n  }\n}\n\nfunction commitRoot(root) {\n  // TODO: This no longer makes any sense. We already wrap the mutation and\n  // layout phases. Should be able to remove.\n  const previousUpdateLanePriority = getCurrentUpdatePriority();\n  const prevTransition = ReactCurrentBatchConfig.transition;\n\n  try {\n    ReactCurrentBatchConfig.transition = 0;\n    setCurrentUpdatePriority(DiscreteEventPriority);\n    commitRootImpl(root, previousUpdateLanePriority);\n  } finally {\n    ReactCurrentBatchConfig.transition = prevTransition;\n    setCurrentUpdatePriority(previousUpdateLanePriority);\n  }\n\n  return null;\n}\n\nfunction commitRootImpl(root, renderPriorityLevel) {\n  do {\n    // `flushPassiveEffects` will call `flushSyncUpdateQueue` at the end, which\n    // means `flushPassiveEffects` will sometimes result in additional\n    // passive effects. So we need to keep flushing in a loop until there are\n    // no more pending effects.\n    // TODO: Might be better if `flushPassiveEffects` did not automatically\n    // flush synchronous work at the end, to avoid factoring hazards like this.\n    flushPassiveEffects();\n  } while (rootWithPendingPassiveEffects !== null);\n\n  flushRenderPhaseStrictModeWarningsInDEV();\n\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n    throw new Error('Should not already be working.');\n  }\n\n  const finishedWork = root.finishedWork;\n  const lanes = root.finishedLanes;\n\n  if (__DEV__) {\n    if (enableDebugTracing) {\n      logCommitStarted(lanes);\n    }\n  }\n\n  if (enableSchedulingProfiler) {\n    markCommitStarted(lanes);\n  }\n\n  if (finishedWork === null) {\n    if (__DEV__) {\n      if (enableDebugTracing) {\n        logCommitStopped();\n      }\n    }\n\n    if (enableSchedulingProfiler) {\n      markCommitStopped();\n    }\n\n    return null;\n  } else {\n    if (__DEV__) {\n      if (lanes === NoLanes) {\n        console.error('root.finishedLanes should not be empty during a commit. This is a ' + 'bug in React.');\n      }\n    }\n  }\n\n  root.finishedWork = null;\n  root.finishedLanes = NoLanes;\n\n  if (finishedWork === root.current) {\n    throw new Error('Cannot commit the same tree as before. This error is likely caused by ' + 'a bug in React. Please file an issue.');\n  } // commitRoot never returns a continuation; it always finishes synchronously.\n  // So we can clear these now to allow a new callback to be scheduled.\n\n\n  root.callbackNode = null;\n  root.callbackPriority = NoLane; // Update the first and last pending times on this root. The new first\n  // pending time is whatever is left on the root fiber.\n\n  let remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);\n  markRootFinished(root, remainingLanes);\n\n  if (root === workInProgressRoot) {\n    // We can reset these now that they are finished.\n    workInProgressRoot = null;\n    workInProgress = null;\n    workInProgressRootRenderLanes = NoLanes;\n  } else {// This indicates that the last root we worked on is not the same one that\n    // we're committing now. This most commonly happens when a suspended root\n    // times out.\n  } // If there are pending passive effects, schedule a callback to process them.\n  // Do this as early as possible, so it is queued before anything else that\n  // might get scheduled in the commit phase. (See #16714.)\n  // TODO: Delete all other places that schedule the passive effect callback\n  // They're redundant.\n\n\n  if ((finishedWork.subtreeFlags & PassiveMask) !== NoFlags || (finishedWork.flags & PassiveMask) !== NoFlags) {\n    if (!rootDoesHavePassiveEffects) {\n      rootDoesHavePassiveEffects = true;\n      pendingPassiveEffectsRemainingLanes = remainingLanes;\n      scheduleCallback(NormalSchedulerPriority, () => {\n        flushPassiveEffects(); // This render triggered passive effects: release the root cache pool\n        // *after* passive effects fire to avoid freeing a cache pool that may\n        // be referenced by a node in the tree (HostRoot, Cache boundary etc)\n\n        return null;\n      });\n    }\n  } // Check if there are any effects in the whole tree.\n  // TODO: This is left over from the effect list implementation, where we had\n  // to check for the existence of `firstEffect` to satisfy Flow. I think the\n  // only other reason this optimization exists is because it affects profiling.\n  // Reconsider whether this is necessary.\n\n\n  const subtreeHasEffects = (finishedWork.subtreeFlags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;\n  const rootHasEffect = (finishedWork.flags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;\n\n  if (subtreeHasEffects || rootHasEffect) {\n    const prevTransition = ReactCurrentBatchConfig.transition;\n    ReactCurrentBatchConfig.transition = 0;\n    const previousPriority = getCurrentUpdatePriority();\n    setCurrentUpdatePriority(DiscreteEventPriority);\n    const prevExecutionContext = executionContext;\n    executionContext |= CommitContext; // Reset this to null before calling lifecycles\n\n    ReactCurrentOwner.current = null; // The commit phase is broken into several sub-phases. We do a separate pass\n    // of the effect list for each phase: all mutation effects come before all\n    // layout effects, and so on.\n    // The first phase a \"before mutation\" phase. We use this phase to read the\n    // state of the host tree right before we mutate it. This is where\n    // getSnapshotBeforeUpdate is called.\n\n    const shouldFireAfterActiveInstanceBlur = commitBeforeMutationEffects(root, finishedWork);\n\n    if (enableProfilerTimer) {\n      // Mark the current commit time to be shared by all Profilers in this\n      // batch. This enables them to be grouped later.\n      recordCommitTime();\n    }\n\n    if (enableProfilerTimer && enableProfilerNestedUpdateScheduledHook) {\n      // Track the root here, rather than in commitLayoutEffects(), because of ref setters.\n      // Updates scheduled during ref detachment should also be flagged.\n      rootCommittingMutationOrLayoutEffects = root;\n    } // The next phase is the mutation phase, where we mutate the host tree.\n\n\n    commitMutationEffects(root, finishedWork, lanes);\n\n    if (enableCreateEventHandleAPI) {\n      if (shouldFireAfterActiveInstanceBlur) {\n        afterActiveInstanceBlur();\n      }\n    }\n\n    resetAfterCommit(root.containerInfo); // The work-in-progress tree is now the current tree. This must come after\n    // the mutation phase, so that the previous tree is still current during\n    // componentWillUnmount, but before the layout phase, so that the finished\n    // work is current during componentDidMount/Update.\n\n    root.current = finishedWork; // The next phase is the layout phase, where we call effects that read\n    // the host tree after it's been mutated. The idiomatic use case for this is\n    // layout, but class component lifecycles also fire here for legacy reasons.\n\n    if (__DEV__) {\n      if (enableDebugTracing) {\n        logLayoutEffectsStarted(lanes);\n      }\n    }\n\n    if (enableSchedulingProfiler) {\n      markLayoutEffectsStarted(lanes);\n    }\n\n    commitLayoutEffects(finishedWork, root, lanes);\n\n    if (__DEV__) {\n      if (enableDebugTracing) {\n        logLayoutEffectsStopped();\n      }\n    }\n\n    if (enableSchedulingProfiler) {\n      markLayoutEffectsStopped();\n    }\n\n    if (enableProfilerTimer && enableProfilerNestedUpdateScheduledHook) {\n      rootCommittingMutationOrLayoutEffects = null;\n    } // Tell Scheduler to yield at the end of the frame, so the browser has an\n    // opportunity to paint.\n\n\n    requestPaint();\n    executionContext = prevExecutionContext; // Reset the priority to the previous non-sync value.\n\n    setCurrentUpdatePriority(previousPriority);\n    ReactCurrentBatchConfig.transition = prevTransition;\n  } else {\n    // No effects.\n    root.current = finishedWork; // Measure these anyway so the flamegraph explicitly shows that there were\n    // no effects.\n    // TODO: Maybe there's a better way to report this.\n\n    if (enableProfilerTimer) {\n      recordCommitTime();\n    }\n  }\n\n  const rootDidHavePassiveEffects = rootDoesHavePassiveEffects;\n\n  if (rootDoesHavePassiveEffects) {\n    // This commit has passive effects. Stash a reference to them. But don't\n    // schedule a callback until after flushing layout work.\n    rootDoesHavePassiveEffects = false;\n    rootWithPendingPassiveEffects = root;\n    pendingPassiveEffectsLanes = lanes;\n  } else {\n    // There were no passive effects, so we can immediately release the cache\n    // pool for this render.\n    releaseRootPooledCache(root, remainingLanes);\n  } // Read this again, since an effect might have updated it\n\n\n  remainingLanes = root.pendingLanes; // Check if there's remaining work on this root\n  // TODO: This is part of the `componentDidCatch` implementation. Its purpose\n  // is to detect whether something might have called setState inside\n  // `componentDidCatch`. The mechanism is known to be flawed because `setState`\n  // inside `componentDidCatch` is itself flawed â€” that's why we recommend\n  // `getDerivedStateFromError` instead. However, it could be improved by\n  // checking if remainingLanes includes Sync work, instead of whether there's\n  // any work remaining at all (which would also include stuff like Suspense\n  // retries or transitions). It's been like this for a while, though, so fixing\n  // it probably isn't that urgent.\n\n  if (remainingLanes === NoLanes) {\n    // If there's no remaining work, we can clear the set of already failed\n    // error boundaries.\n    legacyErrorBoundariesThatAlreadyFailed = null;\n  }\n\n  if (__DEV__ && enableStrictEffects) {\n    if (!rootDidHavePassiveEffects) {\n      commitDoubleInvokeEffectsInDEV(root.current, false);\n    }\n  }\n\n  onCommitRootDevTools(finishedWork.stateNode, renderPriorityLevel);\n\n  if (enableUpdaterTracking) {\n    if (isDevToolsPresent) {\n      root.memoizedUpdaters.clear();\n    }\n  }\n\n  if (__DEV__) {\n    onCommitRootTestSelector();\n  } // Always call this before exiting `commitRoot`, to ensure that any\n  // additional work on this root is scheduled.\n\n\n  ensureRootIsScheduled(root, now());\n\n  if (hasUncaughtError) {\n    hasUncaughtError = false;\n    const error = firstUncaughtError;\n    firstUncaughtError = null;\n    throw error;\n  } // If the passive effects are the result of a discrete render, flush them\n  // synchronously at the end of the current task so that the result is\n  // immediately observable. Otherwise, we assume that they are not\n  // order-dependent and do not need to be observed by external systems, so we\n  // can wait until after paint.\n  // TODO: We can optimize this by not scheduling the callback earlier. Since we\n  // currently schedule the callback in multiple places, will wait until those\n  // are consolidated.\n\n\n  if (includesSomeLane(pendingPassiveEffectsLanes, SyncLane) && root.tag !== LegacyRoot) {\n    flushPassiveEffects();\n  } // Read this again, since a passive effect might have updated it\n\n\n  remainingLanes = root.pendingLanes;\n\n  if (includesSomeLane(remainingLanes, SyncLane)) {\n    if (enableProfilerTimer && enableProfilerNestedUpdatePhase) {\n      markNestedUpdateScheduled();\n    } // Count the number of times the root synchronously re-renders without\n    // finishing. If there are too many, it indicates an infinite update loop.\n\n\n    if (root === rootWithNestedUpdates) {\n      nestedUpdateCount++;\n    } else {\n      nestedUpdateCount = 0;\n      rootWithNestedUpdates = root;\n    }\n  } else {\n    nestedUpdateCount = 0;\n  } // If layout work was scheduled, flush it now.\n\n\n  flushSyncCallbacks();\n\n  if (__DEV__) {\n    if (enableDebugTracing) {\n      logCommitStopped();\n    }\n  }\n\n  if (enableSchedulingProfiler) {\n    markCommitStopped();\n  }\n\n  return null;\n}\n\nfunction releaseRootPooledCache(root, remainingLanes) {\n  if (enableCache) {\n    const pooledCacheLanes = root.pooledCacheLanes &= remainingLanes;\n\n    if (pooledCacheLanes === NoLanes) {\n      // None of the remaining work relies on the cache pool. Clear it so\n      // subsequent requests get a new cache\n      const pooledCache = root.pooledCache;\n\n      if (pooledCache != null) {\n        root.pooledCache = null;\n        releaseCache(pooledCache);\n      }\n    }\n  }\n}\n\nexport function flushPassiveEffects() {\n  // Returns whether passive effects were flushed.\n  // TODO: Combine this check with the one in flushPassiveEFfectsImpl. We should\n  // probably just combine the two functions. I believe they were only separate\n  // in the first place because we used to wrap it with\n  // `Scheduler.runWithPriority`, which accepts a function. But now we track the\n  // priority within React itself, so we can mutate the variable directly.\n  if (rootWithPendingPassiveEffects !== null) {\n    // Cache the root since rootWithPendingPassiveEffects is cleared in\n    // flushPassiveEffectsImpl\n    const root = rootWithPendingPassiveEffects; // Cache and clear the remaining lanes flag; it must be reset since this\n    // method can be called from various places, not always from commitRoot\n    // where the remaining lanes are known\n\n    const remainingLanes = pendingPassiveEffectsRemainingLanes;\n    pendingPassiveEffectsRemainingLanes = NoLanes;\n    const renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes);\n    const priority = lowerEventPriority(DefaultEventPriority, renderPriority);\n    const prevTransition = ReactCurrentBatchConfig.transition;\n    const previousPriority = getCurrentUpdatePriority();\n\n    try {\n      ReactCurrentBatchConfig.transition = 0;\n      setCurrentUpdatePriority(priority);\n      return flushPassiveEffectsImpl();\n    } finally {\n      setCurrentUpdatePriority(previousPriority);\n      ReactCurrentBatchConfig.transition = prevTransition; // Once passive effects have run for the tree - giving components a\n      // chance to retain cache instances they use - release the pooled\n      // cache at the root (if there is one)\n\n      releaseRootPooledCache(root, remainingLanes);\n    }\n  }\n\n  return false;\n}\nexport function enqueuePendingPassiveProfilerEffect(fiber) {\n  if (enableProfilerTimer && enableProfilerCommitHooks) {\n    pendingPassiveProfilerEffects.push(fiber);\n\n    if (!rootDoesHavePassiveEffects) {\n      rootDoesHavePassiveEffects = true;\n      scheduleCallback(NormalSchedulerPriority, () => {\n        flushPassiveEffects();\n        return null;\n      });\n    }\n  }\n}\n\nfunction flushPassiveEffectsImpl() {\n  if (rootWithPendingPassiveEffects === null) {\n    return false;\n  }\n\n  const root = rootWithPendingPassiveEffects;\n  const lanes = pendingPassiveEffectsLanes;\n  rootWithPendingPassiveEffects = null; // TODO: This is sometimes out of sync with rootWithPendingPassiveEffects.\n  // Figure out why and fix it. It's not causing any known issues (probably\n  // because it's only used for profiling), but it's a refactor hazard.\n\n  pendingPassiveEffectsLanes = NoLanes;\n\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n    throw new Error('Cannot flush passive effects while already rendering.');\n  }\n\n  if (__DEV__) {\n    if (enableDebugTracing) {\n      logPassiveEffectsStarted(lanes);\n    }\n  }\n\n  if (enableSchedulingProfiler) {\n    markPassiveEffectsStarted(lanes);\n  }\n\n  const prevExecutionContext = executionContext;\n  executionContext |= CommitContext;\n  commitPassiveUnmountEffects(root.current);\n  commitPassiveMountEffects(root, root.current); // TODO: Move to commitPassiveMountEffects\n\n  if (enableProfilerTimer && enableProfilerCommitHooks) {\n    const profilerEffects = pendingPassiveProfilerEffects;\n    pendingPassiveProfilerEffects = [];\n\n    for (let i = 0; i < profilerEffects.length; i++) {\n      const fiber = profilerEffects[i];\n      commitPassiveEffectDurations(root, fiber);\n    }\n  }\n\n  if (__DEV__) {\n    if (enableDebugTracing) {\n      logPassiveEffectsStopped();\n    }\n  }\n\n  if (enableSchedulingProfiler) {\n    markPassiveEffectsStopped();\n  }\n\n  if (__DEV__ && enableStrictEffects) {\n    commitDoubleInvokeEffectsInDEV(root.current, true);\n  }\n\n  executionContext = prevExecutionContext;\n  flushSyncCallbacks(); // If additional passive effects were scheduled, increment a counter. If this\n  // exceeds the limit, we'll fire a warning.\n\n  nestedPassiveUpdateCount = rootWithPendingPassiveEffects === null ? 0 : nestedPassiveUpdateCount + 1; // TODO: Move to commitPassiveMountEffects\n\n  onPostCommitRootDevTools(root);\n\n  if (enableProfilerTimer && enableProfilerCommitHooks) {\n    const stateNode = root.current.stateNode;\n    stateNode.effectDuration = 0;\n    stateNode.passiveEffectDuration = 0;\n  }\n\n  return true;\n}\n\nexport function isAlreadyFailedLegacyErrorBoundary(instance) {\n  return legacyErrorBoundariesThatAlreadyFailed !== null && legacyErrorBoundariesThatAlreadyFailed.has(instance);\n}\nexport function markLegacyErrorBoundaryAsFailed(instance) {\n  if (legacyErrorBoundariesThatAlreadyFailed === null) {\n    legacyErrorBoundariesThatAlreadyFailed = new Set([instance]);\n  } else {\n    legacyErrorBoundariesThatAlreadyFailed.add(instance);\n  }\n}\n\nfunction prepareToThrowUncaughtError(error) {\n  if (!hasUncaughtError) {\n    hasUncaughtError = true;\n    firstUncaughtError = error;\n  }\n}\n\nexport const onUncaughtError = prepareToThrowUncaughtError;\n\nfunction captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {\n  const errorInfo = createCapturedValue(error, sourceFiber);\n  const update = createRootErrorUpdate(rootFiber, errorInfo, SyncLane);\n  enqueueUpdate(rootFiber, update, SyncLane);\n  const eventTime = requestEventTime();\n  const root = markUpdateLaneFromFiberToRoot(rootFiber, SyncLane);\n\n  if (root !== null) {\n    markRootUpdated(root, SyncLane, eventTime);\n    ensureRootIsScheduled(root, eventTime);\n  }\n}\n\nexport function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {\n  if (sourceFiber.tag === HostRoot) {\n    // Error was thrown at the root. There is no parent, so the root\n    // itself should capture it.\n    captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);\n    return;\n  }\n\n  let fiber = null;\n\n  if (skipUnmountedBoundaries) {\n    fiber = nearestMountedAncestor;\n  } else {\n    fiber = sourceFiber.return;\n  }\n\n  while (fiber !== null) {\n    if (fiber.tag === HostRoot) {\n      captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error);\n      return;\n    } else if (fiber.tag === ClassComponent) {\n      const ctor = fiber.type;\n      const instance = fiber.stateNode;\n\n      if (typeof ctor.getDerivedStateFromError === 'function' || typeof instance.componentDidCatch === 'function' && !isAlreadyFailedLegacyErrorBoundary(instance)) {\n        const errorInfo = createCapturedValue(error, sourceFiber);\n        const update = createClassErrorUpdate(fiber, errorInfo, SyncLane);\n        enqueueUpdate(fiber, update, SyncLane);\n        const eventTime = requestEventTime();\n        const root = markUpdateLaneFromFiberToRoot(fiber, SyncLane);\n\n        if (root !== null) {\n          markRootUpdated(root, SyncLane, eventTime);\n          ensureRootIsScheduled(root, eventTime);\n        }\n\n        return;\n      }\n    }\n\n    fiber = fiber.return;\n  }\n\n  if (__DEV__) {\n    // TODO: Until we re-land skipUnmountedBoundaries (see #20147), this warning\n    // will fire for errors that are thrown by destroy functions inside deleted\n    // trees. What it should instead do is propagate the error to the parent of\n    // the deleted tree. In the meantime, do not add this warning to the\n    // allowlist; this is only for our internal use.\n    console.error('Internal React error: Attempted to capture a commit phase error ' + 'inside a detached tree. This indicates a bug in React. Likely ' + 'causes include deleting the same fiber more than once, committing an ' + 'already-finished tree, or an inconsistent return pointer.\\n\\n' + 'Error message:\\n\\n%s', error);\n  }\n}\nexport function pingSuspendedRoot(root, wakeable, pingedLanes) {\n  const pingCache = root.pingCache;\n\n  if (pingCache !== null) {\n    // The wakeable resolved, so we no longer need to memoize, because it will\n    // never be thrown again.\n    pingCache.delete(wakeable);\n  }\n\n  const eventTime = requestEventTime();\n  markRootPinged(root, pingedLanes, eventTime);\n  warnIfSuspenseResolutionNotWrappedWithActDEV(root);\n\n  if (workInProgressRoot === root && isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)) {\n    // Received a ping at the same priority level at which we're currently\n    // rendering. We might want to restart this render. This should mirror\n    // the logic of whether or not a root suspends once it completes.\n    // TODO: If we're rendering sync either due to Sync, Batched or expired,\n    // we should probably never restart.\n    // If we're suspended with delay, or if it's a retry, we'll always suspend\n    // so we can always restart.\n    if (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && includesOnlyRetries(workInProgressRootRenderLanes) && now() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS) {\n      // Restart from the root.\n      prepareFreshStack(root, NoLanes);\n    } else {\n      // Even though we can't restart right now, we might get an\n      // opportunity later. So we mark this render as having a ping.\n      workInProgressRootPingedLanes = mergeLanes(workInProgressRootPingedLanes, pingedLanes);\n    }\n  }\n\n  ensureRootIsScheduled(root, eventTime);\n}\n\nfunction retryTimedOutBoundary(boundaryFiber, retryLane) {\n  // The boundary fiber (a Suspense component or SuspenseList component)\n  // previously was rendered in its fallback state. One of the promises that\n  // suspended it has resolved, which means at least part of the tree was\n  // likely unblocked. Try rendering again, at a new lanes.\n  if (retryLane === NoLane) {\n    // TODO: Assign this to `suspenseState.retryLane`? to avoid\n    // unnecessary entanglement?\n    retryLane = requestRetryLane(boundaryFiber);\n  } // TODO: Special case idle priority?\n\n\n  const eventTime = requestEventTime();\n  const root = markUpdateLaneFromFiberToRoot(boundaryFiber, retryLane);\n\n  if (root !== null) {\n    markRootUpdated(root, retryLane, eventTime);\n    ensureRootIsScheduled(root, eventTime);\n  }\n}\n\nexport function retryDehydratedSuspenseBoundary(boundaryFiber) {\n  const suspenseState = boundaryFiber.memoizedState;\n  let retryLane = NoLane;\n\n  if (suspenseState !== null) {\n    retryLane = suspenseState.retryLane;\n  }\n\n  retryTimedOutBoundary(boundaryFiber, retryLane);\n}\nexport function resolveRetryWakeable(boundaryFiber, wakeable) {\n  let retryLane = NoLane; // Default\n\n  let retryCache;\n\n  if (enableSuspenseServerRenderer) {\n    switch (boundaryFiber.tag) {\n      case SuspenseComponent:\n        retryCache = boundaryFiber.stateNode;\n        const suspenseState = boundaryFiber.memoizedState;\n\n        if (suspenseState !== null) {\n          retryLane = suspenseState.retryLane;\n        }\n\n        break;\n\n      case SuspenseListComponent:\n        retryCache = boundaryFiber.stateNode;\n        break;\n\n      default:\n        throw new Error('Pinged unknown suspense boundary type. ' + 'This is probably a bug in React.');\n    }\n  } else {\n    retryCache = boundaryFiber.stateNode;\n  }\n\n  if (retryCache !== null) {\n    // The wakeable resolved, so we no longer need to memoize, because it will\n    // never be thrown again.\n    retryCache.delete(wakeable);\n  }\n\n  retryTimedOutBoundary(boundaryFiber, retryLane);\n} // Computes the next Just Noticeable Difference (JND) boundary.\n// The theory is that a person can't tell the difference between small differences in time.\n// Therefore, if we wait a bit longer than necessary that won't translate to a noticeable\n// difference in the experience. However, waiting for longer might mean that we can avoid\n// showing an intermediate loading state. The longer we have already waited, the harder it\n// is to tell small differences in time. Therefore, the longer we've already waited,\n// the longer we can wait additionally. At some point we have to give up though.\n// We pick a train model where the next boundary commits at a consistent schedule.\n// These particular numbers are vague estimates. We expect to adjust them based on research.\n\nfunction jnd(timeElapsed) {\n  return timeElapsed < 120 ? 120 : timeElapsed < 480 ? 480 : timeElapsed < 1080 ? 1080 : timeElapsed < 1920 ? 1920 : timeElapsed < 3000 ? 3000 : timeElapsed < 4320 ? 4320 : ceil(timeElapsed / 1960) * 1960;\n}\n\nfunction checkForNestedUpdates() {\n  if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {\n    nestedUpdateCount = 0;\n    rootWithNestedUpdates = null;\n    throw new Error('Maximum update depth exceeded. This can happen when a component ' + 'repeatedly calls setState inside componentWillUpdate or ' + 'componentDidUpdate. React limits the number of nested updates to ' + 'prevent infinite loops.');\n  }\n\n  if (__DEV__) {\n    if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {\n      nestedPassiveUpdateCount = 0;\n      console.error('Maximum update depth exceeded. This can happen when a component ' + \"calls setState inside useEffect, but useEffect either doesn't \" + 'have a dependency array, or one of the dependencies changes on ' + 'every render.');\n    }\n  }\n}\n\nfunction flushRenderPhaseStrictModeWarningsInDEV() {\n  if (__DEV__) {\n    ReactStrictModeWarnings.flushLegacyContextWarning();\n\n    if (warnAboutDeprecatedLifecycles) {\n      ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();\n    }\n  }\n}\n\nfunction commitDoubleInvokeEffectsInDEV(fiber, hasPassiveEffects) {\n  if (__DEV__ && enableStrictEffects) {\n    // TODO (StrictEffects) Should we set a marker on the root if it contains strict effects\n    // so we don't traverse unnecessarily? similar to subtreeFlags but just at the root level.\n    // Maybe not a big deal since this is DEV only behavior.\n    setCurrentDebugFiberInDEV(fiber);\n    invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectUnmountInDEV);\n\n    if (hasPassiveEffects) {\n      invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectUnmountInDEV);\n    }\n\n    invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectMountInDEV);\n\n    if (hasPassiveEffects) {\n      invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectMountInDEV);\n    }\n\n    resetCurrentDebugFiberInDEV();\n  }\n}\n\nfunction invokeEffectsInDev(firstChild, fiberFlags, invokeEffectFn) {\n  if (__DEV__ && enableStrictEffects) {\n    // We don't need to re-check StrictEffectsMode here.\n    // This function is only called if that check has already passed.\n    let current = firstChild;\n    let subtreeRoot = null;\n\n    while (current !== null) {\n      const primarySubtreeFlag = current.subtreeFlags & fiberFlags;\n\n      if (current !== subtreeRoot && current.child !== null && primarySubtreeFlag !== NoFlags) {\n        current = current.child;\n      } else {\n        if ((current.flags & fiberFlags) !== NoFlags) {\n          invokeEffectFn(current);\n        }\n\n        if (current.sibling !== null) {\n          current = current.sibling;\n        } else {\n          current = subtreeRoot = current.return;\n        }\n      }\n    }\n  }\n}\n\nlet didWarnStateUpdateForNotYetMountedComponent = null;\n\nfunction warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {\n  if (__DEV__) {\n    if ((executionContext & RenderContext) !== NoContext) {\n      // We let the other warning about render phase updates deal with this one.\n      return;\n    }\n\n    if (!(fiber.mode & ConcurrentMode)) {\n      return;\n    }\n\n    const tag = fiber.tag;\n\n    if (tag !== IndeterminateComponent && tag !== HostRoot && tag !== ClassComponent && tag !== FunctionComponent && tag !== ForwardRef && tag !== MemoComponent && tag !== SimpleMemoComponent) {\n      // Only warn for user-defined components, not internal ones like Suspense.\n      return;\n    } // We show the whole stack but dedupe on the top component's name because\n    // the problematic code almost always lies inside that component.\n\n\n    const componentName = getComponentNameFromFiber(fiber) || 'ReactComponent';\n\n    if (didWarnStateUpdateForNotYetMountedComponent !== null) {\n      if (didWarnStateUpdateForNotYetMountedComponent.has(componentName)) {\n        return;\n      }\n\n      didWarnStateUpdateForNotYetMountedComponent.add(componentName);\n    } else {\n      didWarnStateUpdateForNotYetMountedComponent = new Set([componentName]);\n    }\n\n    const previousFiber = ReactCurrentFiberCurrent;\n\n    try {\n      setCurrentDebugFiberInDEV(fiber);\n      console.error(\"Can't perform a React state update on a component that hasn't mounted yet. \" + 'This indicates that you have a side-effect in your render function that ' + 'asynchronously later calls tries to update the component. Move this work to ' + 'useEffect instead.');\n    } finally {\n      if (previousFiber) {\n        setCurrentDebugFiberInDEV(fiber);\n      } else {\n        resetCurrentDebugFiberInDEV();\n      }\n    }\n  }\n}\n\nlet beginWork;\n\nif (__DEV__ && replayFailedUnitOfWorkWithInvokeGuardedCallback) {\n  const dummyFiber = null;\n\n  beginWork = (current, unitOfWork, lanes) => {\n    // If a component throws an error, we replay it again in a synchronously\n    // dispatched event, so that the debugger will treat it as an uncaught\n    // error See ReactErrorUtils for more information.\n    // Before entering the begin phase, copy the work-in-progress onto a dummy\n    // fiber. If beginWork throws, we'll use this to reset the state.\n    const originalWorkInProgressCopy = assignFiberPropertiesInDEV(dummyFiber, unitOfWork);\n\n    try {\n      return originalBeginWork(current, unitOfWork, lanes);\n    } catch (originalError) {\n      if (originalError !== null && typeof originalError === 'object' && typeof originalError.then === 'function') {\n        // Don't replay promises. Treat everything else like an error.\n        throw originalError;\n      } // Keep this code in sync with handleError; any changes here must have\n      // corresponding changes there.\n\n\n      resetContextDependencies();\n      resetHooksAfterThrow(); // Don't reset current debug fiber, since we're about to work on the\n      // same fiber again.\n      // Unwind the failed stack frame\n\n      unwindInterruptedWork(unitOfWork, workInProgressRootRenderLanes); // Restore the original properties of the fiber.\n\n      assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);\n\n      if (enableProfilerTimer && unitOfWork.mode & ProfileMode) {\n        // Reset the profiler timer.\n        startProfilerTimer(unitOfWork);\n      } // Run beginWork again.\n\n\n      invokeGuardedCallback(null, originalBeginWork, null, current, unitOfWork, lanes);\n\n      if (hasCaughtError()) {\n        const replayError = clearCaughtError();\n\n        if (typeof replayError === 'object' && replayError !== null && replayError._suppressLogging && typeof originalError === 'object' && originalError !== null && !originalError._suppressLogging) {\n          // If suppressed, let the flag carry over to the original error which is the one we'll rethrow.\n          originalError._suppressLogging = true;\n        }\n      } // We always throw the original error in case the second render pass is not idempotent.\n      // This can happen if a memoized function or CommonJS module doesn't throw after first invocation.\n\n\n      throw originalError;\n    }\n  };\n} else {\n  beginWork = originalBeginWork;\n}\n\nlet didWarnAboutUpdateInRender = false;\nlet didWarnAboutUpdateInRenderForAnotherComponent;\n\nif (__DEV__) {\n  didWarnAboutUpdateInRenderForAnotherComponent = new Set();\n}\n\nfunction warnAboutRenderPhaseUpdatesInDEV(fiber) {\n  if (__DEV__) {\n    if (ReactCurrentDebugFiberIsRenderingInDEV && !getIsUpdatingOpaqueValueInRenderPhaseInDEV()) {\n      switch (fiber.tag) {\n        case FunctionComponent:\n        case ForwardRef:\n        case SimpleMemoComponent:\n          {\n            const renderingComponentName = workInProgress && getComponentNameFromFiber(workInProgress) || 'Unknown'; // Dedupe by the rendering component because it's the one that needs to be fixed.\n\n            const dedupeKey = renderingComponentName;\n\n            if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {\n              didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);\n              const setStateComponentName = getComponentNameFromFiber(fiber) || 'Unknown';\n              console.error('Cannot update a component (`%s`) while rendering a ' + 'different component (`%s`). To locate the bad setState() call inside `%s`, ' + 'follow the stack trace as described in https://reactjs.org/link/setstate-in-render', setStateComponentName, renderingComponentName, renderingComponentName);\n            }\n\n            break;\n          }\n\n        case ClassComponent:\n          {\n            if (!didWarnAboutUpdateInRender) {\n              console.error('Cannot update during an existing state transition (such as ' + 'within `render`). Render methods should be a pure ' + 'function of props and state.');\n              didWarnAboutUpdateInRender = true;\n            }\n\n            break;\n          }\n      }\n    }\n  }\n}\n\nexport function restorePendingUpdaters(root, lanes) {\n  if (enableUpdaterTracking) {\n    if (isDevToolsPresent) {\n      const memoizedUpdaters = root.memoizedUpdaters;\n      memoizedUpdaters.forEach(schedulingFiber => {\n        addFiberToLanesMap(root, schedulingFiber, lanes);\n      }); // This function intentionally does not clear memoized updaters.\n      // Those may still be relevant to the current commit\n      // and a future one (e.g. Suspense).\n    }\n  }\n}\nconst fakeActCallbackNode = {};\n\nfunction scheduleCallback(priorityLevel, callback) {\n  if (__DEV__) {\n    // If we're currently inside an `act` scope, bypass Scheduler and push to\n    // the `act` queue instead.\n    const actQueue = ReactCurrentActQueue.current;\n\n    if (actQueue !== null) {\n      actQueue.push(callback);\n      return fakeActCallbackNode;\n    } else {\n      return Scheduler_scheduleCallback(priorityLevel, callback);\n    }\n  } else {\n    // In production, always call Scheduler. This function will be stripped out.\n    return Scheduler_scheduleCallback(priorityLevel, callback);\n  }\n}\n\nfunction cancelCallback(callbackNode) {\n  if (__DEV__ && callbackNode === fakeActCallbackNode) {\n    return;\n  } // In production, always call Scheduler. This function will be stripped out.\n\n\n  return Scheduler_cancelCallback(callbackNode);\n}\n\nfunction shouldForceFlushFallbacksInDEV() {\n  // Never force flush in production. This function should get stripped out.\n  return __DEV__ && ReactCurrentActQueue.current !== null;\n}\n\nfunction warnIfUpdatesNotWrappedWithActDEV(fiber) {\n  if (__DEV__) {\n    if (fiber.mode & ConcurrentMode) {\n      if (!isConcurrentActEnvironment()) {\n        // Not in an act environment. No need to warn.\n        return;\n      }\n    } else {\n      // Legacy mode has additional cases where we suppress a warning.\n      if (!isLegacyActEnvironment(fiber)) {\n        // Not in an act environment. No need to warn.\n        return;\n      }\n\n      if (executionContext !== NoContext) {\n        // Legacy mode doesn't warn if the update is batched, i.e.\n        // batchedUpdates or flushSync.\n        return;\n      }\n\n      if (fiber.tag !== FunctionComponent && fiber.tag !== ForwardRef && fiber.tag !== SimpleMemoComponent) {\n        // For backwards compatibility with pre-hooks code, legacy mode only\n        // warns for updates that originate from a hook.\n        return;\n      }\n    }\n\n    if (ReactCurrentActQueue.current === null) {\n      const previousFiber = ReactCurrentFiberCurrent;\n\n      try {\n        setCurrentDebugFiberInDEV(fiber);\n        console.error('An update to %s inside a test was not wrapped in act(...).\\n\\n' + 'When testing, code that causes React state updates should be ' + 'wrapped into act(...):\\n\\n' + 'act(() => {\\n' + '  /* fire events that update state */\\n' + '});\\n' + '/* assert on the output */\\n\\n' + \"This ensures that you're testing the behavior the user would see \" + 'in the browser.' + ' Learn more at https://reactjs.org/link/wrap-tests-with-act', getComponentNameFromFiber(fiber));\n      } finally {\n        if (previousFiber) {\n          setCurrentDebugFiberInDEV(fiber);\n        } else {\n          resetCurrentDebugFiberInDEV();\n        }\n      }\n    }\n  }\n}\n\nfunction warnIfSuspenseResolutionNotWrappedWithActDEV(root) {\n  if (__DEV__) {\n    if (root.tag !== LegacyRoot && isConcurrentActEnvironment() && ReactCurrentActQueue.current === null) {\n      console.error('A suspended resource finished loading inside a test, but the event ' + 'was not wrapped in act(...).\\n\\n' + 'When testing, code that resolves suspended data should be wrapped ' + 'into act(...):\\n\\n' + 'act(() => {\\n' + '  /* finish loading suspended data */\\n' + '});\\n' + '/* assert on the output */\\n\\n' + \"This ensures that you're testing the behavior the user would see \" + 'in the browser.' + ' Learn more at https://reactjs.org/link/wrap-tests-with-act');\n    }\n  }\n}","map":{"version":3,"sources":["/Users/zhangshuo/git/react-source-test/src/react/packages/react-reconciler/src/ReactFiberWorkLoop.old.js"],"names":["warnAboutDeprecatedLifecycles","enableSuspenseServerRenderer","replayFailedUnitOfWorkWithInvokeGuardedCallback","enableCreateEventHandleAPI","enableProfilerTimer","enableProfilerCommitHooks","enableProfilerNestedUpdatePhase","enableProfilerNestedUpdateScheduledHook","deferRenderPhaseUpdateToNextBatch","enableDebugTracing","enableSchedulingProfiler","disableSchedulerTimeoutInWorkLoop","enableStrictEffects","skipUnmountedBoundaries","enableUpdaterTracking","warnOnSubscriptionInsideStartTransition","enableCache","ReactSharedInternals","is","scheduleCallback","Scheduler_scheduleCallback","cancelCallback","Scheduler_cancelCallback","shouldYield","requestPaint","now","ImmediatePriority","ImmediateSchedulerPriority","UserBlockingPriority","UserBlockingSchedulerPriority","NormalPriority","NormalSchedulerPriority","IdlePriority","IdleSchedulerPriority","flushSyncCallbacks","flushSyncCallbacksOnlyInLegacyMode","scheduleSyncCallback","scheduleLegacySyncCallback","logCommitStarted","logCommitStopped","logLayoutEffectsStarted","logLayoutEffectsStopped","logPassiveEffectsStarted","logPassiveEffectsStopped","logRenderStarted","logRenderStopped","markCommitStarted","markCommitStopped","markComponentRenderStopped","markComponentSuspended","markComponentErrored","markLayoutEffectsStarted","markLayoutEffectsStopped","markPassiveEffectsStarted","markPassiveEffectsStopped","markRenderStarted","markRenderYielded","markRenderStopped","resetAfterCommit","scheduleTimeout","cancelTimeout","noTimeout","afterActiveInstanceBlur","clearContainer","getCurrentEventPriority","supportsMicrotasks","errorHydratingContainer","scheduleMicrotask","createWorkInProgress","assignFiberPropertiesInDEV","NoMode","ProfileMode","ConcurrentMode","HostRoot","IndeterminateComponent","ClassComponent","SuspenseComponent","SuspenseListComponent","FunctionComponent","ForwardRef","MemoComponent","SimpleMemoComponent","Profiler","LegacyRoot","NoFlags","Placement","Incomplete","StoreConsistency","HostEffectMask","Hydrating","BeforeMutationMask","MutationMask","LayoutMask","PassiveMask","MountPassiveDev","MountLayoutDev","NoLanes","NoLane","SyncLane","NoTimestamp","claimNextTransitionLane","claimNextRetryLane","includesSomeLane","isSubsetOfLanes","mergeLanes","removeLanes","pickArbitraryLane","includesNonIdleWork","includesOnlyRetries","includesOnlyTransitions","includesBlockingLane","includesExpiredLane","getNextLanes","markStarvedLanesAsExpired","getLanesToRetrySynchronouslyOnError","getMostRecentEventTime","markRootUpdated","markRootSuspended","markRootSuspended_dontCallThisOneDirectly","markRootPinged","markRootEntangled","markRootFinished","getHighestPriorityLane","addFiberToLanesMap","movePendingFibersToMemoized","DiscreteEventPriority","ContinuousEventPriority","DefaultEventPriority","IdleEventPriority","getCurrentUpdatePriority","setCurrentUpdatePriority","lowerEventPriority","lanesToEventPriority","requestCurrentTransition","NoTransition","beginWork","originalBeginWork","completeWork","unwindWork","unwindInterruptedWork","throwException","createRootErrorUpdate","createClassErrorUpdate","commitBeforeMutationEffects","commitLayoutEffects","commitMutationEffects","commitPassiveEffectDurations","commitPassiveMountEffects","commitPassiveUnmountEffects","invokeLayoutEffectMountInDEV","invokePassiveEffectMountInDEV","invokeLayoutEffectUnmountInDEV","invokePassiveEffectUnmountInDEV","enqueueUpdate","resetContextDependencies","resetHooksAfterThrow","ContextOnlyDispatcher","getIsUpdatingOpaqueValueInRenderPhaseInDEV","createCapturedValue","push","pushToStack","pop","popFromStack","createCursor","enqueueInterleavedUpdates","markNestedUpdateScheduled","recordCommitTime","resetNestedUpdateFlag","startProfilerTimer","stopProfilerTimerIfRunningAndRecordDelta","syncNestedUpdateFlag","getComponentNameFromFiber","ReactStrictModeWarnings","isRendering","ReactCurrentDebugFiberIsRenderingInDEV","current","ReactCurrentFiberCurrent","resetCurrentFiber","resetCurrentDebugFiberInDEV","setCurrentFiber","setCurrentDebugFiberInDEV","invokeGuardedCallback","hasCaughtError","clearCaughtError","onCommitRoot","onCommitRootDevTools","onPostCommitRoot","onPostCommitRootDevTools","isDevToolsPresent","onCommitRootTestSelector","releaseCache","isLegacyActEnvironment","isConcurrentActEnvironment","ceil","Math","ReactCurrentDispatcher","ReactCurrentOwner","ReactCurrentBatchConfig","ReactCurrentActQueue","NoContext","BatchedContext","RenderContext","CommitContext","RetryAfterError","RootIncomplete","RootFatalErrored","RootErrored","RootSuspended","RootSuspendedWithDelay","RootCompleted","executionContext","workInProgressRoot","workInProgress","workInProgressRootRenderLanes","subtreeRenderLanes","subtreeRenderLanesCursor","workInProgressRootExitStatus","workInProgressRootFatalError","workInProgressRootIncludedLanes","workInProgressRootSkippedLanes","workInProgressRootInterleavedUpdatedLanes","workInProgressRootRenderPhaseUpdatedLanes","workInProgressRootPingedLanes","globalMostRecentFallbackTime","FALLBACK_THROTTLE_MS","workInProgressRootRenderTargetTime","Infinity","RENDER_TIMEOUT_MS","resetRenderTimer","getRenderTargetTime","hasUncaughtError","firstUncaughtError","legacyErrorBoundariesThatAlreadyFailed","rootCommittingMutationOrLayoutEffects","rootDoesHavePassiveEffects","rootWithPendingPassiveEffects","pendingPassiveEffectsLanes","pendingPassiveProfilerEffects","pendingPassiveEffectsRemainingLanes","NESTED_UPDATE_LIMIT","nestedUpdateCount","rootWithNestedUpdates","NESTED_PASSIVE_UPDATE_LIMIT","nestedPassiveUpdateCount","currentEventTime","currentEventTransitionLane","getWorkInProgressRoot","requestEventTime","getCurrentTime","requestUpdateLane","fiber","mode","isTransition","__DEV__","_updatedFibers","add","updateLane","eventLane","requestRetryLane","scheduleUpdateOnFiber","lane","eventTime","checkForNestedUpdates","root","markUpdateLaneFromFiberToRoot","warnAboutRenderPhaseUpdatesInDEV","warnIfUpdatesNotWrappedWithActDEV","tag","id","onNestedUpdateScheduled","memoizedProps","return","ensureRootIsScheduled","isBatchingLegacy","sourceFiber","lanes","alternate","flags","warnAboutUpdateOnNotYetMountedFiberInDEV","node","parent","childLanes","stateNode","isInterleavedUpdate","currentTime","existingCallbackNode","callbackNode","nextLanes","callbackPriority","newCallbackPriority","existingCallbackPriority","fakeActCallbackNode","console","error","newCallbackNode","didScheduleLegacyUpdate","performSyncWorkOnRoot","bind","schedulerPriorityLevel","performConcurrentWorkOnRoot","didTimeout","Error","originalCallbackNode","didFlushPassiveEffects","flushPassiveEffects","shouldTimeSlice","exitStatus","renderRootConcurrent","renderRootSync","errorRetryLanes","recoverFromConcurrentError","fatalError","prepareFreshStack","renderWasConcurrent","finishedWork","isRenderConsistentWithExternalStores","finishedLanes","finishConcurrentRender","prevExecutionContext","isDehydrated","containerInfo","MAX_ERROR_RETRY_ATTEMPTS","i","commitRoot","shouldForceFlushFallbacksInDEV","msUntilTimeout","suspendedLanes","timeoutHandle","mostRecentEventTime","eventTimeMs","timeElapsedMs","jnd","updateQueue","checks","stores","length","check","getSnapshot","renderedValue","value","child","subtreeFlags","sibling","flushRoot","getExecutionContext","deferredUpdates","fn","previousPriority","prevTransition","transition","batchedUpdates","a","discreteUpdates","b","c","d","flushSync","undefined","isAlreadyRendering","flushControlled","pushRenderLanes","popRenderLanes","interruptedWork","discardPendingWarnings","handleError","thrownValue","erroredWork","then","wakeable","completeUnitOfWork","yetAnotherThrownValue","pushDispatcher","prevDispatcher","popDispatcher","markCommitTimeOfFallback","markSkippedUpdateLanes","renderDidSuspend","renderDidSuspendDelayIfPossible","renderDidError","renderHasNotSuspendedYet","memoizedUpdaters","size","restorePendingUpdaters","clear","workLoopSync","performUnitOfWork","workLoopConcurrent","unitOfWork","next","pendingProps","completedWork","returnFiber","actualDuration","deletions","siblingFiber","previousUpdateLanePriority","commitRootImpl","renderPriorityLevel","flushRenderPhaseStrictModeWarningsInDEV","remainingLanes","subtreeHasEffects","rootHasEffect","shouldFireAfterActiveInstanceBlur","rootDidHavePassiveEffects","releaseRootPooledCache","pendingLanes","commitDoubleInvokeEffectsInDEV","pooledCacheLanes","pooledCache","renderPriority","priority","flushPassiveEffectsImpl","enqueuePendingPassiveProfilerEffect","profilerEffects","effectDuration","passiveEffectDuration","isAlreadyFailedLegacyErrorBoundary","instance","has","markLegacyErrorBoundaryAsFailed","Set","prepareToThrowUncaughtError","onUncaughtError","captureCommitPhaseErrorOnRoot","rootFiber","errorInfo","update","captureCommitPhaseError","nearestMountedAncestor","ctor","type","getDerivedStateFromError","componentDidCatch","pingSuspendedRoot","pingedLanes","pingCache","delete","warnIfSuspenseResolutionNotWrappedWithActDEV","retryTimedOutBoundary","boundaryFiber","retryLane","retryDehydratedSuspenseBoundary","suspenseState","memoizedState","resolveRetryWakeable","retryCache","timeElapsed","flushLegacyContextWarning","flushPendingUnsafeLifecycleWarnings","hasPassiveEffects","invokeEffectsInDev","firstChild","fiberFlags","invokeEffectFn","subtreeRoot","primarySubtreeFlag","didWarnStateUpdateForNotYetMountedComponent","componentName","previousFiber","dummyFiber","originalWorkInProgressCopy","originalError","replayError","_suppressLogging","didWarnAboutUpdateInRender","didWarnAboutUpdateInRenderForAnotherComponent","renderingComponentName","dedupeKey","setStateComponentName","forEach","schedulingFiber","priorityLevel","callback","actQueue"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Wakeable} from 'shared/ReactTypes';\nimport type {Fiber, FiberRoot} from './ReactInternalTypes';\nimport type {Lanes, Lane} from './ReactFiberLane.old';\nimport type {SuspenseState} from './ReactFiberSuspenseComponent.old';\nimport type {StackCursor} from './ReactFiberStack.old';\nimport type {Flags} from './ReactFiberFlags';\nimport type {FunctionComponentUpdateQueue} from './ReactFiberHooks.old';\n\nimport {\n  warnAboutDeprecatedLifecycles,\n  enableSuspenseServerRenderer,\n  replayFailedUnitOfWorkWithInvokeGuardedCallback,\n  enableCreateEventHandleAPI,\n  enableProfilerTimer,\n  enableProfilerCommitHooks,\n  enableProfilerNestedUpdatePhase,\n  enableProfilerNestedUpdateScheduledHook,\n  deferRenderPhaseUpdateToNextBatch,\n  enableDebugTracing,\n  enableSchedulingProfiler,\n  disableSchedulerTimeoutInWorkLoop,\n  enableStrictEffects,\n  skipUnmountedBoundaries,\n  enableUpdaterTracking,\n  warnOnSubscriptionInsideStartTransition,\n  enableCache,\n} from 'shared/ReactFeatureFlags';\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nimport is from 'shared/objectIs';\n\nimport {\n  // Aliased because `act` will override and push to an internal queue\n  scheduleCallback as Scheduler_scheduleCallback,\n  cancelCallback as Scheduler_cancelCallback,\n  shouldYield,\n  requestPaint,\n  now,\n  ImmediatePriority as ImmediateSchedulerPriority,\n  UserBlockingPriority as UserBlockingSchedulerPriority,\n  NormalPriority as NormalSchedulerPriority,\n  IdlePriority as IdleSchedulerPriority,\n} from './Scheduler';\nimport {\n  flushSyncCallbacks,\n  flushSyncCallbacksOnlyInLegacyMode,\n  scheduleSyncCallback,\n  scheduleLegacySyncCallback,\n} from './ReactFiberSyncTaskQueue.old';\nimport {\n  logCommitStarted,\n  logCommitStopped,\n  logLayoutEffectsStarted,\n  logLayoutEffectsStopped,\n  logPassiveEffectsStarted,\n  logPassiveEffectsStopped,\n  logRenderStarted,\n  logRenderStopped,\n} from './DebugTracing';\nimport {\n  markCommitStarted,\n  markCommitStopped,\n  markComponentRenderStopped,\n  markComponentSuspended,\n  markComponentErrored,\n  markLayoutEffectsStarted,\n  markLayoutEffectsStopped,\n  markPassiveEffectsStarted,\n  markPassiveEffectsStopped,\n  markRenderStarted,\n  markRenderYielded,\n  markRenderStopped,\n} from './SchedulingProfiler';\n\nimport {\n  resetAfterCommit,\n  scheduleTimeout,\n  cancelTimeout,\n  noTimeout,\n  afterActiveInstanceBlur,\n  clearContainer,\n  getCurrentEventPriority,\n  supportsMicrotasks,\n  errorHydratingContainer,\n  scheduleMicrotask,\n} from './ReactFiberHostConfig';\n\nimport {\n  createWorkInProgress,\n  assignFiberPropertiesInDEV,\n} from './ReactFiber.old';\nimport {NoMode, ProfileMode, ConcurrentMode} from './ReactTypeOfMode';\nimport {\n  HostRoot,\n  IndeterminateComponent,\n  ClassComponent,\n  SuspenseComponent,\n  SuspenseListComponent,\n  FunctionComponent,\n  ForwardRef,\n  MemoComponent,\n  SimpleMemoComponent,\n  Profiler,\n} from './ReactWorkTags';\nimport {LegacyRoot} from './ReactRootTags';\nimport {\n  NoFlags,\n  Placement,\n  Incomplete,\n  StoreConsistency,\n  HostEffectMask,\n  Hydrating,\n  BeforeMutationMask,\n  MutationMask,\n  LayoutMask,\n  PassiveMask,\n  MountPassiveDev,\n  MountLayoutDev,\n} from './ReactFiberFlags';\nimport {\n  NoLanes,\n  NoLane,\n  SyncLane,\n  NoTimestamp,\n  claimNextTransitionLane,\n  claimNextRetryLane,\n  includesSomeLane,\n  isSubsetOfLanes,\n  mergeLanes,\n  removeLanes,\n  pickArbitraryLane,\n  includesNonIdleWork,\n  includesOnlyRetries,\n  includesOnlyTransitions,\n  includesBlockingLane,\n  includesExpiredLane,\n  getNextLanes,\n  markStarvedLanesAsExpired,\n  getLanesToRetrySynchronouslyOnError,\n  getMostRecentEventTime,\n  markRootUpdated,\n  markRootSuspended as markRootSuspended_dontCallThisOneDirectly,\n  markRootPinged,\n  markRootEntangled,\n  markRootFinished,\n  getHighestPriorityLane,\n  addFiberToLanesMap,\n  movePendingFibersToMemoized,\n} from './ReactFiberLane.old';\nimport {\n  DiscreteEventPriority,\n  ContinuousEventPriority,\n  DefaultEventPriority,\n  IdleEventPriority,\n  getCurrentUpdatePriority,\n  setCurrentUpdatePriority,\n  lowerEventPriority,\n  lanesToEventPriority,\n} from './ReactEventPriorities.old';\nimport {requestCurrentTransition, NoTransition} from './ReactFiberTransition';\nimport {beginWork as originalBeginWork} from './ReactFiberBeginWork.old';\nimport {completeWork} from './ReactFiberCompleteWork.old';\nimport {unwindWork, unwindInterruptedWork} from './ReactFiberUnwindWork.old';\nimport {\n  throwException,\n  createRootErrorUpdate,\n  createClassErrorUpdate,\n} from './ReactFiberThrow.old';\nimport {\n  commitBeforeMutationEffects,\n  commitLayoutEffects,\n  commitMutationEffects,\n  commitPassiveEffectDurations,\n  commitPassiveMountEffects,\n  commitPassiveUnmountEffects,\n  invokeLayoutEffectMountInDEV,\n  invokePassiveEffectMountInDEV,\n  invokeLayoutEffectUnmountInDEV,\n  invokePassiveEffectUnmountInDEV,\n} from './ReactFiberCommitWork.old';\nimport {enqueueUpdate} from './ReactUpdateQueue.old';\nimport {resetContextDependencies} from './ReactFiberNewContext.old';\nimport {\n  resetHooksAfterThrow,\n  ContextOnlyDispatcher,\n  getIsUpdatingOpaqueValueInRenderPhaseInDEV,\n} from './ReactFiberHooks.old';\nimport {createCapturedValue} from './ReactCapturedValue';\nimport {\n  push as pushToStack,\n  pop as popFromStack,\n  createCursor,\n} from './ReactFiberStack.old';\nimport {enqueueInterleavedUpdates} from './ReactFiberInterleavedUpdates.old';\n\nimport {\n  markNestedUpdateScheduled,\n  recordCommitTime,\n  resetNestedUpdateFlag,\n  startProfilerTimer,\n  stopProfilerTimerIfRunningAndRecordDelta,\n  syncNestedUpdateFlag,\n} from './ReactProfilerTimer.old';\n\n// DEV stuff\nimport getComponentNameFromFiber from 'react-reconciler/src/getComponentNameFromFiber';\nimport ReactStrictModeWarnings from './ReactStrictModeWarnings.old';\nimport {\n  isRendering as ReactCurrentDebugFiberIsRenderingInDEV,\n  current as ReactCurrentFiberCurrent,\n  resetCurrentFiber as resetCurrentDebugFiberInDEV,\n  setCurrentFiber as setCurrentDebugFiberInDEV,\n} from './ReactCurrentFiber';\nimport {\n  invokeGuardedCallback,\n  hasCaughtError,\n  clearCaughtError,\n} from 'shared/ReactErrorUtils';\nimport {\n  onCommitRoot as onCommitRootDevTools,\n  onPostCommitRoot as onPostCommitRootDevTools,\n  isDevToolsPresent,\n} from './ReactFiberDevToolsHook.old';\nimport {onCommitRoot as onCommitRootTestSelector} from './ReactTestSelectors';\nimport {releaseCache} from './ReactFiberCacheComponent.old';\nimport {\n  isLegacyActEnvironment,\n  isConcurrentActEnvironment,\n} from './ReactFiberAct.old';\n\nconst ceil = Math.ceil;\n\nconst {\n  ReactCurrentDispatcher,\n  ReactCurrentOwner,\n  ReactCurrentBatchConfig,\n  ReactCurrentActQueue,\n} = ReactSharedInternals;\n\ntype ExecutionContext = number;\n\nexport const NoContext = /*             */ 0b0000;\nconst BatchedContext = /*               */ 0b0001;\nconst RenderContext = /*                */ 0b0010;\nconst CommitContext = /*                */ 0b0100;\nexport const RetryAfterError = /*       */ 0b1000;\n\ntype RootExitStatus = 0 | 1 | 2 | 3 | 4 | 5;\nconst RootIncomplete = 0;\nconst RootFatalErrored = 1;\nconst RootErrored = 2;\nconst RootSuspended = 3;\nconst RootSuspendedWithDelay = 4;\nconst RootCompleted = 5;\n\n// Describes where we are in the React execution stack\nlet executionContext: ExecutionContext = NoContext;\n// The root we're working on\nlet workInProgressRoot: FiberRoot | null = null;\n// The fiber we're working on\nlet workInProgress: Fiber | null = null;\n// The lanes we're rendering\nlet workInProgressRootRenderLanes: Lanes = NoLanes;\n\n// Stack that allows components to change the render lanes for its subtree\n// This is a superset of the lanes we started working on at the root. The only\n// case where it's different from `workInProgressRootRenderLanes` is when we\n// enter a subtree that is hidden and needs to be unhidden: Suspense and\n// Offscreen component.\n//\n// Most things in the work loop should deal with workInProgressRootRenderLanes.\n// Most things in begin/complete phases should deal with subtreeRenderLanes.\nexport let subtreeRenderLanes: Lanes = NoLanes;\nconst subtreeRenderLanesCursor: StackCursor<Lanes> = createCursor(NoLanes);\n\n// Whether to root completed, errored, suspended, etc.\nlet workInProgressRootExitStatus: RootExitStatus = RootIncomplete;\n// A fatal error, if one is thrown\nlet workInProgressRootFatalError: mixed = null;\n// \"Included\" lanes refer to lanes that were worked on during this render. It's\n// slightly different than `renderLanes` because `renderLanes` can change as you\n// enter and exit an Offscreen tree. This value is the combination of all render\n// lanes for the entire render phase.\nlet workInProgressRootIncludedLanes: Lanes = NoLanes;\n// The work left over by components that were visited during this render. Only\n// includes unprocessed updates, not work in bailed out children.\nlet workInProgressRootSkippedLanes: Lanes = NoLanes;\n// Lanes that were updated (in an interleaved event) during this render.\nlet workInProgressRootInterleavedUpdatedLanes: Lanes = NoLanes;\n// Lanes that were updated during the render phase (*not* an interleaved event).\nlet workInProgressRootRenderPhaseUpdatedLanes: Lanes = NoLanes;\n// Lanes that were pinged (in an interleaved event) during this render.\nlet workInProgressRootPingedLanes: Lanes = NoLanes;\n\n// The most recent time we committed a fallback. This lets us ensure a train\n// model where we don't commit new loading states in too quick succession.\nlet globalMostRecentFallbackTime: number = 0;\nconst FALLBACK_THROTTLE_MS: number = 500;\n\n// The absolute time for when we should start giving up on rendering\n// more and prefer CPU suspense heuristics instead.\nlet workInProgressRootRenderTargetTime: number = Infinity;\n// How long a render is supposed to take before we start following CPU\n// suspense heuristics and opt out of rendering more content.\nconst RENDER_TIMEOUT_MS = 500;\n\nfunction resetRenderTimer() {\n  workInProgressRootRenderTargetTime = now() + RENDER_TIMEOUT_MS;\n}\n\nexport function getRenderTargetTime(): number {\n  return workInProgressRootRenderTargetTime;\n}\n\nlet hasUncaughtError = false;\nlet firstUncaughtError = null;\nlet legacyErrorBoundariesThatAlreadyFailed: Set<mixed> | null = null;\n\n// Only used when enableProfilerNestedUpdateScheduledHook is true;\n// to track which root is currently committing layout effects.\nlet rootCommittingMutationOrLayoutEffects: FiberRoot | null = null;\n\nlet rootDoesHavePassiveEffects: boolean = false;\nlet rootWithPendingPassiveEffects: FiberRoot | null = null;\nlet pendingPassiveEffectsLanes: Lanes = NoLanes;\nlet pendingPassiveProfilerEffects: Array<Fiber> = [];\nlet pendingPassiveEffectsRemainingLanes: Lanes = NoLanes;\n\n// Use these to prevent an infinite loop of nested updates\nconst NESTED_UPDATE_LIMIT = 50;\nlet nestedUpdateCount: number = 0;\nlet rootWithNestedUpdates: FiberRoot | null = null;\n\nconst NESTED_PASSIVE_UPDATE_LIMIT = 50;\nlet nestedPassiveUpdateCount: number = 0;\n\n// If two updates are scheduled within the same event, we should treat their\n// event times as simultaneous, even if the actual clock time has advanced\n// between the first and second call.\nlet currentEventTime: number = NoTimestamp;\nlet currentEventTransitionLane: Lanes = NoLanes;\n\nexport function getWorkInProgressRoot(): FiberRoot | null {\n  return workInProgressRoot;\n}\n\nexport function requestEventTime() {\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n    // We're inside React, so it's fine to read the actual time.\n    return now();\n  }\n  // We're not inside React, so we may be in the middle of a browser event.\n  if (currentEventTime !== NoTimestamp) {\n    // Use the same start time for all updates until we enter React again.\n    return currentEventTime;\n  }\n  // This is the first update since React yielded. Compute a new start time.\n  currentEventTime = now();\n  return currentEventTime;\n}\n\nexport function getCurrentTime() {\n  return now();\n}\n\nexport function requestUpdateLane(fiber: Fiber): Lane {\n  // Special cases\n  const mode = fiber.mode;\n  if ((mode & ConcurrentMode) === NoMode) {\n    return (SyncLane: Lane);\n  } else if (\n    !deferRenderPhaseUpdateToNextBatch &&\n    (executionContext & RenderContext) !== NoContext &&\n    workInProgressRootRenderLanes !== NoLanes\n  ) {\n    // This is a render phase update. These are not officially supported. The\n    // old behavior is to give this the same \"thread\" (lanes) as\n    // whatever is currently rendering. So if you call `setState` on a component\n    // that happens later in the same render, it will flush. Ideally, we want to\n    // remove the special case and treat them as if they came from an\n    // interleaved event. Regardless, this pattern is not officially supported.\n    // This behavior is only a fallback. The flag only exists until we can roll\n    // out the setState warning, since existing code might accidentally rely on\n    // the current behavior.\n    return pickArbitraryLane(workInProgressRootRenderLanes);\n  }\n\n  const isTransition = requestCurrentTransition() !== NoTransition;\n  if (isTransition) {\n    if (\n      __DEV__ &&\n      warnOnSubscriptionInsideStartTransition &&\n      ReactCurrentBatchConfig._updatedFibers\n    ) {\n      ReactCurrentBatchConfig._updatedFibers.add(fiber);\n    }\n    // The algorithm for assigning an update to a lane should be stable for all\n    // updates at the same priority within the same event. To do this, the\n    // inputs to the algorithm must be the same.\n    //\n    // The trick we use is to cache the first of each of these inputs within an\n    // event. Then reset the cached values once we can be sure the event is\n    // over. Our heuristic for that is whenever we enter a concurrent work loop.\n    if (currentEventTransitionLane === NoLane) {\n      // All transitions within the same event are assigned the same lane.\n      currentEventTransitionLane = claimNextTransitionLane();\n    }\n    return currentEventTransitionLane;\n  }\n\n  // Updates originating inside certain React methods, like flushSync, have\n  // their priority set by tracking it with a context variable.\n  //\n  // The opaque type returned by the host config is internally a lane, so we can\n  // use that directly.\n  // TODO: Move this type conversion to the event priority module.\n  const updateLane: Lane = (getCurrentUpdatePriority(): any);\n  if (updateLane !== NoLane) {\n    return updateLane;\n  }\n\n  // This update originated outside React. Ask the host environment for an\n  // appropriate priority, based on the type of event.\n  //\n  // The opaque type returned by the host config is internally a lane, so we can\n  // use that directly.\n  // TODO: Move this type conversion to the event priority module.\n  const eventLane: Lane = (getCurrentEventPriority(): any);\n  return eventLane;\n}\n\nfunction requestRetryLane(fiber: Fiber) {\n  // This is a fork of `requestUpdateLane` designed specifically for Suspense\n  // \"retries\" â€” a special update that attempts to flip a Suspense boundary\n  // from its placeholder state to its primary/resolved state.\n\n  // Special cases\n  const mode = fiber.mode;\n  if ((mode & ConcurrentMode) === NoMode) {\n    return (SyncLane: Lane);\n  }\n\n  return claimNextRetryLane();\n}\n\nexport function scheduleUpdateOnFiber(\n  fiber: Fiber,\n  lane: Lane,\n  eventTime: number,\n): FiberRoot | null {\n  checkForNestedUpdates();\n\n  const root = markUpdateLaneFromFiberToRoot(fiber, lane);\n  if (root === null) {\n    return null;\n  }\n\n  // Mark that the root has a pending update.\n  markRootUpdated(root, lane, eventTime);\n\n  if (\n    (executionContext & RenderContext) !== NoLanes &&\n    root === workInProgressRoot\n  ) {\n    // This update was dispatched during the render phase. This is a mistake\n    // if the update originates from user space (with the exception of local\n    // hook updates, which are handled differently and don't reach this\n    // function), but there are some internal React features that use this as\n    // an implementation detail, like selective hydration.\n    warnAboutRenderPhaseUpdatesInDEV(fiber);\n\n    // Track lanes that were updated during the render phase\n    workInProgressRootRenderPhaseUpdatedLanes = mergeLanes(\n      workInProgressRootRenderPhaseUpdatedLanes,\n      lane,\n    );\n  } else {\n    // This is a normal update, scheduled from outside the render phase. For\n    // example, during an input event.\n    if (enableUpdaterTracking) {\n      if (isDevToolsPresent) {\n        addFiberToLanesMap(root, fiber, lane);\n      }\n    }\n\n    warnIfUpdatesNotWrappedWithActDEV(fiber);\n\n    if (enableProfilerTimer && enableProfilerNestedUpdateScheduledHook) {\n      if (\n        (executionContext & CommitContext) !== NoContext &&\n        root === rootCommittingMutationOrLayoutEffects\n      ) {\n        if (fiber.mode & ProfileMode) {\n          let current = fiber;\n          while (current !== null) {\n            if (current.tag === Profiler) {\n              const {id, onNestedUpdateScheduled} = current.memoizedProps;\n              if (typeof onNestedUpdateScheduled === 'function') {\n                onNestedUpdateScheduled(id);\n              }\n            }\n            current = current.return;\n          }\n        }\n      }\n    }\n\n    // TODO: Consolidate with `isInterleavedUpdate` check\n    if (root === workInProgressRoot) {\n      // Received an update to a tree that's in the middle of rendering. Mark\n      // that there was an interleaved update work on this root. Unless the\n      // `deferRenderPhaseUpdateToNextBatch` flag is off and this is a render\n      // phase update. In that case, we don't treat render phase updates as if\n      // they were interleaved, for backwards compat reasons.\n      if (\n        deferRenderPhaseUpdateToNextBatch ||\n        (executionContext & RenderContext) === NoContext\n      ) {\n        workInProgressRootInterleavedUpdatedLanes = mergeLanes(\n          workInProgressRootInterleavedUpdatedLanes,\n          lane,\n        );\n      }\n      if (workInProgressRootExitStatus === RootSuspendedWithDelay) {\n        // The root already suspended with a delay, which means this render\n        // definitely won't finish. Since we have a new update, let's mark it as\n        // suspended now, right before marking the incoming update. This has the\n        // effect of interrupting the current render and switching to the update.\n        // TODO: Make sure this doesn't override pings that happen while we've\n        // already started rendering.\n        markRootSuspended(root, workInProgressRootRenderLanes);\n      }\n    }\n\n    ensureRootIsScheduled(root, eventTime);\n    if (\n      lane === SyncLane &&\n      executionContext === NoContext &&\n      (fiber.mode & ConcurrentMode) === NoMode &&\n      // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.\n      !(__DEV__ && ReactCurrentActQueue.isBatchingLegacy)\n    ) {\n      // Flush the synchronous work now, unless we're already working or inside\n      // a batch. This is intentionally inside scheduleUpdateOnFiber instead of\n      // scheduleCallbackForFiber to preserve the ability to schedule a callback\n      // without immediately flushing it. We only do this for user-initiated\n      // updates, to preserve historical behavior of legacy mode.\n      resetRenderTimer();\n      flushSyncCallbacksOnlyInLegacyMode();\n    }\n  }\n  return root;\n}\n\n// This is split into a separate function so we can mark a fiber with pending\n// work without treating it as a typical update that originates from an event;\n// e.g. retrying a Suspense boundary isn't an update, but it does schedule work\n// on a fiber.\nfunction markUpdateLaneFromFiberToRoot(\n  sourceFiber: Fiber,\n  lane: Lane,\n): FiberRoot | null {\n  // Update the source fiber's lanes\n  sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);\n  let alternate = sourceFiber.alternate;\n  if (alternate !== null) {\n    alternate.lanes = mergeLanes(alternate.lanes, lane);\n  }\n  if (__DEV__) {\n    if (\n      alternate === null &&\n      (sourceFiber.flags & (Placement | Hydrating)) !== NoFlags\n    ) {\n      warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\n    }\n  }\n  // Walk the parent path to the root and update the child lanes.\n  let node = sourceFiber;\n  let parent = sourceFiber.return;\n  while (parent !== null) {\n    parent.childLanes = mergeLanes(parent.childLanes, lane);\n    alternate = parent.alternate;\n    if (alternate !== null) {\n      alternate.childLanes = mergeLanes(alternate.childLanes, lane);\n    } else {\n      if (__DEV__) {\n        if ((parent.flags & (Placement | Hydrating)) !== NoFlags) {\n          warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\n        }\n      }\n    }\n    node = parent;\n    parent = parent.return;\n  }\n  if (node.tag === HostRoot) {\n    const root: FiberRoot = node.stateNode;\n    return root;\n  } else {\n    return null;\n  }\n}\n\nexport function isInterleavedUpdate(fiber: Fiber, lane: Lane) {\n  return (\n    // TODO: Optimize slightly by comparing to root that fiber belongs to.\n    // Requires some refactoring. Not a big deal though since it's rare for\n    // concurrent apps to have more than a single root.\n    workInProgressRoot !== null &&\n    (fiber.mode & ConcurrentMode) !== NoMode &&\n    // If this is a render phase update (i.e. UNSAFE_componentWillReceiveProps),\n    // then don't treat this as an interleaved update. This pattern is\n    // accompanied by a warning but we haven't fully deprecated it yet. We can\n    // remove once the deferRenderPhaseUpdateToNextBatch flag is enabled.\n    (deferRenderPhaseUpdateToNextBatch ||\n      (executionContext & RenderContext) === NoContext)\n  );\n}\n\n// Use this function to schedule a task for a root. There's only one task per\n// root; if a task was already scheduled, we'll check to make sure the priority\n// of the existing task is the same as the priority of the next level that the\n// root has work on. This function is called on every update, and right before\n// exiting a task.\nfunction ensureRootIsScheduled(root: FiberRoot, currentTime: number) {\n  const existingCallbackNode = root.callbackNode;\n\n  // Check if any lanes are being starved by other work. If so, mark them as\n  // expired so we know to work on those next.\n  markStarvedLanesAsExpired(root, currentTime);\n\n  // Determine the next lanes to work on, and their priority.\n  const nextLanes = getNextLanes(\n    root,\n    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,\n  );\n\n  if (nextLanes === NoLanes) {\n    // Special case: There's nothing to work on.\n    if (existingCallbackNode !== null) {\n      cancelCallback(existingCallbackNode);\n    }\n    root.callbackNode = null;\n    root.callbackPriority = NoLane;\n    return;\n  }\n\n  // We use the highest priority lane to represent the priority of the callback.\n  const newCallbackPriority = getHighestPriorityLane(nextLanes);\n\n  // Check if there's an existing task. We may be able to reuse it.\n  const existingCallbackPriority = root.callbackPriority;\n  if (\n    existingCallbackPriority === newCallbackPriority &&\n    // Special case related to `act`. If the currently scheduled task is a\n    // Scheduler task, rather than an `act` task, cancel it and re-scheduled\n    // on the `act` queue.\n    !(\n      __DEV__ &&\n      ReactCurrentActQueue.current !== null &&\n      existingCallbackNode !== fakeActCallbackNode\n    )\n  ) {\n    if (__DEV__) {\n      // If we're going to re-use an existing task, it needs to exist.\n      // Assume that discrete update microtasks are non-cancellable and null.\n      // TODO: Temporary until we confirm this warning is not fired.\n      if (\n        existingCallbackNode == null &&\n        existingCallbackPriority !== SyncLane\n      ) {\n        console.error(\n          'Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.',\n        );\n      }\n    }\n    // The priority hasn't changed. We can reuse the existing task. Exit.\n    return;\n  }\n\n  if (existingCallbackNode != null) {\n    // Cancel the existing callback. We'll schedule a new one below.\n    cancelCallback(existingCallbackNode);\n  }\n\n  // Schedule a new callback.\n  let newCallbackNode;\n  if (newCallbackPriority === SyncLane) {\n    // Special case: Sync React callbacks are scheduled on a special\n    // internal queue\n    if (root.tag === LegacyRoot) {\n      if (__DEV__ && ReactCurrentActQueue.isBatchingLegacy !== null) {\n        ReactCurrentActQueue.didScheduleLegacyUpdate = true;\n      }\n      scheduleLegacySyncCallback(performSyncWorkOnRoot.bind(null, root));\n    } else {\n      scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root));\n    }\n    if (supportsMicrotasks) {\n      // Flush the queue in a microtask.\n      if (__DEV__ && ReactCurrentActQueue.current !== null) {\n        // Inside `act`, use our internal `act` queue so that these get flushed\n        // at the end of the current scope even when using the sync version\n        // of `act`.\n        ReactCurrentActQueue.current.push(flushSyncCallbacks);\n      } else {\n        scheduleMicrotask(flushSyncCallbacks);\n      }\n    } else {\n      // Flush the queue in an Immediate task.\n      scheduleCallback(ImmediateSchedulerPriority, flushSyncCallbacks);\n    }\n    newCallbackNode = null;\n  } else {\n    let schedulerPriorityLevel;\n    switch (lanesToEventPriority(nextLanes)) {\n      case DiscreteEventPriority:\n        schedulerPriorityLevel = ImmediateSchedulerPriority;\n        break;\n      case ContinuousEventPriority:\n        schedulerPriorityLevel = UserBlockingSchedulerPriority;\n        break;\n      case DefaultEventPriority:\n        schedulerPriorityLevel = NormalSchedulerPriority;\n        break;\n      case IdleEventPriority:\n        schedulerPriorityLevel = IdleSchedulerPriority;\n        break;\n      default:\n        schedulerPriorityLevel = NormalSchedulerPriority;\n        break;\n    }\n    newCallbackNode = scheduleCallback(\n      schedulerPriorityLevel,\n      performConcurrentWorkOnRoot.bind(null, root),\n    );\n  }\n\n  root.callbackPriority = newCallbackPriority;\n  root.callbackNode = newCallbackNode;\n}\n\n// This is the entry point for every concurrent task, i.e. anything that\n// goes through Scheduler.\nfunction performConcurrentWorkOnRoot(root, didTimeout) {\n  if (enableProfilerTimer && enableProfilerNestedUpdatePhase) {\n    resetNestedUpdateFlag();\n  }\n\n  // Since we know we're in a React event, we can clear the current\n  // event time. The next update will compute a new event time.\n  currentEventTime = NoTimestamp;\n  currentEventTransitionLane = NoLanes;\n\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n    throw new Error('Should not already be working.');\n  }\n\n  // Flush any pending passive effects before deciding which lanes to work on,\n  // in case they schedule additional work.\n  const originalCallbackNode = root.callbackNode;\n  const didFlushPassiveEffects = flushPassiveEffects();\n  if (didFlushPassiveEffects) {\n    // Something in the passive effect phase may have canceled the current task.\n    // Check if the task node for this root was changed.\n    if (root.callbackNode !== originalCallbackNode) {\n      // The current task was canceled. Exit. We don't need to call\n      // `ensureRootIsScheduled` because the check above implies either that\n      // there's a new task, or that there's no remaining work on this root.\n      return null;\n    } else {\n      // Current task was not canceled. Continue.\n    }\n  }\n\n  // Determine the next lanes to work on, using the fields stored\n  // on the root.\n  let lanes = getNextLanes(\n    root,\n    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,\n  );\n  if (lanes === NoLanes) {\n    // Defensive coding. This is never expected to happen.\n    return null;\n  }\n\n  // We disable time-slicing in some cases: if the work has been CPU-bound\n  // for too long (\"expired\" work, to prevent starvation), or we're in\n  // sync-updates-by-default mode.\n  // TODO: We only check `didTimeout` defensively, to account for a Scheduler\n  // bug we're still investigating. Once the bug in Scheduler is fixed,\n  // we can remove this, since we track expiration ourselves.\n  const shouldTimeSlice =\n    !includesBlockingLane(root, lanes) &&\n    !includesExpiredLane(root, lanes) &&\n    (disableSchedulerTimeoutInWorkLoop || !didTimeout);\n  let exitStatus = shouldTimeSlice\n    ? renderRootConcurrent(root, lanes)\n    : renderRootSync(root, lanes);\n  if (exitStatus !== RootIncomplete) {\n    if (exitStatus === RootErrored) {\n      // If something threw an error, try rendering one more time. We'll\n      // render synchronously to block concurrent data mutations, and we'll\n      // includes all pending updates are included. If it still fails after\n      // the second attempt, we'll give up and commit the resulting tree.\n      const errorRetryLanes = getLanesToRetrySynchronouslyOnError(root);\n      if (errorRetryLanes !== NoLanes) {\n        lanes = errorRetryLanes;\n        exitStatus = recoverFromConcurrentError(root, errorRetryLanes);\n      }\n    }\n    if (exitStatus === RootFatalErrored) {\n      const fatalError = workInProgressRootFatalError;\n      prepareFreshStack(root, NoLanes);\n      markRootSuspended(root, lanes);\n      ensureRootIsScheduled(root, now());\n      throw fatalError;\n    }\n\n    // Check if this render may have yielded to a concurrent event, and if so,\n    // confirm that any newly rendered stores are consistent.\n    // TODO: It's possible that even a concurrent render may never have yielded\n    // to the main thread, if it was fast enough, or if it expired. We could\n    // skip the consistency check in that case, too.\n    const renderWasConcurrent = !includesBlockingLane(root, lanes);\n    const finishedWork: Fiber = (root.current.alternate: any);\n    if (\n      renderWasConcurrent &&\n      !isRenderConsistentWithExternalStores(finishedWork)\n    ) {\n      // A store was mutated in an interleaved event. Render again,\n      // synchronously, to block further mutations.\n      exitStatus = renderRootSync(root, lanes);\n\n      // We need to check again if something threw\n      if (exitStatus === RootErrored) {\n        const errorRetryLanes = getLanesToRetrySynchronouslyOnError(root);\n        if (errorRetryLanes !== NoLanes) {\n          lanes = errorRetryLanes;\n          exitStatus = recoverFromConcurrentError(root, errorRetryLanes);\n          // We assume the tree is now consistent because we didn't yield to any\n          // concurrent events.\n        }\n      }\n      if (exitStatus === RootFatalErrored) {\n        const fatalError = workInProgressRootFatalError;\n        prepareFreshStack(root, NoLanes);\n        markRootSuspended(root, lanes);\n        ensureRootIsScheduled(root, now());\n        throw fatalError;\n      }\n    }\n\n    // We now have a consistent tree. The next step is either to commit it,\n    // or, if something suspended, wait to commit it after a timeout.\n    root.finishedWork = finishedWork;\n    root.finishedLanes = lanes;\n    finishConcurrentRender(root, exitStatus, lanes);\n  }\n\n  ensureRootIsScheduled(root, now());\n  if (root.callbackNode === originalCallbackNode) {\n    // The task node scheduled for this root is the same one that's\n    // currently executed. Need to return a continuation.\n    return performConcurrentWorkOnRoot.bind(null, root);\n  }\n  return null;\n}\n\nfunction recoverFromConcurrentError(root, errorRetryLanes) {\n  const prevExecutionContext = executionContext;\n  executionContext |= RetryAfterError;\n\n  // If an error occurred during hydration, discard server response and fall\n  // back to client side render.\n  if (root.isDehydrated) {\n    root.isDehydrated = false;\n    if (__DEV__) {\n      errorHydratingContainer(root.containerInfo);\n    }\n    clearContainer(root.containerInfo);\n  }\n\n  let exitStatus;\n\n  const MAX_ERROR_RETRY_ATTEMPTS = 50;\n  for (let i = 0; i < MAX_ERROR_RETRY_ATTEMPTS; i++) {\n    exitStatus = renderRootSync(root, errorRetryLanes);\n    if (\n      exitStatus === RootErrored &&\n      workInProgressRootRenderPhaseUpdatedLanes !== NoLanes\n    ) {\n      // There was a render phase update during this render. Some internal React\n      // implementation details may use this as a trick to schedule another\n      // render pass. To protect against an inifinite loop, eventually\n      // we'll give up.\n      continue;\n    }\n    break;\n  }\n\n  executionContext = prevExecutionContext;\n\n  return exitStatus;\n}\n\nfunction finishConcurrentRender(root, exitStatus, lanes) {\n  switch (exitStatus) {\n    case RootIncomplete:\n    case RootFatalErrored: {\n      throw new Error('Root did not complete. This is a bug in React.');\n    }\n    // Flow knows about invariant, so it complains if I add a break\n    // statement, but eslint doesn't know about invariant, so it complains\n    // if I do. eslint-disable-next-line no-fallthrough\n    case RootErrored: {\n      // We should have already attempted to retry this tree. If we reached\n      // this point, it errored again. Commit it.\n      commitRoot(root);\n      break;\n    }\n    case RootSuspended: {\n      markRootSuspended(root, lanes);\n\n      // We have an acceptable loading state. We need to figure out if we\n      // should immediately commit it or wait a bit.\n\n      if (\n        includesOnlyRetries(lanes) &&\n        // do not delay if we're inside an act() scope\n        !shouldForceFlushFallbacksInDEV()\n      ) {\n        // This render only included retries, no updates. Throttle committing\n        // retries so that we don't show too many loading states too quickly.\n        const msUntilTimeout =\n          globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now();\n        // Don't bother with a very short suspense time.\n        if (msUntilTimeout > 10) {\n          const nextLanes = getNextLanes(root, NoLanes);\n          if (nextLanes !== NoLanes) {\n            // There's additional work on this root.\n            break;\n          }\n          const suspendedLanes = root.suspendedLanes;\n          if (!isSubsetOfLanes(suspendedLanes, lanes)) {\n            // We should prefer to render the fallback of at the last\n            // suspended level. Ping the last suspended level to try\n            // rendering it again.\n            // FIXME: What if the suspended lanes are Idle? Should not restart.\n            const eventTime = requestEventTime();\n            markRootPinged(root, suspendedLanes, eventTime);\n            break;\n          }\n\n          // The render is suspended, it hasn't timed out, and there's no\n          // lower priority work to do. Instead of committing the fallback\n          // immediately, wait for more data to arrive.\n          root.timeoutHandle = scheduleTimeout(\n            commitRoot.bind(null, root),\n            msUntilTimeout,\n          );\n          break;\n        }\n      }\n      // The work expired. Commit immediately.\n      commitRoot(root);\n      break;\n    }\n    case RootSuspendedWithDelay: {\n      markRootSuspended(root, lanes);\n\n      if (includesOnlyTransitions(lanes)) {\n        // This is a transition, so we should exit without committing a\n        // placeholder and without scheduling a timeout. Delay indefinitely\n        // until we receive more data.\n        break;\n      }\n\n      if (!shouldForceFlushFallbacksInDEV()) {\n        // This is not a transition, but we did trigger an avoided state.\n        // Schedule a placeholder to display after a short delay, using the Just\n        // Noticeable Difference.\n        // TODO: Is the JND optimization worth the added complexity? If this is\n        // the only reason we track the event time, then probably not.\n        // Consider removing.\n\n        const mostRecentEventTime = getMostRecentEventTime(root, lanes);\n        const eventTimeMs = mostRecentEventTime;\n        const timeElapsedMs = now() - eventTimeMs;\n        const msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs;\n\n        // Don't bother with a very short suspense time.\n        if (msUntilTimeout > 10) {\n          // Instead of committing the fallback immediately, wait for more data\n          // to arrive.\n          root.timeoutHandle = scheduleTimeout(\n            commitRoot.bind(null, root),\n            msUntilTimeout,\n          );\n          break;\n        }\n      }\n\n      // Commit the placeholder.\n      commitRoot(root);\n      break;\n    }\n    case RootCompleted: {\n      // The work completed. Ready to commit.\n      commitRoot(root);\n      break;\n    }\n    default: {\n      throw new Error('Unknown root exit status.');\n    }\n  }\n}\n\nfunction isRenderConsistentWithExternalStores(finishedWork: Fiber): boolean {\n  // Search the rendered tree for external store reads, and check whether the\n  // stores were mutated in a concurrent event. Intentionally using an iterative\n  // loop instead of recursion so we can exit early.\n  let node: Fiber = finishedWork;\n  while (true) {\n    if (node.flags & StoreConsistency) {\n      const updateQueue: FunctionComponentUpdateQueue | null = (node.updateQueue: any);\n      if (updateQueue !== null) {\n        const checks = updateQueue.stores;\n        if (checks !== null) {\n          for (let i = 0; i < checks.length; i++) {\n            const check = checks[i];\n            const getSnapshot = check.getSnapshot;\n            const renderedValue = check.value;\n            try {\n              if (!is(getSnapshot(), renderedValue)) {\n                // Found an inconsistent store.\n                return false;\n              }\n            } catch (error) {\n              // If `getSnapshot` throws, return `false`. This will schedule\n              // a re-render, and the error will be rethrown during render.\n              return false;\n            }\n          }\n        }\n      }\n    }\n    const child = node.child;\n    if (node.subtreeFlags & StoreConsistency && child !== null) {\n      child.return = node;\n      node = child;\n      continue;\n    }\n    if (node === finishedWork) {\n      return true;\n    }\n    while (node.sibling === null) {\n      if (node.return === null || node.return === finishedWork) {\n        return true;\n      }\n      node = node.return;\n    }\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n  // Flow doesn't know this is unreachable, but eslint does\n  // eslint-disable-next-line no-unreachable\n  return true;\n}\n\nfunction markRootSuspended(root, suspendedLanes) {\n  // When suspending, we should always exclude lanes that were pinged or (more\n  // rarely, since we try to avoid it) updated during the render phase.\n  // TODO: Lol maybe there's a better way to factor this besides this\n  // obnoxiously named function :)\n  suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);\n  suspendedLanes = removeLanes(\n    suspendedLanes,\n    workInProgressRootInterleavedUpdatedLanes,\n  );\n  markRootSuspended_dontCallThisOneDirectly(root, suspendedLanes);\n}\n\n// This is the entry point for synchronous tasks that don't go\n// through Scheduler\nfunction performSyncWorkOnRoot(root) {\n  if (enableProfilerTimer && enableProfilerNestedUpdatePhase) {\n    syncNestedUpdateFlag();\n  }\n\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n    throw new Error('Should not already be working.');\n  }\n\n  flushPassiveEffects();\n\n  let lanes = getNextLanes(root, NoLanes);\n  if (!includesSomeLane(lanes, SyncLane)) {\n    // There's no remaining sync work left.\n    ensureRootIsScheduled(root, now());\n    return null;\n  }\n\n  let exitStatus = renderRootSync(root, lanes);\n  if (root.tag !== LegacyRoot && exitStatus === RootErrored) {\n    // If something threw an error, try rendering one more time. We'll render\n    // synchronously to block concurrent data mutations, and we'll includes\n    // all pending updates are included. If it still fails after the second\n    // attempt, we'll give up and commit the resulting tree.\n    const errorRetryLanes = getLanesToRetrySynchronouslyOnError(root);\n    if (errorRetryLanes !== NoLanes) {\n      lanes = errorRetryLanes;\n      exitStatus = recoverFromConcurrentError(root, errorRetryLanes);\n    }\n  }\n\n  if (exitStatus === RootFatalErrored) {\n    const fatalError = workInProgressRootFatalError;\n    prepareFreshStack(root, NoLanes);\n    markRootSuspended(root, lanes);\n    ensureRootIsScheduled(root, now());\n    throw fatalError;\n  }\n\n  // We now have a consistent tree. Because this is a sync render, we\n  // will commit it even if something suspended.\n  const finishedWork: Fiber = (root.current.alternate: any);\n  root.finishedWork = finishedWork;\n  root.finishedLanes = lanes;\n  commitRoot(root);\n\n  // Before exiting, make sure there's a callback scheduled for the next\n  // pending level.\n  ensureRootIsScheduled(root, now());\n\n  return null;\n}\n\nexport function flushRoot(root: FiberRoot, lanes: Lanes) {\n  if (lanes !== NoLanes) {\n    markRootEntangled(root, mergeLanes(lanes, SyncLane));\n    ensureRootIsScheduled(root, now());\n    if ((executionContext & (RenderContext | CommitContext)) === NoContext) {\n      resetRenderTimer();\n      flushSyncCallbacks();\n    }\n  }\n}\n\nexport function getExecutionContext(): ExecutionContext {\n  return executionContext;\n}\n\nexport function deferredUpdates<A>(fn: () => A): A {\n  const previousPriority = getCurrentUpdatePriority();\n  const prevTransition = ReactCurrentBatchConfig.transition;\n  try {\n    ReactCurrentBatchConfig.transition = 0;\n    setCurrentUpdatePriority(DefaultEventPriority);\n    return fn();\n  } finally {\n    setCurrentUpdatePriority(previousPriority);\n    ReactCurrentBatchConfig.transition = prevTransition;\n  }\n}\n\nexport function batchedUpdates<A, R>(fn: A => R, a: A): R {\n  const prevExecutionContext = executionContext;\n  executionContext |= BatchedContext;\n  try {\n    return fn(a);\n  } finally {\n    executionContext = prevExecutionContext;\n    // If there were legacy sync updates, flush them at the end of the outer\n    // most batchedUpdates-like method.\n    if (\n      executionContext === NoContext &&\n      // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.\n      !(__DEV__ && ReactCurrentActQueue.isBatchingLegacy)\n    ) {\n      resetRenderTimer();\n      flushSyncCallbacksOnlyInLegacyMode();\n    }\n  }\n}\n\nexport function discreteUpdates<A, B, C, D, R>(\n  fn: (A, B, C, D) => R,\n  a: A,\n  b: B,\n  c: C,\n  d: D,\n): R {\n  const previousPriority = getCurrentUpdatePriority();\n  const prevTransition = ReactCurrentBatchConfig.transition;\n  try {\n    ReactCurrentBatchConfig.transition = 0;\n    setCurrentUpdatePriority(DiscreteEventPriority);\n    return fn(a, b, c, d);\n  } finally {\n    setCurrentUpdatePriority(previousPriority);\n    ReactCurrentBatchConfig.transition = prevTransition;\n    if (executionContext === NoContext) {\n      resetRenderTimer();\n    }\n  }\n}\n\n// Overload the definition to the two valid signatures.\n// Warning, this opts-out of checking the function body.\ndeclare function flushSync<R>(fn: () => R): R;\n// eslint-disable-next-line no-redeclare\ndeclare function flushSync(): void;\n// eslint-disable-next-line no-redeclare\nexport function flushSync(fn) {\n  // In legacy mode, we flush pending passive effects at the beginning of the\n  // next event, not at the end of the previous one.\n  if (\n    rootWithPendingPassiveEffects !== null &&\n    rootWithPendingPassiveEffects.tag === LegacyRoot &&\n    (executionContext & (RenderContext | CommitContext)) === NoContext\n  ) {\n    flushPassiveEffects();\n  }\n\n  const prevExecutionContext = executionContext;\n  executionContext |= BatchedContext;\n\n  const prevTransition = ReactCurrentBatchConfig.transition;\n  const previousPriority = getCurrentUpdatePriority();\n  try {\n    ReactCurrentBatchConfig.transition = 0;\n    setCurrentUpdatePriority(DiscreteEventPriority);\n    if (fn) {\n      return fn();\n    } else {\n      return undefined;\n    }\n  } finally {\n    setCurrentUpdatePriority(previousPriority);\n    ReactCurrentBatchConfig.transition = prevTransition;\n    executionContext = prevExecutionContext;\n    // Flush the immediate callbacks that were scheduled during this batch.\n    // Note that this will happen even if batchedUpdates is higher up\n    // the stack.\n    if ((executionContext & (RenderContext | CommitContext)) === NoContext) {\n      flushSyncCallbacks();\n    }\n  }\n}\n\nexport function isAlreadyRendering() {\n  // Used by the renderer to print a warning if certain APIs are called from\n  // the wrong context.\n  return (\n    __DEV__ &&\n    (executionContext & (RenderContext | CommitContext)) !== NoContext\n  );\n}\n\nexport function flushControlled(fn: () => mixed): void {\n  const prevExecutionContext = executionContext;\n  executionContext |= BatchedContext;\n  const prevTransition = ReactCurrentBatchConfig.transition;\n  const previousPriority = getCurrentUpdatePriority();\n  try {\n    ReactCurrentBatchConfig.transition = 0;\n    setCurrentUpdatePriority(DiscreteEventPriority);\n    fn();\n  } finally {\n    setCurrentUpdatePriority(previousPriority);\n    ReactCurrentBatchConfig.transition = prevTransition;\n\n    executionContext = prevExecutionContext;\n    if (executionContext === NoContext) {\n      // Flush the immediate callbacks that were scheduled during this batch\n      resetRenderTimer();\n      flushSyncCallbacks();\n    }\n  }\n}\n\nexport function pushRenderLanes(fiber: Fiber, lanes: Lanes) {\n  pushToStack(subtreeRenderLanesCursor, subtreeRenderLanes, fiber);\n  subtreeRenderLanes = mergeLanes(subtreeRenderLanes, lanes);\n  workInProgressRootIncludedLanes = mergeLanes(\n    workInProgressRootIncludedLanes,\n    lanes,\n  );\n}\n\nexport function popRenderLanes(fiber: Fiber) {\n  subtreeRenderLanes = subtreeRenderLanesCursor.current;\n  popFromStack(subtreeRenderLanesCursor, fiber);\n}\n\nfunction prepareFreshStack(root: FiberRoot, lanes: Lanes) {\n  root.finishedWork = null;\n  root.finishedLanes = NoLanes;\n\n  const timeoutHandle = root.timeoutHandle;\n  if (timeoutHandle !== noTimeout) {\n    // The root previous suspended and scheduled a timeout to commit a fallback\n    // state. Now that we have additional work, cancel the timeout.\n    root.timeoutHandle = noTimeout;\n    // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above\n    cancelTimeout(timeoutHandle);\n  }\n\n  if (workInProgress !== null) {\n    let interruptedWork = workInProgress.return;\n    while (interruptedWork !== null) {\n      unwindInterruptedWork(interruptedWork, workInProgressRootRenderLanes);\n      interruptedWork = interruptedWork.return;\n    }\n  }\n  workInProgressRoot = root;\n  workInProgress = createWorkInProgress(root.current, null);\n  workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;\n  workInProgressRootExitStatus = RootIncomplete;\n  workInProgressRootFatalError = null;\n  workInProgressRootSkippedLanes = NoLanes;\n  workInProgressRootInterleavedUpdatedLanes = NoLanes;\n  workInProgressRootRenderPhaseUpdatedLanes = NoLanes;\n  workInProgressRootPingedLanes = NoLanes;\n\n  enqueueInterleavedUpdates();\n\n  if (__DEV__) {\n    ReactStrictModeWarnings.discardPendingWarnings();\n  }\n}\n\nfunction handleError(root, thrownValue): void {\n  do {\n    let erroredWork = workInProgress;\n    try {\n      // Reset module-level state that was set during the render phase.\n      resetContextDependencies();\n      resetHooksAfterThrow();\n      resetCurrentDebugFiberInDEV();\n      // TODO: I found and added this missing line while investigating a\n      // separate issue. Write a regression test using string refs.\n      ReactCurrentOwner.current = null;\n\n      if (erroredWork === null || erroredWork.return === null) {\n        // Expected to be working on a non-root fiber. This is a fatal error\n        // because there's no ancestor that can handle it; the root is\n        // supposed to capture all errors that weren't caught by an error\n        // boundary.\n        workInProgressRootExitStatus = RootFatalErrored;\n        workInProgressRootFatalError = thrownValue;\n        // Set `workInProgress` to null. This represents advancing to the next\n        // sibling, or the parent if there are no siblings. But since the root\n        // has no siblings nor a parent, we set it to null. Usually this is\n        // handled by `completeUnitOfWork` or `unwindWork`, but since we're\n        // intentionally not calling those, we need set it here.\n        // TODO: Consider calling `unwindWork` to pop the contexts.\n        workInProgress = null;\n        return;\n      }\n\n      if (enableProfilerTimer && erroredWork.mode & ProfileMode) {\n        // Record the time spent rendering before an error was thrown. This\n        // avoids inaccurate Profiler durations in the case of a\n        // suspended render.\n        stopProfilerTimerIfRunningAndRecordDelta(erroredWork, true);\n      }\n\n      if (enableSchedulingProfiler) {\n        markComponentRenderStopped();\n\n        if (\n          thrownValue !== null &&\n          typeof thrownValue === 'object' &&\n          typeof thrownValue.then === 'function'\n        ) {\n          const wakeable: Wakeable = (thrownValue: any);\n          markComponentSuspended(\n            erroredWork,\n            wakeable,\n            workInProgressRootRenderLanes,\n          );\n        } else {\n          markComponentErrored(\n            erroredWork,\n            thrownValue,\n            workInProgressRootRenderLanes,\n          );\n        }\n      }\n\n      throwException(\n        root,\n        erroredWork.return,\n        erroredWork,\n        thrownValue,\n        workInProgressRootRenderLanes,\n      );\n      completeUnitOfWork(erroredWork);\n    } catch (yetAnotherThrownValue) {\n      // Something in the return path also threw.\n      thrownValue = yetAnotherThrownValue;\n      if (workInProgress === erroredWork && erroredWork !== null) {\n        // If this boundary has already errored, then we had trouble processing\n        // the error. Bubble it to the next boundary.\n        erroredWork = erroredWork.return;\n        workInProgress = erroredWork;\n      } else {\n        erroredWork = workInProgress;\n      }\n      continue;\n    }\n    // Return to the normal work loop.\n    return;\n  } while (true);\n}\n\nfunction pushDispatcher() {\n  const prevDispatcher = ReactCurrentDispatcher.current;\n  ReactCurrentDispatcher.current = ContextOnlyDispatcher;\n  if (prevDispatcher === null) {\n    // The React isomorphic package does not include a default dispatcher.\n    // Instead the first renderer will lazily attach one, in order to give\n    // nicer error messages.\n    return ContextOnlyDispatcher;\n  } else {\n    return prevDispatcher;\n  }\n}\n\nfunction popDispatcher(prevDispatcher) {\n  ReactCurrentDispatcher.current = prevDispatcher;\n}\n\nexport function markCommitTimeOfFallback() {\n  globalMostRecentFallbackTime = now();\n}\n\nexport function markSkippedUpdateLanes(lane: Lane | Lanes): void {\n  workInProgressRootSkippedLanes = mergeLanes(\n    lane,\n    workInProgressRootSkippedLanes,\n  );\n}\n\nexport function renderDidSuspend(): void {\n  if (workInProgressRootExitStatus === RootIncomplete) {\n    workInProgressRootExitStatus = RootSuspended;\n  }\n}\n\nexport function renderDidSuspendDelayIfPossible(): void {\n  if (\n    workInProgressRootExitStatus === RootIncomplete ||\n    workInProgressRootExitStatus === RootSuspended ||\n    workInProgressRootExitStatus === RootErrored\n  ) {\n    workInProgressRootExitStatus = RootSuspendedWithDelay;\n  }\n\n  // Check if there are updates that we skipped tree that might have unblocked\n  // this render.\n  if (\n    workInProgressRoot !== null &&\n    (includesNonIdleWork(workInProgressRootSkippedLanes) ||\n      includesNonIdleWork(workInProgressRootInterleavedUpdatedLanes))\n  ) {\n    // Mark the current render as suspended so that we switch to working on\n    // the updates that were skipped. Usually we only suspend at the end of\n    // the render phase.\n    // TODO: We should probably always mark the root as suspended immediately\n    // (inside this function), since by suspending at the end of the render\n    // phase introduces a potential mistake where we suspend lanes that were\n    // pinged or updated while we were rendering.\n    markRootSuspended(workInProgressRoot, workInProgressRootRenderLanes);\n  }\n}\n\nexport function renderDidError() {\n  if (workInProgressRootExitStatus !== RootSuspendedWithDelay) {\n    workInProgressRootExitStatus = RootErrored;\n  }\n}\n\n// Called during render to determine if anything has suspended.\n// Returns false if we're not sure.\nexport function renderHasNotSuspendedYet(): boolean {\n  // If something errored or completed, we can't really be sure,\n  // so those are false.\n  return workInProgressRootExitStatus === RootIncomplete;\n}\n\nfunction renderRootSync(root: FiberRoot, lanes: Lanes) {\n  const prevExecutionContext = executionContext;\n  executionContext |= RenderContext;\n  const prevDispatcher = pushDispatcher();\n\n  // If the root or lanes have changed, throw out the existing stack\n  // and prepare a fresh one. Otherwise we'll continue where we left off.\n  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\n    if (enableUpdaterTracking) {\n      if (isDevToolsPresent) {\n        const memoizedUpdaters = root.memoizedUpdaters;\n        if (memoizedUpdaters.size > 0) {\n          restorePendingUpdaters(root, workInProgressRootRenderLanes);\n          memoizedUpdaters.clear();\n        }\n\n        // At this point, move Fibers that scheduled the upcoming work from the Map to the Set.\n        // If we bailout on this work, we'll move them back (like above).\n        // It's important to move them now in case the work spawns more work at the same priority with different updaters.\n        // That way we can keep the current update and future updates separate.\n        movePendingFibersToMemoized(root, lanes);\n      }\n    }\n\n    prepareFreshStack(root, lanes);\n  }\n\n  if (__DEV__) {\n    if (enableDebugTracing) {\n      logRenderStarted(lanes);\n    }\n  }\n\n  if (enableSchedulingProfiler) {\n    markRenderStarted(lanes);\n  }\n\n  do {\n    try {\n      workLoopSync();\n      break;\n    } catch (thrownValue) {\n      handleError(root, thrownValue);\n    }\n  } while (true);\n  resetContextDependencies();\n\n  executionContext = prevExecutionContext;\n  popDispatcher(prevDispatcher);\n\n  if (workInProgress !== null) {\n    // This is a sync render, so we should have finished the whole tree.\n    throw new Error(\n      'Cannot commit an incomplete root. This error is likely caused by a ' +\n        'bug in React. Please file an issue.',\n    );\n  }\n\n  if (__DEV__) {\n    if (enableDebugTracing) {\n      logRenderStopped();\n    }\n  }\n\n  if (enableSchedulingProfiler) {\n    markRenderStopped();\n  }\n\n  // Set this to null to indicate there's no in-progress render.\n  workInProgressRoot = null;\n  workInProgressRootRenderLanes = NoLanes;\n\n  return workInProgressRootExitStatus;\n}\n\n// The work loop is an extremely hot path. Tell Closure not to inline it.\n/** @noinline */\nfunction workLoopSync() {\n  // Already timed out, so perform work without checking if we need to yield.\n  while (workInProgress !== null) {\n    performUnitOfWork(workInProgress);\n  }\n}\n\nfunction renderRootConcurrent(root: FiberRoot, lanes: Lanes) {\n  const prevExecutionContext = executionContext;\n  executionContext |= RenderContext;\n  const prevDispatcher = pushDispatcher();\n\n  // If the root or lanes have changed, throw out the existing stack\n  // and prepare a fresh one. Otherwise we'll continue where we left off.\n  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\n    if (enableUpdaterTracking) {\n      if (isDevToolsPresent) {\n        const memoizedUpdaters = root.memoizedUpdaters;\n        if (memoizedUpdaters.size > 0) {\n          restorePendingUpdaters(root, workInProgressRootRenderLanes);\n          memoizedUpdaters.clear();\n        }\n\n        // At this point, move Fibers that scheduled the upcoming work from the Map to the Set.\n        // If we bailout on this work, we'll move them back (like above).\n        // It's important to move them now in case the work spawns more work at the same priority with different updaters.\n        // That way we can keep the current update and future updates separate.\n        movePendingFibersToMemoized(root, lanes);\n      }\n    }\n\n    resetRenderTimer();\n    prepareFreshStack(root, lanes);\n  }\n\n  if (__DEV__) {\n    if (enableDebugTracing) {\n      logRenderStarted(lanes);\n    }\n  }\n\n  if (enableSchedulingProfiler) {\n    markRenderStarted(lanes);\n  }\n\n  do {\n    try {\n      workLoopConcurrent();\n      break;\n    } catch (thrownValue) {\n      handleError(root, thrownValue);\n    }\n  } while (true);\n  resetContextDependencies();\n\n  popDispatcher(prevDispatcher);\n  executionContext = prevExecutionContext;\n\n  if (__DEV__) {\n    if (enableDebugTracing) {\n      logRenderStopped();\n    }\n  }\n\n  // Check if the tree has completed.\n  if (workInProgress !== null) {\n    // Still work remaining.\n    if (enableSchedulingProfiler) {\n      markRenderYielded();\n    }\n    return RootIncomplete;\n  } else {\n    // Completed the tree.\n    if (enableSchedulingProfiler) {\n      markRenderStopped();\n    }\n\n    // Set this to null to indicate there's no in-progress render.\n    workInProgressRoot = null;\n    workInProgressRootRenderLanes = NoLanes;\n\n    // Return the final exit status.\n    return workInProgressRootExitStatus;\n  }\n}\n\n/** @noinline */\nfunction workLoopConcurrent() {\n  // Perform work until Scheduler asks us to yield\n  while (workInProgress !== null && !shouldYield()) {\n    performUnitOfWork(workInProgress);\n  }\n}\n\nfunction performUnitOfWork(unitOfWork: Fiber): void {\n  // The current, flushed, state of this fiber is the alternate. Ideally\n  // nothing should rely on this, but relying on it here means that we don't\n  // need an additional field on the work in progress.\n  const current = unitOfWork.alternate;\n  setCurrentDebugFiberInDEV(unitOfWork);\n\n  let next;\n  if (enableProfilerTimer && (unitOfWork.mode & ProfileMode) !== NoMode) {\n    startProfilerTimer(unitOfWork);\n    next = beginWork(current, unitOfWork, subtreeRenderLanes);\n    stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);\n  } else {\n    next = beginWork(current, unitOfWork, subtreeRenderLanes);\n  }\n\n  resetCurrentDebugFiberInDEV();\n  unitOfWork.memoizedProps = unitOfWork.pendingProps;\n  if (next === null) {\n    // If this doesn't spawn new work, complete the current work.\n    completeUnitOfWork(unitOfWork);\n  } else {\n    workInProgress = next;\n  }\n\n  ReactCurrentOwner.current = null;\n}\n\nfunction completeUnitOfWork(unitOfWork: Fiber): void {\n  // Attempt to complete the current unit of work, then move to the next\n  // sibling. If there are no more siblings, return to the parent fiber.\n  let completedWork = unitOfWork;\n  do {\n    // The current, flushed, state of this fiber is the alternate. Ideally\n    // nothing should rely on this, but relying on it here means that we don't\n    // need an additional field on the work in progress.\n    const current = completedWork.alternate;\n    const returnFiber = completedWork.return;\n\n    // Check if the work completed or if something threw.\n    if ((completedWork.flags & Incomplete) === NoFlags) {\n      setCurrentDebugFiberInDEV(completedWork);\n      let next;\n      if (\n        !enableProfilerTimer ||\n        (completedWork.mode & ProfileMode) === NoMode\n      ) {\n        next = completeWork(current, completedWork, subtreeRenderLanes);\n      } else {\n        startProfilerTimer(completedWork);\n        next = completeWork(current, completedWork, subtreeRenderLanes);\n        // Update render duration assuming we didn't error.\n        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);\n      }\n      resetCurrentDebugFiberInDEV();\n\n      if (next !== null) {\n        // Completing this fiber spawned new work. Work on that next.\n        workInProgress = next;\n        return;\n      }\n    } else {\n      // This fiber did not complete because something threw. Pop values off\n      // the stack without entering the complete phase. If this is a boundary,\n      // capture values if possible.\n      const next = unwindWork(completedWork, subtreeRenderLanes);\n\n      // Because this fiber did not complete, don't reset its lanes.\n\n      if (next !== null) {\n        // If completing this work spawned new work, do that next. We'll come\n        // back here again.\n        // Since we're restarting, remove anything that is not a host effect\n        // from the effect tag.\n        next.flags &= HostEffectMask;\n        workInProgress = next;\n        return;\n      }\n\n      if (\n        enableProfilerTimer &&\n        (completedWork.mode & ProfileMode) !== NoMode\n      ) {\n        // Record the render duration for the fiber that errored.\n        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);\n\n        // Include the time spent working on failed children before continuing.\n        let actualDuration = completedWork.actualDuration;\n        let child = completedWork.child;\n        while (child !== null) {\n          actualDuration += child.actualDuration;\n          child = child.sibling;\n        }\n        completedWork.actualDuration = actualDuration;\n      }\n\n      if (returnFiber !== null) {\n        // Mark the parent fiber as incomplete and clear its subtree flags.\n        returnFiber.flags |= Incomplete;\n        returnFiber.subtreeFlags = NoFlags;\n        returnFiber.deletions = null;\n      }\n    }\n\n    const siblingFiber = completedWork.sibling;\n    if (siblingFiber !== null) {\n      // If there is more work to do in this returnFiber, do that next.\n      workInProgress = siblingFiber;\n      return;\n    }\n    // Otherwise, return to the parent\n    completedWork = returnFiber;\n    // Update the next thing we're working on in case something throws.\n    workInProgress = completedWork;\n  } while (completedWork !== null);\n\n  // We've reached the root.\n  if (workInProgressRootExitStatus === RootIncomplete) {\n    workInProgressRootExitStatus = RootCompleted;\n  }\n}\n\nfunction commitRoot(root) {\n  // TODO: This no longer makes any sense. We already wrap the mutation and\n  // layout phases. Should be able to remove.\n  const previousUpdateLanePriority = getCurrentUpdatePriority();\n  const prevTransition = ReactCurrentBatchConfig.transition;\n  try {\n    ReactCurrentBatchConfig.transition = 0;\n    setCurrentUpdatePriority(DiscreteEventPriority);\n    commitRootImpl(root, previousUpdateLanePriority);\n  } finally {\n    ReactCurrentBatchConfig.transition = prevTransition;\n    setCurrentUpdatePriority(previousUpdateLanePriority);\n  }\n\n  return null;\n}\n\nfunction commitRootImpl(root, renderPriorityLevel) {\n  do {\n    // `flushPassiveEffects` will call `flushSyncUpdateQueue` at the end, which\n    // means `flushPassiveEffects` will sometimes result in additional\n    // passive effects. So we need to keep flushing in a loop until there are\n    // no more pending effects.\n    // TODO: Might be better if `flushPassiveEffects` did not automatically\n    // flush synchronous work at the end, to avoid factoring hazards like this.\n    flushPassiveEffects();\n  } while (rootWithPendingPassiveEffects !== null);\n  flushRenderPhaseStrictModeWarningsInDEV();\n\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n    throw new Error('Should not already be working.');\n  }\n\n  const finishedWork = root.finishedWork;\n  const lanes = root.finishedLanes;\n\n  if (__DEV__) {\n    if (enableDebugTracing) {\n      logCommitStarted(lanes);\n    }\n  }\n\n  if (enableSchedulingProfiler) {\n    markCommitStarted(lanes);\n  }\n\n  if (finishedWork === null) {\n    if (__DEV__) {\n      if (enableDebugTracing) {\n        logCommitStopped();\n      }\n    }\n\n    if (enableSchedulingProfiler) {\n      markCommitStopped();\n    }\n\n    return null;\n  } else {\n    if (__DEV__) {\n      if (lanes === NoLanes) {\n        console.error(\n          'root.finishedLanes should not be empty during a commit. This is a ' +\n            'bug in React.',\n        );\n      }\n    }\n  }\n  root.finishedWork = null;\n  root.finishedLanes = NoLanes;\n\n  if (finishedWork === root.current) {\n    throw new Error(\n      'Cannot commit the same tree as before. This error is likely caused by ' +\n        'a bug in React. Please file an issue.',\n    );\n  }\n\n  // commitRoot never returns a continuation; it always finishes synchronously.\n  // So we can clear these now to allow a new callback to be scheduled.\n  root.callbackNode = null;\n  root.callbackPriority = NoLane;\n\n  // Update the first and last pending times on this root. The new first\n  // pending time is whatever is left on the root fiber.\n  let remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);\n  markRootFinished(root, remainingLanes);\n\n  if (root === workInProgressRoot) {\n    // We can reset these now that they are finished.\n    workInProgressRoot = null;\n    workInProgress = null;\n    workInProgressRootRenderLanes = NoLanes;\n  } else {\n    // This indicates that the last root we worked on is not the same one that\n    // we're committing now. This most commonly happens when a suspended root\n    // times out.\n  }\n\n  // If there are pending passive effects, schedule a callback to process them.\n  // Do this as early as possible, so it is queued before anything else that\n  // might get scheduled in the commit phase. (See #16714.)\n  // TODO: Delete all other places that schedule the passive effect callback\n  // They're redundant.\n  if (\n    (finishedWork.subtreeFlags & PassiveMask) !== NoFlags ||\n    (finishedWork.flags & PassiveMask) !== NoFlags\n  ) {\n    if (!rootDoesHavePassiveEffects) {\n      rootDoesHavePassiveEffects = true;\n      pendingPassiveEffectsRemainingLanes = remainingLanes;\n      scheduleCallback(NormalSchedulerPriority, () => {\n        flushPassiveEffects();\n        // This render triggered passive effects: release the root cache pool\n        // *after* passive effects fire to avoid freeing a cache pool that may\n        // be referenced by a node in the tree (HostRoot, Cache boundary etc)\n        return null;\n      });\n    }\n  }\n\n  // Check if there are any effects in the whole tree.\n  // TODO: This is left over from the effect list implementation, where we had\n  // to check for the existence of `firstEffect` to satisfy Flow. I think the\n  // only other reason this optimization exists is because it affects profiling.\n  // Reconsider whether this is necessary.\n  const subtreeHasEffects =\n    (finishedWork.subtreeFlags &\n      (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !==\n    NoFlags;\n  const rootHasEffect =\n    (finishedWork.flags &\n      (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !==\n    NoFlags;\n\n  if (subtreeHasEffects || rootHasEffect) {\n    const prevTransition = ReactCurrentBatchConfig.transition;\n    ReactCurrentBatchConfig.transition = 0;\n    const previousPriority = getCurrentUpdatePriority();\n    setCurrentUpdatePriority(DiscreteEventPriority);\n\n    const prevExecutionContext = executionContext;\n    executionContext |= CommitContext;\n\n    // Reset this to null before calling lifecycles\n    ReactCurrentOwner.current = null;\n\n    // The commit phase is broken into several sub-phases. We do a separate pass\n    // of the effect list for each phase: all mutation effects come before all\n    // layout effects, and so on.\n\n    // The first phase a \"before mutation\" phase. We use this phase to read the\n    // state of the host tree right before we mutate it. This is where\n    // getSnapshotBeforeUpdate is called.\n    const shouldFireAfterActiveInstanceBlur = commitBeforeMutationEffects(\n      root,\n      finishedWork,\n    );\n\n    if (enableProfilerTimer) {\n      // Mark the current commit time to be shared by all Profilers in this\n      // batch. This enables them to be grouped later.\n      recordCommitTime();\n    }\n\n    if (enableProfilerTimer && enableProfilerNestedUpdateScheduledHook) {\n      // Track the root here, rather than in commitLayoutEffects(), because of ref setters.\n      // Updates scheduled during ref detachment should also be flagged.\n      rootCommittingMutationOrLayoutEffects = root;\n    }\n\n    // The next phase is the mutation phase, where we mutate the host tree.\n    commitMutationEffects(root, finishedWork, lanes);\n\n    if (enableCreateEventHandleAPI) {\n      if (shouldFireAfterActiveInstanceBlur) {\n        afterActiveInstanceBlur();\n      }\n    }\n    resetAfterCommit(root.containerInfo);\n\n    // The work-in-progress tree is now the current tree. This must come after\n    // the mutation phase, so that the previous tree is still current during\n    // componentWillUnmount, but before the layout phase, so that the finished\n    // work is current during componentDidMount/Update.\n    root.current = finishedWork;\n\n    // The next phase is the layout phase, where we call effects that read\n    // the host tree after it's been mutated. The idiomatic use case for this is\n    // layout, but class component lifecycles also fire here for legacy reasons.\n    if (__DEV__) {\n      if (enableDebugTracing) {\n        logLayoutEffectsStarted(lanes);\n      }\n    }\n    if (enableSchedulingProfiler) {\n      markLayoutEffectsStarted(lanes);\n    }\n    commitLayoutEffects(finishedWork, root, lanes);\n    if (__DEV__) {\n      if (enableDebugTracing) {\n        logLayoutEffectsStopped();\n      }\n    }\n\n    if (enableSchedulingProfiler) {\n      markLayoutEffectsStopped();\n    }\n\n    if (enableProfilerTimer && enableProfilerNestedUpdateScheduledHook) {\n      rootCommittingMutationOrLayoutEffects = null;\n    }\n\n    // Tell Scheduler to yield at the end of the frame, so the browser has an\n    // opportunity to paint.\n    requestPaint();\n\n    executionContext = prevExecutionContext;\n\n    // Reset the priority to the previous non-sync value.\n    setCurrentUpdatePriority(previousPriority);\n    ReactCurrentBatchConfig.transition = prevTransition;\n  } else {\n    // No effects.\n    root.current = finishedWork;\n    // Measure these anyway so the flamegraph explicitly shows that there were\n    // no effects.\n    // TODO: Maybe there's a better way to report this.\n    if (enableProfilerTimer) {\n      recordCommitTime();\n    }\n  }\n\n  const rootDidHavePassiveEffects = rootDoesHavePassiveEffects;\n\n  if (rootDoesHavePassiveEffects) {\n    // This commit has passive effects. Stash a reference to them. But don't\n    // schedule a callback until after flushing layout work.\n    rootDoesHavePassiveEffects = false;\n    rootWithPendingPassiveEffects = root;\n    pendingPassiveEffectsLanes = lanes;\n  } else {\n    // There were no passive effects, so we can immediately release the cache\n    // pool for this render.\n    releaseRootPooledCache(root, remainingLanes);\n  }\n\n  // Read this again, since an effect might have updated it\n  remainingLanes = root.pendingLanes;\n\n  // Check if there's remaining work on this root\n  // TODO: This is part of the `componentDidCatch` implementation. Its purpose\n  // is to detect whether something might have called setState inside\n  // `componentDidCatch`. The mechanism is known to be flawed because `setState`\n  // inside `componentDidCatch` is itself flawed â€” that's why we recommend\n  // `getDerivedStateFromError` instead. However, it could be improved by\n  // checking if remainingLanes includes Sync work, instead of whether there's\n  // any work remaining at all (which would also include stuff like Suspense\n  // retries or transitions). It's been like this for a while, though, so fixing\n  // it probably isn't that urgent.\n  if (remainingLanes === NoLanes) {\n    // If there's no remaining work, we can clear the set of already failed\n    // error boundaries.\n    legacyErrorBoundariesThatAlreadyFailed = null;\n  }\n\n  if (__DEV__ && enableStrictEffects) {\n    if (!rootDidHavePassiveEffects) {\n      commitDoubleInvokeEffectsInDEV(root.current, false);\n    }\n  }\n\n  onCommitRootDevTools(finishedWork.stateNode, renderPriorityLevel);\n\n  if (enableUpdaterTracking) {\n    if (isDevToolsPresent) {\n      root.memoizedUpdaters.clear();\n    }\n  }\n\n  if (__DEV__) {\n    onCommitRootTestSelector();\n  }\n\n  // Always call this before exiting `commitRoot`, to ensure that any\n  // additional work on this root is scheduled.\n  ensureRootIsScheduled(root, now());\n\n  if (hasUncaughtError) {\n    hasUncaughtError = false;\n    const error = firstUncaughtError;\n    firstUncaughtError = null;\n    throw error;\n  }\n\n  // If the passive effects are the result of a discrete render, flush them\n  // synchronously at the end of the current task so that the result is\n  // immediately observable. Otherwise, we assume that they are not\n  // order-dependent and do not need to be observed by external systems, so we\n  // can wait until after paint.\n  // TODO: We can optimize this by not scheduling the callback earlier. Since we\n  // currently schedule the callback in multiple places, will wait until those\n  // are consolidated.\n  if (\n    includesSomeLane(pendingPassiveEffectsLanes, SyncLane) &&\n    root.tag !== LegacyRoot\n  ) {\n    flushPassiveEffects();\n  }\n\n  // Read this again, since a passive effect might have updated it\n  remainingLanes = root.pendingLanes;\n  if (includesSomeLane(remainingLanes, (SyncLane: Lane))) {\n    if (enableProfilerTimer && enableProfilerNestedUpdatePhase) {\n      markNestedUpdateScheduled();\n    }\n\n    // Count the number of times the root synchronously re-renders without\n    // finishing. If there are too many, it indicates an infinite update loop.\n    if (root === rootWithNestedUpdates) {\n      nestedUpdateCount++;\n    } else {\n      nestedUpdateCount = 0;\n      rootWithNestedUpdates = root;\n    }\n  } else {\n    nestedUpdateCount = 0;\n  }\n\n  // If layout work was scheduled, flush it now.\n  flushSyncCallbacks();\n\n  if (__DEV__) {\n    if (enableDebugTracing) {\n      logCommitStopped();\n    }\n  }\n\n  if (enableSchedulingProfiler) {\n    markCommitStopped();\n  }\n\n  return null;\n}\n\nfunction releaseRootPooledCache(root: FiberRoot, remainingLanes: Lanes) {\n  if (enableCache) {\n    const pooledCacheLanes = (root.pooledCacheLanes &= remainingLanes);\n    if (pooledCacheLanes === NoLanes) {\n      // None of the remaining work relies on the cache pool. Clear it so\n      // subsequent requests get a new cache\n      const pooledCache = root.pooledCache;\n      if (pooledCache != null) {\n        root.pooledCache = null;\n        releaseCache(pooledCache);\n      }\n    }\n  }\n}\n\nexport function flushPassiveEffects(): boolean {\n  // Returns whether passive effects were flushed.\n  // TODO: Combine this check with the one in flushPassiveEFfectsImpl. We should\n  // probably just combine the two functions. I believe they were only separate\n  // in the first place because we used to wrap it with\n  // `Scheduler.runWithPriority`, which accepts a function. But now we track the\n  // priority within React itself, so we can mutate the variable directly.\n  if (rootWithPendingPassiveEffects !== null) {\n    // Cache the root since rootWithPendingPassiveEffects is cleared in\n    // flushPassiveEffectsImpl\n    const root = rootWithPendingPassiveEffects;\n    // Cache and clear the remaining lanes flag; it must be reset since this\n    // method can be called from various places, not always from commitRoot\n    // where the remaining lanes are known\n    const remainingLanes = pendingPassiveEffectsRemainingLanes;\n    pendingPassiveEffectsRemainingLanes = NoLanes;\n\n    const renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes);\n    const priority = lowerEventPriority(DefaultEventPriority, renderPriority);\n    const prevTransition = ReactCurrentBatchConfig.transition;\n    const previousPriority = getCurrentUpdatePriority();\n    try {\n      ReactCurrentBatchConfig.transition = 0;\n      setCurrentUpdatePriority(priority);\n      return flushPassiveEffectsImpl();\n    } finally {\n      setCurrentUpdatePriority(previousPriority);\n      ReactCurrentBatchConfig.transition = prevTransition;\n\n      // Once passive effects have run for the tree - giving components a\n      // chance to retain cache instances they use - release the pooled\n      // cache at the root (if there is one)\n      releaseRootPooledCache(root, remainingLanes);\n    }\n  }\n  return false;\n}\n\nexport function enqueuePendingPassiveProfilerEffect(fiber: Fiber): void {\n  if (enableProfilerTimer && enableProfilerCommitHooks) {\n    pendingPassiveProfilerEffects.push(fiber);\n    if (!rootDoesHavePassiveEffects) {\n      rootDoesHavePassiveEffects = true;\n      scheduleCallback(NormalSchedulerPriority, () => {\n        flushPassiveEffects();\n        return null;\n      });\n    }\n  }\n}\n\nfunction flushPassiveEffectsImpl() {\n  if (rootWithPendingPassiveEffects === null) {\n    return false;\n  }\n\n  const root = rootWithPendingPassiveEffects;\n  const lanes = pendingPassiveEffectsLanes;\n  rootWithPendingPassiveEffects = null;\n  // TODO: This is sometimes out of sync with rootWithPendingPassiveEffects.\n  // Figure out why and fix it. It's not causing any known issues (probably\n  // because it's only used for profiling), but it's a refactor hazard.\n  pendingPassiveEffectsLanes = NoLanes;\n\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n    throw new Error('Cannot flush passive effects while already rendering.');\n  }\n\n  if (__DEV__) {\n    if (enableDebugTracing) {\n      logPassiveEffectsStarted(lanes);\n    }\n  }\n\n  if (enableSchedulingProfiler) {\n    markPassiveEffectsStarted(lanes);\n  }\n\n  const prevExecutionContext = executionContext;\n  executionContext |= CommitContext;\n\n  commitPassiveUnmountEffects(root.current);\n  commitPassiveMountEffects(root, root.current);\n\n  // TODO: Move to commitPassiveMountEffects\n  if (enableProfilerTimer && enableProfilerCommitHooks) {\n    const profilerEffects = pendingPassiveProfilerEffects;\n    pendingPassiveProfilerEffects = [];\n    for (let i = 0; i < profilerEffects.length; i++) {\n      const fiber = ((profilerEffects[i]: any): Fiber);\n      commitPassiveEffectDurations(root, fiber);\n    }\n  }\n\n  if (__DEV__) {\n    if (enableDebugTracing) {\n      logPassiveEffectsStopped();\n    }\n  }\n\n  if (enableSchedulingProfiler) {\n    markPassiveEffectsStopped();\n  }\n\n  if (__DEV__ && enableStrictEffects) {\n    commitDoubleInvokeEffectsInDEV(root.current, true);\n  }\n\n  executionContext = prevExecutionContext;\n\n  flushSyncCallbacks();\n\n  // If additional passive effects were scheduled, increment a counter. If this\n  // exceeds the limit, we'll fire a warning.\n  nestedPassiveUpdateCount =\n    rootWithPendingPassiveEffects === null ? 0 : nestedPassiveUpdateCount + 1;\n\n  // TODO: Move to commitPassiveMountEffects\n  onPostCommitRootDevTools(root);\n  if (enableProfilerTimer && enableProfilerCommitHooks) {\n    const stateNode = root.current.stateNode;\n    stateNode.effectDuration = 0;\n    stateNode.passiveEffectDuration = 0;\n  }\n\n  return true;\n}\n\nexport function isAlreadyFailedLegacyErrorBoundary(instance: mixed): boolean {\n  return (\n    legacyErrorBoundariesThatAlreadyFailed !== null &&\n    legacyErrorBoundariesThatAlreadyFailed.has(instance)\n  );\n}\n\nexport function markLegacyErrorBoundaryAsFailed(instance: mixed) {\n  if (legacyErrorBoundariesThatAlreadyFailed === null) {\n    legacyErrorBoundariesThatAlreadyFailed = new Set([instance]);\n  } else {\n    legacyErrorBoundariesThatAlreadyFailed.add(instance);\n  }\n}\n\nfunction prepareToThrowUncaughtError(error: mixed) {\n  if (!hasUncaughtError) {\n    hasUncaughtError = true;\n    firstUncaughtError = error;\n  }\n}\nexport const onUncaughtError = prepareToThrowUncaughtError;\n\nfunction captureCommitPhaseErrorOnRoot(\n  rootFiber: Fiber,\n  sourceFiber: Fiber,\n  error: mixed,\n) {\n  const errorInfo = createCapturedValue(error, sourceFiber);\n  const update = createRootErrorUpdate(rootFiber, errorInfo, (SyncLane: Lane));\n  enqueueUpdate(rootFiber, update, (SyncLane: Lane));\n  const eventTime = requestEventTime();\n  const root = markUpdateLaneFromFiberToRoot(rootFiber, (SyncLane: Lane));\n  if (root !== null) {\n    markRootUpdated(root, SyncLane, eventTime);\n    ensureRootIsScheduled(root, eventTime);\n  }\n}\n\nexport function captureCommitPhaseError(\n  sourceFiber: Fiber,\n  nearestMountedAncestor: Fiber | null,\n  error: mixed,\n) {\n  if (sourceFiber.tag === HostRoot) {\n    // Error was thrown at the root. There is no parent, so the root\n    // itself should capture it.\n    captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);\n    return;\n  }\n\n  let fiber = null;\n  if (skipUnmountedBoundaries) {\n    fiber = nearestMountedAncestor;\n  } else {\n    fiber = sourceFiber.return;\n  }\n\n  while (fiber !== null) {\n    if (fiber.tag === HostRoot) {\n      captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error);\n      return;\n    } else if (fiber.tag === ClassComponent) {\n      const ctor = fiber.type;\n      const instance = fiber.stateNode;\n      if (\n        typeof ctor.getDerivedStateFromError === 'function' ||\n        (typeof instance.componentDidCatch === 'function' &&\n          !isAlreadyFailedLegacyErrorBoundary(instance))\n      ) {\n        const errorInfo = createCapturedValue(error, sourceFiber);\n        const update = createClassErrorUpdate(\n          fiber,\n          errorInfo,\n          (SyncLane: Lane),\n        );\n        enqueueUpdate(fiber, update, (SyncLane: Lane));\n        const eventTime = requestEventTime();\n        const root = markUpdateLaneFromFiberToRoot(fiber, (SyncLane: Lane));\n        if (root !== null) {\n          markRootUpdated(root, SyncLane, eventTime);\n          ensureRootIsScheduled(root, eventTime);\n        }\n        return;\n      }\n    }\n    fiber = fiber.return;\n  }\n\n  if (__DEV__) {\n    // TODO: Until we re-land skipUnmountedBoundaries (see #20147), this warning\n    // will fire for errors that are thrown by destroy functions inside deleted\n    // trees. What it should instead do is propagate the error to the parent of\n    // the deleted tree. In the meantime, do not add this warning to the\n    // allowlist; this is only for our internal use.\n    console.error(\n      'Internal React error: Attempted to capture a commit phase error ' +\n        'inside a detached tree. This indicates a bug in React. Likely ' +\n        'causes include deleting the same fiber more than once, committing an ' +\n        'already-finished tree, or an inconsistent return pointer.\\n\\n' +\n        'Error message:\\n\\n%s',\n      error,\n    );\n  }\n}\n\nexport function pingSuspendedRoot(\n  root: FiberRoot,\n  wakeable: Wakeable,\n  pingedLanes: Lanes,\n) {\n  const pingCache = root.pingCache;\n  if (pingCache !== null) {\n    // The wakeable resolved, so we no longer need to memoize, because it will\n    // never be thrown again.\n    pingCache.delete(wakeable);\n  }\n\n  const eventTime = requestEventTime();\n  markRootPinged(root, pingedLanes, eventTime);\n\n  warnIfSuspenseResolutionNotWrappedWithActDEV(root);\n\n  if (\n    workInProgressRoot === root &&\n    isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)\n  ) {\n    // Received a ping at the same priority level at which we're currently\n    // rendering. We might want to restart this render. This should mirror\n    // the logic of whether or not a root suspends once it completes.\n\n    // TODO: If we're rendering sync either due to Sync, Batched or expired,\n    // we should probably never restart.\n\n    // If we're suspended with delay, or if it's a retry, we'll always suspend\n    // so we can always restart.\n    if (\n      workInProgressRootExitStatus === RootSuspendedWithDelay ||\n      (workInProgressRootExitStatus === RootSuspended &&\n        includesOnlyRetries(workInProgressRootRenderLanes) &&\n        now() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS)\n    ) {\n      // Restart from the root.\n      prepareFreshStack(root, NoLanes);\n    } else {\n      // Even though we can't restart right now, we might get an\n      // opportunity later. So we mark this render as having a ping.\n      workInProgressRootPingedLanes = mergeLanes(\n        workInProgressRootPingedLanes,\n        pingedLanes,\n      );\n    }\n  }\n\n  ensureRootIsScheduled(root, eventTime);\n}\n\nfunction retryTimedOutBoundary(boundaryFiber: Fiber, retryLane: Lane) {\n  // The boundary fiber (a Suspense component or SuspenseList component)\n  // previously was rendered in its fallback state. One of the promises that\n  // suspended it has resolved, which means at least part of the tree was\n  // likely unblocked. Try rendering again, at a new lanes.\n  if (retryLane === NoLane) {\n    // TODO: Assign this to `suspenseState.retryLane`? to avoid\n    // unnecessary entanglement?\n    retryLane = requestRetryLane(boundaryFiber);\n  }\n  // TODO: Special case idle priority?\n  const eventTime = requestEventTime();\n  const root = markUpdateLaneFromFiberToRoot(boundaryFiber, retryLane);\n  if (root !== null) {\n    markRootUpdated(root, retryLane, eventTime);\n    ensureRootIsScheduled(root, eventTime);\n  }\n}\n\nexport function retryDehydratedSuspenseBoundary(boundaryFiber: Fiber) {\n  const suspenseState: null | SuspenseState = boundaryFiber.memoizedState;\n  let retryLane = NoLane;\n  if (suspenseState !== null) {\n    retryLane = suspenseState.retryLane;\n  }\n  retryTimedOutBoundary(boundaryFiber, retryLane);\n}\n\nexport function resolveRetryWakeable(boundaryFiber: Fiber, wakeable: Wakeable) {\n  let retryLane = NoLane; // Default\n  let retryCache: WeakSet<Wakeable> | Set<Wakeable> | null;\n  if (enableSuspenseServerRenderer) {\n    switch (boundaryFiber.tag) {\n      case SuspenseComponent:\n        retryCache = boundaryFiber.stateNode;\n        const suspenseState: null | SuspenseState = boundaryFiber.memoizedState;\n        if (suspenseState !== null) {\n          retryLane = suspenseState.retryLane;\n        }\n        break;\n      case SuspenseListComponent:\n        retryCache = boundaryFiber.stateNode;\n        break;\n      default:\n        throw new Error(\n          'Pinged unknown suspense boundary type. ' +\n            'This is probably a bug in React.',\n        );\n    }\n  } else {\n    retryCache = boundaryFiber.stateNode;\n  }\n\n  if (retryCache !== null) {\n    // The wakeable resolved, so we no longer need to memoize, because it will\n    // never be thrown again.\n    retryCache.delete(wakeable);\n  }\n\n  retryTimedOutBoundary(boundaryFiber, retryLane);\n}\n\n// Computes the next Just Noticeable Difference (JND) boundary.\n// The theory is that a person can't tell the difference between small differences in time.\n// Therefore, if we wait a bit longer than necessary that won't translate to a noticeable\n// difference in the experience. However, waiting for longer might mean that we can avoid\n// showing an intermediate loading state. The longer we have already waited, the harder it\n// is to tell small differences in time. Therefore, the longer we've already waited,\n// the longer we can wait additionally. At some point we have to give up though.\n// We pick a train model where the next boundary commits at a consistent schedule.\n// These particular numbers are vague estimates. We expect to adjust them based on research.\nfunction jnd(timeElapsed: number) {\n  return timeElapsed < 120\n    ? 120\n    : timeElapsed < 480\n    ? 480\n    : timeElapsed < 1080\n    ? 1080\n    : timeElapsed < 1920\n    ? 1920\n    : timeElapsed < 3000\n    ? 3000\n    : timeElapsed < 4320\n    ? 4320\n    : ceil(timeElapsed / 1960) * 1960;\n}\n\nfunction checkForNestedUpdates() {\n  if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {\n    nestedUpdateCount = 0;\n    rootWithNestedUpdates = null;\n\n    throw new Error(\n      'Maximum update depth exceeded. This can happen when a component ' +\n        'repeatedly calls setState inside componentWillUpdate or ' +\n        'componentDidUpdate. React limits the number of nested updates to ' +\n        'prevent infinite loops.',\n    );\n  }\n\n  if (__DEV__) {\n    if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {\n      nestedPassiveUpdateCount = 0;\n      console.error(\n        'Maximum update depth exceeded. This can happen when a component ' +\n          \"calls setState inside useEffect, but useEffect either doesn't \" +\n          'have a dependency array, or one of the dependencies changes on ' +\n          'every render.',\n      );\n    }\n  }\n}\n\nfunction flushRenderPhaseStrictModeWarningsInDEV() {\n  if (__DEV__) {\n    ReactStrictModeWarnings.flushLegacyContextWarning();\n\n    if (warnAboutDeprecatedLifecycles) {\n      ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();\n    }\n  }\n}\n\nfunction commitDoubleInvokeEffectsInDEV(\n  fiber: Fiber,\n  hasPassiveEffects: boolean,\n) {\n  if (__DEV__ && enableStrictEffects) {\n    // TODO (StrictEffects) Should we set a marker on the root if it contains strict effects\n    // so we don't traverse unnecessarily? similar to subtreeFlags but just at the root level.\n    // Maybe not a big deal since this is DEV only behavior.\n\n    setCurrentDebugFiberInDEV(fiber);\n    invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectUnmountInDEV);\n    if (hasPassiveEffects) {\n      invokeEffectsInDev(\n        fiber,\n        MountPassiveDev,\n        invokePassiveEffectUnmountInDEV,\n      );\n    }\n\n    invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectMountInDEV);\n    if (hasPassiveEffects) {\n      invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectMountInDEV);\n    }\n    resetCurrentDebugFiberInDEV();\n  }\n}\n\nfunction invokeEffectsInDev(\n  firstChild: Fiber,\n  fiberFlags: Flags,\n  invokeEffectFn: (fiber: Fiber) => void,\n): void {\n  if (__DEV__ && enableStrictEffects) {\n    // We don't need to re-check StrictEffectsMode here.\n    // This function is only called if that check has already passed.\n\n    let current = firstChild;\n    let subtreeRoot = null;\n    while (current !== null) {\n      const primarySubtreeFlag = current.subtreeFlags & fiberFlags;\n      if (\n        current !== subtreeRoot &&\n        current.child !== null &&\n        primarySubtreeFlag !== NoFlags\n      ) {\n        current = current.child;\n      } else {\n        if ((current.flags & fiberFlags) !== NoFlags) {\n          invokeEffectFn(current);\n        }\n\n        if (current.sibling !== null) {\n          current = current.sibling;\n        } else {\n          current = subtreeRoot = current.return;\n        }\n      }\n    }\n  }\n}\n\nlet didWarnStateUpdateForNotYetMountedComponent: Set<string> | null = null;\nfunction warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {\n  if (__DEV__) {\n    if ((executionContext & RenderContext) !== NoContext) {\n      // We let the other warning about render phase updates deal with this one.\n      return;\n    }\n\n    if (!(fiber.mode & ConcurrentMode)) {\n      return;\n    }\n\n    const tag = fiber.tag;\n    if (\n      tag !== IndeterminateComponent &&\n      tag !== HostRoot &&\n      tag !== ClassComponent &&\n      tag !== FunctionComponent &&\n      tag !== ForwardRef &&\n      tag !== MemoComponent &&\n      tag !== SimpleMemoComponent\n    ) {\n      // Only warn for user-defined components, not internal ones like Suspense.\n      return;\n    }\n\n    // We show the whole stack but dedupe on the top component's name because\n    // the problematic code almost always lies inside that component.\n    const componentName = getComponentNameFromFiber(fiber) || 'ReactComponent';\n    if (didWarnStateUpdateForNotYetMountedComponent !== null) {\n      if (didWarnStateUpdateForNotYetMountedComponent.has(componentName)) {\n        return;\n      }\n      didWarnStateUpdateForNotYetMountedComponent.add(componentName);\n    } else {\n      didWarnStateUpdateForNotYetMountedComponent = new Set([componentName]);\n    }\n\n    const previousFiber = ReactCurrentFiberCurrent;\n    try {\n      setCurrentDebugFiberInDEV(fiber);\n      console.error(\n        \"Can't perform a React state update on a component that hasn't mounted yet. \" +\n          'This indicates that you have a side-effect in your render function that ' +\n          'asynchronously later calls tries to update the component. Move this work to ' +\n          'useEffect instead.',\n      );\n    } finally {\n      if (previousFiber) {\n        setCurrentDebugFiberInDEV(fiber);\n      } else {\n        resetCurrentDebugFiberInDEV();\n      }\n    }\n  }\n}\n\nlet beginWork;\nif (__DEV__ && replayFailedUnitOfWorkWithInvokeGuardedCallback) {\n  const dummyFiber = null;\n  beginWork = (current, unitOfWork, lanes) => {\n    // If a component throws an error, we replay it again in a synchronously\n    // dispatched event, so that the debugger will treat it as an uncaught\n    // error See ReactErrorUtils for more information.\n\n    // Before entering the begin phase, copy the work-in-progress onto a dummy\n    // fiber. If beginWork throws, we'll use this to reset the state.\n    const originalWorkInProgressCopy = assignFiberPropertiesInDEV(\n      dummyFiber,\n      unitOfWork,\n    );\n    try {\n      return originalBeginWork(current, unitOfWork, lanes);\n    } catch (originalError) {\n      if (\n        originalError !== null &&\n        typeof originalError === 'object' &&\n        typeof originalError.then === 'function'\n      ) {\n        // Don't replay promises. Treat everything else like an error.\n        throw originalError;\n      }\n\n      // Keep this code in sync with handleError; any changes here must have\n      // corresponding changes there.\n      resetContextDependencies();\n      resetHooksAfterThrow();\n      // Don't reset current debug fiber, since we're about to work on the\n      // same fiber again.\n\n      // Unwind the failed stack frame\n      unwindInterruptedWork(unitOfWork, workInProgressRootRenderLanes);\n\n      // Restore the original properties of the fiber.\n      assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);\n\n      if (enableProfilerTimer && unitOfWork.mode & ProfileMode) {\n        // Reset the profiler timer.\n        startProfilerTimer(unitOfWork);\n      }\n\n      // Run beginWork again.\n      invokeGuardedCallback(\n        null,\n        originalBeginWork,\n        null,\n        current,\n        unitOfWork,\n        lanes,\n      );\n\n      if (hasCaughtError()) {\n        const replayError = clearCaughtError();\n        if (\n          typeof replayError === 'object' &&\n          replayError !== null &&\n          replayError._suppressLogging &&\n          typeof originalError === 'object' &&\n          originalError !== null &&\n          !originalError._suppressLogging\n        ) {\n          // If suppressed, let the flag carry over to the original error which is the one we'll rethrow.\n          originalError._suppressLogging = true;\n        }\n      }\n      // We always throw the original error in case the second render pass is not idempotent.\n      // This can happen if a memoized function or CommonJS module doesn't throw after first invocation.\n      throw originalError;\n    }\n  };\n} else {\n  beginWork = originalBeginWork;\n}\n\nlet didWarnAboutUpdateInRender = false;\nlet didWarnAboutUpdateInRenderForAnotherComponent;\nif (__DEV__) {\n  didWarnAboutUpdateInRenderForAnotherComponent = new Set();\n}\n\nfunction warnAboutRenderPhaseUpdatesInDEV(fiber) {\n  if (__DEV__) {\n    if (\n      ReactCurrentDebugFiberIsRenderingInDEV &&\n      !getIsUpdatingOpaqueValueInRenderPhaseInDEV()\n    ) {\n      switch (fiber.tag) {\n        case FunctionComponent:\n        case ForwardRef:\n        case SimpleMemoComponent: {\n          const renderingComponentName =\n            (workInProgress && getComponentNameFromFiber(workInProgress)) ||\n            'Unknown';\n          // Dedupe by the rendering component because it's the one that needs to be fixed.\n          const dedupeKey = renderingComponentName;\n          if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {\n            didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);\n            const setStateComponentName =\n              getComponentNameFromFiber(fiber) || 'Unknown';\n            console.error(\n              'Cannot update a component (`%s`) while rendering a ' +\n                'different component (`%s`). To locate the bad setState() call inside `%s`, ' +\n                'follow the stack trace as described in https://reactjs.org/link/setstate-in-render',\n              setStateComponentName,\n              renderingComponentName,\n              renderingComponentName,\n            );\n          }\n          break;\n        }\n        case ClassComponent: {\n          if (!didWarnAboutUpdateInRender) {\n            console.error(\n              'Cannot update during an existing state transition (such as ' +\n                'within `render`). Render methods should be a pure ' +\n                'function of props and state.',\n            );\n            didWarnAboutUpdateInRender = true;\n          }\n          break;\n        }\n      }\n    }\n  }\n}\n\nexport function restorePendingUpdaters(root: FiberRoot, lanes: Lanes): void {\n  if (enableUpdaterTracking) {\n    if (isDevToolsPresent) {\n      const memoizedUpdaters = root.memoizedUpdaters;\n      memoizedUpdaters.forEach(schedulingFiber => {\n        addFiberToLanesMap(root, schedulingFiber, lanes);\n      });\n\n      // This function intentionally does not clear memoized updaters.\n      // Those may still be relevant to the current commit\n      // and a future one (e.g. Suspense).\n    }\n  }\n}\n\nconst fakeActCallbackNode = {};\nfunction scheduleCallback(priorityLevel, callback) {\n  if (__DEV__) {\n    // If we're currently inside an `act` scope, bypass Scheduler and push to\n    // the `act` queue instead.\n    const actQueue = ReactCurrentActQueue.current;\n    if (actQueue !== null) {\n      actQueue.push(callback);\n      return fakeActCallbackNode;\n    } else {\n      return Scheduler_scheduleCallback(priorityLevel, callback);\n    }\n  } else {\n    // In production, always call Scheduler. This function will be stripped out.\n    return Scheduler_scheduleCallback(priorityLevel, callback);\n  }\n}\n\nfunction cancelCallback(callbackNode) {\n  if (__DEV__ && callbackNode === fakeActCallbackNode) {\n    return;\n  }\n  // In production, always call Scheduler. This function will be stripped out.\n  return Scheduler_cancelCallback(callbackNode);\n}\n\nfunction shouldForceFlushFallbacksInDEV() {\n  // Never force flush in production. This function should get stripped out.\n  return __DEV__ && ReactCurrentActQueue.current !== null;\n}\n\nfunction warnIfUpdatesNotWrappedWithActDEV(fiber: Fiber): void {\n  if (__DEV__) {\n    if (fiber.mode & ConcurrentMode) {\n      if (!isConcurrentActEnvironment()) {\n        // Not in an act environment. No need to warn.\n        return;\n      }\n    } else {\n      // Legacy mode has additional cases where we suppress a warning.\n      if (!isLegacyActEnvironment(fiber)) {\n        // Not in an act environment. No need to warn.\n        return;\n      }\n      if (executionContext !== NoContext) {\n        // Legacy mode doesn't warn if the update is batched, i.e.\n        // batchedUpdates or flushSync.\n        return;\n      }\n      if (\n        fiber.tag !== FunctionComponent &&\n        fiber.tag !== ForwardRef &&\n        fiber.tag !== SimpleMemoComponent\n      ) {\n        // For backwards compatibility with pre-hooks code, legacy mode only\n        // warns for updates that originate from a hook.\n        return;\n      }\n    }\n\n    if (ReactCurrentActQueue.current === null) {\n      const previousFiber = ReactCurrentFiberCurrent;\n      try {\n        setCurrentDebugFiberInDEV(fiber);\n        console.error(\n          'An update to %s inside a test was not wrapped in act(...).\\n\\n' +\n            'When testing, code that causes React state updates should be ' +\n            'wrapped into act(...):\\n\\n' +\n            'act(() => {\\n' +\n            '  /* fire events that update state */\\n' +\n            '});\\n' +\n            '/* assert on the output */\\n\\n' +\n            \"This ensures that you're testing the behavior the user would see \" +\n            'in the browser.' +\n            ' Learn more at https://reactjs.org/link/wrap-tests-with-act',\n          getComponentNameFromFiber(fiber),\n        );\n      } finally {\n        if (previousFiber) {\n          setCurrentDebugFiberInDEV(fiber);\n        } else {\n          resetCurrentDebugFiberInDEV();\n        }\n      }\n    }\n  }\n}\n\nfunction warnIfSuspenseResolutionNotWrappedWithActDEV(root: FiberRoot): void {\n  if (__DEV__) {\n    if (\n      root.tag !== LegacyRoot &&\n      isConcurrentActEnvironment() &&\n      ReactCurrentActQueue.current === null\n    ) {\n      console.error(\n        'A suspended resource finished loading inside a test, but the event ' +\n          'was not wrapped in act(...).\\n\\n' +\n          'When testing, code that resolves suspended data should be wrapped ' +\n          'into act(...):\\n\\n' +\n          'act(() => {\\n' +\n          '  /* finish loading suspended data */\\n' +\n          '});\\n' +\n          '/* assert on the output */\\n\\n' +\n          \"This ensures that you're testing the behavior the user would see \" +\n          'in the browser.' +\n          ' Learn more at https://reactjs.org/link/wrap-tests-with-act',\n      );\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}