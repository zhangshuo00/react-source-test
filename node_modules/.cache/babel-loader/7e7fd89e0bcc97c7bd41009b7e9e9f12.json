{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n// Ids are base 32 strings whose binary representation corresponds to the\n// position of a node in a tree.\n// Every time the tree forks into multiple children, we add additional bits to\n// the left of the sequence that represent the position of the child within the\n// current level of children.\n//\n//      00101       00010001011010101\n//      ╰─┬─╯       ╰───────┬───────╯\n//   Fork 5 of 20       Parent id\n//\n// The leading 0s are important. In the above example, you only need 3 bits to\n// represent slot 5. However, you need 5 bits to represent all the forks at\n// the current level, so we must account for the empty bits at the end.\n//\n// For this same reason, slots are 1-indexed instead of 0-indexed. Otherwise,\n// the zeroth id at a level would be indistinguishable from its parent.\n//\n// If a node has only one child, and does not materialize an id (i.e. does not\n// contain a useId hook), then we don't need to allocate any space in the\n// sequence. It's treated as a transparent indirection. For example, these two\n// trees produce the same ids:\n//\n// <>                          <>\n//   <Indirection>               <A />\n//     <A />                     <B />\n//   </Indirection>            </>\n//   <B />\n// </>\n//\n// However, we cannot skip any node that materializes an id. Otherwise, a parent\n// id that does not fork would be indistinguishable from its child id. For\n// example, this tree does not fork, but the parent and child must have\n// different ids.\n//\n// <Parent>\n//   <Child />\n// </Parent>\n//\n// To handle this scenario, every time we materialize an id, we allocate a\n// new level with a single slot. You can think of this as a fork with only one\n// prong, or an array of children with length 1.\n//\n// It's possible for the size of the sequence to exceed 32 bits, the max\n// size for bitwise operations. When this happens, we make more room by\n// converting the right part of the id to a string and storing it in an overflow\n// variable. We use a base 32 string representation, because 32 is the largest\n// power of 2 that is supported by toString(). We want the base to be large so\n// that the resulting ids are compact, and we want the base to be a power of 2\n// because every log2(base) bits corresponds to a single character, i.e. every\n// log2(32) = 5 bits. That means we can lop bits off the end 5 at a time without\n// affecting the final result.\nimport { getIsHydrating } from './ReactFiberHydrationContext.new';\nimport { clz32 } from './clz32';\nimport { Forked, NoFlags } from './ReactFiberFlags';\n// TODO: Use the unified fiber stack module instead of this local one?\n// Intentionally not using it yet to derisk the initial implementation, because\n// the way we push/pop these values is a bit unusual. If there's a mistake, I'd\n// rather the ids be wrong than crash the whole reconciler.\nconst forkStack = [];\nlet forkStackIndex = 0;\nlet treeForkProvider = null;\nlet treeForkCount = 0;\nconst idStack = [];\nlet idStackIndex = 0;\nlet treeContextProvider = null;\nlet treeContextId = 1;\nlet treeContextOverflow = '';\nexport function isForkedChild(workInProgress) {\n  warnIfNotHydrating();\n  return (workInProgress.flags & Forked) !== NoFlags;\n}\nexport function getForksAtLevel(workInProgress) {\n  warnIfNotHydrating();\n  return treeForkCount;\n}\nexport function getTreeId() {\n  const overflow = treeContextOverflow;\n  const idWithLeadingBit = treeContextId;\n  const id = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);\n  return id.toString(32) + overflow;\n}\nexport function pushTreeFork(workInProgress, totalChildren) {\n  // This is called right after we reconcile an array (or iterator) of child\n  // fibers, because that's the only place where we know how many children in\n  // the whole set without doing extra work later, or storing addtional\n  // information on the fiber.\n  //\n  // That's why this function is separate from pushTreeId — it's called during\n  // the render phase of the fork parent, not the child, which is where we push\n  // the other context values.\n  //\n  // In the Fizz implementation this is much simpler because the child is\n  // rendered in the same callstack as the parent.\n  //\n  // It might be better to just add a `forks` field to the Fiber type. It would\n  // make this module simpler.\n  warnIfNotHydrating();\n  forkStack[forkStackIndex++] = treeForkCount;\n  forkStack[forkStackIndex++] = treeForkProvider;\n  treeForkProvider = workInProgress;\n  treeForkCount = totalChildren;\n}\nexport function pushTreeId(workInProgress, totalChildren, index) {\n  warnIfNotHydrating();\n  idStack[idStackIndex++] = treeContextId;\n  idStack[idStackIndex++] = treeContextOverflow;\n  idStack[idStackIndex++] = treeContextProvider;\n  treeContextProvider = workInProgress;\n  const baseIdWithLeadingBit = treeContextId;\n  const baseOverflow = treeContextOverflow; // The leftmost 1 marks the end of the sequence, non-inclusive. It's not part\n  // of the id; we use it to account for leading 0s.\n\n  const baseLength = getBitLength(baseIdWithLeadingBit) - 1;\n  const baseId = baseIdWithLeadingBit & ~(1 << baseLength);\n  const slot = index + 1;\n  const length = getBitLength(totalChildren) + baseLength; // 30 is the max length we can store without overflowing, taking into\n  // consideration the leading 1 we use to mark the end of the sequence.\n\n  if (length > 30) {\n    // We overflowed the bitwise-safe range. Fall back to slower algorithm.\n    // This branch assumes the length of the base id is greater than 5; it won't\n    // work for smaller ids, because you need 5 bits per character.\n    //\n    // We encode the id in multiple steps: first the base id, then the\n    // remaining digits.\n    //\n    // Each 5 bit sequence corresponds to a single base 32 character. So for\n    // example, if the current id is 23 bits long, we can convert 20 of those\n    // bits into a string of 4 characters, with 3 bits left over.\n    //\n    // First calculate how many bits in the base id represent a complete\n    // sequence of characters.\n    const numberOfOverflowBits = baseLength - baseLength % 5; // Then create a bitmask that selects only those bits.\n\n    const newOverflowBits = (1 << numberOfOverflowBits) - 1; // Select the bits, and convert them to a base 32 string.\n\n    const newOverflow = (baseId & newOverflowBits).toString(32); // Now we can remove those bits from the base id.\n\n    const restOfBaseId = baseId >> numberOfOverflowBits;\n    const restOfBaseLength = baseLength - numberOfOverflowBits; // Finally, encode the rest of the bits using the normal algorithm. Because\n    // we made more room, this time it won't overflow.\n\n    const restOfLength = getBitLength(totalChildren) + restOfBaseLength;\n    const restOfNewBits = slot << restOfBaseLength;\n    const id = restOfNewBits | restOfBaseId;\n    const overflow = newOverflow + baseOverflow;\n    treeContextId = 1 << restOfLength | id;\n    treeContextOverflow = overflow;\n  } else {\n    // Normal path\n    const newBits = slot << baseLength;\n    const id = newBits | baseId;\n    const overflow = baseOverflow;\n    treeContextId = 1 << length | id;\n    treeContextOverflow = overflow;\n  }\n}\nexport function pushMaterializedTreeId(workInProgress) {\n  warnIfNotHydrating(); // This component materialized an id. This will affect any ids that appear\n  // in its children.\n\n  const returnFiber = workInProgress.return;\n\n  if (returnFiber !== null) {\n    const numberOfForks = 1;\n    const slotIndex = 0;\n    pushTreeFork(workInProgress, numberOfForks);\n    pushTreeId(workInProgress, numberOfForks, slotIndex);\n  }\n}\n\nfunction getBitLength(number) {\n  return 32 - clz32(number);\n}\n\nfunction getLeadingBit(id) {\n  return 1 << getBitLength(id) - 1;\n}\n\nexport function popTreeContext(workInProgress) {\n  // Restore the previous values.\n  // This is a bit more complicated than other context-like modules in Fiber\n  // because the same Fiber may appear on the stack multiple times and for\n  // different reasons. We have to keep popping until the work-in-progress is\n  // no longer at the top of the stack.\n  while (workInProgress === treeForkProvider) {\n    treeForkProvider = forkStack[--forkStackIndex];\n    forkStack[forkStackIndex] = null;\n    treeForkCount = forkStack[--forkStackIndex];\n    forkStack[forkStackIndex] = null;\n  }\n\n  while (workInProgress === treeContextProvider) {\n    treeContextProvider = idStack[--idStackIndex];\n    idStack[idStackIndex] = null;\n    treeContextOverflow = idStack[--idStackIndex];\n    idStack[idStackIndex] = null;\n    treeContextId = idStack[--idStackIndex];\n    idStack[idStackIndex] = null;\n  }\n}\nexport function getSuspendedTreeContext() {\n  warnIfNotHydrating();\n\n  if (treeContextProvider !== null) {\n    return {\n      id: treeContextId,\n      overflow: treeContextOverflow\n    };\n  } else {\n    return null;\n  }\n}\nexport function restoreSuspendedTreeContext(workInProgress, suspendedContext) {\n  warnIfNotHydrating();\n  idStack[idStackIndex++] = treeContextId;\n  idStack[idStackIndex++] = treeContextOverflow;\n  idStack[idStackIndex++] = treeContextProvider;\n  treeContextId = suspendedContext.id;\n  treeContextOverflow = suspendedContext.overflow;\n  treeContextProvider = workInProgress;\n}\n\nfunction warnIfNotHydrating() {\n  if (__DEV__) {\n    if (!getIsHydrating()) {\n      console.error('Expected to be hydrating. This is a bug in React. Please file ' + 'an issue.');\n    }\n  }\n}","map":{"version":3,"sources":["/Users/zhangshuo/git/react-source-test/src/react/packages/react-reconciler/src/ReactFiberTreeContext.new.js"],"names":["getIsHydrating","clz32","Forked","NoFlags","forkStack","forkStackIndex","treeForkProvider","treeForkCount","idStack","idStackIndex","treeContextProvider","treeContextId","treeContextOverflow","isForkedChild","workInProgress","warnIfNotHydrating","flags","getForksAtLevel","getTreeId","overflow","idWithLeadingBit","id","getLeadingBit","toString","pushTreeFork","totalChildren","pushTreeId","index","baseIdWithLeadingBit","baseOverflow","baseLength","getBitLength","baseId","slot","length","numberOfOverflowBits","newOverflowBits","newOverflow","restOfBaseId","restOfBaseLength","restOfLength","restOfNewBits","newBits","pushMaterializedTreeId","returnFiber","return","numberOfForks","slotIndex","number","popTreeContext","getSuspendedTreeContext","restoreSuspendedTreeContext","suspendedContext","__DEV__","console","error"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\n// Ids are base 32 strings whose binary representation corresponds to the\n// position of a node in a tree.\n\n// Every time the tree forks into multiple children, we add additional bits to\n// the left of the sequence that represent the position of the child within the\n// current level of children.\n//\n//      00101       00010001011010101\n//      ╰─┬─╯       ╰───────┬───────╯\n//   Fork 5 of 20       Parent id\n//\n// The leading 0s are important. In the above example, you only need 3 bits to\n// represent slot 5. However, you need 5 bits to represent all the forks at\n// the current level, so we must account for the empty bits at the end.\n//\n// For this same reason, slots are 1-indexed instead of 0-indexed. Otherwise,\n// the zeroth id at a level would be indistinguishable from its parent.\n//\n// If a node has only one child, and does not materialize an id (i.e. does not\n// contain a useId hook), then we don't need to allocate any space in the\n// sequence. It's treated as a transparent indirection. For example, these two\n// trees produce the same ids:\n//\n// <>                          <>\n//   <Indirection>               <A />\n//     <A />                     <B />\n//   </Indirection>            </>\n//   <B />\n// </>\n//\n// However, we cannot skip any node that materializes an id. Otherwise, a parent\n// id that does not fork would be indistinguishable from its child id. For\n// example, this tree does not fork, but the parent and child must have\n// different ids.\n//\n// <Parent>\n//   <Child />\n// </Parent>\n//\n// To handle this scenario, every time we materialize an id, we allocate a\n// new level with a single slot. You can think of this as a fork with only one\n// prong, or an array of children with length 1.\n//\n// It's possible for the size of the sequence to exceed 32 bits, the max\n// size for bitwise operations. When this happens, we make more room by\n// converting the right part of the id to a string and storing it in an overflow\n// variable. We use a base 32 string representation, because 32 is the largest\n// power of 2 that is supported by toString(). We want the base to be large so\n// that the resulting ids are compact, and we want the base to be a power of 2\n// because every log2(base) bits corresponds to a single character, i.e. every\n// log2(32) = 5 bits. That means we can lop bits off the end 5 at a time without\n// affecting the final result.\n\nimport {getIsHydrating} from './ReactFiberHydrationContext.new';\nimport {clz32} from './clz32';\nimport {Forked, NoFlags} from './ReactFiberFlags';\n\nexport type TreeContext = {\n  id: number,\n  overflow: string,\n};\n\n// TODO: Use the unified fiber stack module instead of this local one?\n// Intentionally not using it yet to derisk the initial implementation, because\n// the way we push/pop these values is a bit unusual. If there's a mistake, I'd\n// rather the ids be wrong than crash the whole reconciler.\nconst forkStack: Array<any> = [];\nlet forkStackIndex: number = 0;\nlet treeForkProvider: Fiber | null = null;\nlet treeForkCount: number = 0;\n\nconst idStack: Array<any> = [];\nlet idStackIndex: number = 0;\nlet treeContextProvider: Fiber | null = null;\nlet treeContextId: number = 1;\nlet treeContextOverflow: string = '';\n\nexport function isForkedChild(workInProgress: Fiber): boolean {\n  warnIfNotHydrating();\n  return (workInProgress.flags & Forked) !== NoFlags;\n}\n\nexport function getForksAtLevel(workInProgress: Fiber): number {\n  warnIfNotHydrating();\n  return treeForkCount;\n}\n\nexport function getTreeId(): string {\n  const overflow = treeContextOverflow;\n  const idWithLeadingBit = treeContextId;\n  const id = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);\n  return id.toString(32) + overflow;\n}\n\nexport function pushTreeFork(\n  workInProgress: Fiber,\n  totalChildren: number,\n): void {\n  // This is called right after we reconcile an array (or iterator) of child\n  // fibers, because that's the only place where we know how many children in\n  // the whole set without doing extra work later, or storing addtional\n  // information on the fiber.\n  //\n  // That's why this function is separate from pushTreeId — it's called during\n  // the render phase of the fork parent, not the child, which is where we push\n  // the other context values.\n  //\n  // In the Fizz implementation this is much simpler because the child is\n  // rendered in the same callstack as the parent.\n  //\n  // It might be better to just add a `forks` field to the Fiber type. It would\n  // make this module simpler.\n\n  warnIfNotHydrating();\n\n  forkStack[forkStackIndex++] = treeForkCount;\n  forkStack[forkStackIndex++] = treeForkProvider;\n\n  treeForkProvider = workInProgress;\n  treeForkCount = totalChildren;\n}\n\nexport function pushTreeId(\n  workInProgress: Fiber,\n  totalChildren: number,\n  index: number,\n) {\n  warnIfNotHydrating();\n\n  idStack[idStackIndex++] = treeContextId;\n  idStack[idStackIndex++] = treeContextOverflow;\n  idStack[idStackIndex++] = treeContextProvider;\n\n  treeContextProvider = workInProgress;\n\n  const baseIdWithLeadingBit = treeContextId;\n  const baseOverflow = treeContextOverflow;\n\n  // The leftmost 1 marks the end of the sequence, non-inclusive. It's not part\n  // of the id; we use it to account for leading 0s.\n  const baseLength = getBitLength(baseIdWithLeadingBit) - 1;\n  const baseId = baseIdWithLeadingBit & ~(1 << baseLength);\n\n  const slot = index + 1;\n  const length = getBitLength(totalChildren) + baseLength;\n\n  // 30 is the max length we can store without overflowing, taking into\n  // consideration the leading 1 we use to mark the end of the sequence.\n  if (length > 30) {\n    // We overflowed the bitwise-safe range. Fall back to slower algorithm.\n    // This branch assumes the length of the base id is greater than 5; it won't\n    // work for smaller ids, because you need 5 bits per character.\n    //\n    // We encode the id in multiple steps: first the base id, then the\n    // remaining digits.\n    //\n    // Each 5 bit sequence corresponds to a single base 32 character. So for\n    // example, if the current id is 23 bits long, we can convert 20 of those\n    // bits into a string of 4 characters, with 3 bits left over.\n    //\n    // First calculate how many bits in the base id represent a complete\n    // sequence of characters.\n    const numberOfOverflowBits = baseLength - (baseLength % 5);\n\n    // Then create a bitmask that selects only those bits.\n    const newOverflowBits = (1 << numberOfOverflowBits) - 1;\n\n    // Select the bits, and convert them to a base 32 string.\n    const newOverflow = (baseId & newOverflowBits).toString(32);\n\n    // Now we can remove those bits from the base id.\n    const restOfBaseId = baseId >> numberOfOverflowBits;\n    const restOfBaseLength = baseLength - numberOfOverflowBits;\n\n    // Finally, encode the rest of the bits using the normal algorithm. Because\n    // we made more room, this time it won't overflow.\n    const restOfLength = getBitLength(totalChildren) + restOfBaseLength;\n    const restOfNewBits = slot << restOfBaseLength;\n    const id = restOfNewBits | restOfBaseId;\n    const overflow = newOverflow + baseOverflow;\n\n    treeContextId = (1 << restOfLength) | id;\n    treeContextOverflow = overflow;\n  } else {\n    // Normal path\n    const newBits = slot << baseLength;\n    const id = newBits | baseId;\n    const overflow = baseOverflow;\n\n    treeContextId = (1 << length) | id;\n    treeContextOverflow = overflow;\n  }\n}\n\nexport function pushMaterializedTreeId(workInProgress: Fiber) {\n  warnIfNotHydrating();\n\n  // This component materialized an id. This will affect any ids that appear\n  // in its children.\n  const returnFiber = workInProgress.return;\n  if (returnFiber !== null) {\n    const numberOfForks = 1;\n    const slotIndex = 0;\n    pushTreeFork(workInProgress, numberOfForks);\n    pushTreeId(workInProgress, numberOfForks, slotIndex);\n  }\n}\n\nfunction getBitLength(number: number): number {\n  return 32 - clz32(number);\n}\n\nfunction getLeadingBit(id: number) {\n  return 1 << (getBitLength(id) - 1);\n}\n\nexport function popTreeContext(workInProgress: Fiber) {\n  // Restore the previous values.\n\n  // This is a bit more complicated than other context-like modules in Fiber\n  // because the same Fiber may appear on the stack multiple times and for\n  // different reasons. We have to keep popping until the work-in-progress is\n  // no longer at the top of the stack.\n\n  while (workInProgress === treeForkProvider) {\n    treeForkProvider = forkStack[--forkStackIndex];\n    forkStack[forkStackIndex] = null;\n    treeForkCount = forkStack[--forkStackIndex];\n    forkStack[forkStackIndex] = null;\n  }\n\n  while (workInProgress === treeContextProvider) {\n    treeContextProvider = idStack[--idStackIndex];\n    idStack[idStackIndex] = null;\n    treeContextOverflow = idStack[--idStackIndex];\n    idStack[idStackIndex] = null;\n    treeContextId = idStack[--idStackIndex];\n    idStack[idStackIndex] = null;\n  }\n}\n\nexport function getSuspendedTreeContext(): TreeContext | null {\n  warnIfNotHydrating();\n  if (treeContextProvider !== null) {\n    return {\n      id: treeContextId,\n      overflow: treeContextOverflow,\n    };\n  } else {\n    return null;\n  }\n}\n\nexport function restoreSuspendedTreeContext(\n  workInProgress: Fiber,\n  suspendedContext: TreeContext,\n) {\n  warnIfNotHydrating();\n\n  idStack[idStackIndex++] = treeContextId;\n  idStack[idStackIndex++] = treeContextOverflow;\n  idStack[idStackIndex++] = treeContextProvider;\n\n  treeContextId = suspendedContext.id;\n  treeContextOverflow = suspendedContext.overflow;\n  treeContextProvider = workInProgress;\n}\n\nfunction warnIfNotHydrating() {\n  if (__DEV__) {\n    if (!getIsHydrating()) {\n      console.error(\n        'Expected to be hydrating. This is a bug in React. Please file ' +\n          'an issue.',\n      );\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}