{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { NoMode, ConcurrentMode } from './ReactTypeOfMode';\nimport { HostComponent, HostText, HostRoot, SuspenseComponent } from './ReactWorkTags';\nimport { ChildDeletion, Placement, Hydrating } from './ReactFiberFlags';\nimport { createFiberFromHostInstanceForDeletion, createFiberFromDehydratedFragment } from './ReactFiber.new';\nimport { shouldSetTextContent, supportsHydration, canHydrateInstance, canHydrateTextInstance, canHydrateSuspenseInstance, getNextHydratableSibling, getFirstHydratableChild, getFirstHydratableChildWithinContainer, getFirstHydratableChildWithinSuspenseInstance, hydrateInstance, hydrateTextInstance, hydrateSuspenseInstance, getNextHydratableInstanceAfterSuspenseInstance, shouldDeleteUnhydratedTailInstances, didNotMatchHydratedContainerTextInstance, didNotMatchHydratedTextInstance, didNotHydrateInstanceWithinContainer, didNotHydrateInstanceWithinSuspenseInstance, didNotHydrateInstance, didNotFindHydratableInstanceWithinContainer, didNotFindHydratableTextInstanceWithinContainer, didNotFindHydratableSuspenseInstanceWithinContainer, didNotFindHydratableInstanceWithinSuspenseInstance, didNotFindHydratableTextInstanceWithinSuspenseInstance, didNotFindHydratableSuspenseInstanceWithinSuspenseInstance, didNotFindHydratableInstance, didNotFindHydratableTextInstance, didNotFindHydratableSuspenseInstance } from './ReactFiberHostConfig';\nimport { enableSuspenseServerRenderer } from 'shared/ReactFeatureFlags';\nimport { OffscreenLane } from './ReactFiberLane.new';\nimport { getSuspendedTreeContext, restoreSuspendedTreeContext } from './ReactFiberTreeContext.new'; // The deepest Fiber on the stack involved in a hydration context.\n// This may have been an insertion or a hydration.\n\nlet hydrationParentFiber = null;\nlet nextHydratableInstance = null;\nlet isHydrating = false;\n\nfunction warnIfHydrating() {\n  if (__DEV__) {\n    if (isHydrating) {\n      console.error('We should not be hydrating here. This is a bug in React. Please file a bug.');\n    }\n  }\n}\n\nfunction enterHydrationState(fiber) {\n  if (!supportsHydration) {\n    return false;\n  }\n\n  const parentInstance = fiber.stateNode.containerInfo;\n  nextHydratableInstance = getFirstHydratableChildWithinContainer(parentInstance);\n  hydrationParentFiber = fiber;\n  isHydrating = true;\n  return true;\n}\n\nfunction reenterHydrationStateFromDehydratedSuspenseInstance(fiber, suspenseInstance, treeContext) {\n  if (!supportsHydration) {\n    return false;\n  }\n\n  nextHydratableInstance = getFirstHydratableChildWithinSuspenseInstance(suspenseInstance);\n  hydrationParentFiber = fiber;\n  isHydrating = true;\n\n  if (treeContext !== null) {\n    restoreSuspendedTreeContext(fiber, treeContext);\n  }\n\n  return true;\n}\n\nfunction deleteHydratableInstance(returnFiber, instance) {\n  if (__DEV__) {\n    switch (returnFiber.tag) {\n      case HostRoot:\n        didNotHydrateInstanceWithinContainer(returnFiber.stateNode.containerInfo, instance);\n        break;\n\n      case HostComponent:\n        didNotHydrateInstance(returnFiber.type, returnFiber.memoizedProps, returnFiber.stateNode, instance);\n        break;\n\n      case SuspenseComponent:\n        const suspenseState = returnFiber.memoizedState;\n        if (suspenseState.dehydrated !== null) didNotHydrateInstanceWithinSuspenseInstance(suspenseState.dehydrated, instance);\n        break;\n    }\n  }\n\n  const childToDelete = createFiberFromHostInstanceForDeletion();\n  childToDelete.stateNode = instance;\n  childToDelete.return = returnFiber;\n  const deletions = returnFiber.deletions;\n\n  if (deletions === null) {\n    returnFiber.deletions = [childToDelete];\n    returnFiber.flags |= ChildDeletion;\n  } else {\n    deletions.push(childToDelete);\n  }\n}\n\nfunction insertNonHydratedInstance(returnFiber, fiber) {\n  fiber.flags = fiber.flags & ~Hydrating | Placement;\n\n  if (__DEV__) {\n    switch (returnFiber.tag) {\n      case HostRoot:\n        {\n          const parentContainer = returnFiber.stateNode.containerInfo;\n\n          switch (fiber.tag) {\n            case HostComponent:\n              const type = fiber.type;\n              const props = fiber.pendingProps;\n              didNotFindHydratableInstanceWithinContainer(parentContainer, type, props);\n              break;\n\n            case HostText:\n              const text = fiber.pendingProps;\n              didNotFindHydratableTextInstanceWithinContainer(parentContainer, text);\n              break;\n\n            case SuspenseComponent:\n              didNotFindHydratableSuspenseInstanceWithinContainer(parentContainer);\n              break;\n          }\n\n          break;\n        }\n\n      case HostComponent:\n        {\n          const parentType = returnFiber.type;\n          const parentProps = returnFiber.memoizedProps;\n          const parentInstance = returnFiber.stateNode;\n\n          switch (fiber.tag) {\n            case HostComponent:\n              const type = fiber.type;\n              const props = fiber.pendingProps;\n              didNotFindHydratableInstance(parentType, parentProps, parentInstance, type, props);\n              break;\n\n            case HostText:\n              const text = fiber.pendingProps;\n              didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, text);\n              break;\n\n            case SuspenseComponent:\n              didNotFindHydratableSuspenseInstance(parentType, parentProps, parentInstance);\n              break;\n          }\n\n          break;\n        }\n\n      case SuspenseComponent:\n        {\n          const suspenseState = returnFiber.memoizedState;\n          const parentInstance = suspenseState.dehydrated;\n          if (parentInstance !== null) switch (fiber.tag) {\n            case HostComponent:\n              const type = fiber.type;\n              const props = fiber.pendingProps;\n              didNotFindHydratableInstanceWithinSuspenseInstance(parentInstance, type, props);\n              break;\n\n            case HostText:\n              const text = fiber.pendingProps;\n              didNotFindHydratableTextInstanceWithinSuspenseInstance(parentInstance, text);\n              break;\n\n            case SuspenseComponent:\n              didNotFindHydratableSuspenseInstanceWithinSuspenseInstance(parentInstance);\n              break;\n          }\n          break;\n        }\n\n      default:\n        return;\n    }\n  }\n}\n\nfunction tryHydrate(fiber, nextInstance) {\n  switch (fiber.tag) {\n    case HostComponent:\n      {\n        const type = fiber.type;\n        const props = fiber.pendingProps;\n        const instance = canHydrateInstance(nextInstance, type, props);\n\n        if (instance !== null) {\n          fiber.stateNode = instance;\n          hydrationParentFiber = fiber;\n          nextHydratableInstance = getFirstHydratableChild(instance);\n          return true;\n        }\n\n        return false;\n      }\n\n    case HostText:\n      {\n        const text = fiber.pendingProps;\n        const textInstance = canHydrateTextInstance(nextInstance, text);\n\n        if (textInstance !== null) {\n          fiber.stateNode = textInstance;\n          hydrationParentFiber = fiber; // Text Instances don't have children so there's nothing to hydrate.\n\n          nextHydratableInstance = null;\n          return true;\n        }\n\n        return false;\n      }\n\n    case SuspenseComponent:\n      {\n        if (enableSuspenseServerRenderer) {\n          const suspenseInstance = canHydrateSuspenseInstance(nextInstance);\n\n          if (suspenseInstance !== null) {\n            const suspenseState = {\n              dehydrated: suspenseInstance,\n              treeContext: getSuspendedTreeContext(),\n              retryLane: OffscreenLane\n            };\n            fiber.memoizedState = suspenseState; // Store the dehydrated fragment as a child fiber.\n            // This simplifies the code for getHostSibling and deleting nodes,\n            // since it doesn't have to consider all Suspense boundaries and\n            // check if they're dehydrated ones or not.\n\n            const dehydratedFragment = createFiberFromDehydratedFragment(suspenseInstance);\n            dehydratedFragment.return = fiber;\n            fiber.child = dehydratedFragment;\n            hydrationParentFiber = fiber; // While a Suspense Instance does have children, we won't step into\n            // it during the first pass. Instead, we'll reenter it later.\n\n            nextHydratableInstance = null;\n            return true;\n          }\n        }\n\n        return false;\n      }\n\n    default:\n      return false;\n  }\n}\n\nfunction throwOnHydrationMismatchIfConcurrentMode(fiber) {\n  if ((fiber.mode & ConcurrentMode) !== NoMode) {\n    throw new Error('An error occurred during hydration. The server HTML was replaced with client content');\n  }\n}\n\nfunction tryToClaimNextHydratableInstance(fiber) {\n  if (!isHydrating) {\n    return;\n  }\n\n  let nextInstance = nextHydratableInstance;\n\n  if (!nextInstance) {\n    throwOnHydrationMismatchIfConcurrentMode(fiber); // Nothing to hydrate. Make it an insertion.\n\n    insertNonHydratedInstance(hydrationParentFiber, fiber);\n    isHydrating = false;\n    hydrationParentFiber = fiber;\n    return;\n  }\n\n  const firstAttemptedInstance = nextInstance;\n\n  if (!tryHydrate(fiber, nextInstance)) {\n    throwOnHydrationMismatchIfConcurrentMode(fiber); // If we can't hydrate this instance let's try the next one.\n    // We use this as a heuristic. It's based on intuition and not data so it\n    // might be flawed or unnecessary.\n\n    nextInstance = getNextHydratableSibling(firstAttemptedInstance);\n    const prevHydrationParentFiber = hydrationParentFiber;\n\n    if (!nextInstance || !tryHydrate(fiber, nextInstance)) {\n      // Nothing to hydrate. Make it an insertion.\n      insertNonHydratedInstance(hydrationParentFiber, fiber);\n      isHydrating = false;\n      hydrationParentFiber = fiber;\n      return;\n    } // We matched the next one, we'll now assume that the first one was\n    // superfluous and we'll delete it. Since we can't eagerly delete it\n    // we'll have to schedule a deletion. To do that, this node needs a dummy\n    // fiber associated with it.\n\n\n    deleteHydratableInstance(prevHydrationParentFiber, firstAttemptedInstance);\n  }\n}\n\nfunction prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {\n  if (!supportsHydration) {\n    throw new Error('Expected prepareToHydrateHostInstance() to never be called. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n  }\n\n  const instance = fiber.stateNode;\n  const updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber); // TODO: Type this specific to this type of component.\n\n  fiber.updateQueue = updatePayload; // If the update payload indicates that there is a change or if there\n  // is a new ref we mark this as an update.\n\n  if (updatePayload !== null) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction prepareToHydrateHostTextInstance(fiber) {\n  if (!supportsHydration) {\n    throw new Error('Expected prepareToHydrateHostTextInstance() to never be called. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n  }\n\n  const textInstance = fiber.stateNode;\n  const textContent = fiber.memoizedProps;\n  const shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);\n\n  if (__DEV__) {\n    if (shouldUpdate) {\n      // We assume that prepareToHydrateHostTextInstance is called in a context where the\n      // hydration parent is the parent host component of this host text.\n      const returnFiber = hydrationParentFiber;\n\n      if (returnFiber !== null) {\n        switch (returnFiber.tag) {\n          case HostRoot:\n            {\n              const parentContainer = returnFiber.stateNode.containerInfo;\n              didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, textContent);\n              break;\n            }\n\n          case HostComponent:\n            {\n              const parentType = returnFiber.type;\n              const parentProps = returnFiber.memoizedProps;\n              const parentInstance = returnFiber.stateNode;\n              didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, textContent);\n              break;\n            }\n        }\n      }\n    }\n  }\n\n  return shouldUpdate;\n}\n\nfunction prepareToHydrateHostSuspenseInstance(fiber) {\n  if (!supportsHydration) {\n    throw new Error('Expected prepareToHydrateHostSuspenseInstance() to never be called. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n  }\n\n  const suspenseState = fiber.memoizedState;\n  const suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;\n\n  if (!suspenseInstance) {\n    throw new Error('Expected to have a hydrated suspense instance. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n  }\n\n  hydrateSuspenseInstance(suspenseInstance, fiber);\n}\n\nfunction skipPastDehydratedSuspenseInstance(fiber) {\n  if (!supportsHydration) {\n    throw new Error('Expected skipPastDehydratedSuspenseInstance() to never be called. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n  }\n\n  const suspenseState = fiber.memoizedState;\n  const suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;\n\n  if (!suspenseInstance) {\n    throw new Error('Expected to have a hydrated suspense instance. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n  }\n\n  return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);\n}\n\nfunction popToNextHostParent(fiber) {\n  let parent = fiber.return;\n\n  while (parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot && parent.tag !== SuspenseComponent) {\n    parent = parent.return;\n  }\n\n  hydrationParentFiber = parent;\n}\n\nfunction popHydrationState(fiber) {\n  if (!supportsHydration) {\n    return false;\n  }\n\n  if (fiber !== hydrationParentFiber) {\n    // We're deeper than the current hydration context, inside an inserted\n    // tree.\n    return false;\n  }\n\n  if (!isHydrating) {\n    // If we're not currently hydrating but we're in a hydration context, then\n    // we were an insertion and now need to pop up reenter hydration of our\n    // siblings.\n    popToNextHostParent(fiber);\n    isHydrating = true;\n    return false;\n  } // If we have any remaining hydratable nodes, we need to delete them now.\n  // We only do this deeper than head and body since they tend to have random\n  // other nodes in them. We also ignore components with pure text content in\n  // side of them. We also don't delete anything inside the root container.\n\n\n  if (fiber.tag !== HostRoot && (fiber.tag !== HostComponent || shouldDeleteUnhydratedTailInstances(fiber.type) && !shouldSetTextContent(fiber.type, fiber.memoizedProps))) {\n    let nextInstance = nextHydratableInstance;\n\n    while (nextInstance) {\n      deleteHydratableInstance(fiber, nextInstance);\n      nextInstance = getNextHydratableSibling(nextInstance);\n    }\n  }\n\n  popToNextHostParent(fiber);\n\n  if (fiber.tag === SuspenseComponent) {\n    nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber);\n  } else {\n    nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;\n  }\n\n  return true;\n}\n\nfunction resetHydrationState() {\n  if (!supportsHydration) {\n    return;\n  }\n\n  hydrationParentFiber = null;\n  nextHydratableInstance = null;\n  isHydrating = false;\n}\n\nfunction getIsHydrating() {\n  return isHydrating;\n}\n\nexport { warnIfHydrating, enterHydrationState, getIsHydrating, reenterHydrationStateFromDehydratedSuspenseInstance, resetHydrationState, tryToClaimNextHydratableInstance, prepareToHydrateHostInstance, prepareToHydrateHostTextInstance, prepareToHydrateHostSuspenseInstance, popHydrationState };","map":{"version":3,"sources":["/Users/zhangshuo/git/react-source-test/src/react/packages/react-reconciler/src/ReactFiberHydrationContext.new.js"],"names":["NoMode","ConcurrentMode","HostComponent","HostText","HostRoot","SuspenseComponent","ChildDeletion","Placement","Hydrating","createFiberFromHostInstanceForDeletion","createFiberFromDehydratedFragment","shouldSetTextContent","supportsHydration","canHydrateInstance","canHydrateTextInstance","canHydrateSuspenseInstance","getNextHydratableSibling","getFirstHydratableChild","getFirstHydratableChildWithinContainer","getFirstHydratableChildWithinSuspenseInstance","hydrateInstance","hydrateTextInstance","hydrateSuspenseInstance","getNextHydratableInstanceAfterSuspenseInstance","shouldDeleteUnhydratedTailInstances","didNotMatchHydratedContainerTextInstance","didNotMatchHydratedTextInstance","didNotHydrateInstanceWithinContainer","didNotHydrateInstanceWithinSuspenseInstance","didNotHydrateInstance","didNotFindHydratableInstanceWithinContainer","didNotFindHydratableTextInstanceWithinContainer","didNotFindHydratableSuspenseInstanceWithinContainer","didNotFindHydratableInstanceWithinSuspenseInstance","didNotFindHydratableTextInstanceWithinSuspenseInstance","didNotFindHydratableSuspenseInstanceWithinSuspenseInstance","didNotFindHydratableInstance","didNotFindHydratableTextInstance","didNotFindHydratableSuspenseInstance","enableSuspenseServerRenderer","OffscreenLane","getSuspendedTreeContext","restoreSuspendedTreeContext","hydrationParentFiber","nextHydratableInstance","isHydrating","warnIfHydrating","__DEV__","console","error","enterHydrationState","fiber","parentInstance","stateNode","containerInfo","reenterHydrationStateFromDehydratedSuspenseInstance","suspenseInstance","treeContext","deleteHydratableInstance","returnFiber","instance","tag","type","memoizedProps","suspenseState","memoizedState","dehydrated","childToDelete","return","deletions","flags","push","insertNonHydratedInstance","parentContainer","props","pendingProps","text","parentType","parentProps","tryHydrate","nextInstance","textInstance","retryLane","dehydratedFragment","child","throwOnHydrationMismatchIfConcurrentMode","mode","Error","tryToClaimNextHydratableInstance","firstAttemptedInstance","prevHydrationParentFiber","prepareToHydrateHostInstance","rootContainerInstance","hostContext","updatePayload","updateQueue","prepareToHydrateHostTextInstance","textContent","shouldUpdate","prepareToHydrateHostSuspenseInstance","skipPastDehydratedSuspenseInstance","popToNextHostParent","parent","popHydrationState","resetHydrationState","getIsHydrating"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA,SAAQA,MAAR,EAAgBC,cAAhB,QAAqC,mBAArC;AAYA,SACEC,aADF,EAEEC,QAFF,EAGEC,QAHF,EAIEC,iBAJF,QAKO,iBALP;AAMA,SAAQC,aAAR,EAAuBC,SAAvB,EAAkCC,SAAlC,QAAkD,mBAAlD;AAEA,SACEC,sCADF,EAEEC,iCAFF,QAGO,kBAHP;AAIA,SACEC,oBADF,EAEEC,iBAFF,EAGEC,kBAHF,EAIEC,sBAJF,EAKEC,0BALF,EAMEC,wBANF,EAOEC,uBAPF,EAQEC,sCARF,EASEC,6CATF,EAUEC,eAVF,EAWEC,mBAXF,EAYEC,uBAZF,EAaEC,8CAbF,EAcEC,mCAdF,EAeEC,wCAfF,EAgBEC,+BAhBF,EAiBEC,oCAjBF,EAkBEC,2CAlBF,EAmBEC,qBAnBF,EAoBEC,2CApBF,EAqBEC,+CArBF,EAsBEC,mDAtBF,EAuBEC,kDAvBF,EAwBEC,sDAxBF,EAyBEC,0DAzBF,EA0BEC,4BA1BF,EA2BEC,gCA3BF,EA4BEC,oCA5BF,QA6BO,wBA7BP;AA8BA,SAAQC,4BAAR,QAA2C,0BAA3C;AACA,SAAQC,aAAR,QAA4B,sBAA5B;AACA,SACEC,uBADF,EAEEC,2BAFF,QAGO,6BAHP,C,CAKA;AACA;;AACA,IAAIC,oBAAkC,GAAG,IAAzC;AACA,IAAIC,sBAAiD,GAAG,IAAxD;AACA,IAAIC,WAAoB,GAAG,KAA3B;;AAEA,SAASC,eAAT,GAA2B;AACzB,MAAIC,OAAJ,EAAa;AACX,QAAIF,WAAJ,EAAiB;AACfG,MAAAA,OAAO,CAACC,KAAR,CACE,6EADF;AAGD;AACF;AACF;;AAED,SAASC,mBAAT,CAA6BC,KAA7B,EAAoD;AAClD,MAAI,CAACvC,iBAAL,EAAwB;AACtB,WAAO,KAAP;AACD;;AAED,QAAMwC,cAAyB,GAAGD,KAAK,CAACE,SAAN,CAAgBC,aAAlD;AACAV,EAAAA,sBAAsB,GAAG1B,sCAAsC,CAC7DkC,cAD6D,CAA/D;AAGAT,EAAAA,oBAAoB,GAAGQ,KAAvB;AACAN,EAAAA,WAAW,GAAG,IAAd;AACA,SAAO,IAAP;AACD;;AAED,SAASU,mDAAT,CACEJ,KADF,EAEEK,gBAFF,EAGEC,WAHF,EAIW;AACT,MAAI,CAAC7C,iBAAL,EAAwB;AACtB,WAAO,KAAP;AACD;;AACDgC,EAAAA,sBAAsB,GAAGzB,6CAA6C,CACpEqC,gBADoE,CAAtE;AAGAb,EAAAA,oBAAoB,GAAGQ,KAAvB;AACAN,EAAAA,WAAW,GAAG,IAAd;;AACA,MAAIY,WAAW,KAAK,IAApB,EAA0B;AACxBf,IAAAA,2BAA2B,CAACS,KAAD,EAAQM,WAAR,CAA3B;AACD;;AACD,SAAO,IAAP;AACD;;AAED,SAASC,wBAAT,CACEC,WADF,EAEEC,QAFF,EAGE;AACA,MAAIb,OAAJ,EAAa;AACX,YAAQY,WAAW,CAACE,GAApB;AACE,WAAKzD,QAAL;AACEuB,QAAAA,oCAAoC,CAClCgC,WAAW,CAACN,SAAZ,CAAsBC,aADY,EAElCM,QAFkC,CAApC;AAIA;;AACF,WAAK1D,aAAL;AACE2B,QAAAA,qBAAqB,CACnB8B,WAAW,CAACG,IADO,EAEnBH,WAAW,CAACI,aAFO,EAGnBJ,WAAW,CAACN,SAHO,EAInBO,QAJmB,CAArB;AAMA;;AACF,WAAKvD,iBAAL;AACE,cAAM2D,aAA4B,GAAGL,WAAW,CAACM,aAAjD;AACA,YAAID,aAAa,CAACE,UAAd,KAA6B,IAAjC,EACEtC,2CAA2C,CACzCoC,aAAa,CAACE,UAD2B,EAEzCN,QAFyC,CAA3C;AAIF;AAtBJ;AAwBD;;AAED,QAAMO,aAAa,GAAG1D,sCAAsC,EAA5D;AACA0D,EAAAA,aAAa,CAACd,SAAd,GAA0BO,QAA1B;AACAO,EAAAA,aAAa,CAACC,MAAd,GAAuBT,WAAvB;AAEA,QAAMU,SAAS,GAAGV,WAAW,CAACU,SAA9B;;AACA,MAAIA,SAAS,KAAK,IAAlB,EAAwB;AACtBV,IAAAA,WAAW,CAACU,SAAZ,GAAwB,CAACF,aAAD,CAAxB;AACAR,IAAAA,WAAW,CAACW,KAAZ,IAAqBhE,aAArB;AACD,GAHD,MAGO;AACL+D,IAAAA,SAAS,CAACE,IAAV,CAAeJ,aAAf;AACD;AACF;;AAED,SAASK,yBAAT,CAAmCb,WAAnC,EAAuDR,KAAvD,EAAqE;AACnEA,EAAAA,KAAK,CAACmB,KAAN,GAAenB,KAAK,CAACmB,KAAN,GAAc,CAAC9D,SAAhB,GAA6BD,SAA3C;;AACA,MAAIwC,OAAJ,EAAa;AACX,YAAQY,WAAW,CAACE,GAApB;AACE,WAAKzD,QAAL;AAAe;AACb,gBAAMqE,eAAe,GAAGd,WAAW,CAACN,SAAZ,CAAsBC,aAA9C;;AACA,kBAAQH,KAAK,CAACU,GAAd;AACE,iBAAK3D,aAAL;AACE,oBAAM4D,IAAI,GAAGX,KAAK,CAACW,IAAnB;AACA,oBAAMY,KAAK,GAAGvB,KAAK,CAACwB,YAApB;AACA7C,cAAAA,2CAA2C,CACzC2C,eADyC,EAEzCX,IAFyC,EAGzCY,KAHyC,CAA3C;AAKA;;AACF,iBAAKvE,QAAL;AACE,oBAAMyE,IAAI,GAAGzB,KAAK,CAACwB,YAAnB;AACA5C,cAAAA,+CAA+C,CAC7C0C,eAD6C,EAE7CG,IAF6C,CAA/C;AAIA;;AACF,iBAAKvE,iBAAL;AACE2B,cAAAA,mDAAmD,CACjDyC,eADiD,CAAnD;AAGA;AArBJ;;AAuBA;AACD;;AACD,WAAKvE,aAAL;AAAoB;AAClB,gBAAM2E,UAAU,GAAGlB,WAAW,CAACG,IAA/B;AACA,gBAAMgB,WAAW,GAAGnB,WAAW,CAACI,aAAhC;AACA,gBAAMX,cAAc,GAAGO,WAAW,CAACN,SAAnC;;AACA,kBAAQF,KAAK,CAACU,GAAd;AACE,iBAAK3D,aAAL;AACE,oBAAM4D,IAAI,GAAGX,KAAK,CAACW,IAAnB;AACA,oBAAMY,KAAK,GAAGvB,KAAK,CAACwB,YAApB;AACAvC,cAAAA,4BAA4B,CAC1ByC,UAD0B,EAE1BC,WAF0B,EAG1B1B,cAH0B,EAI1BU,IAJ0B,EAK1BY,KAL0B,CAA5B;AAOA;;AACF,iBAAKvE,QAAL;AACE,oBAAMyE,IAAI,GAAGzB,KAAK,CAACwB,YAAnB;AACAtC,cAAAA,gCAAgC,CAC9BwC,UAD8B,EAE9BC,WAF8B,EAG9B1B,cAH8B,EAI9BwB,IAJ8B,CAAhC;AAMA;;AACF,iBAAKvE,iBAAL;AACEiC,cAAAA,oCAAoC,CAClCuC,UADkC,EAElCC,WAFkC,EAGlC1B,cAHkC,CAApC;AAKA;AA3BJ;;AA6BA;AACD;;AACD,WAAK/C,iBAAL;AAAwB;AACtB,gBAAM2D,aAA4B,GAAGL,WAAW,CAACM,aAAjD;AACA,gBAAMb,cAAc,GAAGY,aAAa,CAACE,UAArC;AACA,cAAId,cAAc,KAAK,IAAvB,EACE,QAAQD,KAAK,CAACU,GAAd;AACE,iBAAK3D,aAAL;AACE,oBAAM4D,IAAI,GAAGX,KAAK,CAACW,IAAnB;AACA,oBAAMY,KAAK,GAAGvB,KAAK,CAACwB,YAApB;AACA1C,cAAAA,kDAAkD,CAChDmB,cADgD,EAEhDU,IAFgD,EAGhDY,KAHgD,CAAlD;AAKA;;AACF,iBAAKvE,QAAL;AACE,oBAAMyE,IAAI,GAAGzB,KAAK,CAACwB,YAAnB;AACAzC,cAAAA,sDAAsD,CACpDkB,cADoD,EAEpDwB,IAFoD,CAAtD;AAIA;;AACF,iBAAKvE,iBAAL;AACE8B,cAAAA,0DAA0D,CACxDiB,cADwD,CAA1D;AAGA;AArBJ;AAuBF;AACD;;AACD;AACE;AA7FJ;AA+FD;AACF;;AAED,SAAS2B,UAAT,CAAoB5B,KAApB,EAA2B6B,YAA3B,EAAyC;AACvC,UAAQ7B,KAAK,CAACU,GAAd;AACE,SAAK3D,aAAL;AAAoB;AAClB,cAAM4D,IAAI,GAAGX,KAAK,CAACW,IAAnB;AACA,cAAMY,KAAK,GAAGvB,KAAK,CAACwB,YAApB;AACA,cAAMf,QAAQ,GAAG/C,kBAAkB,CAACmE,YAAD,EAAelB,IAAf,EAAqBY,KAArB,CAAnC;;AACA,YAAId,QAAQ,KAAK,IAAjB,EAAuB;AACrBT,UAAAA,KAAK,CAACE,SAAN,GAAmBO,QAAnB;AACAjB,UAAAA,oBAAoB,GAAGQ,KAAvB;AACAP,UAAAA,sBAAsB,GAAG3B,uBAAuB,CAAC2C,QAAD,CAAhD;AACA,iBAAO,IAAP;AACD;;AACD,eAAO,KAAP;AACD;;AACD,SAAKzD,QAAL;AAAe;AACb,cAAMyE,IAAI,GAAGzB,KAAK,CAACwB,YAAnB;AACA,cAAMM,YAAY,GAAGnE,sBAAsB,CAACkE,YAAD,EAAeJ,IAAf,CAA3C;;AACA,YAAIK,YAAY,KAAK,IAArB,EAA2B;AACzB9B,UAAAA,KAAK,CAACE,SAAN,GAAmB4B,YAAnB;AACAtC,UAAAA,oBAAoB,GAAGQ,KAAvB,CAFyB,CAGzB;;AACAP,UAAAA,sBAAsB,GAAG,IAAzB;AACA,iBAAO,IAAP;AACD;;AACD,eAAO,KAAP;AACD;;AACD,SAAKvC,iBAAL;AAAwB;AACtB,YAAIkC,4BAAJ,EAAkC;AAChC,gBAAMiB,gBAAyC,GAAGzC,0BAA0B,CAC1EiE,YAD0E,CAA5E;;AAGA,cAAIxB,gBAAgB,KAAK,IAAzB,EAA+B;AAC7B,kBAAMQ,aAA4B,GAAG;AACnCE,cAAAA,UAAU,EAAEV,gBADuB;AAEnCC,cAAAA,WAAW,EAAEhB,uBAAuB,EAFD;AAGnCyC,cAAAA,SAAS,EAAE1C;AAHwB,aAArC;AAKAW,YAAAA,KAAK,CAACc,aAAN,GAAsBD,aAAtB,CAN6B,CAO7B;AACA;AACA;AACA;;AACA,kBAAMmB,kBAAkB,GAAGzE,iCAAiC,CAC1D8C,gBAD0D,CAA5D;AAGA2B,YAAAA,kBAAkB,CAACf,MAAnB,GAA4BjB,KAA5B;AACAA,YAAAA,KAAK,CAACiC,KAAN,GAAcD,kBAAd;AACAxC,YAAAA,oBAAoB,GAAGQ,KAAvB,CAhB6B,CAiB7B;AACA;;AACAP,YAAAA,sBAAsB,GAAG,IAAzB;AACA,mBAAO,IAAP;AACD;AACF;;AACD,eAAO,KAAP;AACD;;AACD;AACE,aAAO,KAAP;AAxDJ;AA0DD;;AAED,SAASyC,wCAAT,CAAkDlC,KAAlD,EAAyD;AACvD,MAAI,CAACA,KAAK,CAACmC,IAAN,GAAarF,cAAd,MAAkCD,MAAtC,EAA8C;AAC5C,UAAM,IAAIuF,KAAJ,CACJ,sFADI,CAAN;AAGD;AACF;;AAED,SAASC,gCAAT,CAA0CrC,KAA1C,EAA8D;AAC5D,MAAI,CAACN,WAAL,EAAkB;AAChB;AACD;;AACD,MAAImC,YAAY,GAAGpC,sBAAnB;;AACA,MAAI,CAACoC,YAAL,EAAmB;AACjBK,IAAAA,wCAAwC,CAAClC,KAAD,CAAxC,CADiB,CAEjB;;AACAqB,IAAAA,yBAAyB,CAAE7B,oBAAF,EAA8BQ,KAA9B,CAAzB;AACAN,IAAAA,WAAW,GAAG,KAAd;AACAF,IAAAA,oBAAoB,GAAGQ,KAAvB;AACA;AACD;;AACD,QAAMsC,sBAAsB,GAAGT,YAA/B;;AACA,MAAI,CAACD,UAAU,CAAC5B,KAAD,EAAQ6B,YAAR,CAAf,EAAsC;AACpCK,IAAAA,wCAAwC,CAAClC,KAAD,CAAxC,CADoC,CAEpC;AACA;AACA;;AACA6B,IAAAA,YAAY,GAAGhE,wBAAwB,CAACyE,sBAAD,CAAvC;AACA,UAAMC,wBAA+B,GAAI/C,oBAAzC;;AACA,QAAI,CAACqC,YAAD,IAAiB,CAACD,UAAU,CAAC5B,KAAD,EAAQ6B,YAAR,CAAhC,EAAuD;AACrD;AACAR,MAAAA,yBAAyB,CAAE7B,oBAAF,EAA8BQ,KAA9B,CAAzB;AACAN,MAAAA,WAAW,GAAG,KAAd;AACAF,MAAAA,oBAAoB,GAAGQ,KAAvB;AACA;AACD,KAbmC,CAcpC;AACA;AACA;AACA;;;AACAO,IAAAA,wBAAwB,CAACgC,wBAAD,EAA2BD,sBAA3B,CAAxB;AACD;AACF;;AAED,SAASE,4BAAT,CACExC,KADF,EAEEyC,qBAFF,EAGEC,WAHF,EAIW;AACT,MAAI,CAACjF,iBAAL,EAAwB;AACtB,UAAM,IAAI2E,KAAJ,CACJ,iEACE,sEAFE,CAAN;AAID;;AAED,QAAM3B,QAAkB,GAAGT,KAAK,CAACE,SAAjC;AACA,QAAMyC,aAAa,GAAG1E,eAAe,CACnCwC,QADmC,EAEnCT,KAAK,CAACW,IAF6B,EAGnCX,KAAK,CAACY,aAH6B,EAInC6B,qBAJmC,EAKnCC,WALmC,EAMnC1C,KANmC,CAArC,CATS,CAiBT;;AACAA,EAAAA,KAAK,CAAC4C,WAAN,GAAqBD,aAArB,CAlBS,CAmBT;AACA;;AACA,MAAIA,aAAa,KAAK,IAAtB,EAA4B;AAC1B,WAAO,IAAP;AACD;;AACD,SAAO,KAAP;AACD;;AAED,SAASE,gCAAT,CAA0C7C,KAA1C,EAAiE;AAC/D,MAAI,CAACvC,iBAAL,EAAwB;AACtB,UAAM,IAAI2E,KAAJ,CACJ,qEACE,sEAFE,CAAN;AAID;;AAED,QAAMN,YAA0B,GAAG9B,KAAK,CAACE,SAAzC;AACA,QAAM4C,WAAmB,GAAG9C,KAAK,CAACY,aAAlC;AACA,QAAMmC,YAAY,GAAG7E,mBAAmB,CAAC4D,YAAD,EAAegB,WAAf,EAA4B9C,KAA5B,CAAxC;;AACA,MAAIJ,OAAJ,EAAa;AACX,QAAImD,YAAJ,EAAkB;AAChB;AACA;AACA,YAAMvC,WAAW,GAAGhB,oBAApB;;AACA,UAAIgB,WAAW,KAAK,IAApB,EAA0B;AACxB,gBAAQA,WAAW,CAACE,GAApB;AACE,eAAKzD,QAAL;AAAe;AACb,oBAAMqE,eAAe,GAAGd,WAAW,CAACN,SAAZ,CAAsBC,aAA9C;AACA7B,cAAAA,wCAAwC,CACtCgD,eADsC,EAEtCQ,YAFsC,EAGtCgB,WAHsC,CAAxC;AAKA;AACD;;AACD,eAAK/F,aAAL;AAAoB;AAClB,oBAAM2E,UAAU,GAAGlB,WAAW,CAACG,IAA/B;AACA,oBAAMgB,WAAW,GAAGnB,WAAW,CAACI,aAAhC;AACA,oBAAMX,cAAc,GAAGO,WAAW,CAACN,SAAnC;AACA3B,cAAAA,+BAA+B,CAC7BmD,UAD6B,EAE7BC,WAF6B,EAG7B1B,cAH6B,EAI7B6B,YAJ6B,EAK7BgB,WAL6B,CAA/B;AAOA;AACD;AAtBH;AAwBD;AACF;AACF;;AACD,SAAOC,YAAP;AACD;;AAED,SAASC,oCAAT,CAA8ChD,KAA9C,EAAkE;AAChE,MAAI,CAACvC,iBAAL,EAAwB;AACtB,UAAM,IAAI2E,KAAJ,CACJ,yEACE,sEAFE,CAAN;AAID;;AAED,QAAMvB,aAAmC,GAAGb,KAAK,CAACc,aAAlD;AACA,QAAMT,gBAAyC,GAC7CQ,aAAa,KAAK,IAAlB,GAAyBA,aAAa,CAACE,UAAvC,GAAoD,IADtD;;AAGA,MAAI,CAACV,gBAAL,EAAuB;AACrB,UAAM,IAAI+B,KAAJ,CACJ,oDACE,sEAFE,CAAN;AAID;;AAEDjE,EAAAA,uBAAuB,CAACkC,gBAAD,EAAmBL,KAAnB,CAAvB;AACD;;AAED,SAASiD,kCAAT,CACEjD,KADF,EAE6B;AAC3B,MAAI,CAACvC,iBAAL,EAAwB;AACtB,UAAM,IAAI2E,KAAJ,CACJ,uEACE,sEAFE,CAAN;AAID;;AACD,QAAMvB,aAAmC,GAAGb,KAAK,CAACc,aAAlD;AACA,QAAMT,gBAAyC,GAC7CQ,aAAa,KAAK,IAAlB,GAAyBA,aAAa,CAACE,UAAvC,GAAoD,IADtD;;AAGA,MAAI,CAACV,gBAAL,EAAuB;AACrB,UAAM,IAAI+B,KAAJ,CACJ,oDACE,sEAFE,CAAN;AAID;;AAED,SAAOhE,8CAA8C,CAACiC,gBAAD,CAArD;AACD;;AAED,SAAS6C,mBAAT,CAA6BlD,KAA7B,EAAiD;AAC/C,MAAImD,MAAM,GAAGnD,KAAK,CAACiB,MAAnB;;AACA,SACEkC,MAAM,KAAK,IAAX,IACAA,MAAM,CAACzC,GAAP,KAAe3D,aADf,IAEAoG,MAAM,CAACzC,GAAP,KAAezD,QAFf,IAGAkG,MAAM,CAACzC,GAAP,KAAexD,iBAJjB,EAKE;AACAiG,IAAAA,MAAM,GAAGA,MAAM,CAAClC,MAAhB;AACD;;AACDzB,EAAAA,oBAAoB,GAAG2D,MAAvB;AACD;;AAED,SAASC,iBAAT,CAA2BpD,KAA3B,EAAkD;AAChD,MAAI,CAACvC,iBAAL,EAAwB;AACtB,WAAO,KAAP;AACD;;AACD,MAAIuC,KAAK,KAAKR,oBAAd,EAAoC;AAClC;AACA;AACA,WAAO,KAAP;AACD;;AACD,MAAI,CAACE,WAAL,EAAkB;AAChB;AACA;AACA;AACAwD,IAAAA,mBAAmB,CAAClD,KAAD,CAAnB;AACAN,IAAAA,WAAW,GAAG,IAAd;AACA,WAAO,KAAP;AACD,GAhB+C,CAkBhD;AACA;AACA;AACA;;;AACA,MACEM,KAAK,CAACU,GAAN,KAAczD,QAAd,KACC+C,KAAK,CAACU,GAAN,KAAc3D,aAAd,IACEsB,mCAAmC,CAAC2B,KAAK,CAACW,IAAP,CAAnC,IACC,CAACnD,oBAAoB,CAACwC,KAAK,CAACW,IAAP,EAAaX,KAAK,CAACY,aAAnB,CAHzB,CADF,EAKE;AACA,QAAIiB,YAAY,GAAGpC,sBAAnB;;AACA,WAAOoC,YAAP,EAAqB;AACnBtB,MAAAA,wBAAwB,CAACP,KAAD,EAAQ6B,YAAR,CAAxB;AACAA,MAAAA,YAAY,GAAGhE,wBAAwB,CAACgE,YAAD,CAAvC;AACD;AACF;;AAEDqB,EAAAA,mBAAmB,CAAClD,KAAD,CAAnB;;AACA,MAAIA,KAAK,CAACU,GAAN,KAAcxD,iBAAlB,EAAqC;AACnCuC,IAAAA,sBAAsB,GAAGwD,kCAAkC,CAACjD,KAAD,CAA3D;AACD,GAFD,MAEO;AACLP,IAAAA,sBAAsB,GAAGD,oBAAoB,GACzC3B,wBAAwB,CAACmC,KAAK,CAACE,SAAP,CADiB,GAEzC,IAFJ;AAGD;;AACD,SAAO,IAAP;AACD;;AAED,SAASmD,mBAAT,GAAqC;AACnC,MAAI,CAAC5F,iBAAL,EAAwB;AACtB;AACD;;AAED+B,EAAAA,oBAAoB,GAAG,IAAvB;AACAC,EAAAA,sBAAsB,GAAG,IAAzB;AACAC,EAAAA,WAAW,GAAG,KAAd;AACD;;AAED,SAAS4D,cAAT,GAAmC;AACjC,SAAO5D,WAAP;AACD;;AAED,SACEC,eADF,EAEEI,mBAFF,EAGEuD,cAHF,EAIElD,mDAJF,EAKEiD,mBALF,EAMEhB,gCANF,EAOEG,4BAPF,EAQEK,gCARF,EASEG,oCATF,EAUEI,iBAVF","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Fiber} from './ReactInternalTypes';\nimport {NoMode, ConcurrentMode} from './ReactTypeOfMode';\nimport type {\n  Instance,\n  TextInstance,\n  HydratableInstance,\n  SuspenseInstance,\n  Container,\n  HostContext,\n} from './ReactFiberHostConfig';\nimport type {SuspenseState} from './ReactFiberSuspenseComponent.new';\nimport type {TreeContext} from './ReactFiberTreeContext.new';\n\nimport {\n  HostComponent,\n  HostText,\n  HostRoot,\n  SuspenseComponent,\n} from './ReactWorkTags';\nimport {ChildDeletion, Placement, Hydrating} from './ReactFiberFlags';\n\nimport {\n  createFiberFromHostInstanceForDeletion,\n  createFiberFromDehydratedFragment,\n} from './ReactFiber.new';\nimport {\n  shouldSetTextContent,\n  supportsHydration,\n  canHydrateInstance,\n  canHydrateTextInstance,\n  canHydrateSuspenseInstance,\n  getNextHydratableSibling,\n  getFirstHydratableChild,\n  getFirstHydratableChildWithinContainer,\n  getFirstHydratableChildWithinSuspenseInstance,\n  hydrateInstance,\n  hydrateTextInstance,\n  hydrateSuspenseInstance,\n  getNextHydratableInstanceAfterSuspenseInstance,\n  shouldDeleteUnhydratedTailInstances,\n  didNotMatchHydratedContainerTextInstance,\n  didNotMatchHydratedTextInstance,\n  didNotHydrateInstanceWithinContainer,\n  didNotHydrateInstanceWithinSuspenseInstance,\n  didNotHydrateInstance,\n  didNotFindHydratableInstanceWithinContainer,\n  didNotFindHydratableTextInstanceWithinContainer,\n  didNotFindHydratableSuspenseInstanceWithinContainer,\n  didNotFindHydratableInstanceWithinSuspenseInstance,\n  didNotFindHydratableTextInstanceWithinSuspenseInstance,\n  didNotFindHydratableSuspenseInstanceWithinSuspenseInstance,\n  didNotFindHydratableInstance,\n  didNotFindHydratableTextInstance,\n  didNotFindHydratableSuspenseInstance,\n} from './ReactFiberHostConfig';\nimport {enableSuspenseServerRenderer} from 'shared/ReactFeatureFlags';\nimport {OffscreenLane} from './ReactFiberLane.new';\nimport {\n  getSuspendedTreeContext,\n  restoreSuspendedTreeContext,\n} from './ReactFiberTreeContext.new';\n\n// The deepest Fiber on the stack involved in a hydration context.\n// This may have been an insertion or a hydration.\nlet hydrationParentFiber: null | Fiber = null;\nlet nextHydratableInstance: null | HydratableInstance = null;\nlet isHydrating: boolean = false;\n\nfunction warnIfHydrating() {\n  if (__DEV__) {\n    if (isHydrating) {\n      console.error(\n        'We should not be hydrating here. This is a bug in React. Please file a bug.',\n      );\n    }\n  }\n}\n\nfunction enterHydrationState(fiber: Fiber): boolean {\n  if (!supportsHydration) {\n    return false;\n  }\n\n  const parentInstance: Container = fiber.stateNode.containerInfo;\n  nextHydratableInstance = getFirstHydratableChildWithinContainer(\n    parentInstance,\n  );\n  hydrationParentFiber = fiber;\n  isHydrating = true;\n  return true;\n}\n\nfunction reenterHydrationStateFromDehydratedSuspenseInstance(\n  fiber: Fiber,\n  suspenseInstance: SuspenseInstance,\n  treeContext: TreeContext | null,\n): boolean {\n  if (!supportsHydration) {\n    return false;\n  }\n  nextHydratableInstance = getFirstHydratableChildWithinSuspenseInstance(\n    suspenseInstance,\n  );\n  hydrationParentFiber = fiber;\n  isHydrating = true;\n  if (treeContext !== null) {\n    restoreSuspendedTreeContext(fiber, treeContext);\n  }\n  return true;\n}\n\nfunction deleteHydratableInstance(\n  returnFiber: Fiber,\n  instance: HydratableInstance,\n) {\n  if (__DEV__) {\n    switch (returnFiber.tag) {\n      case HostRoot:\n        didNotHydrateInstanceWithinContainer(\n          returnFiber.stateNode.containerInfo,\n          instance,\n        );\n        break;\n      case HostComponent:\n        didNotHydrateInstance(\n          returnFiber.type,\n          returnFiber.memoizedProps,\n          returnFiber.stateNode,\n          instance,\n        );\n        break;\n      case SuspenseComponent:\n        const suspenseState: SuspenseState = returnFiber.memoizedState;\n        if (suspenseState.dehydrated !== null)\n          didNotHydrateInstanceWithinSuspenseInstance(\n            suspenseState.dehydrated,\n            instance,\n          );\n        break;\n    }\n  }\n\n  const childToDelete = createFiberFromHostInstanceForDeletion();\n  childToDelete.stateNode = instance;\n  childToDelete.return = returnFiber;\n\n  const deletions = returnFiber.deletions;\n  if (deletions === null) {\n    returnFiber.deletions = [childToDelete];\n    returnFiber.flags |= ChildDeletion;\n  } else {\n    deletions.push(childToDelete);\n  }\n}\n\nfunction insertNonHydratedInstance(returnFiber: Fiber, fiber: Fiber) {\n  fiber.flags = (fiber.flags & ~Hydrating) | Placement;\n  if (__DEV__) {\n    switch (returnFiber.tag) {\n      case HostRoot: {\n        const parentContainer = returnFiber.stateNode.containerInfo;\n        switch (fiber.tag) {\n          case HostComponent:\n            const type = fiber.type;\n            const props = fiber.pendingProps;\n            didNotFindHydratableInstanceWithinContainer(\n              parentContainer,\n              type,\n              props,\n            );\n            break;\n          case HostText:\n            const text = fiber.pendingProps;\n            didNotFindHydratableTextInstanceWithinContainer(\n              parentContainer,\n              text,\n            );\n            break;\n          case SuspenseComponent:\n            didNotFindHydratableSuspenseInstanceWithinContainer(\n              parentContainer,\n            );\n            break;\n        }\n        break;\n      }\n      case HostComponent: {\n        const parentType = returnFiber.type;\n        const parentProps = returnFiber.memoizedProps;\n        const parentInstance = returnFiber.stateNode;\n        switch (fiber.tag) {\n          case HostComponent:\n            const type = fiber.type;\n            const props = fiber.pendingProps;\n            didNotFindHydratableInstance(\n              parentType,\n              parentProps,\n              parentInstance,\n              type,\n              props,\n            );\n            break;\n          case HostText:\n            const text = fiber.pendingProps;\n            didNotFindHydratableTextInstance(\n              parentType,\n              parentProps,\n              parentInstance,\n              text,\n            );\n            break;\n          case SuspenseComponent:\n            didNotFindHydratableSuspenseInstance(\n              parentType,\n              parentProps,\n              parentInstance,\n            );\n            break;\n        }\n        break;\n      }\n      case SuspenseComponent: {\n        const suspenseState: SuspenseState = returnFiber.memoizedState;\n        const parentInstance = suspenseState.dehydrated;\n        if (parentInstance !== null)\n          switch (fiber.tag) {\n            case HostComponent:\n              const type = fiber.type;\n              const props = fiber.pendingProps;\n              didNotFindHydratableInstanceWithinSuspenseInstance(\n                parentInstance,\n                type,\n                props,\n              );\n              break;\n            case HostText:\n              const text = fiber.pendingProps;\n              didNotFindHydratableTextInstanceWithinSuspenseInstance(\n                parentInstance,\n                text,\n              );\n              break;\n            case SuspenseComponent:\n              didNotFindHydratableSuspenseInstanceWithinSuspenseInstance(\n                parentInstance,\n              );\n              break;\n          }\n        break;\n      }\n      default:\n        return;\n    }\n  }\n}\n\nfunction tryHydrate(fiber, nextInstance) {\n  switch (fiber.tag) {\n    case HostComponent: {\n      const type = fiber.type;\n      const props = fiber.pendingProps;\n      const instance = canHydrateInstance(nextInstance, type, props);\n      if (instance !== null) {\n        fiber.stateNode = (instance: Instance);\n        hydrationParentFiber = fiber;\n        nextHydratableInstance = getFirstHydratableChild(instance);\n        return true;\n      }\n      return false;\n    }\n    case HostText: {\n      const text = fiber.pendingProps;\n      const textInstance = canHydrateTextInstance(nextInstance, text);\n      if (textInstance !== null) {\n        fiber.stateNode = (textInstance: TextInstance);\n        hydrationParentFiber = fiber;\n        // Text Instances don't have children so there's nothing to hydrate.\n        nextHydratableInstance = null;\n        return true;\n      }\n      return false;\n    }\n    case SuspenseComponent: {\n      if (enableSuspenseServerRenderer) {\n        const suspenseInstance: null | SuspenseInstance = canHydrateSuspenseInstance(\n          nextInstance,\n        );\n        if (suspenseInstance !== null) {\n          const suspenseState: SuspenseState = {\n            dehydrated: suspenseInstance,\n            treeContext: getSuspendedTreeContext(),\n            retryLane: OffscreenLane,\n          };\n          fiber.memoizedState = suspenseState;\n          // Store the dehydrated fragment as a child fiber.\n          // This simplifies the code for getHostSibling and deleting nodes,\n          // since it doesn't have to consider all Suspense boundaries and\n          // check if they're dehydrated ones or not.\n          const dehydratedFragment = createFiberFromDehydratedFragment(\n            suspenseInstance,\n          );\n          dehydratedFragment.return = fiber;\n          fiber.child = dehydratedFragment;\n          hydrationParentFiber = fiber;\n          // While a Suspense Instance does have children, we won't step into\n          // it during the first pass. Instead, we'll reenter it later.\n          nextHydratableInstance = null;\n          return true;\n        }\n      }\n      return false;\n    }\n    default:\n      return false;\n  }\n}\n\nfunction throwOnHydrationMismatchIfConcurrentMode(fiber) {\n  if ((fiber.mode & ConcurrentMode) !== NoMode) {\n    throw new Error(\n      'An error occurred during hydration. The server HTML was replaced with client content',\n    );\n  }\n}\n\nfunction tryToClaimNextHydratableInstance(fiber: Fiber): void {\n  if (!isHydrating) {\n    return;\n  }\n  let nextInstance = nextHydratableInstance;\n  if (!nextInstance) {\n    throwOnHydrationMismatchIfConcurrentMode(fiber);\n    // Nothing to hydrate. Make it an insertion.\n    insertNonHydratedInstance((hydrationParentFiber: any), fiber);\n    isHydrating = false;\n    hydrationParentFiber = fiber;\n    return;\n  }\n  const firstAttemptedInstance = nextInstance;\n  if (!tryHydrate(fiber, nextInstance)) {\n    throwOnHydrationMismatchIfConcurrentMode(fiber);\n    // If we can't hydrate this instance let's try the next one.\n    // We use this as a heuristic. It's based on intuition and not data so it\n    // might be flawed or unnecessary.\n    nextInstance = getNextHydratableSibling(firstAttemptedInstance);\n    const prevHydrationParentFiber: Fiber = (hydrationParentFiber: any);\n    if (!nextInstance || !tryHydrate(fiber, nextInstance)) {\n      // Nothing to hydrate. Make it an insertion.\n      insertNonHydratedInstance((hydrationParentFiber: any), fiber);\n      isHydrating = false;\n      hydrationParentFiber = fiber;\n      return;\n    }\n    // We matched the next one, we'll now assume that the first one was\n    // superfluous and we'll delete it. Since we can't eagerly delete it\n    // we'll have to schedule a deletion. To do that, this node needs a dummy\n    // fiber associated with it.\n    deleteHydratableInstance(prevHydrationParentFiber, firstAttemptedInstance);\n  }\n}\n\nfunction prepareToHydrateHostInstance(\n  fiber: Fiber,\n  rootContainerInstance: Container,\n  hostContext: HostContext,\n): boolean {\n  if (!supportsHydration) {\n    throw new Error(\n      'Expected prepareToHydrateHostInstance() to never be called. ' +\n        'This error is likely caused by a bug in React. Please file an issue.',\n    );\n  }\n\n  const instance: Instance = fiber.stateNode;\n  const updatePayload = hydrateInstance(\n    instance,\n    fiber.type,\n    fiber.memoizedProps,\n    rootContainerInstance,\n    hostContext,\n    fiber,\n  );\n  // TODO: Type this specific to this type of component.\n  fiber.updateQueue = (updatePayload: any);\n  // If the update payload indicates that there is a change or if there\n  // is a new ref we mark this as an update.\n  if (updatePayload !== null) {\n    return true;\n  }\n  return false;\n}\n\nfunction prepareToHydrateHostTextInstance(fiber: Fiber): boolean {\n  if (!supportsHydration) {\n    throw new Error(\n      'Expected prepareToHydrateHostTextInstance() to never be called. ' +\n        'This error is likely caused by a bug in React. Please file an issue.',\n    );\n  }\n\n  const textInstance: TextInstance = fiber.stateNode;\n  const textContent: string = fiber.memoizedProps;\n  const shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);\n  if (__DEV__) {\n    if (shouldUpdate) {\n      // We assume that prepareToHydrateHostTextInstance is called in a context where the\n      // hydration parent is the parent host component of this host text.\n      const returnFiber = hydrationParentFiber;\n      if (returnFiber !== null) {\n        switch (returnFiber.tag) {\n          case HostRoot: {\n            const parentContainer = returnFiber.stateNode.containerInfo;\n            didNotMatchHydratedContainerTextInstance(\n              parentContainer,\n              textInstance,\n              textContent,\n            );\n            break;\n          }\n          case HostComponent: {\n            const parentType = returnFiber.type;\n            const parentProps = returnFiber.memoizedProps;\n            const parentInstance = returnFiber.stateNode;\n            didNotMatchHydratedTextInstance(\n              parentType,\n              parentProps,\n              parentInstance,\n              textInstance,\n              textContent,\n            );\n            break;\n          }\n        }\n      }\n    }\n  }\n  return shouldUpdate;\n}\n\nfunction prepareToHydrateHostSuspenseInstance(fiber: Fiber): void {\n  if (!supportsHydration) {\n    throw new Error(\n      'Expected prepareToHydrateHostSuspenseInstance() to never be called. ' +\n        'This error is likely caused by a bug in React. Please file an issue.',\n    );\n  }\n\n  const suspenseState: null | SuspenseState = fiber.memoizedState;\n  const suspenseInstance: null | SuspenseInstance =\n    suspenseState !== null ? suspenseState.dehydrated : null;\n\n  if (!suspenseInstance) {\n    throw new Error(\n      'Expected to have a hydrated suspense instance. ' +\n        'This error is likely caused by a bug in React. Please file an issue.',\n    );\n  }\n\n  hydrateSuspenseInstance(suspenseInstance, fiber);\n}\n\nfunction skipPastDehydratedSuspenseInstance(\n  fiber: Fiber,\n): null | HydratableInstance {\n  if (!supportsHydration) {\n    throw new Error(\n      'Expected skipPastDehydratedSuspenseInstance() to never be called. ' +\n        'This error is likely caused by a bug in React. Please file an issue.',\n    );\n  }\n  const suspenseState: null | SuspenseState = fiber.memoizedState;\n  const suspenseInstance: null | SuspenseInstance =\n    suspenseState !== null ? suspenseState.dehydrated : null;\n\n  if (!suspenseInstance) {\n    throw new Error(\n      'Expected to have a hydrated suspense instance. ' +\n        'This error is likely caused by a bug in React. Please file an issue.',\n    );\n  }\n\n  return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);\n}\n\nfunction popToNextHostParent(fiber: Fiber): void {\n  let parent = fiber.return;\n  while (\n    parent !== null &&\n    parent.tag !== HostComponent &&\n    parent.tag !== HostRoot &&\n    parent.tag !== SuspenseComponent\n  ) {\n    parent = parent.return;\n  }\n  hydrationParentFiber = parent;\n}\n\nfunction popHydrationState(fiber: Fiber): boolean {\n  if (!supportsHydration) {\n    return false;\n  }\n  if (fiber !== hydrationParentFiber) {\n    // We're deeper than the current hydration context, inside an inserted\n    // tree.\n    return false;\n  }\n  if (!isHydrating) {\n    // If we're not currently hydrating but we're in a hydration context, then\n    // we were an insertion and now need to pop up reenter hydration of our\n    // siblings.\n    popToNextHostParent(fiber);\n    isHydrating = true;\n    return false;\n  }\n\n  // If we have any remaining hydratable nodes, we need to delete them now.\n  // We only do this deeper than head and body since they tend to have random\n  // other nodes in them. We also ignore components with pure text content in\n  // side of them. We also don't delete anything inside the root container.\n  if (\n    fiber.tag !== HostRoot &&\n    (fiber.tag !== HostComponent ||\n      (shouldDeleteUnhydratedTailInstances(fiber.type) &&\n        !shouldSetTextContent(fiber.type, fiber.memoizedProps)))\n  ) {\n    let nextInstance = nextHydratableInstance;\n    while (nextInstance) {\n      deleteHydratableInstance(fiber, nextInstance);\n      nextInstance = getNextHydratableSibling(nextInstance);\n    }\n  }\n\n  popToNextHostParent(fiber);\n  if (fiber.tag === SuspenseComponent) {\n    nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber);\n  } else {\n    nextHydratableInstance = hydrationParentFiber\n      ? getNextHydratableSibling(fiber.stateNode)\n      : null;\n  }\n  return true;\n}\n\nfunction resetHydrationState(): void {\n  if (!supportsHydration) {\n    return;\n  }\n\n  hydrationParentFiber = null;\n  nextHydratableInstance = null;\n  isHydrating = false;\n}\n\nfunction getIsHydrating(): boolean {\n  return isHydrating;\n}\n\nexport {\n  warnIfHydrating,\n  enterHydrationState,\n  getIsHydrating,\n  reenterHydrationStateFromDehydratedSuspenseInstance,\n  resetHydrationState,\n  tryToClaimNextHydratableInstance,\n  prepareToHydrateHostInstance,\n  prepareToHydrateHostTextInstance,\n  prepareToHydrateHostSuspenseInstance,\n  popHydrationState,\n};\n"]},"metadata":{},"sourceType":"module"}