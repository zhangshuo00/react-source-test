{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n// An array of all update queues that received updates during the current\n// render. When this render exits, either because it finishes or because it is\n// interrupted, the interleaved updates will be transferred onto the main part\n// of the queue.\nlet interleavedQueues = null;\nexport function pushInterleavedQueue(queue) {\n  if (interleavedQueues === null) {\n    interleavedQueues = [queue];\n  } else {\n    interleavedQueues.push(queue);\n  }\n}\nexport function enqueueInterleavedUpdates() {\n  // Transfer the interleaved updates onto the main queue. Each queue has a\n  // `pending` field and an `interleaved` field. When they are not null, they\n  // point to the last node in a circular linked list. We need to append the\n  // interleaved list to the end of the pending list by joining them into a\n  // single, circular list.\n  if (interleavedQueues !== null) {\n    for (let i = 0; i < interleavedQueues.length; i++) {\n      const queue = interleavedQueues[i];\n      const lastInterleavedUpdate = queue.interleaved;\n\n      if (lastInterleavedUpdate !== null) {\n        queue.interleaved = null;\n        const firstInterleavedUpdate = lastInterleavedUpdate.next;\n        const lastPendingUpdate = queue.pending;\n\n        if (lastPendingUpdate !== null) {\n          const firstPendingUpdate = lastPendingUpdate.next;\n          lastPendingUpdate.next = firstInterleavedUpdate;\n          lastInterleavedUpdate.next = firstPendingUpdate;\n        }\n\n        queue.pending = lastInterleavedUpdate;\n      }\n    }\n\n    interleavedQueues = null;\n  }\n}","map":{"version":3,"sources":["/Users/zhangshuo/git/my-app/src/react/packages/react-reconciler/src/ReactFiberInterleavedUpdates.new.js"],"names":["interleavedQueues","pushInterleavedQueue","queue","push","enqueueInterleavedUpdates","i","length","lastInterleavedUpdate","interleaved","firstInterleavedUpdate","next","lastPendingUpdate","pending","firstPendingUpdate"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA,IAAIA,iBAEI,GAAG,IAFX;AAIA,OAAO,SAASC,oBAAT,CACLC,KADK,EAEL;AACA,MAAIF,iBAAiB,KAAK,IAA1B,EAAgC;AAC9BA,IAAAA,iBAAiB,GAAG,CAACE,KAAD,CAApB;AACD,GAFD,MAEO;AACLF,IAAAA,iBAAiB,CAACG,IAAlB,CAAuBD,KAAvB;AACD;AACF;AAED,OAAO,SAASE,yBAAT,GAAqC;AAC1C;AACA;AACA;AACA;AACA;AACA,MAAIJ,iBAAiB,KAAK,IAA1B,EAAgC;AAC9B,SAAK,IAAIK,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,iBAAiB,CAACM,MAAtC,EAA8CD,CAAC,EAA/C,EAAmD;AACjD,YAAMH,KAAK,GAAGF,iBAAiB,CAACK,CAAD,CAA/B;AACA,YAAME,qBAAqB,GAAGL,KAAK,CAACM,WAApC;;AACA,UAAID,qBAAqB,KAAK,IAA9B,EAAoC;AAClCL,QAAAA,KAAK,CAACM,WAAN,GAAoB,IAApB;AACA,cAAMC,sBAAsB,GAAGF,qBAAqB,CAACG,IAArD;AACA,cAAMC,iBAAiB,GAAGT,KAAK,CAACU,OAAhC;;AACA,YAAID,iBAAiB,KAAK,IAA1B,EAAgC;AAC9B,gBAAME,kBAAkB,GAAGF,iBAAiB,CAACD,IAA7C;AACAC,UAAAA,iBAAiB,CAACD,IAAlB,GAA0BD,sBAA1B;AACAF,UAAAA,qBAAqB,CAACG,IAAtB,GAA8BG,kBAA9B;AACD;;AACDX,QAAAA,KAAK,CAACU,OAAN,GAAiBL,qBAAjB;AACD;AACF;;AACDP,IAAAA,iBAAiB,GAAG,IAApB;AACD;AACF","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {UpdateQueue as HookQueue} from './ReactFiberHooks.new';\nimport type {SharedQueue as ClassQueue} from './ReactUpdateQueue.new';\n\n// An array of all update queues that received updates during the current\n// render. When this render exits, either because it finishes or because it is\n// interrupted, the interleaved updates will be transferred onto the main part\n// of the queue.\nlet interleavedQueues: Array<\n  HookQueue<any, any> | ClassQueue<any>,\n> | null = null;\n\nexport function pushInterleavedQueue(\n  queue: HookQueue<any, any> | ClassQueue<any>,\n) {\n  if (interleavedQueues === null) {\n    interleavedQueues = [queue];\n  } else {\n    interleavedQueues.push(queue);\n  }\n}\n\nexport function enqueueInterleavedUpdates() {\n  // Transfer the interleaved updates onto the main queue. Each queue has a\n  // `pending` field and an `interleaved` field. When they are not null, they\n  // point to the last node in a circular linked list. We need to append the\n  // interleaved list to the end of the pending list by joining them into a\n  // single, circular list.\n  if (interleavedQueues !== null) {\n    for (let i = 0; i < interleavedQueues.length; i++) {\n      const queue = interleavedQueues[i];\n      const lastInterleavedUpdate = queue.interleaved;\n      if (lastInterleavedUpdate !== null) {\n        queue.interleaved = null;\n        const firstInterleavedUpdate = lastInterleavedUpdate.next;\n        const lastPendingUpdate = queue.pending;\n        if (lastPendingUpdate !== null) {\n          const firstPendingUpdate = lastPendingUpdate.next;\n          lastPendingUpdate.next = (firstInterleavedUpdate: any);\n          lastInterleavedUpdate.next = (firstPendingUpdate: any);\n        }\n        queue.pending = (lastInterleavedUpdate: any);\n      }\n    }\n    interleavedQueues = null;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}