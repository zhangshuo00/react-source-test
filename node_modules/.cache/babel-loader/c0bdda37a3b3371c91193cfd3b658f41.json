{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { getPublicInstance, getInstanceFromNode, getInstanceFromScope } from './ReactFiberHostConfig';\nimport { isFiberSuspenseAndTimedOut } from './ReactFiberTreeReflection';\nimport { HostComponent, ScopeComponent, ContextProvider } from './ReactWorkTags';\nimport { enableScopeAPI } from 'shared/ReactFeatureFlags';\n\nfunction getSuspenseFallbackChild(fiber) {\n  return fiber.child.sibling.child;\n}\n\nconst emptyObject = {};\n\nfunction collectScopedNodes(node, fn, scopedNodes) {\n  if (enableScopeAPI) {\n    if (node.tag === HostComponent) {\n      const {\n        type,\n        memoizedProps,\n        stateNode\n      } = node;\n      const instance = getPublicInstance(stateNode);\n\n      if (instance !== null && fn(type, memoizedProps || emptyObject, instance) === true) {\n        scopedNodes.push(instance);\n      }\n    }\n\n    let child = node.child;\n\n    if (isFiberSuspenseAndTimedOut(node)) {\n      child = getSuspenseFallbackChild(node);\n    }\n\n    if (child !== null) {\n      collectScopedNodesFromChildren(child, fn, scopedNodes);\n    }\n  }\n}\n\nfunction collectFirstScopedNode(node, fn) {\n  if (enableScopeAPI) {\n    if (node.tag === HostComponent) {\n      const {\n        type,\n        memoizedProps,\n        stateNode\n      } = node;\n      const instance = getPublicInstance(stateNode);\n\n      if (instance !== null && fn(type, memoizedProps, instance) === true) {\n        return instance;\n      }\n    }\n\n    let child = node.child;\n\n    if (isFiberSuspenseAndTimedOut(node)) {\n      child = getSuspenseFallbackChild(node);\n    }\n\n    if (child !== null) {\n      return collectFirstScopedNodeFromChildren(child, fn);\n    }\n  }\n\n  return null;\n}\n\nfunction collectScopedNodesFromChildren(startingChild, fn, scopedNodes) {\n  let child = startingChild;\n\n  while (child !== null) {\n    collectScopedNodes(child, fn, scopedNodes);\n    child = child.sibling;\n  }\n}\n\nfunction collectFirstScopedNodeFromChildren(startingChild, fn) {\n  let child = startingChild;\n\n  while (child !== null) {\n    const scopedNode = collectFirstScopedNode(child, fn);\n\n    if (scopedNode !== null) {\n      return scopedNode;\n    }\n\n    child = child.sibling;\n  }\n\n  return null;\n}\n\nfunction collectNearestContextValues(node, context, childContextValues) {\n  if (node.tag === ContextProvider && node.type._context === context) {\n    const contextValue = node.memoizedProps.value;\n    childContextValues.push(contextValue);\n  } else {\n    let child = node.child;\n\n    if (isFiberSuspenseAndTimedOut(node)) {\n      child = getSuspenseFallbackChild(node);\n    }\n\n    if (child !== null) {\n      collectNearestChildContextValues(child, context, childContextValues);\n    }\n  }\n}\n\nfunction collectNearestChildContextValues(startingChild, context, childContextValues) {\n  let child = startingChild;\n\n  while (child !== null) {\n    collectNearestContextValues(child, context, childContextValues);\n    child = child.sibling;\n  }\n}\n\nfunction DO_NOT_USE_queryAllNodes(fn) {\n  const currentFiber = getInstanceFromScope(this);\n\n  if (currentFiber === null) {\n    return null;\n  }\n\n  const child = currentFiber.child;\n  const scopedNodes = [];\n\n  if (child !== null) {\n    collectScopedNodesFromChildren(child, fn, scopedNodes);\n  }\n\n  return scopedNodes.length === 0 ? null : scopedNodes;\n}\n\n_c = DO_NOT_USE_queryAllNodes;\n\nfunction DO_NOT_USE_queryFirstNode(fn) {\n  const currentFiber = getInstanceFromScope(this);\n\n  if (currentFiber === null) {\n    return null;\n  }\n\n  const child = currentFiber.child;\n\n  if (child !== null) {\n    return collectFirstScopedNodeFromChildren(child, fn);\n  }\n\n  return null;\n}\n\n_c2 = DO_NOT_USE_queryFirstNode;\n\nfunction containsNode(node) {\n  let fiber = getInstanceFromNode(node);\n\n  while (fiber !== null) {\n    if (fiber.tag === ScopeComponent && fiber.stateNode === this) {\n      return true;\n    }\n\n    fiber = fiber.return;\n  }\n\n  return false;\n}\n\nfunction getChildContextValues(context) {\n  const currentFiber = getInstanceFromScope(this);\n\n  if (currentFiber === null) {\n    return [];\n  }\n\n  const child = currentFiber.child;\n  const childContextValues = [];\n\n  if (child !== null) {\n    collectNearestChildContextValues(child, context, childContextValues);\n  }\n\n  return childContextValues;\n}\n\nexport function createScopeInstance() {\n  return {\n    DO_NOT_USE_queryAllNodes,\n    DO_NOT_USE_queryFirstNode,\n    containsNode,\n    getChildContextValues\n  };\n}\n\nvar _c, _c2;\n\n$RefreshReg$(_c, \"DO_NOT_USE_queryAllNodes\");\n$RefreshReg$(_c2, \"DO_NOT_USE_queryFirstNode\");","map":{"version":3,"sources":["/Users/zhangshuo/git/my-app/src/react/packages/react-reconciler/src/ReactFiberScope.old.js"],"names":["getPublicInstance","getInstanceFromNode","getInstanceFromScope","isFiberSuspenseAndTimedOut","HostComponent","ScopeComponent","ContextProvider","enableScopeAPI","getSuspenseFallbackChild","fiber","child","sibling","emptyObject","collectScopedNodes","node","fn","scopedNodes","tag","type","memoizedProps","stateNode","instance","push","collectScopedNodesFromChildren","collectFirstScopedNode","collectFirstScopedNodeFromChildren","startingChild","scopedNode","collectNearestContextValues","context","childContextValues","_context","contextValue","value","collectNearestChildContextValues","DO_NOT_USE_queryAllNodes","currentFiber","length","DO_NOT_USE_queryFirstNode","containsNode","return","getChildContextValues","createScopeInstance"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Fiber} from './ReactInternalTypes';\nimport type {\n  ReactScopeInstance,\n  ReactContext,\n  ReactScopeQuery,\n} from 'shared/ReactTypes';\n\nimport {\n  getPublicInstance,\n  getInstanceFromNode,\n  getInstanceFromScope,\n} from './ReactFiberHostConfig';\nimport {isFiberSuspenseAndTimedOut} from './ReactFiberTreeReflection';\n\nimport {HostComponent, ScopeComponent, ContextProvider} from './ReactWorkTags';\nimport {enableScopeAPI} from 'shared/ReactFeatureFlags';\n\nfunction getSuspenseFallbackChild(fiber: Fiber): Fiber | null {\n  return ((((fiber.child: any): Fiber).sibling: any): Fiber).child;\n}\n\nconst emptyObject = {};\n\nfunction collectScopedNodes(\n  node: Fiber,\n  fn: ReactScopeQuery,\n  scopedNodes: Array<any>,\n): void {\n  if (enableScopeAPI) {\n    if (node.tag === HostComponent) {\n      const {type, memoizedProps, stateNode} = node;\n      const instance = getPublicInstance(stateNode);\n      if (\n        instance !== null &&\n        fn(type, memoizedProps || emptyObject, instance) === true\n      ) {\n        scopedNodes.push(instance);\n      }\n    }\n    let child = node.child;\n\n    if (isFiberSuspenseAndTimedOut(node)) {\n      child = getSuspenseFallbackChild(node);\n    }\n    if (child !== null) {\n      collectScopedNodesFromChildren(child, fn, scopedNodes);\n    }\n  }\n}\n\nfunction collectFirstScopedNode(\n  node: Fiber,\n  fn: ReactScopeQuery,\n): null | Object {\n  if (enableScopeAPI) {\n    if (node.tag === HostComponent) {\n      const {type, memoizedProps, stateNode} = node;\n      const instance = getPublicInstance(stateNode);\n      if (instance !== null && fn(type, memoizedProps, instance) === true) {\n        return instance;\n      }\n    }\n    let child = node.child;\n\n    if (isFiberSuspenseAndTimedOut(node)) {\n      child = getSuspenseFallbackChild(node);\n    }\n    if (child !== null) {\n      return collectFirstScopedNodeFromChildren(child, fn);\n    }\n  }\n  return null;\n}\n\nfunction collectScopedNodesFromChildren(\n  startingChild: Fiber,\n  fn: ReactScopeQuery,\n  scopedNodes: Array<any>,\n): void {\n  let child = startingChild;\n  while (child !== null) {\n    collectScopedNodes(child, fn, scopedNodes);\n    child = child.sibling;\n  }\n}\n\nfunction collectFirstScopedNodeFromChildren(\n  startingChild: Fiber,\n  fn: ReactScopeQuery,\n): Object | null {\n  let child = startingChild;\n  while (child !== null) {\n    const scopedNode = collectFirstScopedNode(child, fn);\n    if (scopedNode !== null) {\n      return scopedNode;\n    }\n    child = child.sibling;\n  }\n  return null;\n}\n\nfunction collectNearestContextValues<T>(\n  node: Fiber,\n  context: ReactContext<T>,\n  childContextValues: Array<T>,\n): void {\n  if (node.tag === ContextProvider && node.type._context === context) {\n    const contextValue = node.memoizedProps.value;\n    childContextValues.push(contextValue);\n  } else {\n    let child = node.child;\n\n    if (isFiberSuspenseAndTimedOut(node)) {\n      child = getSuspenseFallbackChild(node);\n    }\n    if (child !== null) {\n      collectNearestChildContextValues(child, context, childContextValues);\n    }\n  }\n}\n\nfunction collectNearestChildContextValues<T>(\n  startingChild: Fiber | null,\n  context: ReactContext<T>,\n  childContextValues: Array<T>,\n): void {\n  let child = startingChild;\n  while (child !== null) {\n    collectNearestContextValues(child, context, childContextValues);\n    child = child.sibling;\n  }\n}\n\nfunction DO_NOT_USE_queryAllNodes(fn: ReactScopeQuery): null | Array<Object> {\n  const currentFiber = getInstanceFromScope(this);\n  if (currentFiber === null) {\n    return null;\n  }\n  const child = currentFiber.child;\n  const scopedNodes = [];\n  if (child !== null) {\n    collectScopedNodesFromChildren(child, fn, scopedNodes);\n  }\n  return scopedNodes.length === 0 ? null : scopedNodes;\n}\n\nfunction DO_NOT_USE_queryFirstNode(fn: ReactScopeQuery): null | Object {\n  const currentFiber = getInstanceFromScope(this);\n  if (currentFiber === null) {\n    return null;\n  }\n  const child = currentFiber.child;\n  if (child !== null) {\n    return collectFirstScopedNodeFromChildren(child, fn);\n  }\n  return null;\n}\n\nfunction containsNode(node: Object): boolean {\n  let fiber = getInstanceFromNode(node);\n  while (fiber !== null) {\n    if (fiber.tag === ScopeComponent && fiber.stateNode === this) {\n      return true;\n    }\n    fiber = fiber.return;\n  }\n  return false;\n}\n\nfunction getChildContextValues<T>(context: ReactContext<T>): Array<T> {\n  const currentFiber = getInstanceFromScope(this);\n  if (currentFiber === null) {\n    return [];\n  }\n  const child = currentFiber.child;\n  const childContextValues = [];\n  if (child !== null) {\n    collectNearestChildContextValues(child, context, childContextValues);\n  }\n  return childContextValues;\n}\n\nexport function createScopeInstance(): ReactScopeInstance {\n  return {\n    DO_NOT_USE_queryAllNodes,\n    DO_NOT_USE_queryFirstNode,\n    containsNode,\n    getChildContextValues,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}