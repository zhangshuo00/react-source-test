{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { registerDirectEvent } from '../EventRegistry';\nimport { IS_REPLAYED } from 'react-dom/src/events/EventSystemFlags';\nimport { SyntheticMouseEvent, SyntheticPointerEvent } from '../SyntheticEvent';\nimport { getClosestInstanceFromNode, getNodeFromInstance, isContainerMarkedAsRoot } from '../../client/ReactDOMComponentTree';\nimport { accumulateEnterLeaveTwoPhaseListeners } from '../DOMPluginEventSystem';\nimport { HostComponent, HostText } from 'react-reconciler/src/ReactWorkTags';\nimport { getNearestMountedFiber } from 'react-reconciler/src/ReactFiberTreeReflection';\n\nfunction registerEvents() {\n  registerDirectEvent('onMouseEnter', ['mouseout', 'mouseover']);\n  registerDirectEvent('onMouseLeave', ['mouseout', 'mouseover']);\n  registerDirectEvent('onPointerEnter', ['pointerout', 'pointerover']);\n  registerDirectEvent('onPointerLeave', ['pointerout', 'pointerover']);\n}\n/**\n * For almost every interaction we care about, there will be both a top-level\n * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that\n * we do not extract duplicate events. However, moving the mouse into the\n * browser from outside will not fire a `mouseout` event. In this case, we use\n * the `mouseover` top-level event.\n */\n\n\nfunction extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {\n  const isOverEvent = domEventName === 'mouseover' || domEventName === 'pointerover';\n  const isOutEvent = domEventName === 'mouseout' || domEventName === 'pointerout';\n\n  if (isOverEvent && (eventSystemFlags & IS_REPLAYED) === 0) {\n    // If this is an over event with a target, we might have already dispatched\n    // the event in the out event of the other target. If this is replayed,\n    // then it's because we couldn't dispatch against this target previously\n    // so we have to do it now instead.\n    const related = nativeEvent.relatedTarget || nativeEvent.fromElement;\n\n    if (related) {\n      // If the related node is managed by React, we can assume that we have\n      // already dispatched the corresponding events during its mouseout.\n      if (getClosestInstanceFromNode(related) || isContainerMarkedAsRoot(related)) {\n        return;\n      }\n    }\n  }\n\n  if (!isOutEvent && !isOverEvent) {\n    // Must not be a mouse or pointer in or out - ignoring.\n    return;\n  }\n\n  let win; // TODO: why is this nullable in the types but we read from it?\n\n  if (nativeEventTarget.window === nativeEventTarget) {\n    // `nativeEventTarget` is probably a window object.\n    win = nativeEventTarget;\n  } else {\n    // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.\n    const doc = nativeEventTarget.ownerDocument;\n\n    if (doc) {\n      win = doc.defaultView || doc.parentWindow;\n    } else {\n      win = window;\n    }\n  }\n\n  let from;\n  let to;\n\n  if (isOutEvent) {\n    const related = nativeEvent.relatedTarget || nativeEvent.toElement;\n    from = targetInst;\n    to = related ? getClosestInstanceFromNode(related) : null;\n\n    if (to !== null) {\n      const nearestMounted = getNearestMountedFiber(to);\n\n      if (to !== nearestMounted || to.tag !== HostComponent && to.tag !== HostText) {\n        to = null;\n      }\n    }\n  } else {\n    // Moving to a node from outside the window.\n    from = null;\n    to = targetInst;\n  }\n\n  if (from === to) {\n    // Nothing pertains to our managed components.\n    return;\n  }\n\n  let SyntheticEventCtor = SyntheticMouseEvent;\n  let leaveEventType = 'onMouseLeave';\n  let enterEventType = 'onMouseEnter';\n  let eventTypePrefix = 'mouse';\n\n  if (domEventName === 'pointerout' || domEventName === 'pointerover') {\n    SyntheticEventCtor = SyntheticPointerEvent;\n    leaveEventType = 'onPointerLeave';\n    enterEventType = 'onPointerEnter';\n    eventTypePrefix = 'pointer';\n  }\n\n  const fromNode = from == null ? win : getNodeFromInstance(from);\n  const toNode = to == null ? win : getNodeFromInstance(to);\n  const leave = new SyntheticEventCtor(leaveEventType, eventTypePrefix + 'leave', from, nativeEvent, nativeEventTarget);\n  leave.target = fromNode;\n  leave.relatedTarget = toNode;\n  let enter = null; // We should only process this nativeEvent if we are processing\n  // the first ancestor. Next time, we will ignore the event.\n\n  const nativeTargetInst = getClosestInstanceFromNode(nativeEventTarget);\n\n  if (nativeTargetInst === targetInst) {\n    const enterEvent = new SyntheticEventCtor(enterEventType, eventTypePrefix + 'enter', to, nativeEvent, nativeEventTarget);\n    enterEvent.target = toNode;\n    enterEvent.relatedTarget = fromNode;\n    enter = enterEvent;\n  }\n\n  accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leave, enter, from, to);\n}\n\nexport { registerEvents, extractEvents };","map":{"version":3,"sources":["/Users/zhangshuo/git/my-app/src/react/packages/react-dom/src/events/plugins/EnterLeaveEventPlugin.js"],"names":["registerDirectEvent","IS_REPLAYED","SyntheticMouseEvent","SyntheticPointerEvent","getClosestInstanceFromNode","getNodeFromInstance","isContainerMarkedAsRoot","accumulateEnterLeaveTwoPhaseListeners","HostComponent","HostText","getNearestMountedFiber","registerEvents","extractEvents","dispatchQueue","domEventName","targetInst","nativeEvent","nativeEventTarget","eventSystemFlags","targetContainer","isOverEvent","isOutEvent","related","relatedTarget","fromElement","win","window","doc","ownerDocument","defaultView","parentWindow","from","to","toElement","nearestMounted","tag","SyntheticEventCtor","leaveEventType","enterEventType","eventTypePrefix","fromNode","toNode","leave","target","enter","nativeTargetInst","enterEvent"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {AnyNativeEvent} from '../PluginModuleType';\nimport type {DOMEventName} from '../DOMEventNames';\nimport type {DispatchQueue} from '../DOMPluginEventSystem';\nimport type {EventSystemFlags} from '../EventSystemFlags';\n\nimport {registerDirectEvent} from '../EventRegistry';\nimport {IS_REPLAYED} from 'react-dom/src/events/EventSystemFlags';\nimport {SyntheticMouseEvent, SyntheticPointerEvent} from '../SyntheticEvent';\nimport {\n  getClosestInstanceFromNode,\n  getNodeFromInstance,\n  isContainerMarkedAsRoot,\n} from '../../client/ReactDOMComponentTree';\nimport {accumulateEnterLeaveTwoPhaseListeners} from '../DOMPluginEventSystem';\nimport type {KnownReactSyntheticEvent} from '../ReactSyntheticEventType';\n\nimport {HostComponent, HostText} from 'react-reconciler/src/ReactWorkTags';\nimport {getNearestMountedFiber} from 'react-reconciler/src/ReactFiberTreeReflection';\n\nfunction registerEvents() {\n  registerDirectEvent('onMouseEnter', ['mouseout', 'mouseover']);\n  registerDirectEvent('onMouseLeave', ['mouseout', 'mouseover']);\n  registerDirectEvent('onPointerEnter', ['pointerout', 'pointerover']);\n  registerDirectEvent('onPointerLeave', ['pointerout', 'pointerover']);\n}\n\n/**\n * For almost every interaction we care about, there will be both a top-level\n * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that\n * we do not extract duplicate events. However, moving the mouse into the\n * browser from outside will not fire a `mouseout` event. In this case, we use\n * the `mouseover` top-level event.\n */\nfunction extractEvents(\n  dispatchQueue: DispatchQueue,\n  domEventName: DOMEventName,\n  targetInst: null | Fiber,\n  nativeEvent: AnyNativeEvent,\n  nativeEventTarget: null | EventTarget,\n  eventSystemFlags: EventSystemFlags,\n  targetContainer: EventTarget,\n) {\n  const isOverEvent =\n    domEventName === 'mouseover' || domEventName === 'pointerover';\n  const isOutEvent =\n    domEventName === 'mouseout' || domEventName === 'pointerout';\n\n  if (isOverEvent && (eventSystemFlags & IS_REPLAYED) === 0) {\n    // If this is an over event with a target, we might have already dispatched\n    // the event in the out event of the other target. If this is replayed,\n    // then it's because we couldn't dispatch against this target previously\n    // so we have to do it now instead.\n    const related =\n      (nativeEvent: any).relatedTarget || (nativeEvent: any).fromElement;\n    if (related) {\n      // If the related node is managed by React, we can assume that we have\n      // already dispatched the corresponding events during its mouseout.\n      if (\n        getClosestInstanceFromNode(related) ||\n        isContainerMarkedAsRoot(related)\n      ) {\n        return;\n      }\n    }\n  }\n\n  if (!isOutEvent && !isOverEvent) {\n    // Must not be a mouse or pointer in or out - ignoring.\n    return;\n  }\n\n  let win;\n  // TODO: why is this nullable in the types but we read from it?\n  if ((nativeEventTarget: any).window === nativeEventTarget) {\n    // `nativeEventTarget` is probably a window object.\n    win = nativeEventTarget;\n  } else {\n    // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.\n    const doc = (nativeEventTarget: any).ownerDocument;\n    if (doc) {\n      win = doc.defaultView || doc.parentWindow;\n    } else {\n      win = window;\n    }\n  }\n\n  let from;\n  let to;\n  if (isOutEvent) {\n    const related = nativeEvent.relatedTarget || (nativeEvent: any).toElement;\n    from = targetInst;\n    to = related ? getClosestInstanceFromNode((related: any)) : null;\n    if (to !== null) {\n      const nearestMounted = getNearestMountedFiber(to);\n      if (\n        to !== nearestMounted ||\n        (to.tag !== HostComponent && to.tag !== HostText)\n      ) {\n        to = null;\n      }\n    }\n  } else {\n    // Moving to a node from outside the window.\n    from = null;\n    to = targetInst;\n  }\n\n  if (from === to) {\n    // Nothing pertains to our managed components.\n    return;\n  }\n\n  let SyntheticEventCtor = SyntheticMouseEvent;\n  let leaveEventType = 'onMouseLeave';\n  let enterEventType = 'onMouseEnter';\n  let eventTypePrefix = 'mouse';\n  if (domEventName === 'pointerout' || domEventName === 'pointerover') {\n    SyntheticEventCtor = SyntheticPointerEvent;\n    leaveEventType = 'onPointerLeave';\n    enterEventType = 'onPointerEnter';\n    eventTypePrefix = 'pointer';\n  }\n\n  const fromNode = from == null ? win : getNodeFromInstance(from);\n  const toNode = to == null ? win : getNodeFromInstance(to);\n\n  const leave = new SyntheticEventCtor(\n    leaveEventType,\n    eventTypePrefix + 'leave',\n    from,\n    nativeEvent,\n    nativeEventTarget,\n  );\n  leave.target = fromNode;\n  leave.relatedTarget = toNode;\n\n  let enter: KnownReactSyntheticEvent | null = null;\n\n  // We should only process this nativeEvent if we are processing\n  // the first ancestor. Next time, we will ignore the event.\n  const nativeTargetInst = getClosestInstanceFromNode((nativeEventTarget: any));\n  if (nativeTargetInst === targetInst) {\n    const enterEvent: KnownReactSyntheticEvent = new SyntheticEventCtor(\n      enterEventType,\n      eventTypePrefix + 'enter',\n      to,\n      nativeEvent,\n      nativeEventTarget,\n    );\n    enterEvent.target = toNode;\n    enterEvent.relatedTarget = fromNode;\n    enter = enterEvent;\n  }\n\n  accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leave, enter, from, to);\n}\n\nexport {registerEvents, extractEvents};\n"]},"metadata":{},"sourceType":"module"}