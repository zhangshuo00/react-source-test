{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { enableSelectiveHydration, enableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay } from 'shared/ReactFeatureFlags';\nimport { unstable_scheduleCallback as scheduleCallback, unstable_NormalPriority as NormalPriority } from 'scheduler';\nimport { getNearestMountedFiber, getContainerFromFiber, getSuspenseInstanceFromFiber } from 'react-reconciler/src/ReactFiberTreeReflection';\nimport { attemptToDispatchEvent } from './ReactDOMEventListener';\nimport { getInstanceFromNode, getClosestInstanceFromNode } from '../client/ReactDOMComponentTree';\nimport { HostRoot, SuspenseComponent } from 'react-reconciler/src/ReactWorkTags';\nimport { isHigherEventPriority } from 'react-reconciler/src/ReactEventPriorities';\n\nlet _attemptSynchronousHydration;\n\nexport function setAttemptSynchronousHydration(fn) {\n  _attemptSynchronousHydration = fn;\n}\nexport function attemptSynchronousHydration(fiber) {\n  _attemptSynchronousHydration(fiber);\n}\nlet attemptDiscreteHydration;\nexport function setAttemptDiscreteHydration(fn) {\n  attemptDiscreteHydration = fn;\n}\nlet attemptContinuousHydration;\nexport function setAttemptContinuousHydration(fn) {\n  attemptContinuousHydration = fn;\n}\nlet attemptHydrationAtCurrentPriority;\nexport function setAttemptHydrationAtCurrentPriority(fn) {\n  attemptHydrationAtCurrentPriority = fn;\n}\nlet getCurrentUpdatePriority;\nexport function setGetCurrentUpdatePriority(fn) {\n  getCurrentUpdatePriority = fn;\n}\nlet attemptHydrationAtPriority;\nexport function setAttemptHydrationAtPriority(fn) {\n  attemptHydrationAtPriority = fn;\n} // TODO: Upgrade this definition once we're on a newer version of Flow that\n// has this definition built-in.\n\nimport { IS_REPLAYED } from './EventSystemFlags';\nlet hasScheduledReplayAttempt = false; // The queue of discrete events to be replayed.\n\nconst queuedDiscreteEvents = []; // Indicates if any continuous event targets are non-null for early bailout.\n\nconst hasAnyQueuedContinuousEvents = false; // The last of each continuous event type. We only need to replay the last one\n// if the last target was dehydrated.\n\nlet queuedFocus = null;\nlet queuedDrag = null;\nlet queuedMouse = null; // For pointer events there can be one latest event per pointerId.\n\nconst queuedPointers = new Map();\nconst queuedPointerCaptures = new Map(); // We could consider replaying selectionchange and touchmoves too.\n\nconst queuedExplicitHydrationTargets = [];\nexport function hasQueuedDiscreteEvents() {\n  return queuedDiscreteEvents.length > 0;\n}\nexport function hasQueuedContinuousEvents() {\n  return hasAnyQueuedContinuousEvents;\n}\nconst discreteReplayableEvents = ['mousedown', 'mouseup', 'touchcancel', 'touchend', 'touchstart', 'auxclick', 'dblclick', 'pointercancel', 'pointerdown', 'pointerup', 'dragend', 'dragstart', 'drop', 'compositionend', 'compositionstart', 'keydown', 'keypress', 'keyup', 'input', 'textInput', // Intentionally camelCase\n'copy', 'cut', 'paste', 'click', 'change', 'contextmenu', 'reset', 'submit'];\nexport function isDiscreteEventThatRequiresHydration(eventType) {\n  return discreteReplayableEvents.indexOf(eventType) > -1;\n}\n\nfunction createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {\n  return {\n    blockedOn,\n    domEventName,\n    eventSystemFlags: eventSystemFlags | IS_REPLAYED,\n    nativeEvent,\n    targetContainers: [targetContainer]\n  };\n}\n\nexport function queueDiscreteEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {\n  if (enableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay) {\n    return;\n  }\n\n  const queuedEvent = createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent);\n  queuedDiscreteEvents.push(queuedEvent);\n\n  if (enableSelectiveHydration) {\n    if (queuedDiscreteEvents.length === 1) {\n      // If this was the first discrete event, we might be able to\n      // synchronously unblock it so that preventDefault still works.\n      while (queuedEvent.blockedOn !== null) {\n        const fiber = getInstanceFromNode(queuedEvent.blockedOn);\n\n        if (fiber === null) {\n          break;\n        }\n\n        attemptSynchronousHydration(fiber);\n\n        if (queuedEvent.blockedOn === null) {\n          // We got unblocked by hydration. Let's try again.\n          replayUnblockedEvents(); // If we're reblocked, on an inner boundary, we might need\n          // to attempt hydrating that one.\n\n          continue;\n        } else {\n          // We're still blocked from hydration, we have to give up\n          // and replay later.\n          break;\n        }\n      }\n    }\n  }\n} // Resets the replaying for this type of continuous event to no event.\n\nexport function clearIfContinuousEvent(domEventName, nativeEvent) {\n  switch (domEventName) {\n    case 'focusin':\n    case 'focusout':\n      queuedFocus = null;\n      break;\n\n    case 'dragenter':\n    case 'dragleave':\n      queuedDrag = null;\n      break;\n\n    case 'mouseover':\n    case 'mouseout':\n      queuedMouse = null;\n      break;\n\n    case 'pointerover':\n    case 'pointerout':\n      {\n        const pointerId = nativeEvent.pointerId;\n        queuedPointers.delete(pointerId);\n        break;\n      }\n\n    case 'gotpointercapture':\n    case 'lostpointercapture':\n      {\n        const pointerId = nativeEvent.pointerId;\n        queuedPointerCaptures.delete(pointerId);\n        break;\n      }\n  }\n}\n\nfunction accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {\n  if (existingQueuedEvent === null || existingQueuedEvent.nativeEvent !== nativeEvent) {\n    const queuedEvent = createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent);\n\n    if (blockedOn !== null) {\n      const fiber = getInstanceFromNode(blockedOn);\n\n      if (fiber !== null) {\n        // Attempt to increase the priority of this target.\n        attemptContinuousHydration(fiber);\n      }\n    }\n\n    return queuedEvent;\n  } // If we have already queued this exact event, then it's because\n  // the different event systems have different DOM event listeners.\n  // We can accumulate the flags, and the targetContainers, and\n  // store a single event to be replayed.\n\n\n  existingQueuedEvent.eventSystemFlags |= eventSystemFlags;\n  const targetContainers = existingQueuedEvent.targetContainers;\n\n  if (targetContainer !== null && targetContainers.indexOf(targetContainer) === -1) {\n    targetContainers.push(targetContainer);\n  }\n\n  return existingQueuedEvent;\n}\n\nexport function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {\n  // These set relatedTarget to null because the replayed event will be treated as if we\n  // moved from outside the window (no target) onto the target once it hydrates.\n  // Instead of mutating we could clone the event.\n  switch (domEventName) {\n    case 'focusin':\n      {\n        const focusEvent = nativeEvent;\n        queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus, blockedOn, domEventName, eventSystemFlags, targetContainer, focusEvent);\n        return true;\n      }\n\n    case 'dragenter':\n      {\n        const dragEvent = nativeEvent;\n        queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag, blockedOn, domEventName, eventSystemFlags, targetContainer, dragEvent);\n        return true;\n      }\n\n    case 'mouseover':\n      {\n        const mouseEvent = nativeEvent;\n        queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse, blockedOn, domEventName, eventSystemFlags, targetContainer, mouseEvent);\n        return true;\n      }\n\n    case 'pointerover':\n      {\n        const pointerEvent = nativeEvent;\n        const pointerId = pointerEvent.pointerId;\n        queuedPointers.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(pointerId) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, pointerEvent));\n        return true;\n      }\n\n    case 'gotpointercapture':\n      {\n        const pointerEvent = nativeEvent;\n        const pointerId = pointerEvent.pointerId;\n        queuedPointerCaptures.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(pointerId) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, pointerEvent));\n        return true;\n      }\n  }\n\n  return false;\n} // Check if this target is unblocked. Returns true if it's unblocked.\n\nfunction attemptExplicitHydrationTarget(queuedTarget) {\n  // TODO: This function shares a lot of logic with attemptToDispatchEvent.\n  // Try to unify them. It's a bit tricky since it would require two return\n  // values.\n  const targetInst = getClosestInstanceFromNode(queuedTarget.target);\n\n  if (targetInst !== null) {\n    const nearestMounted = getNearestMountedFiber(targetInst);\n\n    if (nearestMounted !== null) {\n      const tag = nearestMounted.tag;\n\n      if (tag === SuspenseComponent) {\n        const instance = getSuspenseInstanceFromFiber(nearestMounted);\n\n        if (instance !== null) {\n          // We're blocked on hydrating this boundary.\n          // Increase its priority.\n          queuedTarget.blockedOn = instance;\n          attemptHydrationAtPriority(queuedTarget.priority, () => {\n            attemptHydrationAtCurrentPriority(nearestMounted);\n          });\n          return;\n        }\n      } else if (tag === HostRoot) {\n        const root = nearestMounted.stateNode;\n\n        if (root.isDehydrated) {\n          queuedTarget.blockedOn = getContainerFromFiber(nearestMounted); // We don't currently have a way to increase the priority of\n          // a root other than sync.\n\n          return;\n        }\n      }\n    }\n  }\n\n  queuedTarget.blockedOn = null;\n}\n\nexport function queueExplicitHydrationTarget(target) {\n  if (enableSelectiveHydration) {\n    // TODO: This will read the priority if it's dispatched by the React\n    // event system but not native events. Should read window.event.type, like\n    // we do for updates (getCurrentEventPriority).\n    const updatePriority = getCurrentUpdatePriority();\n    const queuedTarget = {\n      blockedOn: null,\n      target: target,\n      priority: updatePriority\n    };\n    let i = 0;\n\n    for (; i < queuedExplicitHydrationTargets.length; i++) {\n      // Stop once we hit the first target with lower priority than\n      if (!isHigherEventPriority(updatePriority, queuedExplicitHydrationTargets[i].priority)) {\n        break;\n      }\n    }\n\n    queuedExplicitHydrationTargets.splice(i, 0, queuedTarget);\n\n    if (i === 0) {\n      attemptExplicitHydrationTarget(queuedTarget);\n    }\n  }\n}\n\nfunction attemptReplayContinuousQueuedEvent(queuedEvent) {\n  if (queuedEvent.blockedOn !== null) {\n    return false;\n  }\n\n  const targetContainers = queuedEvent.targetContainers;\n\n  while (targetContainers.length > 0) {\n    const targetContainer = targetContainers[0];\n    const nextBlockedOn = attemptToDispatchEvent(queuedEvent.domEventName, queuedEvent.eventSystemFlags, targetContainer, queuedEvent.nativeEvent);\n\n    if (nextBlockedOn !== null) {\n      // We're still blocked. Try again later.\n      const fiber = getInstanceFromNode(nextBlockedOn);\n\n      if (fiber !== null) {\n        attemptContinuousHydration(fiber);\n      }\n\n      queuedEvent.blockedOn = nextBlockedOn;\n      return false;\n    } // This target container was successfully dispatched. Try the next.\n\n\n    targetContainers.shift();\n  }\n\n  return true;\n}\n\nfunction attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {\n  if (attemptReplayContinuousQueuedEvent(queuedEvent)) {\n    map.delete(key);\n  }\n}\n\nfunction replayUnblockedEvents() {\n  hasScheduledReplayAttempt = false;\n\n  if (!enableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay) {\n    // First replay discrete events.\n    while (queuedDiscreteEvents.length > 0) {\n      const nextDiscreteEvent = queuedDiscreteEvents[0];\n\n      if (nextDiscreteEvent.blockedOn !== null) {\n        // We're still blocked.\n        // Increase the priority of this boundary to unblock\n        // the next discrete event.\n        const fiber = getInstanceFromNode(nextDiscreteEvent.blockedOn);\n\n        if (fiber !== null) {\n          attemptDiscreteHydration(fiber);\n        }\n\n        break;\n      }\n\n      const targetContainers = nextDiscreteEvent.targetContainers;\n\n      while (targetContainers.length > 0) {\n        const targetContainer = targetContainers[0];\n        const nextBlockedOn = attemptToDispatchEvent(nextDiscreteEvent.domEventName, nextDiscreteEvent.eventSystemFlags, targetContainer, nextDiscreteEvent.nativeEvent);\n\n        if (nextBlockedOn !== null) {\n          // We're still blocked. Try again later.\n          nextDiscreteEvent.blockedOn = nextBlockedOn;\n          break;\n        } // This target container was successfully dispatched. Try the next.\n\n\n        targetContainers.shift();\n      }\n\n      if (nextDiscreteEvent.blockedOn === null) {\n        // We've successfully replayed the first event. Let's try the next one.\n        queuedDiscreteEvents.shift();\n      }\n    }\n  } // Next replay any continuous events.\n\n\n  if (queuedFocus !== null && attemptReplayContinuousQueuedEvent(queuedFocus)) {\n    queuedFocus = null;\n  }\n\n  if (queuedDrag !== null && attemptReplayContinuousQueuedEvent(queuedDrag)) {\n    queuedDrag = null;\n  }\n\n  if (queuedMouse !== null && attemptReplayContinuousQueuedEvent(queuedMouse)) {\n    queuedMouse = null;\n  }\n\n  queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);\n  queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);\n}\n\nfunction scheduleCallbackIfUnblocked(queuedEvent, unblocked) {\n  if (queuedEvent.blockedOn === unblocked) {\n    queuedEvent.blockedOn = null;\n\n    if (!hasScheduledReplayAttempt) {\n      hasScheduledReplayAttempt = true; // Schedule a callback to attempt replaying as many events as are\n      // now unblocked. This first might not actually be unblocked yet.\n      // We could check it early to avoid scheduling an unnecessary callback.\n\n      scheduleCallback(NormalPriority, replayUnblockedEvents);\n    }\n  }\n}\n\nexport function retryIfBlockedOn(unblocked) {\n  // Mark anything that was blocked on this as no longer blocked\n  // and eligible for a replay.\n  if (queuedDiscreteEvents.length > 0) {\n    scheduleCallbackIfUnblocked(queuedDiscreteEvents[0], unblocked); // This is a exponential search for each boundary that commits. I think it's\n    // worth it because we expect very few discrete events to queue up and once\n    // we are actually fully unblocked it will be fast to replay them.\n\n    for (let i = 1; i < queuedDiscreteEvents.length; i++) {\n      const queuedEvent = queuedDiscreteEvents[i];\n\n      if (queuedEvent.blockedOn === unblocked) {\n        queuedEvent.blockedOn = null;\n      }\n    }\n  }\n\n  if (queuedFocus !== null) {\n    scheduleCallbackIfUnblocked(queuedFocus, unblocked);\n  }\n\n  if (queuedDrag !== null) {\n    scheduleCallbackIfUnblocked(queuedDrag, unblocked);\n  }\n\n  if (queuedMouse !== null) {\n    scheduleCallbackIfUnblocked(queuedMouse, unblocked);\n  }\n\n  const unblock = queuedEvent => scheduleCallbackIfUnblocked(queuedEvent, unblocked);\n\n  queuedPointers.forEach(unblock);\n  queuedPointerCaptures.forEach(unblock);\n\n  for (let i = 0; i < queuedExplicitHydrationTargets.length; i++) {\n    const queuedTarget = queuedExplicitHydrationTargets[i];\n\n    if (queuedTarget.blockedOn === unblocked) {\n      queuedTarget.blockedOn = null;\n    }\n  }\n\n  while (queuedExplicitHydrationTargets.length > 0) {\n    const nextExplicitTarget = queuedExplicitHydrationTargets[0];\n\n    if (nextExplicitTarget.blockedOn !== null) {\n      // We're still blocked.\n      break;\n    } else {\n      attemptExplicitHydrationTarget(nextExplicitTarget);\n\n      if (nextExplicitTarget.blockedOn === null) {\n        // We're unblocked.\n        queuedExplicitHydrationTargets.shift();\n      }\n    }\n  }\n}","map":{"version":3,"sources":["/Users/zhangshuo/git/my-app/src/react/packages/react-dom/src/events/ReactDOMEventReplaying.js"],"names":["enableSelectiveHydration","enableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay","unstable_scheduleCallback","scheduleCallback","unstable_NormalPriority","NormalPriority","getNearestMountedFiber","getContainerFromFiber","getSuspenseInstanceFromFiber","attemptToDispatchEvent","getInstanceFromNode","getClosestInstanceFromNode","HostRoot","SuspenseComponent","isHigherEventPriority","_attemptSynchronousHydration","setAttemptSynchronousHydration","fn","attemptSynchronousHydration","fiber","attemptDiscreteHydration","setAttemptDiscreteHydration","attemptContinuousHydration","setAttemptContinuousHydration","attemptHydrationAtCurrentPriority","setAttemptHydrationAtCurrentPriority","getCurrentUpdatePriority","setGetCurrentUpdatePriority","attemptHydrationAtPriority","setAttemptHydrationAtPriority","IS_REPLAYED","hasScheduledReplayAttempt","queuedDiscreteEvents","hasAnyQueuedContinuousEvents","queuedFocus","queuedDrag","queuedMouse","queuedPointers","Map","queuedPointerCaptures","queuedExplicitHydrationTargets","hasQueuedDiscreteEvents","length","hasQueuedContinuousEvents","discreteReplayableEvents","isDiscreteEventThatRequiresHydration","eventType","indexOf","createQueuedReplayableEvent","blockedOn","domEventName","eventSystemFlags","targetContainer","nativeEvent","targetContainers","queueDiscreteEvent","queuedEvent","push","replayUnblockedEvents","clearIfContinuousEvent","pointerId","delete","accumulateOrCreateContinuousQueuedReplayableEvent","existingQueuedEvent","queueIfContinuousEvent","focusEvent","dragEvent","mouseEvent","pointerEvent","set","get","attemptExplicitHydrationTarget","queuedTarget","targetInst","target","nearestMounted","tag","instance","priority","root","stateNode","isDehydrated","queueExplicitHydrationTarget","updatePriority","i","splice","attemptReplayContinuousQueuedEvent","nextBlockedOn","shift","attemptReplayContinuousQueuedEventInMap","key","map","nextDiscreteEvent","forEach","scheduleCallbackIfUnblocked","unblocked","retryIfBlockedOn","unblock","nextExplicitTarget"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {AnyNativeEvent} from '../events/PluginModuleType';\nimport type {Container, SuspenseInstance} from '../client/ReactDOMHostConfig';\nimport type {DOMEventName} from '../events/DOMEventNames';\nimport type {EventSystemFlags} from './EventSystemFlags';\nimport type {FiberRoot} from 'react-reconciler/src/ReactInternalTypes';\nimport type {EventPriority} from 'react-reconciler/src/ReactEventPriorities';\n\nimport {\n  enableSelectiveHydration,\n  enableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay,\n} from 'shared/ReactFeatureFlags';\nimport {\n  unstable_scheduleCallback as scheduleCallback,\n  unstable_NormalPriority as NormalPriority,\n} from 'scheduler';\nimport {\n  getNearestMountedFiber,\n  getContainerFromFiber,\n  getSuspenseInstanceFromFiber,\n} from 'react-reconciler/src/ReactFiberTreeReflection';\nimport {attemptToDispatchEvent} from './ReactDOMEventListener';\nimport {\n  getInstanceFromNode,\n  getClosestInstanceFromNode,\n} from '../client/ReactDOMComponentTree';\nimport {HostRoot, SuspenseComponent} from 'react-reconciler/src/ReactWorkTags';\nimport {isHigherEventPriority} from 'react-reconciler/src/ReactEventPriorities';\n\nlet _attemptSynchronousHydration: (fiber: Object) => void;\n\nexport function setAttemptSynchronousHydration(fn: (fiber: Object) => void) {\n  _attemptSynchronousHydration = fn;\n}\n\nexport function attemptSynchronousHydration(fiber: Object) {\n  _attemptSynchronousHydration(fiber);\n}\n\nlet attemptDiscreteHydration: (fiber: Object) => void;\n\nexport function setAttemptDiscreteHydration(fn: (fiber: Object) => void) {\n  attemptDiscreteHydration = fn;\n}\n\nlet attemptContinuousHydration: (fiber: Object) => void;\n\nexport function setAttemptContinuousHydration(fn: (fiber: Object) => void) {\n  attemptContinuousHydration = fn;\n}\n\nlet attemptHydrationAtCurrentPriority: (fiber: Object) => void;\n\nexport function setAttemptHydrationAtCurrentPriority(\n  fn: (fiber: Object) => void,\n) {\n  attemptHydrationAtCurrentPriority = fn;\n}\n\nlet getCurrentUpdatePriority: () => EventPriority;\n\nexport function setGetCurrentUpdatePriority(fn: () => EventPriority) {\n  getCurrentUpdatePriority = fn;\n}\n\nlet attemptHydrationAtPriority: <T>(priority: EventPriority, fn: () => T) => T;\n\nexport function setAttemptHydrationAtPriority(\n  fn: <T>(priority: EventPriority, fn: () => T) => T,\n) {\n  attemptHydrationAtPriority = fn;\n}\n\n// TODO: Upgrade this definition once we're on a newer version of Flow that\n// has this definition built-in.\ntype PointerEvent = Event & {\n  pointerId: number,\n  relatedTarget: EventTarget | null,\n  ...\n};\n\nimport {IS_REPLAYED} from './EventSystemFlags';\n\ntype QueuedReplayableEvent = {|\n  blockedOn: null | Container | SuspenseInstance,\n  domEventName: DOMEventName,\n  eventSystemFlags: EventSystemFlags,\n  nativeEvent: AnyNativeEvent,\n  targetContainers: Array<EventTarget>,\n|};\n\nlet hasScheduledReplayAttempt = false;\n\n// The queue of discrete events to be replayed.\nconst queuedDiscreteEvents: Array<QueuedReplayableEvent> = [];\n\n// Indicates if any continuous event targets are non-null for early bailout.\nconst hasAnyQueuedContinuousEvents: boolean = false;\n// The last of each continuous event type. We only need to replay the last one\n// if the last target was dehydrated.\nlet queuedFocus: null | QueuedReplayableEvent = null;\nlet queuedDrag: null | QueuedReplayableEvent = null;\nlet queuedMouse: null | QueuedReplayableEvent = null;\n// For pointer events there can be one latest event per pointerId.\nconst queuedPointers: Map<number, QueuedReplayableEvent> = new Map();\nconst queuedPointerCaptures: Map<number, QueuedReplayableEvent> = new Map();\n// We could consider replaying selectionchange and touchmoves too.\n\ntype QueuedHydrationTarget = {|\n  blockedOn: null | Container | SuspenseInstance,\n  target: Node,\n  priority: EventPriority,\n|};\nconst queuedExplicitHydrationTargets: Array<QueuedHydrationTarget> = [];\n\nexport function hasQueuedDiscreteEvents(): boolean {\n  return queuedDiscreteEvents.length > 0;\n}\n\nexport function hasQueuedContinuousEvents(): boolean {\n  return hasAnyQueuedContinuousEvents;\n}\n\nconst discreteReplayableEvents: Array<DOMEventName> = [\n  'mousedown',\n  'mouseup',\n  'touchcancel',\n  'touchend',\n  'touchstart',\n  'auxclick',\n  'dblclick',\n  'pointercancel',\n  'pointerdown',\n  'pointerup',\n  'dragend',\n  'dragstart',\n  'drop',\n  'compositionend',\n  'compositionstart',\n  'keydown',\n  'keypress',\n  'keyup',\n  'input',\n  'textInput', // Intentionally camelCase\n  'copy',\n  'cut',\n  'paste',\n  'click',\n  'change',\n  'contextmenu',\n  'reset',\n  'submit',\n];\n\nexport function isDiscreteEventThatRequiresHydration(\n  eventType: DOMEventName,\n): boolean {\n  return discreteReplayableEvents.indexOf(eventType) > -1;\n}\n\nfunction createQueuedReplayableEvent(\n  blockedOn: null | Container | SuspenseInstance,\n  domEventName: DOMEventName,\n  eventSystemFlags: EventSystemFlags,\n  targetContainer: EventTarget,\n  nativeEvent: AnyNativeEvent,\n): QueuedReplayableEvent {\n  return {\n    blockedOn,\n    domEventName,\n    eventSystemFlags: eventSystemFlags | IS_REPLAYED,\n    nativeEvent,\n    targetContainers: [targetContainer],\n  };\n}\n\nexport function queueDiscreteEvent(\n  blockedOn: null | Container | SuspenseInstance,\n  domEventName: DOMEventName,\n  eventSystemFlags: EventSystemFlags,\n  targetContainer: EventTarget,\n  nativeEvent: AnyNativeEvent,\n): void {\n  if (enableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay) {\n    return;\n  }\n  const queuedEvent = createQueuedReplayableEvent(\n    blockedOn,\n    domEventName,\n    eventSystemFlags,\n    targetContainer,\n    nativeEvent,\n  );\n  queuedDiscreteEvents.push(queuedEvent);\n  if (enableSelectiveHydration) {\n    if (queuedDiscreteEvents.length === 1) {\n      // If this was the first discrete event, we might be able to\n      // synchronously unblock it so that preventDefault still works.\n      while (queuedEvent.blockedOn !== null) {\n        const fiber = getInstanceFromNode(queuedEvent.blockedOn);\n        if (fiber === null) {\n          break;\n        }\n        attemptSynchronousHydration(fiber);\n        if (queuedEvent.blockedOn === null) {\n          // We got unblocked by hydration. Let's try again.\n          replayUnblockedEvents();\n          // If we're reblocked, on an inner boundary, we might need\n          // to attempt hydrating that one.\n          continue;\n        } else {\n          // We're still blocked from hydration, we have to give up\n          // and replay later.\n          break;\n        }\n      }\n    }\n  }\n}\n\n// Resets the replaying for this type of continuous event to no event.\nexport function clearIfContinuousEvent(\n  domEventName: DOMEventName,\n  nativeEvent: AnyNativeEvent,\n): void {\n  switch (domEventName) {\n    case 'focusin':\n    case 'focusout':\n      queuedFocus = null;\n      break;\n    case 'dragenter':\n    case 'dragleave':\n      queuedDrag = null;\n      break;\n    case 'mouseover':\n    case 'mouseout':\n      queuedMouse = null;\n      break;\n    case 'pointerover':\n    case 'pointerout': {\n      const pointerId = ((nativeEvent: any): PointerEvent).pointerId;\n      queuedPointers.delete(pointerId);\n      break;\n    }\n    case 'gotpointercapture':\n    case 'lostpointercapture': {\n      const pointerId = ((nativeEvent: any): PointerEvent).pointerId;\n      queuedPointerCaptures.delete(pointerId);\n      break;\n    }\n  }\n}\n\nfunction accumulateOrCreateContinuousQueuedReplayableEvent(\n  existingQueuedEvent: null | QueuedReplayableEvent,\n  blockedOn: null | Container | SuspenseInstance,\n  domEventName: DOMEventName,\n  eventSystemFlags: EventSystemFlags,\n  targetContainer: EventTarget,\n  nativeEvent: AnyNativeEvent,\n): QueuedReplayableEvent {\n  if (\n    existingQueuedEvent === null ||\n    existingQueuedEvent.nativeEvent !== nativeEvent\n  ) {\n    const queuedEvent = createQueuedReplayableEvent(\n      blockedOn,\n      domEventName,\n      eventSystemFlags,\n      targetContainer,\n      nativeEvent,\n    );\n    if (blockedOn !== null) {\n      const fiber = getInstanceFromNode(blockedOn);\n      if (fiber !== null) {\n        // Attempt to increase the priority of this target.\n        attemptContinuousHydration(fiber);\n      }\n    }\n    return queuedEvent;\n  }\n  // If we have already queued this exact event, then it's because\n  // the different event systems have different DOM event listeners.\n  // We can accumulate the flags, and the targetContainers, and\n  // store a single event to be replayed.\n  existingQueuedEvent.eventSystemFlags |= eventSystemFlags;\n  const targetContainers = existingQueuedEvent.targetContainers;\n  if (\n    targetContainer !== null &&\n    targetContainers.indexOf(targetContainer) === -1\n  ) {\n    targetContainers.push(targetContainer);\n  }\n  return existingQueuedEvent;\n}\n\nexport function queueIfContinuousEvent(\n  blockedOn: null | Container | SuspenseInstance,\n  domEventName: DOMEventName,\n  eventSystemFlags: EventSystemFlags,\n  targetContainer: EventTarget,\n  nativeEvent: AnyNativeEvent,\n): boolean {\n  // These set relatedTarget to null because the replayed event will be treated as if we\n  // moved from outside the window (no target) onto the target once it hydrates.\n  // Instead of mutating we could clone the event.\n  switch (domEventName) {\n    case 'focusin': {\n      const focusEvent = ((nativeEvent: any): FocusEvent);\n      queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(\n        queuedFocus,\n        blockedOn,\n        domEventName,\n        eventSystemFlags,\n        targetContainer,\n        focusEvent,\n      );\n      return true;\n    }\n    case 'dragenter': {\n      const dragEvent = ((nativeEvent: any): DragEvent);\n      queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(\n        queuedDrag,\n        blockedOn,\n        domEventName,\n        eventSystemFlags,\n        targetContainer,\n        dragEvent,\n      );\n      return true;\n    }\n    case 'mouseover': {\n      const mouseEvent = ((nativeEvent: any): MouseEvent);\n      queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(\n        queuedMouse,\n        blockedOn,\n        domEventName,\n        eventSystemFlags,\n        targetContainer,\n        mouseEvent,\n      );\n      return true;\n    }\n    case 'pointerover': {\n      const pointerEvent = ((nativeEvent: any): PointerEvent);\n      const pointerId = pointerEvent.pointerId;\n      queuedPointers.set(\n        pointerId,\n        accumulateOrCreateContinuousQueuedReplayableEvent(\n          queuedPointers.get(pointerId) || null,\n          blockedOn,\n          domEventName,\n          eventSystemFlags,\n          targetContainer,\n          pointerEvent,\n        ),\n      );\n      return true;\n    }\n    case 'gotpointercapture': {\n      const pointerEvent = ((nativeEvent: any): PointerEvent);\n      const pointerId = pointerEvent.pointerId;\n      queuedPointerCaptures.set(\n        pointerId,\n        accumulateOrCreateContinuousQueuedReplayableEvent(\n          queuedPointerCaptures.get(pointerId) || null,\n          blockedOn,\n          domEventName,\n          eventSystemFlags,\n          targetContainer,\n          pointerEvent,\n        ),\n      );\n      return true;\n    }\n  }\n  return false;\n}\n\n// Check if this target is unblocked. Returns true if it's unblocked.\nfunction attemptExplicitHydrationTarget(\n  queuedTarget: QueuedHydrationTarget,\n): void {\n  // TODO: This function shares a lot of logic with attemptToDispatchEvent.\n  // Try to unify them. It's a bit tricky since it would require two return\n  // values.\n  const targetInst = getClosestInstanceFromNode(queuedTarget.target);\n  if (targetInst !== null) {\n    const nearestMounted = getNearestMountedFiber(targetInst);\n    if (nearestMounted !== null) {\n      const tag = nearestMounted.tag;\n      if (tag === SuspenseComponent) {\n        const instance = getSuspenseInstanceFromFiber(nearestMounted);\n        if (instance !== null) {\n          // We're blocked on hydrating this boundary.\n          // Increase its priority.\n          queuedTarget.blockedOn = instance;\n          attemptHydrationAtPriority(queuedTarget.priority, () => {\n            attemptHydrationAtCurrentPriority(nearestMounted);\n          });\n\n          return;\n        }\n      } else if (tag === HostRoot) {\n        const root: FiberRoot = nearestMounted.stateNode;\n        if (root.isDehydrated) {\n          queuedTarget.blockedOn = getContainerFromFiber(nearestMounted);\n          // We don't currently have a way to increase the priority of\n          // a root other than sync.\n          return;\n        }\n      }\n    }\n  }\n  queuedTarget.blockedOn = null;\n}\n\nexport function queueExplicitHydrationTarget(target: Node): void {\n  if (enableSelectiveHydration) {\n    // TODO: This will read the priority if it's dispatched by the React\n    // event system but not native events. Should read window.event.type, like\n    // we do for updates (getCurrentEventPriority).\n    const updatePriority = getCurrentUpdatePriority();\n    const queuedTarget: QueuedHydrationTarget = {\n      blockedOn: null,\n      target: target,\n      priority: updatePriority,\n    };\n    let i = 0;\n    for (; i < queuedExplicitHydrationTargets.length; i++) {\n      // Stop once we hit the first target with lower priority than\n      if (\n        !isHigherEventPriority(\n          updatePriority,\n          queuedExplicitHydrationTargets[i].priority,\n        )\n      ) {\n        break;\n      }\n    }\n    queuedExplicitHydrationTargets.splice(i, 0, queuedTarget);\n    if (i === 0) {\n      attemptExplicitHydrationTarget(queuedTarget);\n    }\n  }\n}\n\nfunction attemptReplayContinuousQueuedEvent(\n  queuedEvent: QueuedReplayableEvent,\n): boolean {\n  if (queuedEvent.blockedOn !== null) {\n    return false;\n  }\n  const targetContainers = queuedEvent.targetContainers;\n  while (targetContainers.length > 0) {\n    const targetContainer = targetContainers[0];\n    const nextBlockedOn = attemptToDispatchEvent(\n      queuedEvent.domEventName,\n      queuedEvent.eventSystemFlags,\n      targetContainer,\n      queuedEvent.nativeEvent,\n    );\n    if (nextBlockedOn !== null) {\n      // We're still blocked. Try again later.\n      const fiber = getInstanceFromNode(nextBlockedOn);\n      if (fiber !== null) {\n        attemptContinuousHydration(fiber);\n      }\n      queuedEvent.blockedOn = nextBlockedOn;\n      return false;\n    }\n    // This target container was successfully dispatched. Try the next.\n    targetContainers.shift();\n  }\n  return true;\n}\n\nfunction attemptReplayContinuousQueuedEventInMap(\n  queuedEvent: QueuedReplayableEvent,\n  key: number,\n  map: Map<number, QueuedReplayableEvent>,\n): void {\n  if (attemptReplayContinuousQueuedEvent(queuedEvent)) {\n    map.delete(key);\n  }\n}\n\nfunction replayUnblockedEvents() {\n  hasScheduledReplayAttempt = false;\n  if (!enableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay) {\n    // First replay discrete events.\n    while (queuedDiscreteEvents.length > 0) {\n      const nextDiscreteEvent = queuedDiscreteEvents[0];\n      if (nextDiscreteEvent.blockedOn !== null) {\n        // We're still blocked.\n        // Increase the priority of this boundary to unblock\n        // the next discrete event.\n        const fiber = getInstanceFromNode(nextDiscreteEvent.blockedOn);\n        if (fiber !== null) {\n          attemptDiscreteHydration(fiber);\n        }\n        break;\n      }\n      const targetContainers = nextDiscreteEvent.targetContainers;\n      while (targetContainers.length > 0) {\n        const targetContainer = targetContainers[0];\n        const nextBlockedOn = attemptToDispatchEvent(\n          nextDiscreteEvent.domEventName,\n          nextDiscreteEvent.eventSystemFlags,\n          targetContainer,\n          nextDiscreteEvent.nativeEvent,\n        );\n        if (nextBlockedOn !== null) {\n          // We're still blocked. Try again later.\n          nextDiscreteEvent.blockedOn = nextBlockedOn;\n          break;\n        }\n        // This target container was successfully dispatched. Try the next.\n        targetContainers.shift();\n      }\n      if (nextDiscreteEvent.blockedOn === null) {\n        // We've successfully replayed the first event. Let's try the next one.\n        queuedDiscreteEvents.shift();\n      }\n    }\n  }\n  // Next replay any continuous events.\n  if (queuedFocus !== null && attemptReplayContinuousQueuedEvent(queuedFocus)) {\n    queuedFocus = null;\n  }\n  if (queuedDrag !== null && attemptReplayContinuousQueuedEvent(queuedDrag)) {\n    queuedDrag = null;\n  }\n  if (queuedMouse !== null && attemptReplayContinuousQueuedEvent(queuedMouse)) {\n    queuedMouse = null;\n  }\n  queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);\n  queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);\n}\n\nfunction scheduleCallbackIfUnblocked(\n  queuedEvent: QueuedReplayableEvent,\n  unblocked: Container | SuspenseInstance,\n) {\n  if (queuedEvent.blockedOn === unblocked) {\n    queuedEvent.blockedOn = null;\n    if (!hasScheduledReplayAttempt) {\n      hasScheduledReplayAttempt = true;\n      // Schedule a callback to attempt replaying as many events as are\n      // now unblocked. This first might not actually be unblocked yet.\n      // We could check it early to avoid scheduling an unnecessary callback.\n      scheduleCallback(NormalPriority, replayUnblockedEvents);\n    }\n  }\n}\n\nexport function retryIfBlockedOn(\n  unblocked: Container | SuspenseInstance,\n): void {\n  // Mark anything that was blocked on this as no longer blocked\n  // and eligible for a replay.\n  if (queuedDiscreteEvents.length > 0) {\n    scheduleCallbackIfUnblocked(queuedDiscreteEvents[0], unblocked);\n    // This is a exponential search for each boundary that commits. I think it's\n    // worth it because we expect very few discrete events to queue up and once\n    // we are actually fully unblocked it will be fast to replay them.\n    for (let i = 1; i < queuedDiscreteEvents.length; i++) {\n      const queuedEvent = queuedDiscreteEvents[i];\n      if (queuedEvent.blockedOn === unblocked) {\n        queuedEvent.blockedOn = null;\n      }\n    }\n  }\n\n  if (queuedFocus !== null) {\n    scheduleCallbackIfUnblocked(queuedFocus, unblocked);\n  }\n  if (queuedDrag !== null) {\n    scheduleCallbackIfUnblocked(queuedDrag, unblocked);\n  }\n  if (queuedMouse !== null) {\n    scheduleCallbackIfUnblocked(queuedMouse, unblocked);\n  }\n  const unblock = queuedEvent =>\n    scheduleCallbackIfUnblocked(queuedEvent, unblocked);\n  queuedPointers.forEach(unblock);\n  queuedPointerCaptures.forEach(unblock);\n\n  for (let i = 0; i < queuedExplicitHydrationTargets.length; i++) {\n    const queuedTarget = queuedExplicitHydrationTargets[i];\n    if (queuedTarget.blockedOn === unblocked) {\n      queuedTarget.blockedOn = null;\n    }\n  }\n\n  while (queuedExplicitHydrationTargets.length > 0) {\n    const nextExplicitTarget = queuedExplicitHydrationTargets[0];\n    if (nextExplicitTarget.blockedOn !== null) {\n      // We're still blocked.\n      break;\n    } else {\n      attemptExplicitHydrationTarget(nextExplicitTarget);\n      if (nextExplicitTarget.blockedOn === null) {\n        // We're unblocked.\n        queuedExplicitHydrationTargets.shift();\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}