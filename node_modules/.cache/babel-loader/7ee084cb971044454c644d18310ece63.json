{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$(),\n    _s4 = $RefreshSig$(),\n    _s5 = $RefreshSig$(),\n    _s6 = $RefreshSig$(),\n    _s7 = $RefreshSig$(),\n    _s8 = $RefreshSig$(),\n    _s9 = $RefreshSig$(),\n    _s10 = $RefreshSig$(),\n    _s11 = $RefreshSig$(),\n    _s12 = $RefreshSig$(),\n    _s13 = $RefreshSig$(),\n    _s14 = $RefreshSig$(),\n    _s15 = $RefreshSig$(),\n    _s16 = $RefreshSig$(),\n    _s17 = $RefreshSig$();\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport ReactCurrentDispatcher from './ReactCurrentDispatcher';\n\nfunction resolveDispatcher() {\n  const dispatcher = ReactCurrentDispatcher.current;\n\n  if (__DEV__) {\n    if (dispatcher === null) {\n      console.error('Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' + ' one of the following reasons:\\n' + '1. You might have mismatching versions of React and the renderer (such as React DOM)\\n' + '2. You might be breaking the Rules of Hooks\\n' + '3. You might have more than one copy of React in the same app\\n' + 'See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.');\n    }\n  } // Will result in a null access error if accessed outside render phase. We\n  // intentionally don't throw our own error because this is in a hot path.\n  // Also helps ensure this is inlined.\n\n\n  return dispatcher;\n}\n\nexport function getCacheSignal() {\n  const dispatcher = resolveDispatcher(); // $FlowFixMe This is unstable, thus optional\n\n  return dispatcher.getCacheSignal();\n}\nexport function getCacheForType(resourceType) {\n  const dispatcher = resolveDispatcher(); // $FlowFixMe This is unstable, thus optional\n\n  return dispatcher.getCacheForType(resourceType);\n}\nexport function useContext(Context) {\n  _s();\n\n  const dispatcher = resolveDispatcher();\n\n  if (__DEV__) {\n    // TODO: add a more generic warning for invalid values.\n    if (Context._context !== undefined) {\n      const realContext = Context._context; // Don't deduplicate because this legitimately causes bugs\n      // and nobody should be using this in existing code.\n\n      if (realContext.Consumer === Context) {\n        console.error('Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be ' + 'removed in a future major release. Did you mean to call useContext(Context) instead?');\n      } else if (realContext.Provider === Context) {\n        console.error('Calling useContext(Context.Provider) is not supported. ' + 'Did you mean to call useContext(Context) instead?');\n      }\n    }\n  }\n\n  return dispatcher.useContext(Context);\n}\n\n_s(useContext, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\n\nexport function useState(initialState) {\n  _s2();\n\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useState(initialState);\n}\n\n_s2(useState, \"ivzlgorP4GeLgLCP2g2oo8lrHBQ=\");\n\nexport function useReducer(reducer, initialArg, init) {\n  _s3();\n\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useReducer(reducer, initialArg, init);\n}\n\n_s3(useReducer, \"UB8b1SLMookzcOV5tTvlJ/kwReQ=\");\n\nexport function useRef(initialValue) {\n  _s4();\n\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useRef(initialValue);\n}\n\n_s4(useRef, \"J9pzIsEOVEZ74gjFtMkCj+5Po7s=\");\n\nexport function useEffect(create, deps) {\n  _s5();\n\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useEffect(create, deps);\n}\n\n_s5(useEffect, \"OD7bBpZva5O2jO+Puf00hKivP7c=\");\n\nexport function useInsertionEffect(create, deps) {\n  _s6();\n\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useInsertionEffect(create, deps);\n}\n\n_s6(useInsertionEffect, \"KP04oOqX3NbUYDsTwGwlE3GUn5Y=\", true);\n\nexport function useLayoutEffect(create, deps) {\n  _s7();\n\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useLayoutEffect(create, deps);\n}\n\n_s7(useLayoutEffect, \"n7/vCynhJvM+pLkyL2DMQUF0odM=\");\n\nexport function useCallback(callback, deps) {\n  _s8();\n\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useCallback(callback, deps);\n}\n\n_s8(useCallback, \"epj4qY15NHsef74wNqHIp5fdZmg=\");\n\nexport function useMemo(create, deps) {\n  _s9();\n\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useMemo(create, deps);\n}\n\n_s9(useMemo, \"nwk+m61qLgjDVUp4IGV/072DDN4=\");\n\nexport function useImperativeHandle(ref, create, deps) {\n  _s10();\n\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useImperativeHandle(ref, create, deps);\n}\n\n_s10(useImperativeHandle, \"PYzlZ2AGFM0KxtNOGoZVRb5EOEw=\", true);\n\nexport function useDebugValue(value, formatterFn) {\n  _s11();\n\n  if (__DEV__) {\n    const dispatcher = resolveDispatcher();\n    return dispatcher.useDebugValue(value, formatterFn);\n  }\n}\n\n_s11(useDebugValue, \"GhvPrRYADeIBc0kER6M56ZZ9cIU=\");\n\nexport const emptyObject = {};\nexport function useTransition() {\n  _s12();\n\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useTransition();\n}\n\n_s12(useTransition, \"28mb38mkSsMdKhDodgMEJ1axbVA=\", true);\n\nexport function useDeferredValue(value) {\n  _s13();\n\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useDeferredValue(value);\n}\n\n_s13(useDeferredValue, \"4U68yWucejOUMGrZQU+1Y6yEx1c=\", true);\n\nexport function useId() {\n  _s14();\n\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useId();\n}\n\n_s14(useId, \"xfMyHNFebGjSN1/YPqrD8z5EdLc=\", true);\n\nexport function useMutableSource(source, getSnapshot, subscribe) {\n  _s15();\n\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useMutableSource(source, getSnapshot, subscribe);\n}\n\n_s15(useMutableSource, \"G46HpqTIWGoryMbF+wh82aRle1o=\", true);\n\nexport function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n  _s16();\n\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n}\n\n_s16(useSyncExternalStore, \"FpwL93IKMLJZuQQXefVtWynbBPQ=\", true);\n\nexport function useCacheRefresh() {\n  _s17();\n\n  const dispatcher = resolveDispatcher(); // $FlowFixMe This is unstable, thus optional\n\n  return dispatcher.useCacheRefresh();\n}\n\n_s17(useCacheRefresh, \"dUE4gryUZYPtpUaNzxoKmuGYZlA=\", true);","map":{"version":3,"sources":["/Users/zhangshuo/git/react-source-test/src/react/packages/react/src/ReactHooks.js"],"names":["ReactCurrentDispatcher","resolveDispatcher","dispatcher","current","__DEV__","console","error","getCacheSignal","getCacheForType","resourceType","useContext","Context","_context","undefined","realContext","Consumer","Provider","useState","initialState","useReducer","reducer","initialArg","init","useRef","initialValue","useEffect","create","deps","useInsertionEffect","useLayoutEffect","useCallback","callback","useMemo","useImperativeHandle","ref","useDebugValue","value","formatterFn","emptyObject","useTransition","useDeferredValue","useId","useMutableSource","source","getSnapshot","subscribe","useSyncExternalStore","getServerSnapshot","useCacheRefresh"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Dispatcher} from 'react-reconciler/src/ReactInternalTypes';\nimport type {\n  MutableSource,\n  MutableSourceGetSnapshotFn,\n  MutableSourceSubscribeFn,\n  ReactContext,\n} from 'shared/ReactTypes';\n\nimport ReactCurrentDispatcher from './ReactCurrentDispatcher';\n\ntype BasicStateAction<S> = (S => S) | S;\ntype Dispatch<A> = A => void;\n\nfunction resolveDispatcher() {\n  const dispatcher = ReactCurrentDispatcher.current;\n  if (__DEV__) {\n    if (dispatcher === null) {\n      console.error(\n        'Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' +\n          ' one of the following reasons:\\n' +\n          '1. You might have mismatching versions of React and the renderer (such as React DOM)\\n' +\n          '2. You might be breaking the Rules of Hooks\\n' +\n          '3. You might have more than one copy of React in the same app\\n' +\n          'See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.',\n      );\n    }\n  }\n  // Will result in a null access error if accessed outside render phase. We\n  // intentionally don't throw our own error because this is in a hot path.\n  // Also helps ensure this is inlined.\n  return ((dispatcher: any): Dispatcher);\n}\n\nexport function getCacheSignal(): AbortSignal {\n  const dispatcher = resolveDispatcher();\n  // $FlowFixMe This is unstable, thus optional\n  return dispatcher.getCacheSignal();\n}\n\nexport function getCacheForType<T>(resourceType: () => T): T {\n  const dispatcher = resolveDispatcher();\n  // $FlowFixMe This is unstable, thus optional\n  return dispatcher.getCacheForType(resourceType);\n}\n\nexport function useContext<T>(Context: ReactContext<T>): T {\n  const dispatcher = resolveDispatcher();\n  if (__DEV__) {\n    // TODO: add a more generic warning for invalid values.\n    if ((Context: any)._context !== undefined) {\n      const realContext = (Context: any)._context;\n      // Don't deduplicate because this legitimately causes bugs\n      // and nobody should be using this in existing code.\n      if (realContext.Consumer === Context) {\n        console.error(\n          'Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be ' +\n            'removed in a future major release. Did you mean to call useContext(Context) instead?',\n        );\n      } else if (realContext.Provider === Context) {\n        console.error(\n          'Calling useContext(Context.Provider) is not supported. ' +\n            'Did you mean to call useContext(Context) instead?',\n        );\n      }\n    }\n  }\n  return dispatcher.useContext(Context);\n}\n\nexport function useState<S>(\n  initialState: (() => S) | S,\n): [S, Dispatch<BasicStateAction<S>>] {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useState(initialState);\n}\n\nexport function useReducer<S, I, A>(\n  reducer: (S, A) => S,\n  initialArg: I,\n  init?: I => S,\n): [S, Dispatch<A>] {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useReducer(reducer, initialArg, init);\n}\n\nexport function useRef<T>(initialValue: T): {|current: T|} {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useRef(initialValue);\n}\n\nexport function useEffect(\n  create: () => (() => void) | void,\n  deps: Array<mixed> | void | null,\n): void {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useEffect(create, deps);\n}\n\nexport function useInsertionEffect(\n  create: () => (() => void) | void,\n  deps: Array<mixed> | void | null,\n): void {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useInsertionEffect(create, deps);\n}\n\nexport function useLayoutEffect(\n  create: () => (() => void) | void,\n  deps: Array<mixed> | void | null,\n): void {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useLayoutEffect(create, deps);\n}\n\nexport function useCallback<T>(\n  callback: T,\n  deps: Array<mixed> | void | null,\n): T {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useCallback(callback, deps);\n}\n\nexport function useMemo<T>(\n  create: () => T,\n  deps: Array<mixed> | void | null,\n): T {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useMemo(create, deps);\n}\n\nexport function useImperativeHandle<T>(\n  ref: {|current: T | null|} | ((inst: T | null) => mixed) | null | void,\n  create: () => T,\n  deps: Array<mixed> | void | null,\n): void {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useImperativeHandle(ref, create, deps);\n}\n\nexport function useDebugValue<T>(\n  value: T,\n  formatterFn: ?(value: T) => mixed,\n): void {\n  if (__DEV__) {\n    const dispatcher = resolveDispatcher();\n    return dispatcher.useDebugValue(value, formatterFn);\n  }\n}\n\nexport const emptyObject = {};\n\nexport function useTransition(): [boolean, (() => void) => void] {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useTransition();\n}\n\nexport function useDeferredValue<T>(value: T): T {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useDeferredValue(value);\n}\n\nexport function useId(): string {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useId();\n}\n\nexport function useMutableSource<Source, Snapshot>(\n  source: MutableSource<Source>,\n  getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,\n  subscribe: MutableSourceSubscribeFn<Source, Snapshot>,\n): Snapshot {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useMutableSource(source, getSnapshot, subscribe);\n}\n\nexport function useSyncExternalStore<T>(\n  subscribe: (() => void) => () => void,\n  getSnapshot: () => T,\n  getServerSnapshot?: () => T,\n): T {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useSyncExternalStore(\n    subscribe,\n    getSnapshot,\n    getServerSnapshot,\n  );\n}\n\nexport function useCacheRefresh(): <T>(?() => T, ?T) => void {\n  const dispatcher = resolveDispatcher();\n  // $FlowFixMe This is unstable, thus optional\n  return dispatcher.useCacheRefresh();\n}\n"]},"metadata":{},"sourceType":"module"}