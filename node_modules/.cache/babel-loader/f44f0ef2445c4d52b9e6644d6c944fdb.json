{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { registerTwoPhaseEvent } from '../EventRegistry';\nimport { SyntheticEvent } from '../SyntheticEvent';\nimport isTextInputElement from '../isTextInputElement';\nimport { canUseDOM } from 'shared/ExecutionEnvironment';\nimport getEventTarget from '../getEventTarget';\nimport isEventSupported from '../isEventSupported';\nimport { getNodeFromInstance } from '../../client/ReactDOMComponentTree';\nimport { updateValueIfChanged } from '../../client/inputValueTracking';\nimport { setDefaultValue } from '../../client/ReactDOMInput';\nimport { enqueueStateRestore } from '../ReactDOMControlledComponent';\nimport { disableInputAttributeSyncing } from 'shared/ReactFeatureFlags';\nimport { batchedUpdates } from '../ReactDOMUpdateBatching';\nimport { processDispatchQueue, accumulateTwoPhaseListeners } from '../DOMPluginEventSystem';\n\nfunction registerEvents() {\n  registerTwoPhaseEvent('onChange', ['change', 'click', 'focusin', 'focusout', 'input', 'keydown', 'keyup', 'selectionchange']);\n}\n\nfunction createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {\n  // Flag this event loop as needing state restore.\n  enqueueStateRestore(target);\n  const listeners = accumulateTwoPhaseListeners(inst, 'onChange');\n\n  if (listeners.length > 0) {\n    const event = new SyntheticEvent('onChange', 'change', null, nativeEvent, target);\n    dispatchQueue.push({\n      event,\n      listeners\n    });\n  }\n}\n/**\n * For IE shims\n */\n\n\nlet activeElement = null;\nlet activeElementInst = null;\n/**\n * SECTION: handle `change` event\n */\n\nfunction shouldUseChangeEvent(elem) {\n  const nodeName = elem.nodeName && elem.nodeName.toLowerCase();\n  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';\n}\n\nfunction manualDispatchChangeEvent(nativeEvent) {\n  const dispatchQueue = [];\n  createAndAccumulateChangeEvent(dispatchQueue, activeElementInst, nativeEvent, getEventTarget(nativeEvent)); // If change and propertychange bubbled, we'd just bind to it like all the\n  // other events and have it go through ReactBrowserEventEmitter. Since it\n  // doesn't, we manually listen for the events and so we have to enqueue and\n  // process the abstract event manually.\n  //\n  // Batching is necessary here in order to ensure that all event handlers run\n  // before the next rerender (including event handlers attached to ancestor\n  // elements instead of directly on the input). Without this, controlled\n  // components don't work properly in conjunction with event bubbling because\n  // the component is rerendered and the value reverted before all the event\n  // handlers can run. See https://github.com/facebook/react/issues/708.\n\n  batchedUpdates(runEventInBatch, dispatchQueue);\n}\n\nfunction runEventInBatch(dispatchQueue) {\n  processDispatchQueue(dispatchQueue, 0);\n}\n\nfunction getInstIfValueChanged(targetInst) {\n  const targetNode = getNodeFromInstance(targetInst);\n\n  if (updateValueIfChanged(targetNode)) {\n    return targetInst;\n  }\n}\n\nfunction getTargetInstForChangeEvent(domEventName, targetInst) {\n  if (domEventName === 'change') {\n    return targetInst;\n  }\n}\n/**\n * SECTION: handle `input` event\n */\n\n\nlet isInputEventSupported = false;\n\nif (canUseDOM) {\n  // IE9 claims to support the input event but fails to trigger it when\n  // deleting text, so we ignore its input events.\n  isInputEventSupported = isEventSupported('input') && (!document.documentMode || document.documentMode > 9);\n}\n/**\n * (For IE <=9) Starts tracking propertychange events on the passed-in element\n * and override the value property so that we can distinguish user events from\n * value changes in JS.\n */\n\n\nfunction startWatchingForValueChange(target, targetInst) {\n  activeElement = target;\n  activeElementInst = targetInst;\n  activeElement.attachEvent('onpropertychange', handlePropertyChange);\n}\n/**\n * (For IE <=9) Removes the event listeners from the currently-tracked element,\n * if any exists.\n */\n\n\nfunction stopWatchingForValueChange() {\n  if (!activeElement) {\n    return;\n  }\n\n  activeElement.detachEvent('onpropertychange', handlePropertyChange);\n  activeElement = null;\n  activeElementInst = null;\n}\n/**\n * (For IE <=9) Handles a propertychange event, sending a `change` event if\n * the value of the active element has changed.\n */\n\n\nfunction handlePropertyChange(nativeEvent) {\n  if (nativeEvent.propertyName !== 'value') {\n    return;\n  }\n\n  if (getInstIfValueChanged(activeElementInst)) {\n    manualDispatchChangeEvent(nativeEvent);\n  }\n}\n\nfunction handleEventsForInputEventPolyfill(domEventName, target, targetInst) {\n  if (domEventName === 'focusin') {\n    // In IE9, propertychange fires for most input events but is buggy and\n    // doesn't fire when text is deleted, but conveniently, selectionchange\n    // appears to fire in all of the remaining cases so we catch those and\n    // forward the event if the value has changed\n    // In either case, we don't want to call the event handler if the value\n    // is changed from JS so we redefine a setter for `.value` that updates\n    // our activeElementValue variable, allowing us to ignore those changes\n    //\n    // stopWatching() should be a noop here but we call it just in case we\n    // missed a blur event somehow.\n    stopWatchingForValueChange();\n    startWatchingForValueChange(target, targetInst);\n  } else if (domEventName === 'focusout') {\n    stopWatchingForValueChange();\n  }\n} // For IE8 and IE9.\n\n\nfunction getTargetInstForInputEventPolyfill(domEventName, targetInst) {\n  if (domEventName === 'selectionchange' || domEventName === 'keyup' || domEventName === 'keydown') {\n    // On the selectionchange event, the target is just document which isn't\n    // helpful for us so just check activeElement instead.\n    //\n    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire\n    // propertychange on the first input event after setting `value` from a\n    // script and fires only keydown, keypress, keyup. Catching keyup usually\n    // gets it and catching keydown lets us fire an event for the first\n    // keystroke if user does a key repeat (it'll be a little delayed: right\n    // before the second keystroke). Other input methods (e.g., paste) seem to\n    // fire selectionchange normally.\n    return getInstIfValueChanged(activeElementInst);\n  }\n}\n/**\n * SECTION: handle `click` event\n */\n\n\nfunction shouldUseClickEvent(elem) {\n  // Use the `click` event to detect changes to checkbox and radio inputs.\n  // This approach works across all browsers, whereas `change` does not fire\n  // until `blur` in IE8.\n  const nodeName = elem.nodeName;\n  return nodeName && nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');\n}\n\nfunction getTargetInstForClickEvent(domEventName, targetInst) {\n  if (domEventName === 'click') {\n    return getInstIfValueChanged(targetInst);\n  }\n}\n\nfunction getTargetInstForInputOrChangeEvent(domEventName, targetInst) {\n  if (domEventName === 'input' || domEventName === 'change') {\n    return getInstIfValueChanged(targetInst);\n  }\n}\n\nfunction handleControlledInputBlur(node) {\n  const state = node._wrapperState;\n\n  if (!state || !state.controlled || node.type !== 'number') {\n    return;\n  }\n\n  if (!disableInputAttributeSyncing) {\n    // If controlled, assign the value attribute to the current value on blur\n    setDefaultValue(node, 'number', node.value);\n  }\n}\n/**\n * This plugin creates an `onChange` event that normalizes change events\n * across form elements. This event fires at a time when it's possible to\n * change the element's value without seeing a flicker.\n *\n * Supported elements are:\n * - input (see `isTextInputElement`)\n * - textarea\n * - select\n */\n\n\nfunction extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {\n  const targetNode = targetInst ? getNodeFromInstance(targetInst) : window;\n  let getTargetInstFunc, handleEventFunc;\n\n  if (shouldUseChangeEvent(targetNode)) {\n    getTargetInstFunc = getTargetInstForChangeEvent;\n  } else if (isTextInputElement(targetNode)) {\n    if (isInputEventSupported) {\n      getTargetInstFunc = getTargetInstForInputOrChangeEvent;\n    } else {\n      getTargetInstFunc = getTargetInstForInputEventPolyfill;\n      handleEventFunc = handleEventsForInputEventPolyfill;\n    }\n  } else if (shouldUseClickEvent(targetNode)) {\n    getTargetInstFunc = getTargetInstForClickEvent;\n  }\n\n  if (getTargetInstFunc) {\n    const inst = getTargetInstFunc(domEventName, targetInst);\n\n    if (inst) {\n      createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, nativeEventTarget);\n      return;\n    }\n  }\n\n  if (handleEventFunc) {\n    handleEventFunc(domEventName, targetNode, targetInst);\n  } // When blurring, set the value attribute for number inputs\n\n\n  if (domEventName === 'focusout') {\n    handleControlledInputBlur(targetNode);\n  }\n}\n\nexport { registerEvents, extractEvents };","map":{"version":3,"sources":["/Users/zhangshuo/git/my-app/src/react/packages/react-dom/src/events/plugins/ChangeEventPlugin.js"],"names":["registerTwoPhaseEvent","SyntheticEvent","isTextInputElement","canUseDOM","getEventTarget","isEventSupported","getNodeFromInstance","updateValueIfChanged","setDefaultValue","enqueueStateRestore","disableInputAttributeSyncing","batchedUpdates","processDispatchQueue","accumulateTwoPhaseListeners","registerEvents","createAndAccumulateChangeEvent","dispatchQueue","inst","nativeEvent","target","listeners","length","event","push","activeElement","activeElementInst","shouldUseChangeEvent","elem","nodeName","toLowerCase","type","manualDispatchChangeEvent","runEventInBatch","getInstIfValueChanged","targetInst","targetNode","getTargetInstForChangeEvent","domEventName","isInputEventSupported","document","documentMode","startWatchingForValueChange","attachEvent","handlePropertyChange","stopWatchingForValueChange","detachEvent","propertyName","handleEventsForInputEventPolyfill","getTargetInstForInputEventPolyfill","shouldUseClickEvent","getTargetInstForClickEvent","getTargetInstForInputOrChangeEvent","handleControlledInputBlur","node","state","_wrapperState","controlled","value","extractEvents","nativeEventTarget","eventSystemFlags","targetContainer","window","getTargetInstFunc","handleEventFunc"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\nimport type {AnyNativeEvent} from '../PluginModuleType';\nimport type {DOMEventName} from '../DOMEventNames';\nimport type {DispatchQueue} from '../DOMPluginEventSystem';\nimport type {EventSystemFlags} from '../EventSystemFlags';\n\nimport {registerTwoPhaseEvent} from '../EventRegistry';\nimport {SyntheticEvent} from '../SyntheticEvent';\nimport isTextInputElement from '../isTextInputElement';\nimport {canUseDOM} from 'shared/ExecutionEnvironment';\n\nimport getEventTarget from '../getEventTarget';\nimport isEventSupported from '../isEventSupported';\nimport {getNodeFromInstance} from '../../client/ReactDOMComponentTree';\nimport {updateValueIfChanged} from '../../client/inputValueTracking';\nimport {setDefaultValue} from '../../client/ReactDOMInput';\nimport {enqueueStateRestore} from '../ReactDOMControlledComponent';\n\nimport {disableInputAttributeSyncing} from 'shared/ReactFeatureFlags';\nimport {batchedUpdates} from '../ReactDOMUpdateBatching';\nimport {\n  processDispatchQueue,\n  accumulateTwoPhaseListeners,\n} from '../DOMPluginEventSystem';\n\nfunction registerEvents() {\n  registerTwoPhaseEvent('onChange', [\n    'change',\n    'click',\n    'focusin',\n    'focusout',\n    'input',\n    'keydown',\n    'keyup',\n    'selectionchange',\n  ]);\n}\n\nfunction createAndAccumulateChangeEvent(\n  dispatchQueue,\n  inst,\n  nativeEvent,\n  target,\n) {\n  // Flag this event loop as needing state restore.\n  enqueueStateRestore(((target: any): Node));\n  const listeners = accumulateTwoPhaseListeners(inst, 'onChange');\n  if (listeners.length > 0) {\n    const event = new SyntheticEvent(\n      'onChange',\n      'change',\n      null,\n      nativeEvent,\n      target,\n    );\n    dispatchQueue.push({event, listeners});\n  }\n}\n/**\n * For IE shims\n */\nlet activeElement = null;\nlet activeElementInst = null;\n\n/**\n * SECTION: handle `change` event\n */\nfunction shouldUseChangeEvent(elem) {\n  const nodeName = elem.nodeName && elem.nodeName.toLowerCase();\n  return (\n    nodeName === 'select' ||\n    (nodeName === 'input' && (elem: any).type === 'file')\n  );\n}\n\nfunction manualDispatchChangeEvent(nativeEvent) {\n  const dispatchQueue = [];\n  createAndAccumulateChangeEvent(\n    dispatchQueue,\n    activeElementInst,\n    nativeEvent,\n    getEventTarget(nativeEvent),\n  );\n\n  // If change and propertychange bubbled, we'd just bind to it like all the\n  // other events and have it go through ReactBrowserEventEmitter. Since it\n  // doesn't, we manually listen for the events and so we have to enqueue and\n  // process the abstract event manually.\n  //\n  // Batching is necessary here in order to ensure that all event handlers run\n  // before the next rerender (including event handlers attached to ancestor\n  // elements instead of directly on the input). Without this, controlled\n  // components don't work properly in conjunction with event bubbling because\n  // the component is rerendered and the value reverted before all the event\n  // handlers can run. See https://github.com/facebook/react/issues/708.\n  batchedUpdates(runEventInBatch, dispatchQueue);\n}\n\nfunction runEventInBatch(dispatchQueue) {\n  processDispatchQueue(dispatchQueue, 0);\n}\n\nfunction getInstIfValueChanged(targetInst: Object) {\n  const targetNode = getNodeFromInstance(targetInst);\n  if (updateValueIfChanged(((targetNode: any): HTMLInputElement))) {\n    return targetInst;\n  }\n}\n\nfunction getTargetInstForChangeEvent(domEventName: DOMEventName, targetInst) {\n  if (domEventName === 'change') {\n    return targetInst;\n  }\n}\n\n/**\n * SECTION: handle `input` event\n */\nlet isInputEventSupported = false;\nif (canUseDOM) {\n  // IE9 claims to support the input event but fails to trigger it when\n  // deleting text, so we ignore its input events.\n  isInputEventSupported =\n    isEventSupported('input') &&\n    (!document.documentMode || document.documentMode > 9);\n}\n\n/**\n * (For IE <=9) Starts tracking propertychange events on the passed-in element\n * and override the value property so that we can distinguish user events from\n * value changes in JS.\n */\nfunction startWatchingForValueChange(target, targetInst) {\n  activeElement = target;\n  activeElementInst = targetInst;\n  (activeElement: any).attachEvent('onpropertychange', handlePropertyChange);\n}\n\n/**\n * (For IE <=9) Removes the event listeners from the currently-tracked element,\n * if any exists.\n */\nfunction stopWatchingForValueChange() {\n  if (!activeElement) {\n    return;\n  }\n  (activeElement: any).detachEvent('onpropertychange', handlePropertyChange);\n  activeElement = null;\n  activeElementInst = null;\n}\n\n/**\n * (For IE <=9) Handles a propertychange event, sending a `change` event if\n * the value of the active element has changed.\n */\nfunction handlePropertyChange(nativeEvent) {\n  if (nativeEvent.propertyName !== 'value') {\n    return;\n  }\n  if (getInstIfValueChanged(activeElementInst)) {\n    manualDispatchChangeEvent(nativeEvent);\n  }\n}\n\nfunction handleEventsForInputEventPolyfill(\n  domEventName: DOMEventName,\n  target,\n  targetInst,\n) {\n  if (domEventName === 'focusin') {\n    // In IE9, propertychange fires for most input events but is buggy and\n    // doesn't fire when text is deleted, but conveniently, selectionchange\n    // appears to fire in all of the remaining cases so we catch those and\n    // forward the event if the value has changed\n    // In either case, we don't want to call the event handler if the value\n    // is changed from JS so we redefine a setter for `.value` that updates\n    // our activeElementValue variable, allowing us to ignore those changes\n    //\n    // stopWatching() should be a noop here but we call it just in case we\n    // missed a blur event somehow.\n    stopWatchingForValueChange();\n    startWatchingForValueChange(target, targetInst);\n  } else if (domEventName === 'focusout') {\n    stopWatchingForValueChange();\n  }\n}\n\n// For IE8 and IE9.\nfunction getTargetInstForInputEventPolyfill(\n  domEventName: DOMEventName,\n  targetInst,\n) {\n  if (\n    domEventName === 'selectionchange' ||\n    domEventName === 'keyup' ||\n    domEventName === 'keydown'\n  ) {\n    // On the selectionchange event, the target is just document which isn't\n    // helpful for us so just check activeElement instead.\n    //\n    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire\n    // propertychange on the first input event after setting `value` from a\n    // script and fires only keydown, keypress, keyup. Catching keyup usually\n    // gets it and catching keydown lets us fire an event for the first\n    // keystroke if user does a key repeat (it'll be a little delayed: right\n    // before the second keystroke). Other input methods (e.g., paste) seem to\n    // fire selectionchange normally.\n    return getInstIfValueChanged(activeElementInst);\n  }\n}\n\n/**\n * SECTION: handle `click` event\n */\nfunction shouldUseClickEvent(elem) {\n  // Use the `click` event to detect changes to checkbox and radio inputs.\n  // This approach works across all browsers, whereas `change` does not fire\n  // until `blur` in IE8.\n  const nodeName = elem.nodeName;\n  return (\n    nodeName &&\n    nodeName.toLowerCase() === 'input' &&\n    (elem.type === 'checkbox' || elem.type === 'radio')\n  );\n}\n\nfunction getTargetInstForClickEvent(domEventName: DOMEventName, targetInst) {\n  if (domEventName === 'click') {\n    return getInstIfValueChanged(targetInst);\n  }\n}\n\nfunction getTargetInstForInputOrChangeEvent(\n  domEventName: DOMEventName,\n  targetInst,\n) {\n  if (domEventName === 'input' || domEventName === 'change') {\n    return getInstIfValueChanged(targetInst);\n  }\n}\n\nfunction handleControlledInputBlur(node: HTMLInputElement) {\n  const state = (node: any)._wrapperState;\n\n  if (!state || !state.controlled || node.type !== 'number') {\n    return;\n  }\n\n  if (!disableInputAttributeSyncing) {\n    // If controlled, assign the value attribute to the current value on blur\n    setDefaultValue((node: any), 'number', (node: any).value);\n  }\n}\n\n/**\n * This plugin creates an `onChange` event that normalizes change events\n * across form elements. This event fires at a time when it's possible to\n * change the element's value without seeing a flicker.\n *\n * Supported elements are:\n * - input (see `isTextInputElement`)\n * - textarea\n * - select\n */\nfunction extractEvents(\n  dispatchQueue: DispatchQueue,\n  domEventName: DOMEventName,\n  targetInst: null | Fiber,\n  nativeEvent: AnyNativeEvent,\n  nativeEventTarget: null | EventTarget,\n  eventSystemFlags: EventSystemFlags,\n  targetContainer: null | EventTarget,\n) {\n  const targetNode = targetInst ? getNodeFromInstance(targetInst) : window;\n\n  let getTargetInstFunc, handleEventFunc;\n  if (shouldUseChangeEvent(targetNode)) {\n    getTargetInstFunc = getTargetInstForChangeEvent;\n  } else if (isTextInputElement(((targetNode: any): HTMLElement))) {\n    if (isInputEventSupported) {\n      getTargetInstFunc = getTargetInstForInputOrChangeEvent;\n    } else {\n      getTargetInstFunc = getTargetInstForInputEventPolyfill;\n      handleEventFunc = handleEventsForInputEventPolyfill;\n    }\n  } else if (shouldUseClickEvent(targetNode)) {\n    getTargetInstFunc = getTargetInstForClickEvent;\n  }\n\n  if (getTargetInstFunc) {\n    const inst = getTargetInstFunc(domEventName, targetInst);\n    if (inst) {\n      createAndAccumulateChangeEvent(\n        dispatchQueue,\n        inst,\n        nativeEvent,\n        nativeEventTarget,\n      );\n      return;\n    }\n  }\n\n  if (handleEventFunc) {\n    handleEventFunc(domEventName, targetNode, targetInst);\n  }\n\n  // When blurring, set the value attribute for number inputs\n  if (domEventName === 'focusout') {\n    handleControlledInputBlur(((targetNode: any): HTMLInputElement));\n  }\n}\n\nexport {registerEvents, extractEvents};\n"]},"metadata":{},"sourceType":"module"}