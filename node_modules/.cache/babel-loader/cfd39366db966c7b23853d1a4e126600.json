{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport getComponentNameFromType from 'shared/getComponentNameFromType';\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nimport hasOwnProperty from 'shared/hasOwnProperty';\nimport { REACT_ELEMENT_TYPE } from 'shared/ReactSymbols';\nimport { checkKeyStringCoercion } from 'shared/CheckStringCoercion';\nconst ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nconst RESERVED_PROPS = {\n  key: true,\n  ref: true,\n  __self: true,\n  __source: true\n};\nlet specialPropKeyWarningShown;\nlet specialPropRefWarningShown;\nlet didWarnAboutStringRefs;\n\nif (__DEV__) {\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  if (__DEV__) {\n    if (hasOwnProperty.call(config, 'ref')) {\n      const getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  if (__DEV__) {\n    if (hasOwnProperty.call(config, 'key')) {\n      const getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\n  if (__DEV__) {\n    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\n      const componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        console.error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  if (__DEV__) {\n    const warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n        console.error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true\n    });\n  }\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  if (__DEV__) {\n    const warnAboutAccessingRef = function () {\n      if (!specialPropRefWarningShown) {\n        specialPropRefWarningShown = true;\n        console.error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingRef.isReactWarning = true;\n    Object.defineProperty(props, 'ref', {\n      get: warnAboutAccessingRef,\n      configurable: true\n    });\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nconst ReactElement = function (type, key, ref, self, source, owner, props) {\n  const element = {\n    // This tag allows us to uniquely identify this as a React Element\n    $$typeof: REACT_ELEMENT_TYPE,\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n    // Record the component responsible for creating this element.\n    _owner: owner\n  };\n\n  if (__DEV__) {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // self and source are DEV only properties.\n\n    Object.defineProperty(element, '_self', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: self\n    }); // Two elements created in two different places should be considered\n    // equal for testing purposes and therefore we hide it from enumeration.\n\n    Object.defineProperty(element, '_source', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: source\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n};\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\n\n_c = ReactElement;\nexport function jsx(type, config, maybeKey) {\n  let propName; // Reserved names are extracted\n\n  const props = {};\n  let key = null;\n  let ref = null; // Currently, key can be spread in as a prop. This causes a potential\n  // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n  // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n  // but as an intermediary step, we will use jsxDEV for everything except\n  // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n  // key is explicitly declared to be undefined or not.\n\n  if (maybeKey !== undefined) {\n    if (__DEV__) {\n      checkKeyStringCoercion(maybeKey);\n    }\n\n    key = '' + maybeKey;\n  }\n\n  if (hasValidKey(config)) {\n    if (__DEV__) {\n      checkKeyStringCoercion(config.key);\n    }\n\n    key = '' + config.key;\n  }\n\n  if (hasValidRef(config)) {\n    ref = config.ref;\n  } // Remaining properties are added to a new props object\n\n\n  for (propName in config) {\n    if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n      props[propName] = config[propName];\n    }\n  } // Resolve default props\n\n\n  if (type && type.defaultProps) {\n    const defaultProps = type.defaultProps;\n\n    for (propName in defaultProps) {\n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  }\n\n  return ReactElement(type, key, ref, undefined, undefined, ReactCurrentOwner.current, props);\n}\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\nexport function jsxDEV(type, config, maybeKey, source, self) {\n  if (__DEV__) {\n    let propName; // Reserved names are extracted\n\n    const props = {};\n    let key = null;\n    let ref = null; // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n\n    if (maybeKey !== undefined) {\n      if (__DEV__) {\n        checkKeyStringCoercion(maybeKey);\n      }\n\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      if (__DEV__) {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    }\n\n    if (hasValidRef(config)) {\n      ref = config.ref;\n      warnIfStringRefCannotBeAutoConverted(config, self);\n    } // Remaining properties are added to a new props object\n\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        props[propName] = config[propName];\n      }\n    } // Resolve default props\n\n\n    if (type && type.defaultProps) {\n      const defaultProps = type.defaultProps;\n\n      for (propName in defaultProps) {\n        if (props[propName] === undefined) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    }\n\n    if (key || ref) {\n      const displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n\n    return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n  }\n}\n\nvar _c;\n\n$RefreshReg$(_c, \"ReactElement\");","map":{"version":3,"sources":["/Users/zhangshuo/git/react-source-test/src/react/packages/react/src/jsx/ReactJSXElement.js"],"names":["getComponentNameFromType","ReactSharedInternals","hasOwnProperty","REACT_ELEMENT_TYPE","checkKeyStringCoercion","ReactCurrentOwner","RESERVED_PROPS","key","ref","__self","__source","specialPropKeyWarningShown","specialPropRefWarningShown","didWarnAboutStringRefs","__DEV__","hasValidRef","config","call","getter","Object","getOwnPropertyDescriptor","get","isReactWarning","undefined","hasValidKey","warnIfStringRefCannotBeAutoConverted","self","current","stateNode","componentName","type","console","error","defineKeyPropWarningGetter","props","displayName","warnAboutAccessingKey","defineProperty","configurable","defineRefPropWarningGetter","warnAboutAccessingRef","ReactElement","source","owner","element","$$typeof","_owner","_store","enumerable","writable","value","freeze","jsx","maybeKey","propName","defaultProps","jsxDEV","name"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport getComponentNameFromType from 'shared/getComponentNameFromType';\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nimport hasOwnProperty from 'shared/hasOwnProperty';\nimport {REACT_ELEMENT_TYPE} from 'shared/ReactSymbols';\nimport {checkKeyStringCoercion} from 'shared/CheckStringCoercion';\n\nconst ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\n\nconst RESERVED_PROPS = {\n  key: true,\n  ref: true,\n  __self: true,\n  __source: true,\n};\n\nlet specialPropKeyWarningShown;\nlet specialPropRefWarningShown;\nlet didWarnAboutStringRefs;\n\nif (__DEV__) {\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  if (__DEV__) {\n    if (hasOwnProperty.call(config, 'ref')) {\n      const getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  if (__DEV__) {\n    if (hasOwnProperty.call(config, 'key')) {\n      const getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n  return config.key !== undefined;\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\n  if (__DEV__) {\n    if (\n      typeof config.ref === 'string' &&\n      ReactCurrentOwner.current &&\n      self &&\n      ReactCurrentOwner.current.stateNode !== self\n    ) {\n      const componentName = getComponentNameFromType(\n        ReactCurrentOwner.current.type,\n      );\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        console.error(\n          'Component \"%s\" contains the string ref \"%s\". ' +\n            'Support for string refs will be removed in a future major release. ' +\n            'This case cannot be automatically converted to an arrow function. ' +\n            'We ask you to manually fix this case by using useRef() or createRef() instead. ' +\n            'Learn more about using refs safely here: ' +\n            'https://reactjs.org/link/strict-mode-string-ref',\n          getComponentNameFromType(ReactCurrentOwner.current.type),\n          config.ref,\n        );\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  if (__DEV__) {\n    const warnAboutAccessingKey = function() {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n        console.error(\n          '%s: `key` is not a prop. Trying to access it will result ' +\n            'in `undefined` being returned. If you need to access the same ' +\n            'value within the child component, you should pass it as a different ' +\n            'prop. (https://reactjs.org/link/special-props)',\n          displayName,\n        );\n      }\n    };\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true,\n    });\n  }\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  if (__DEV__) {\n    const warnAboutAccessingRef = function() {\n      if (!specialPropRefWarningShown) {\n        specialPropRefWarningShown = true;\n        console.error(\n          '%s: `ref` is not a prop. Trying to access it will result ' +\n            'in `undefined` being returned. If you need to access the same ' +\n            'value within the child component, you should pass it as a different ' +\n            'prop. (https://reactjs.org/link/special-props)',\n          displayName,\n        );\n      }\n    };\n    warnAboutAccessingRef.isReactWarning = true;\n    Object.defineProperty(props, 'ref', {\n      get: warnAboutAccessingRef,\n      configurable: true,\n    });\n  }\n}\n\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\nconst ReactElement = function(type, key, ref, self, source, owner, props) {\n  const element = {\n    // This tag allows us to uniquely identify this as a React Element\n    $$typeof: REACT_ELEMENT_TYPE,\n\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n\n    // Record the component responsible for creating this element.\n    _owner: owner,\n  };\n\n  if (__DEV__) {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {};\n\n    // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false,\n    });\n    // self and source are DEV only properties.\n    Object.defineProperty(element, '_self', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: self,\n    });\n    // Two elements created in two different places should be considered\n    // equal for testing purposes and therefore we hide it from enumeration.\n    Object.defineProperty(element, '_source', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: source,\n    });\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n};\n\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\nexport function jsx(type, config, maybeKey) {\n  let propName;\n\n  // Reserved names are extracted\n  const props = {};\n\n  let key = null;\n  let ref = null;\n\n  // Currently, key can be spread in as a prop. This causes a potential\n  // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n  // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n  // but as an intermediary step, we will use jsxDEV for everything except\n  // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n  // key is explicitly declared to be undefined or not.\n  if (maybeKey !== undefined) {\n    if (__DEV__) {\n      checkKeyStringCoercion(maybeKey);\n    }\n    key = '' + maybeKey;\n  }\n\n  if (hasValidKey(config)) {\n    if (__DEV__) {\n      checkKeyStringCoercion(config.key);\n    }\n    key = '' + config.key;\n  }\n\n  if (hasValidRef(config)) {\n    ref = config.ref;\n  }\n\n  // Remaining properties are added to a new props object\n  for (propName in config) {\n    if (\n      hasOwnProperty.call(config, propName) &&\n      !RESERVED_PROPS.hasOwnProperty(propName)\n    ) {\n      props[propName] = config[propName];\n    }\n  }\n\n  // Resolve default props\n  if (type && type.defaultProps) {\n    const defaultProps = type.defaultProps;\n    for (propName in defaultProps) {\n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  }\n\n  return ReactElement(\n    type,\n    key,\n    ref,\n    undefined,\n    undefined,\n    ReactCurrentOwner.current,\n    props,\n  );\n}\n\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\nexport function jsxDEV(type, config, maybeKey, source, self) {\n  if (__DEV__) {\n    let propName;\n\n    // Reserved names are extracted\n    const props = {};\n\n    let key = null;\n    let ref = null;\n\n    // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n    if (maybeKey !== undefined) {\n      if (__DEV__) {\n        checkKeyStringCoercion(maybeKey);\n      }\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      if (__DEV__) {\n        checkKeyStringCoercion(config.key);\n      }\n      key = '' + config.key;\n    }\n\n    if (hasValidRef(config)) {\n      ref = config.ref;\n      warnIfStringRefCannotBeAutoConverted(config, self);\n    }\n\n    // Remaining properties are added to a new props object\n    for (propName in config) {\n      if (\n        hasOwnProperty.call(config, propName) &&\n        !RESERVED_PROPS.hasOwnProperty(propName)\n      ) {\n        props[propName] = config[propName];\n      }\n    }\n\n    // Resolve default props\n    if (type && type.defaultProps) {\n      const defaultProps = type.defaultProps;\n      for (propName in defaultProps) {\n        if (props[propName] === undefined) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    }\n\n    if (key || ref) {\n      const displayName =\n        typeof type === 'function'\n          ? type.displayName || type.name || 'Unknown'\n          : type;\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n\n    return ReactElement(\n      type,\n      key,\n      ref,\n      self,\n      source,\n      ReactCurrentOwner.current,\n      props,\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"module"}